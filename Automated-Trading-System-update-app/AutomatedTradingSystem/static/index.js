var DA = Object.defineProperty;
var NA = (e,t,n)=>t in e ? DA(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : e[t] = n;
var je = (e,t,n)=>(NA(e, typeof t != "symbol" ? t + "" : t, n),
n);
function t8(e, t) {
    for (var n = 0; n < t.length; n++) {
        const i = t[n];
        if (typeof i != "string" && !Array.isArray(i)) {
            for (const r in i)
                if (r !== "default" && !(r in e)) {
                    const s = Object.getOwnPropertyDescriptor(i, r);
                    s && Object.defineProperty(e, r, s.get ? s : {
                        enumerable: !0,
                        get: ()=>i[r]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload"))
        return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
        i(r);
    new MutationObserver(r=>{
        for (const s of r)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && i(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(r) {
        const s = {};
        return r.integrity && (s.integrity = r.integrity),
        r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
        r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function i(r) {
        if (r.ep)
            return;
        r.ep = !0;
        const s = n(r);
        fetch(r.href, s)
    }
}
)();
var n8 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Jr(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var i8 = {
    exports: {}
}
  , fd = {}
  , r8 = {
    exports: {}
}
  , Ge = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cc = Symbol.for("react.element")
  , FA = Symbol.for("react.portal")
  , IA = Symbol.for("react.fragment")
  , BA = Symbol.for("react.strict_mode")
  , zA = Symbol.for("react.profiler")
  , VA = Symbol.for("react.provider")
  , WA = Symbol.for("react.context")
  , HA = Symbol.for("react.forward_ref")
  , UA = Symbol.for("react.suspense")
  , GA = Symbol.for("react.memo")
  , XA = Symbol.for("react.lazy")
  , yv = Symbol.iterator;
function YA(e) {
    return e === null || typeof e != "object" ? null : (e = yv && e[yv] || e["@@iterator"],
    typeof e == "function" ? e : null)
}
var s8 = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , o8 = Object.assign
  , a8 = {};
function xa(e, t, n) {
    this.props = e,
    this.context = t,
    this.refs = a8,
    this.updater = n || s8
}
xa.prototype.isReactComponent = {};
xa.prototype.setState = function(e, t) {
    if (typeof e != "object" && typeof e != "function" && e != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, e, t, "setState")
}
;
xa.prototype.forceUpdate = function(e) {
    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
}
;
function l8() {}
l8.prototype = xa.prototype;
function um(e, t, n) {
    this.props = e,
    this.context = t,
    this.refs = a8,
    this.updater = n || s8
}
var hm = um.prototype = new l8;
hm.constructor = um;
o8(hm, xa.prototype);
hm.isPureReactComponent = !0;
var xv = Array.isArray
  , c8 = Object.prototype.hasOwnProperty
  , dm = {
    current: null
}
  , u8 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function h8(e, t, n) {
    var i, r = {}, s = null, o = null;
    if (t != null)
        for (i in t.ref !== void 0 && (o = t.ref),
        t.key !== void 0 && (s = "" + t.key),
        t)
            c8.call(t, i) && !u8.hasOwnProperty(i) && (r[i] = t[i]);
    var a = arguments.length - 2;
    if (a === 1)
        r.children = n;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++)
            l[c] = arguments[c + 2];
        r.children = l
    }
    if (e && e.defaultProps)
        for (i in a = e.defaultProps,
        a)
            r[i] === void 0 && (r[i] = a[i]);
    return {
        $$typeof: cc,
        type: e,
        key: s,
        ref: o,
        props: r,
        _owner: dm.current
    }
}
function $A(e, t) {
    return {
        $$typeof: cc,
        type: e.type,
        key: t,
        ref: e.ref,
        props: e.props,
        _owner: e._owner
    }
}
function fm(e) {
    return typeof e == "object" && e !== null && e.$$typeof === cc
}
function KA(e) {
    var t = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + e.replace(/[=:]/g, function(n) {
        return t[n]
    })
}
var bv = /\/+/g;
function Ef(e, t) {
    return typeof e == "object" && e !== null && e.key != null ? KA("" + e.key) : t.toString(36)
}
function Fu(e, t, n, i, r) {
    var s = typeof e;
    (s === "undefined" || s === "boolean") && (e = null);
    var o = !1;
    if (e === null)
        o = !0;
    else
        switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (e.$$typeof) {
            case cc:
            case FA:
                o = !0
            }
        }
    if (o)
        return o = e,
        r = r(o),
        e = i === "" ? "." + Ef(o, 0) : i,
        xv(r) ? (n = "",
        e != null && (n = e.replace(bv, "$&/") + "/"),
        Fu(r, t, n, "", function(c) {
            return c
        })) : r != null && (fm(r) && (r = $A(r, n + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(bv, "$&/") + "/") + e)),
        t.push(r)),
        1;
    if (o = 0,
    i = i === "" ? "." : i + ":",
    xv(e))
        for (var a = 0; a < e.length; a++) {
            s = e[a];
            var l = i + Ef(s, a);
            o += Fu(s, t, n, l, r)
        }
    else if (l = YA(e),
    typeof l == "function")
        for (e = l.call(e),
        a = 0; !(s = e.next()).done; )
            s = s.value,
            l = i + Ef(s, a++),
            o += Fu(s, t, n, l, r);
    else if (s === "object")
        throw t = String(e),
        Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function Ic(e, t, n) {
    if (e == null)
        return e;
    var i = []
      , r = 0;
    return Fu(e, i, "", "", function(s) {
        return t.call(n, s, r++)
    }),
    i
}
function QA(e) {
    if (e._status === -1) {
        var t = e._result;
        t = t(),
        t.then(function(n) {
            (e._status === 0 || e._status === -1) && (e._status = 1,
            e._result = n)
        }, function(n) {
            (e._status === 0 || e._status === -1) && (e._status = 2,
            e._result = n)
        }),
        e._status === -1 && (e._status = 0,
        e._result = t)
    }
    if (e._status === 1)
        return e._result.default;
    throw e._result
}
var yn = {
    current: null
}
  , Iu = {
    transition: null
}
  , qA = {
    ReactCurrentDispatcher: yn,
    ReactCurrentBatchConfig: Iu,
    ReactCurrentOwner: dm
};
Ge.Children = {
    map: Ic,
    forEach: function(e, t, n) {
        Ic(e, function() {
            t.apply(this, arguments)
        }, n)
    },
    count: function(e) {
        var t = 0;
        return Ic(e, function() {
            t++
        }),
        t
    },
    toArray: function(e) {
        return Ic(e, function(t) {
            return t
        }) || []
    },
    only: function(e) {
        if (!fm(e))
            throw Error("React.Children.only expected to receive a single React element child.");
        return e
    }
};
Ge.Component = xa;
Ge.Fragment = IA;
Ge.Profiler = zA;
Ge.PureComponent = um;
Ge.StrictMode = BA;
Ge.Suspense = UA;
Ge.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = qA;
Ge.cloneElement = function(e, t, n) {
    if (e == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
    var i = o8({}, e.props)
      , r = e.key
      , s = e.ref
      , o = e._owner;
    if (t != null) {
        if (t.ref !== void 0 && (s = t.ref,
        o = dm.current),
        t.key !== void 0 && (r = "" + t.key),
        e.type && e.type.defaultProps)
            var a = e.type.defaultProps;
        for (l in t)
            c8.call(t, l) && !u8.hasOwnProperty(l) && (i[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        i.children = n;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++)
            a[c] = arguments[c + 2];
        i.children = a
    }
    return {
        $$typeof: cc,
        type: e.type,
        key: r,
        ref: s,
        props: i,
        _owner: o
    }
}
;
Ge.createContext = function(e) {
    return e = {
        $$typeof: WA,
        _currentValue: e,
        _currentValue2: e,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    e.Provider = {
        $$typeof: VA,
        _context: e
    },
    e.Consumer = e
}
;
Ge.createElement = h8;
Ge.createFactory = function(e) {
    var t = h8.bind(null, e);
    return t.type = e,
    t
}
;
Ge.createRef = function() {
    return {
        current: null
    }
}
;
Ge.forwardRef = function(e) {
    return {
        $$typeof: HA,
        render: e
    }
}
;
Ge.isValidElement = fm;
Ge.lazy = function(e) {
    return {
        $$typeof: XA,
        _payload: {
            _status: -1,
            _result: e
        },
        _init: QA
    }
}
;
Ge.memo = function(e, t) {
    return {
        $$typeof: GA,
        type: e,
        compare: t === void 0 ? null : t
    }
}
;
Ge.startTransition = function(e) {
    var t = Iu.transition;
    Iu.transition = {};
    try {
        e()
    } finally {
        Iu.transition = t
    }
}
;
Ge.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
}
;
Ge.useCallback = function(e, t) {
    return yn.current.useCallback(e, t)
}
;
Ge.useContext = function(e) {
    return yn.current.useContext(e)
}
;
Ge.useDebugValue = function() {}
;
Ge.useDeferredValue = function(e) {
    return yn.current.useDeferredValue(e)
}
;
Ge.useEffect = function(e, t) {
    return yn.current.useEffect(e, t)
}
;
Ge.useId = function() {
    return yn.current.useId()
}
;
Ge.useImperativeHandle = function(e, t, n) {
    return yn.current.useImperativeHandle(e, t, n)
}
;
Ge.useInsertionEffect = function(e, t) {
    return yn.current.useInsertionEffect(e, t)
}
;
Ge.useLayoutEffect = function(e, t) {
    return yn.current.useLayoutEffect(e, t)
}
;
Ge.useMemo = function(e, t) {
    return yn.current.useMemo(e, t)
}
;
Ge.useReducer = function(e, t, n) {
    return yn.current.useReducer(e, t, n)
}
;
Ge.useRef = function(e) {
    return yn.current.useRef(e)
}
;
Ge.useState = function(e) {
    return yn.current.useState(e)
}
;
Ge.useSyncExternalStore = function(e, t, n) {
    return yn.current.useSyncExternalStore(e, t, n)
}
;
Ge.useTransition = function() {
    return yn.current.useTransition()
}
;
Ge.version = "18.2.0";
r8.exports = Ge;
var M = r8.exports;
const Ce = Jr(M)
  , uc = t8({
    __proto__: null,
    default: Ce
}, [M]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZA = M
  , JA = Symbol.for("react.element")
  , eM = Symbol.for("react.fragment")
  , tM = Object.prototype.hasOwnProperty
  , nM = ZA.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , iM = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function d8(e, t, n) {
    var i, r = {}, s = null, o = null;
    n !== void 0 && (s = "" + n),
    t.key !== void 0 && (s = "" + t.key),
    t.ref !== void 0 && (o = t.ref);
    for (i in t)
        tM.call(t, i) && !iM.hasOwnProperty(i) && (r[i] = t[i]);
    if (e && e.defaultProps)
        for (i in t = e.defaultProps,
        t)
            r[i] === void 0 && (r[i] = t[i]);
    return {
        $$typeof: JA,
        type: e,
        key: s,
        ref: o,
        props: r,
        _owner: nM.current
    }
}
fd.Fragment = eM;
fd.jsx = d8;
fd.jsxs = d8;
i8.exports = fd;
var y = i8.exports
  , G0 = {}
  , f8 = {
    exports: {}
}
  , Un = {}
  , p8 = {
    exports: {}
}
  , g8 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(e) {
    function t(j, B) {
        var W = j.length;
        j.push(B);
        e: for (; 0 < W; ) {
            var N = W - 1 >>> 1
              , H = j[N];
            if (0 < r(H, B))
                j[N] = B,
                j[W] = H,
                W = N;
            else
                break e
        }
    }
    function n(j) {
        return j.length === 0 ? null : j[0]
    }
    function i(j) {
        if (j.length === 0)
            return null;
        var B = j[0]
          , W = j.pop();
        if (W !== B) {
            j[0] = W;
            e: for (var N = 0, H = j.length, X = H >>> 1; N < X; ) {
                var ie = 2 * (N + 1) - 1
                  , K = j[ie]
                  , D = ie + 1
                  , V = j[D];
                if (0 > r(K, W))
                    D < H && 0 > r(V, K) ? (j[N] = V,
                    j[D] = W,
                    N = D) : (j[N] = K,
                    j[ie] = W,
                    N = ie);
                else if (D < H && 0 > r(V, W))
                    j[N] = V,
                    j[D] = W,
                    N = D;
                else
                    break e
            }
        }
        return B
    }
    function r(j, B) {
        var W = j.sortIndex - B.sortIndex;
        return W !== 0 ? W : j.id - B.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        e.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        e.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , c = []
      , u = 1
      , h = null
      , d = 3
      , m = !1
      , f = !1
      , x = !1
      , S = typeof setTimeout == "function" ? setTimeout : null
      , v = typeof clearTimeout == "function" ? clearTimeout : null
      , p = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function g(j) {
        for (var B = n(c); B !== null; ) {
            if (B.callback === null)
                i(c);
            else if (B.startTime <= j)
                i(c),
                B.sortIndex = B.expirationTime,
                t(l, B);
            else
                break;
            B = n(c)
        }
    }
    function C(j) {
        if (x = !1,
        g(j),
        !f)
            if (n(l) !== null)
                f = !0,
                b(E);
            else {
                var B = n(c);
                B !== null && A(C, B.startTime - j)
            }
    }
    function E(j, B) {
        f = !1,
        x && (x = !1,
        v(F),
        F = -1),
        m = !0;
        var W = d;
        try {
            for (g(B),
            h = n(l); h !== null && (!(h.expirationTime > B) || j && !T()); ) {
                var N = h.callback;
                if (typeof N == "function") {
                    h.callback = null,
                    d = h.priorityLevel;
                    var H = N(h.expirationTime <= B);
                    B = e.unstable_now(),
                    typeof H == "function" ? h.callback = H : h === n(l) && i(l),
                    g(B)
                } else
                    i(l);
                h = n(l)
            }
            if (h !== null)
                var X = !0;
            else {
                var ie = n(c);
                ie !== null && A(C, ie.startTime - B),
                X = !1
            }
            return X
        } finally {
            h = null,
            d = W,
            m = !1
        }
    }
    var O = !1
      , R = null
      , F = -1
      , P = 5
      , _ = -1;
    function T() {
        return !(e.unstable_now() - _ < P)
    }
    function L() {
        if (R !== null) {
            var j = e.unstable_now();
            _ = j;
            var B = !0;
            try {
                B = R(!0, j)
            } finally {
                B ? I() : (O = !1,
                R = null)
            }
        } else
            O = !1
    }
    var I;
    if (typeof p == "function")
        I = function() {
            p(L)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var k = new MessageChannel
          , w = k.port2;
        k.port1.onmessage = L,
        I = function() {
            w.postMessage(null)
        }
    } else
        I = function() {
            S(L, 0)
        }
        ;
    function b(j) {
        R = j,
        O || (O = !0,
        I())
    }
    function A(j, B) {
        F = S(function() {
            j(e.unstable_now())
        }, B)
    }
    e.unstable_IdlePriority = 5,
    e.unstable_ImmediatePriority = 1,
    e.unstable_LowPriority = 4,
    e.unstable_NormalPriority = 3,
    e.unstable_Profiling = null,
    e.unstable_UserBlockingPriority = 2,
    e.unstable_cancelCallback = function(j) {
        j.callback = null
    }
    ,
    e.unstable_continueExecution = function() {
        f || m || (f = !0,
        b(E))
    }
    ,
    e.unstable_forceFrameRate = function(j) {
        0 > j || 125 < j ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < j ? Math.floor(1e3 / j) : 5
    }
    ,
    e.unstable_getCurrentPriorityLevel = function() {
        return d
    }
    ,
    e.unstable_getFirstCallbackNode = function() {
        return n(l)
    }
    ,
    e.unstable_next = function(j) {
        switch (d) {
        case 1:
        case 2:
        case 3:
            var B = 3;
            break;
        default:
            B = d
        }
        var W = d;
        d = B;
        try {
            return j()
        } finally {
            d = W
        }
    }
    ,
    e.unstable_pauseExecution = function() {}
    ,
    e.unstable_requestPaint = function() {}
    ,
    e.unstable_runWithPriority = function(j, B) {
        switch (j) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            j = 3
        }
        var W = d;
        d = j;
        try {
            return B()
        } finally {
            d = W
        }
    }
    ,
    e.unstable_scheduleCallback = function(j, B, W) {
        var N = e.unstable_now();
        switch (typeof W == "object" && W !== null ? (W = W.delay,
        W = typeof W == "number" && 0 < W ? N + W : N) : W = N,
        j) {
        case 1:
            var H = -1;
            break;
        case 2:
            H = 250;
            break;
        case 5:
            H = 1073741823;
            break;
        case 4:
            H = 1e4;
            break;
        default:
            H = 5e3
        }
        return H = W + H,
        j = {
            id: u++,
            callback: B,
            priorityLevel: j,
            startTime: W,
            expirationTime: H,
            sortIndex: -1
        },
        W > N ? (j.sortIndex = W,
        t(c, j),
        n(l) === null && j === n(c) && (x ? (v(F),
        F = -1) : x = !0,
        A(C, W - N))) : (j.sortIndex = H,
        t(l, j),
        f || m || (f = !0,
        b(E))),
        j
    }
    ,
    e.unstable_shouldYield = T,
    e.unstable_wrapCallback = function(j) {
        var B = d;
        return function() {
            var W = d;
            d = B;
            try {
                return j.apply(this, arguments)
            } finally {
                d = W
            }
        }
    }
}
)(g8);
p8.exports = g8;
var rM = p8.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var m8 = M
  , zn = rM;
function Se(e) {
    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)
        t += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var v8 = new Set
  , kl = {};
function eo(e, t) {
    ia(e, t),
    ia(e + "Capture", t)
}
function ia(e, t) {
    for (kl[e] = t,
    e = 0; e < t.length; e++)
        v8.add(t[e])
}
var lr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , X0 = Object.prototype.hasOwnProperty
  , sM = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , wv = {}
  , Sv = {};
function oM(e) {
    return X0.call(Sv, e) ? !0 : X0.call(wv, e) ? !1 : sM.test(e) ? Sv[e] = !0 : (wv[e] = !0,
    !1)
}
function aM(e, t, n, i) {
    if (n !== null && n.type === 0)
        return !1;
    switch (typeof t) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return i ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5),
        e !== "data-" && e !== "aria-");
    default:
        return !1
    }
}
function lM(e, t, n, i) {
    if (t === null || typeof t > "u" || aM(e, t, n, i))
        return !0;
    if (i)
        return !1;
    if (n !== null)
        switch (n.type) {
        case 3:
            return !t;
        case 4:
            return t === !1;
        case 5:
            return isNaN(t);
        case 6:
            return isNaN(t) || 1 > t
        }
    return !1
}
function xn(e, t, n, i, r, s, o) {
    this.acceptsBooleans = t === 2 || t === 3 || t === 4,
    this.attributeName = i,
    this.attributeNamespace = r,
    this.mustUseProperty = n,
    this.propertyName = e,
    this.type = t,
    this.sanitizeURL = s,
    this.removeEmptyString = o
}
var nn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
    nn[e] = new xn(e,0,!1,e,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
    var t = e[0];
    nn[t] = new xn(t,1,!1,e[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
    nn[e] = new xn(e,2,!1,e.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
    nn[e] = new xn(e,2,!1,e,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
    nn[e] = new xn(e,3,!1,e.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(e) {
    nn[e] = new xn(e,3,!0,e,null,!1,!1)
});
["capture", "download"].forEach(function(e) {
    nn[e] = new xn(e,4,!1,e,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(e) {
    nn[e] = new xn(e,6,!1,e,null,!1,!1)
});
["rowSpan", "start"].forEach(function(e) {
    nn[e] = new xn(e,5,!1,e.toLowerCase(),null,!1,!1)
});
var pm = /[\-:]([a-z])/g;
function gm(e) {
    return e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
    var t = e.replace(pm, gm);
    nn[t] = new xn(t,1,!1,e,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
    var t = e.replace(pm, gm);
    nn[t] = new xn(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(e) {
    var t = e.replace(pm, gm);
    nn[t] = new xn(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(e) {
    nn[e] = new xn(e,1,!1,e.toLowerCase(),null,!1,!1)
});
nn.xlinkHref = new xn("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(e) {
    nn[e] = new xn(e,1,!1,e.toLowerCase(),null,!0,!0)
});
function mm(e, t, n, i) {
    var r = nn.hasOwnProperty(t) ? nn[t] : null;
    (r !== null ? r.type !== 0 : i || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (lM(t, n, r, i) && (n = null),
    i || r === null ? oM(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : r.mustUseProperty ? e[r.propertyName] = n === null ? r.type === 3 ? !1 : "" : n : (t = r.attributeName,
    i = r.attributeNamespace,
    n === null ? e.removeAttribute(t) : (r = r.type,
    n = r === 3 || r === 4 && n === !0 ? "" : "" + n,
    i ? e.setAttributeNS(i, t, n) : e.setAttribute(t, n))))
}
var fr = m8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Bc = Symbol.for("react.element")
  , Ao = Symbol.for("react.portal")
  , Mo = Symbol.for("react.fragment")
  , vm = Symbol.for("react.strict_mode")
  , Y0 = Symbol.for("react.profiler")
  , y8 = Symbol.for("react.provider")
  , x8 = Symbol.for("react.context")
  , ym = Symbol.for("react.forward_ref")
  , $0 = Symbol.for("react.suspense")
  , K0 = Symbol.for("react.suspense_list")
  , xm = Symbol.for("react.memo")
  , wr = Symbol.for("react.lazy")
  , b8 = Symbol.for("react.offscreen")
  , Cv = Symbol.iterator;
function Ta(e) {
    return e === null || typeof e != "object" ? null : (e = Cv && e[Cv] || e["@@iterator"],
    typeof e == "function" ? e : null)
}
var Ct = Object.assign, Pf;
function Xa(e) {
    if (Pf === void 0)
        try {
            throw Error()
        } catch (n) {
            var t = n.stack.trim().match(/\n( *(at )?)/);
            Pf = t && t[1] || ""
        }
    return `
` + Pf + e
}
var Tf = !1;
function jf(e, t) {
    if (!e || Tf)
        return "";
    Tf = !0;
    var n = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (t)
            if (t = function() {
                throw Error()
            }
            ,
            Object.defineProperty(t.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(t, [])
                } catch (c) {
                    var i = c
                }
                Reflect.construct(e, [], t)
            } else {
                try {
                    t.call()
                } catch (c) {
                    i = c
                }
                e.call(t.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                i = c
            }
            e()
        }
    } catch (c) {
        if (c && i && typeof c.stack == "string") {
            for (var r = c.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (r[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || r[o] !== s[a]) {
                                var l = `
` + r[o].replace(" at new ", " at ");
                                return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)),
                                l
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        Tf = !1,
        Error.prepareStackTrace = n
    }
    return (e = e ? e.displayName || e.name : "") ? Xa(e) : ""
}
function cM(e) {
    switch (e.tag) {
    case 5:
        return Xa(e.type);
    case 16:
        return Xa("Lazy");
    case 13:
        return Xa("Suspense");
    case 19:
        return Xa("SuspenseList");
    case 0:
    case 2:
    case 15:
        return e = jf(e.type, !1),
        e;
    case 11:
        return e = jf(e.type.render, !1),
        e;
    case 1:
        return e = jf(e.type, !0),
        e;
    default:
        return ""
    }
}
function Q0(e) {
    if (e == null)
        return null;
    if (typeof e == "function")
        return e.displayName || e.name || null;
    if (typeof e == "string")
        return e;
    switch (e) {
    case Mo:
        return "Fragment";
    case Ao:
        return "Portal";
    case Y0:
        return "Profiler";
    case vm:
        return "StrictMode";
    case $0:
        return "Suspense";
    case K0:
        return "SuspenseList"
    }
    if (typeof e == "object")
        switch (e.$$typeof) {
        case x8:
            return (e.displayName || "Context") + ".Consumer";
        case y8:
            return (e._context.displayName || "Context") + ".Provider";
        case ym:
            var t = e.render;
            return e = e.displayName,
            e || (e = t.displayName || t.name || "",
            e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"),
            e;
        case xm:
            return t = e.displayName || null,
            t !== null ? t : Q0(e.type) || "Memo";
        case wr:
            t = e._payload,
            e = e._init;
            try {
                return Q0(e(t))
            } catch {}
        }
    return null
}
function uM(e) {
    var t = e.type;
    switch (e.tag) {
    case 24:
        return "Cache";
    case 9:
        return (t.displayName || "Context") + ".Consumer";
    case 10:
        return (t._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return e = t.render,
        e = e.displayName || e.name || "",
        t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return t;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Q0(t);
    case 8:
        return t === vm ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof t == "function")
            return t.displayName || t.name || null;
        if (typeof t == "string")
            return t
    }
    return null
}
function Yr(e) {
    switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return e;
    case "object":
        return e;
    default:
        return ""
    }
}
function w8(e) {
    var t = e.type;
    return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio")
}
function hM(e) {
    var t = w8(e) ? "checked" : "value"
      , n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t)
      , i = "" + e[t];
    if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
        var r = n.get
          , s = n.set;
        return Object.defineProperty(e, t, {
            configurable: !0,
            get: function() {
                return r.call(this)
            },
            set: function(o) {
                i = "" + o,
                s.call(this, o)
            }
        }),
        Object.defineProperty(e, t, {
            enumerable: n.enumerable
        }),
        {
            getValue: function() {
                return i
            },
            setValue: function(o) {
                i = "" + o
            },
            stopTracking: function() {
                e._valueTracker = null,
                delete e[t]
            }
        }
    }
}
function zc(e) {
    e._valueTracker || (e._valueTracker = hM(e))
}
function S8(e) {
    if (!e)
        return !1;
    var t = e._valueTracker;
    if (!t)
        return !0;
    var n = t.getValue()
      , i = "";
    return e && (i = w8(e) ? e.checked ? "true" : "false" : e.value),
    e = i,
    e !== n ? (t.setValue(e),
    !0) : !1
}
function lh(e) {
    if (e = e || (typeof document < "u" ? document : void 0),
    typeof e > "u")
        return null;
    try {
        return e.activeElement || e.body
    } catch {
        return e.body
    }
}
function q0(e, t) {
    var n = t.checked;
    return Ct({}, t, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: n ?? e._wrapperState.initialChecked
    })
}
function kv(e, t) {
    var n = t.defaultValue == null ? "" : t.defaultValue
      , i = t.checked != null ? t.checked : t.defaultChecked;
    n = Yr(t.value != null ? t.value : n),
    e._wrapperState = {
        initialChecked: i,
        initialValue: n,
        controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null
    }
}
function C8(e, t) {
    t = t.checked,
    t != null && mm(e, "checked", t, !1)
}
function Z0(e, t) {
    C8(e, t);
    var n = Yr(t.value)
      , i = t.type;
    if (n != null)
        i === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
    else if (i === "submit" || i === "reset") {
        e.removeAttribute("value");
        return
    }
    t.hasOwnProperty("value") ? J0(e, t.type, n) : t.hasOwnProperty("defaultValue") && J0(e, t.type, Yr(t.defaultValue)),
    t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)
}
function Av(e, t, n) {
    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
        var i = t.type;
        if (!(i !== "submit" && i !== "reset" || t.value !== void 0 && t.value !== null))
            return;
        t = "" + e._wrapperState.initialValue,
        n || t === e.value || (e.value = t),
        e.defaultValue = t
    }
    n = e.name,
    n !== "" && (e.name = ""),
    e.defaultChecked = !!e._wrapperState.initialChecked,
    n !== "" && (e.name = n)
}
function J0(e, t, n) {
    (t !== "number" || lh(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
}
var Ya = Array.isArray;
function Xo(e, t, n, i) {
    if (e = e.options,
    t) {
        t = {};
        for (var r = 0; r < n.length; r++)
            t["$" + n[r]] = !0;
        for (n = 0; n < e.length; n++)
            r = t.hasOwnProperty("$" + e[n].value),
            e[n].selected !== r && (e[n].selected = r),
            r && i && (e[n].defaultSelected = !0)
    } else {
        for (n = "" + Yr(n),
        t = null,
        r = 0; r < e.length; r++) {
            if (e[r].value === n) {
                e[r].selected = !0,
                i && (e[r].defaultSelected = !0);
                return
            }
            t !== null || e[r].disabled || (t = e[r])
        }
        t !== null && (t.selected = !0)
    }
}
function e1(e, t) {
    if (t.dangerouslySetInnerHTML != null)
        throw Error(Se(91));
    return Ct({}, t, {
        value: void 0,
        defaultValue: void 0,
        children: "" + e._wrapperState.initialValue
    })
}
function Mv(e, t) {
    var n = t.value;
    if (n == null) {
        if (n = t.children,
        t = t.defaultValue,
        n != null) {
            if (t != null)
                throw Error(Se(92));
            if (Ya(n)) {
                if (1 < n.length)
                    throw Error(Se(93));
                n = n[0]
            }
            t = n
        }
        t == null && (t = ""),
        n = t
    }
    e._wrapperState = {
        initialValue: Yr(n)
    }
}
function k8(e, t) {
    var n = Yr(t.value)
      , i = Yr(t.defaultValue);
    n != null && (n = "" + n,
    n !== e.value && (e.value = n),
    t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)),
    i != null && (e.defaultValue = "" + i)
}
function Ev(e) {
    var t = e.textContent;
    t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t)
}
function A8(e) {
    switch (e) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function t1(e, t) {
    return e == null || e === "http://www.w3.org/1999/xhtml" ? A8(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e
}
var Vc, M8 = function(e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, n, i, r) {
        MSApp.execUnsafeLocalFunction(function() {
            return e(t, n, i, r)
        })
    }
    : e
}(function(e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in e)
        e.innerHTML = t;
    else {
        for (Vc = Vc || document.createElement("div"),
        Vc.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
        t = Vc.firstChild; e.firstChild; )
            e.removeChild(e.firstChild);
        for (; t.firstChild; )
            e.appendChild(t.firstChild)
    }
});
function Al(e, t) {
    if (t) {
        var n = e.firstChild;
        if (n && n === e.lastChild && n.nodeType === 3) {
            n.nodeValue = t;
            return
        }
    }
    e.textContent = t
}
var il = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , dM = ["Webkit", "ms", "Moz", "O"];
Object.keys(il).forEach(function(e) {
    dM.forEach(function(t) {
        t = t + e.charAt(0).toUpperCase() + e.substring(1),
        il[t] = il[e]
    })
});
function E8(e, t, n) {
    return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || il.hasOwnProperty(e) && il[e] ? ("" + t).trim() : t + "px"
}
function P8(e, t) {
    e = e.style;
    for (var n in t)
        if (t.hasOwnProperty(n)) {
            var i = n.indexOf("--") === 0
              , r = E8(n, t[n], i);
            n === "float" && (n = "cssFloat"),
            i ? e.setProperty(n, r) : e[n] = r
        }
}
var fM = Ct({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function n1(e, t) {
    if (t) {
        if (fM[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
            throw Error(Se(137, e));
        if (t.dangerouslySetInnerHTML != null) {
            if (t.children != null)
                throw Error(Se(60));
            if (typeof t.dangerouslySetInnerHTML != "object" || !("__html"in t.dangerouslySetInnerHTML))
                throw Error(Se(61))
        }
        if (t.style != null && typeof t.style != "object")
            throw Error(Se(62))
    }
}
function i1(e, t) {
    if (e.indexOf("-") === -1)
        return typeof t.is == "string";
    switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var r1 = null;
function bm(e) {
    return e = e.target || e.srcElement || window,
    e.correspondingUseElement && (e = e.correspondingUseElement),
    e.nodeType === 3 ? e.parentNode : e
}
var s1 = null
  , Yo = null
  , $o = null;
function Pv(e) {
    if (e = fc(e)) {
        if (typeof s1 != "function")
            throw Error(Se(280));
        var t = e.stateNode;
        t && (t = yd(t),
        s1(e.stateNode, e.type, t))
    }
}
function T8(e) {
    Yo ? $o ? $o.push(e) : $o = [e] : Yo = e
}
function j8() {
    if (Yo) {
        var e = Yo
          , t = $o;
        if ($o = Yo = null,
        Pv(e),
        t)
            for (e = 0; e < t.length; e++)
                Pv(t[e])
    }
}
function O8(e, t) {
    return e(t)
}
function L8() {}
var Of = !1;
function R8(e, t, n) {
    if (Of)
        return e(t, n);
    Of = !0;
    try {
        return O8(e, t, n)
    } finally {
        Of = !1,
        (Yo !== null || $o !== null) && (L8(),
        j8())
    }
}
function Ml(e, t) {
    var n = e.stateNode;
    if (n === null)
        return null;
    var i = yd(n);
    if (i === null)
        return null;
    n = i[t];
    e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (i = !i.disabled) || (e = e.type,
        i = !(e === "button" || e === "input" || e === "select" || e === "textarea")),
        e = !i;
        break e;
    default:
        e = !1
    }
    if (e)
        return null;
    if (n && typeof n != "function")
        throw Error(Se(231, t, typeof n));
    return n
}
var o1 = !1;
if (lr)
    try {
        var ja = {};
        Object.defineProperty(ja, "passive", {
            get: function() {
                o1 = !0
            }
        }),
        window.addEventListener("test", ja, ja),
        window.removeEventListener("test", ja, ja)
    } catch {
        o1 = !1
    }
function pM(e, t, n, i, r, s, o, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        t.apply(n, c)
    } catch (u) {
        this.onError(u)
    }
}
var rl = !1
  , ch = null
  , uh = !1
  , a1 = null
  , gM = {
    onError: function(e) {
        rl = !0,
        ch = e
    }
};
function mM(e, t, n, i, r, s, o, a, l) {
    rl = !1,
    ch = null,
    pM.apply(gM, arguments)
}
function vM(e, t, n, i, r, s, o, a, l) {
    if (mM.apply(this, arguments),
    rl) {
        if (rl) {
            var c = ch;
            rl = !1,
            ch = null
        } else
            throw Error(Se(198));
        uh || (uh = !0,
        a1 = c)
    }
}
function to(e) {
    var t = e
      , n = e;
    if (e.alternate)
        for (; t.return; )
            t = t.return;
    else {
        e = t;
        do
            t = e,
            t.flags & 4098 && (n = t.return),
            e = t.return;
        while (e)
    }
    return t.tag === 3 ? n : null
}
function _8(e) {
    if (e.tag === 13) {
        var t = e.memoizedState;
        if (t === null && (e = e.alternate,
        e !== null && (t = e.memoizedState)),
        t !== null)
            return t.dehydrated
    }
    return null
}
function Tv(e) {
    if (to(e) !== e)
        throw Error(Se(188))
}
function yM(e) {
    var t = e.alternate;
    if (!t) {
        if (t = to(e),
        t === null)
            throw Error(Se(188));
        return t !== e ? null : e
    }
    for (var n = e, i = t; ; ) {
        var r = n.return;
        if (r === null)
            break;
        var s = r.alternate;
        if (s === null) {
            if (i = r.return,
            i !== null) {
                n = i;
                continue
            }
            break
        }
        if (r.child === s.child) {
            for (s = r.child; s; ) {
                if (s === n)
                    return Tv(r),
                    e;
                if (s === i)
                    return Tv(r),
                    t;
                s = s.sibling
            }
            throw Error(Se(188))
        }
        if (n.return !== i.return)
            n = r,
            i = s;
        else {
            for (var o = !1, a = r.child; a; ) {
                if (a === n) {
                    o = !0,
                    n = r,
                    i = s;
                    break
                }
                if (a === i) {
                    o = !0,
                    i = r,
                    n = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a; ) {
                    if (a === n) {
                        o = !0,
                        n = s,
                        i = r;
                        break
                    }
                    if (a === i) {
                        o = !0,
                        i = s,
                        n = r;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(Se(189))
            }
        }
        if (n.alternate !== i)
            throw Error(Se(190))
    }
    if (n.tag !== 3)
        throw Error(Se(188));
    return n.stateNode.current === n ? e : t
}
function D8(e) {
    return e = yM(e),
    e !== null ? N8(e) : null
}
function N8(e) {
    if (e.tag === 5 || e.tag === 6)
        return e;
    for (e = e.child; e !== null; ) {
        var t = N8(e);
        if (t !== null)
            return t;
        e = e.sibling
    }
    return null
}
var F8 = zn.unstable_scheduleCallback
  , jv = zn.unstable_cancelCallback
  , xM = zn.unstable_shouldYield
  , bM = zn.unstable_requestPaint
  , Lt = zn.unstable_now
  , wM = zn.unstable_getCurrentPriorityLevel
  , wm = zn.unstable_ImmediatePriority
  , I8 = zn.unstable_UserBlockingPriority
  , hh = zn.unstable_NormalPriority
  , SM = zn.unstable_LowPriority
  , B8 = zn.unstable_IdlePriority
  , pd = null
  , Fi = null;
function CM(e) {
    if (Fi && typeof Fi.onCommitFiberRoot == "function")
        try {
            Fi.onCommitFiberRoot(pd, e, void 0, (e.current.flags & 128) === 128)
        } catch {}
}
var xi = Math.clz32 ? Math.clz32 : MM
  , kM = Math.log
  , AM = Math.LN2;
function MM(e) {
    return e >>>= 0,
    e === 0 ? 32 : 31 - (kM(e) / AM | 0) | 0
}
var Wc = 64
  , Hc = 4194304;
function $a(e) {
    switch (e & -e) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return e & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return e
    }
}
function dh(e, t) {
    var n = e.pendingLanes;
    if (n === 0)
        return 0;
    var i = 0
      , r = e.suspendedLanes
      , s = e.pingedLanes
      , o = n & 268435455;
    if (o !== 0) {
        var a = o & ~r;
        a !== 0 ? i = $a(a) : (s &= o,
        s !== 0 && (i = $a(s)))
    } else
        o = n & ~r,
        o !== 0 ? i = $a(o) : s !== 0 && (i = $a(s));
    if (i === 0)
        return 0;
    if (t !== 0 && t !== i && !(t & r) && (r = i & -i,
    s = t & -t,
    r >= s || r === 16 && (s & 4194240) !== 0))
        return t;
    if (i & 4 && (i |= n & 16),
    t = e.entangledLanes,
    t !== 0)
        for (e = e.entanglements,
        t &= i; 0 < t; )
            n = 31 - xi(t),
            r = 1 << n,
            i |= e[n],
            t &= ~r;
    return i
}
function EM(e, t) {
    switch (e) {
    case 1:
    case 2:
    case 4:
        return t + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return t + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function PM(e, t) {
    for (var n = e.suspendedLanes, i = e.pingedLanes, r = e.expirationTimes, s = e.pendingLanes; 0 < s; ) {
        var o = 31 - xi(s)
          , a = 1 << o
          , l = r[o];
        l === -1 ? (!(a & n) || a & i) && (r[o] = EM(a, t)) : l <= t && (e.expiredLanes |= a),
        s &= ~a
    }
}
function l1(e) {
    return e = e.pendingLanes & -1073741825,
    e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
}
function z8() {
    var e = Wc;
    return Wc <<= 1,
    !(Wc & 4194240) && (Wc = 64),
    e
}
function Lf(e) {
    for (var t = [], n = 0; 31 > n; n++)
        t.push(e);
    return t
}
function hc(e, t, n) {
    e.pendingLanes |= t,
    t !== 536870912 && (e.suspendedLanes = 0,
    e.pingedLanes = 0),
    e = e.eventTimes,
    t = 31 - xi(t),
    e[t] = n
}
function TM(e, t) {
    var n = e.pendingLanes & ~t;
    e.pendingLanes = t,
    e.suspendedLanes = 0,
    e.pingedLanes = 0,
    e.expiredLanes &= t,
    e.mutableReadLanes &= t,
    e.entangledLanes &= t,
    t = e.entanglements;
    var i = e.eventTimes;
    for (e = e.expirationTimes; 0 < n; ) {
        var r = 31 - xi(n)
          , s = 1 << r;
        t[r] = 0,
        i[r] = -1,
        e[r] = -1,
        n &= ~s
    }
}
function Sm(e, t) {
    var n = e.entangledLanes |= t;
    for (e = e.entanglements; n; ) {
        var i = 31 - xi(n)
          , r = 1 << i;
        r & t | e[i] & t && (e[i] |= t),
        n &= ~r
    }
}
var Je = 0;
function V8(e) {
    return e &= -e,
    1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1
}
var W8, Cm, H8, U8, G8, c1 = !1, Uc = [], _r = null, Dr = null, Nr = null, El = new Map, Pl = new Map, kr = [], jM = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Ov(e, t) {
    switch (e) {
    case "focusin":
    case "focusout":
        _r = null;
        break;
    case "dragenter":
    case "dragleave":
        Dr = null;
        break;
    case "mouseover":
    case "mouseout":
        Nr = null;
        break;
    case "pointerover":
    case "pointerout":
        El.delete(t.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Pl.delete(t.pointerId)
    }
}
function Oa(e, t, n, i, r, s) {
    return e === null || e.nativeEvent !== s ? (e = {
        blockedOn: t,
        domEventName: n,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r]
    },
    t !== null && (t = fc(t),
    t !== null && Cm(t)),
    e) : (e.eventSystemFlags |= i,
    t = e.targetContainers,
    r !== null && t.indexOf(r) === -1 && t.push(r),
    e)
}
function OM(e, t, n, i, r) {
    switch (t) {
    case "focusin":
        return _r = Oa(_r, e, t, n, i, r),
        !0;
    case "dragenter":
        return Dr = Oa(Dr, e, t, n, i, r),
        !0;
    case "mouseover":
        return Nr = Oa(Nr, e, t, n, i, r),
        !0;
    case "pointerover":
        var s = r.pointerId;
        return El.set(s, Oa(El.get(s) || null, e, t, n, i, r)),
        !0;
    case "gotpointercapture":
        return s = r.pointerId,
        Pl.set(s, Oa(Pl.get(s) || null, e, t, n, i, r)),
        !0
    }
    return !1
}
function X8(e) {
    var t = js(e.target);
    if (t !== null) {
        var n = to(t);
        if (n !== null) {
            if (t = n.tag,
            t === 13) {
                if (t = _8(n),
                t !== null) {
                    e.blockedOn = t,
                    G8(e.priority, function() {
                        H8(n)
                    });
                    return
                }
            } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
                e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
                return
            }
        }
    }
    e.blockedOn = null
}
function Bu(e) {
    if (e.blockedOn !== null)
        return !1;
    for (var t = e.targetContainers; 0 < t.length; ) {
        var n = u1(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
        if (n === null) {
            n = e.nativeEvent;
            var i = new n.constructor(n.type,n);
            r1 = i,
            n.target.dispatchEvent(i),
            r1 = null
        } else
            return t = fc(n),
            t !== null && Cm(t),
            e.blockedOn = n,
            !1;
        t.shift()
    }
    return !0
}
function Lv(e, t, n) {
    Bu(e) && n.delete(t)
}
function LM() {
    c1 = !1,
    _r !== null && Bu(_r) && (_r = null),
    Dr !== null && Bu(Dr) && (Dr = null),
    Nr !== null && Bu(Nr) && (Nr = null),
    El.forEach(Lv),
    Pl.forEach(Lv)
}
function La(e, t) {
    e.blockedOn === t && (e.blockedOn = null,
    c1 || (c1 = !0,
    zn.unstable_scheduleCallback(zn.unstable_NormalPriority, LM)))
}
function Tl(e) {
    function t(r) {
        return La(r, e)
    }
    if (0 < Uc.length) {
        La(Uc[0], e);
        for (var n = 1; n < Uc.length; n++) {
            var i = Uc[n];
            i.blockedOn === e && (i.blockedOn = null)
        }
    }
    for (_r !== null && La(_r, e),
    Dr !== null && La(Dr, e),
    Nr !== null && La(Nr, e),
    El.forEach(t),
    Pl.forEach(t),
    n = 0; n < kr.length; n++)
        i = kr[n],
        i.blockedOn === e && (i.blockedOn = null);
    for (; 0 < kr.length && (n = kr[0],
    n.blockedOn === null); )
        X8(n),
        n.blockedOn === null && kr.shift()
}
var Ko = fr.ReactCurrentBatchConfig
  , fh = !0;
function RM(e, t, n, i) {
    var r = Je
      , s = Ko.transition;
    Ko.transition = null;
    try {
        Je = 1,
        km(e, t, n, i)
    } finally {
        Je = r,
        Ko.transition = s
    }
}
function _M(e, t, n, i) {
    var r = Je
      , s = Ko.transition;
    Ko.transition = null;
    try {
        Je = 4,
        km(e, t, n, i)
    } finally {
        Je = r,
        Ko.transition = s
    }
}
function km(e, t, n, i) {
    if (fh) {
        var r = u1(e, t, n, i);
        if (r === null)
            Wf(e, t, i, ph, n),
            Ov(e, i);
        else if (OM(r, e, t, n, i))
            i.stopPropagation();
        else if (Ov(e, i),
        t & 4 && -1 < jM.indexOf(e)) {
            for (; r !== null; ) {
                var s = fc(r);
                if (s !== null && W8(s),
                s = u1(e, t, n, i),
                s === null && Wf(e, t, i, ph, n),
                s === r)
                    break;
                r = s
            }
            r !== null && i.stopPropagation()
        } else
            Wf(e, t, i, null, n)
    }
}
var ph = null;
function u1(e, t, n, i) {
    if (ph = null,
    e = bm(i),
    e = js(e),
    e !== null)
        if (t = to(e),
        t === null)
            e = null;
        else if (n = t.tag,
        n === 13) {
            if (e = _8(t),
            e !== null)
                return e;
            e = null
        } else if (n === 3) {
            if (t.stateNode.current.memoizedState.isDehydrated)
                return t.tag === 3 ? t.stateNode.containerInfo : null;
            e = null
        } else
            t !== e && (e = null);
    return ph = e,
    null
}
function Y8(e) {
    switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (wM()) {
        case wm:
            return 1;
        case I8:
            return 4;
        case hh:
        case SM:
            return 16;
        case B8:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var Mr = null
  , Am = null
  , zu = null;
function $8() {
    if (zu)
        return zu;
    var e, t = Am, n = t.length, i, r = "value"in Mr ? Mr.value : Mr.textContent, s = r.length;
    for (e = 0; e < n && t[e] === r[e]; e++)
        ;
    var o = n - e;
    for (i = 1; i <= o && t[n - i] === r[s - i]; i++)
        ;
    return zu = r.slice(e, 1 < i ? 1 - i : void 0)
}
function Vu(e) {
    var t = e.keyCode;
    return "charCode"in e ? (e = e.charCode,
    e === 0 && t === 13 && (e = 13)) : e = t,
    e === 10 && (e = 13),
    32 <= e || e === 13 ? e : 0
}
function Gc() {
    return !0
}
function Rv() {
    return !1
}
function Gn(e) {
    function t(n, i, r, s, o) {
        this._reactName = n,
        this._targetInst = r,
        this.type = i,
        this.nativeEvent = s,
        this.target = o,
        this.currentTarget = null;
        for (var a in e)
            e.hasOwnProperty(a) && (n = e[a],
            this[a] = n ? n(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Gc : Rv,
        this.isPropagationStopped = Rv,
        this
    }
    return Ct(t.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var n = this.nativeEvent;
            n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1),
            this.isDefaultPrevented = Gc)
        },
        stopPropagation: function() {
            var n = this.nativeEvent;
            n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
            this.isPropagationStopped = Gc)
        },
        persist: function() {},
        isPersistent: Gc
    }),
    t
}
var ba = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(e) {
        return e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, Mm = Gn(ba), dc = Ct({}, ba, {
    view: 0,
    detail: 0
}), DM = Gn(dc), Rf, _f, Ra, gd = Ct({}, dc, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Em,
    button: 0,
    buttons: 0,
    relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
    },
    movementX: function(e) {
        return "movementX"in e ? e.movementX : (e !== Ra && (Ra && e.type === "mousemove" ? (Rf = e.screenX - Ra.screenX,
        _f = e.screenY - Ra.screenY) : _f = Rf = 0,
        Ra = e),
        Rf)
    },
    movementY: function(e) {
        return "movementY"in e ? e.movementY : _f
    }
}), _v = Gn(gd), NM = Ct({}, gd, {
    dataTransfer: 0
}), FM = Gn(NM), IM = Ct({}, dc, {
    relatedTarget: 0
}), Df = Gn(IM), BM = Ct({}, ba, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), zM = Gn(BM), VM = Ct({}, ba, {
    clipboardData: function(e) {
        return "clipboardData"in e ? e.clipboardData : window.clipboardData
    }
}), WM = Gn(VM), HM = Ct({}, ba, {
    data: 0
}), Dv = Gn(HM), UM = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, GM = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, XM = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function YM(e) {
    var t = this.nativeEvent;
    return t.getModifierState ? t.getModifierState(e) : (e = XM[e]) ? !!t[e] : !1
}
function Em() {
    return YM
}
var $M = Ct({}, dc, {
    key: function(e) {
        if (e.key) {
            var t = UM[e.key] || e.key;
            if (t !== "Unidentified")
                return t
        }
        return e.type === "keypress" ? (e = Vu(e),
        e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? GM[e.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Em,
    charCode: function(e) {
        return e.type === "keypress" ? Vu(e) : 0
    },
    keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    },
    which: function(e) {
        return e.type === "keypress" ? Vu(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    }
})
  , KM = Gn($M)
  , QM = Ct({}, gd, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , Nv = Gn(QM)
  , qM = Ct({}, dc, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Em
})
  , ZM = Gn(qM)
  , JM = Ct({}, ba, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , eE = Gn(JM)
  , tE = Ct({}, gd, {
    deltaX: function(e) {
        return "deltaX"in e ? e.deltaX : "wheelDeltaX"in e ? -e.wheelDeltaX : 0
    },
    deltaY: function(e) {
        return "deltaY"in e ? e.deltaY : "wheelDeltaY"in e ? -e.wheelDeltaY : "wheelDelta"in e ? -e.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , nE = Gn(tE)
  , iE = [9, 13, 27, 32]
  , Pm = lr && "CompositionEvent"in window
  , sl = null;
lr && "documentMode"in document && (sl = document.documentMode);
var rE = lr && "TextEvent"in window && !sl
  , K8 = lr && (!Pm || sl && 8 < sl && 11 >= sl)
  , Fv = " "
  , Iv = !1;
function Q8(e, t) {
    switch (e) {
    case "keyup":
        return iE.indexOf(t.keyCode) !== -1;
    case "keydown":
        return t.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function q8(e) {
    return e = e.detail,
    typeof e == "object" && "data"in e ? e.data : null
}
var Eo = !1;
function sE(e, t) {
    switch (e) {
    case "compositionend":
        return q8(t);
    case "keypress":
        return t.which !== 32 ? null : (Iv = !0,
        Fv);
    case "textInput":
        return e = t.data,
        e === Fv && Iv ? null : e;
    default:
        return null
    }
}
function oE(e, t) {
    if (Eo)
        return e === "compositionend" || !Pm && Q8(e, t) ? (e = $8(),
        zu = Am = Mr = null,
        Eo = !1,
        e) : null;
    switch (e) {
    case "paste":
        return null;
    case "keypress":
        if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
            if (t.char && 1 < t.char.length)
                return t.char;
            if (t.which)
                return String.fromCharCode(t.which)
        }
        return null;
    case "compositionend":
        return K8 && t.locale !== "ko" ? null : t.data;
    default:
        return null
    }
}
var aE = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function Bv(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t === "input" ? !!aE[e.type] : t === "textarea"
}
function Z8(e, t, n, i) {
    T8(i),
    t = gh(t, "onChange"),
    0 < t.length && (n = new Mm("onChange","change",null,n,i),
    e.push({
        event: n,
        listeners: t
    }))
}
var ol = null
  , jl = null;
function lE(e) {
    c9(e, 0)
}
function md(e) {
    var t = jo(e);
    if (S8(t))
        return e
}
function cE(e, t) {
    if (e === "change")
        return t
}
var J8 = !1;
if (lr) {
    var Nf;
    if (lr) {
        var Ff = "oninput"in document;
        if (!Ff) {
            var zv = document.createElement("div");
            zv.setAttribute("oninput", "return;"),
            Ff = typeof zv.oninput == "function"
        }
        Nf = Ff
    } else
        Nf = !1;
    J8 = Nf && (!document.documentMode || 9 < document.documentMode)
}
function Vv() {
    ol && (ol.detachEvent("onpropertychange", e9),
    jl = ol = null)
}
function e9(e) {
    if (e.propertyName === "value" && md(jl)) {
        var t = [];
        Z8(t, jl, e, bm(e)),
        R8(lE, t)
    }
}
function uE(e, t, n) {
    e === "focusin" ? (Vv(),
    ol = t,
    jl = n,
    ol.attachEvent("onpropertychange", e9)) : e === "focusout" && Vv()
}
function hE(e) {
    if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return md(jl)
}
function dE(e, t) {
    if (e === "click")
        return md(t)
}
function fE(e, t) {
    if (e === "input" || e === "change")
        return md(t)
}
function pE(e, t) {
    return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var Si = typeof Object.is == "function" ? Object.is : pE;
function Ol(e, t) {
    if (Si(e, t))
        return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
        return !1;
    var n = Object.keys(e)
      , i = Object.keys(t);
    if (n.length !== i.length)
        return !1;
    for (i = 0; i < n.length; i++) {
        var r = n[i];
        if (!X0.call(t, r) || !Si(e[r], t[r]))
            return !1
    }
    return !0
}
function Wv(e) {
    for (; e && e.firstChild; )
        e = e.firstChild;
    return e
}
function Hv(e, t) {
    var n = Wv(e);
    e = 0;
    for (var i; n; ) {
        if (n.nodeType === 3) {
            if (i = e + n.textContent.length,
            e <= t && i >= t)
                return {
                    node: n,
                    offset: t - e
                };
            e = i
        }
        e: {
            for (; n; ) {
                if (n.nextSibling) {
                    n = n.nextSibling;
                    break e
                }
                n = n.parentNode
            }
            n = void 0
        }
        n = Wv(n)
    }
}
function t9(e, t) {
    return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? t9(e, t.parentNode) : "contains"in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1
}
function n9() {
    for (var e = window, t = lh(); t instanceof e.HTMLIFrameElement; ) {
        try {
            var n = typeof t.contentWindow.location.href == "string"
        } catch {
            n = !1
        }
        if (n)
            e = t.contentWindow;
        else
            break;
        t = lh(e.document)
    }
    return t
}
function Tm(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true")
}
function gE(e) {
    var t = n9()
      , n = e.focusedElem
      , i = e.selectionRange;
    if (t !== n && n && n.ownerDocument && t9(n.ownerDocument.documentElement, n)) {
        if (i !== null && Tm(n)) {
            if (t = i.start,
            e = i.end,
            e === void 0 && (e = t),
            "selectionStart"in n)
                n.selectionStart = t,
                n.selectionEnd = Math.min(e, n.value.length);
            else if (e = (t = n.ownerDocument || document) && t.defaultView || window,
            e.getSelection) {
                e = e.getSelection();
                var r = n.textContent.length
                  , s = Math.min(i.start, r);
                i = i.end === void 0 ? s : Math.min(i.end, r),
                !e.extend && s > i && (r = i,
                i = s,
                s = r),
                r = Hv(n, s);
                var o = Hv(n, i);
                r && o && (e.rangeCount !== 1 || e.anchorNode !== r.node || e.anchorOffset !== r.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(),
                t.setStart(r.node, r.offset),
                e.removeAllRanges(),
                s > i ? (e.addRange(t),
                e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset),
                e.addRange(t)))
            }
        }
        for (t = [],
        e = n; e = e.parentNode; )
            e.nodeType === 1 && t.push({
                element: e,
                left: e.scrollLeft,
                top: e.scrollTop
            });
        for (typeof n.focus == "function" && n.focus(),
        n = 0; n < t.length; n++)
            e = t[n],
            e.element.scrollLeft = e.left,
            e.element.scrollTop = e.top
    }
}
var mE = lr && "documentMode"in document && 11 >= document.documentMode
  , Po = null
  , h1 = null
  , al = null
  , d1 = !1;
function Uv(e, t, n) {
    var i = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
    d1 || Po == null || Po !== lh(i) || (i = Po,
    "selectionStart"in i && Tm(i) ? i = {
        start: i.selectionStart,
        end: i.selectionEnd
    } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(),
    i = {
        anchorNode: i.anchorNode,
        anchorOffset: i.anchorOffset,
        focusNode: i.focusNode,
        focusOffset: i.focusOffset
    }),
    al && Ol(al, i) || (al = i,
    i = gh(h1, "onSelect"),
    0 < i.length && (t = new Mm("onSelect","select",null,t,n),
    e.push({
        event: t,
        listeners: i
    }),
    t.target = Po)))
}
function Xc(e, t) {
    var n = {};
    return n[e.toLowerCase()] = t.toLowerCase(),
    n["Webkit" + e] = "webkit" + t,
    n["Moz" + e] = "moz" + t,
    n
}
var To = {
    animationend: Xc("Animation", "AnimationEnd"),
    animationiteration: Xc("Animation", "AnimationIteration"),
    animationstart: Xc("Animation", "AnimationStart"),
    transitionend: Xc("Transition", "TransitionEnd")
}
  , If = {}
  , i9 = {};
lr && (i9 = document.createElement("div").style,
"AnimationEvent"in window || (delete To.animationend.animation,
delete To.animationiteration.animation,
delete To.animationstart.animation),
"TransitionEvent"in window || delete To.transitionend.transition);
function vd(e) {
    if (If[e])
        return If[e];
    if (!To[e])
        return e;
    var t = To[e], n;
    for (n in t)
        if (t.hasOwnProperty(n) && n in i9)
            return If[e] = t[n];
    return e
}
var r9 = vd("animationend")
  , s9 = vd("animationiteration")
  , o9 = vd("animationstart")
  , a9 = vd("transitionend")
  , l9 = new Map
  , Gv = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function es(e, t) {
    l9.set(e, t),
    eo(t, [e])
}
for (var Bf = 0; Bf < Gv.length; Bf++) {
    var zf = Gv[Bf]
      , vE = zf.toLowerCase()
      , yE = zf[0].toUpperCase() + zf.slice(1);
    es(vE, "on" + yE)
}
es(r9, "onAnimationEnd");
es(s9, "onAnimationIteration");
es(o9, "onAnimationStart");
es("dblclick", "onDoubleClick");
es("focusin", "onFocus");
es("focusout", "onBlur");
es(a9, "onTransitionEnd");
ia("onMouseEnter", ["mouseout", "mouseover"]);
ia("onMouseLeave", ["mouseout", "mouseover"]);
ia("onPointerEnter", ["pointerout", "pointerover"]);
ia("onPointerLeave", ["pointerout", "pointerover"]);
eo("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
eo("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
eo("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
eo("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
eo("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
eo("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Ka = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , xE = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ka));
function Xv(e, t, n) {
    var i = e.type || "unknown-event";
    e.currentTarget = n,
    vM(i, t, void 0, e),
    e.currentTarget = null
}
function c9(e, t) {
    t = (t & 4) !== 0;
    for (var n = 0; n < e.length; n++) {
        var i = e[n]
          , r = i.event;
        i = i.listeners;
        e: {
            var s = void 0;
            if (t)
                for (var o = i.length - 1; 0 <= o; o--) {
                    var a = i[o]
                      , l = a.instance
                      , c = a.currentTarget;
                    if (a = a.listener,
                    l !== s && r.isPropagationStopped())
                        break e;
                    Xv(r, a, c),
                    s = l
                }
            else
                for (o = 0; o < i.length; o++) {
                    if (a = i[o],
                    l = a.instance,
                    c = a.currentTarget,
                    a = a.listener,
                    l !== s && r.isPropagationStopped())
                        break e;
                    Xv(r, a, c),
                    s = l
                }
        }
    }
    if (uh)
        throw e = a1,
        uh = !1,
        a1 = null,
        e
}
function dt(e, t) {
    var n = t[v1];
    n === void 0 && (n = t[v1] = new Set);
    var i = e + "__bubble";
    n.has(i) || (u9(t, e, 2, !1),
    n.add(i))
}
function Vf(e, t, n) {
    var i = 0;
    t && (i |= 4),
    u9(n, e, i, t)
}
var Yc = "_reactListening" + Math.random().toString(36).slice(2);
function Ll(e) {
    if (!e[Yc]) {
        e[Yc] = !0,
        v8.forEach(function(n) {
            n !== "selectionchange" && (xE.has(n) || Vf(n, !1, e),
            Vf(n, !0, e))
        });
        var t = e.nodeType === 9 ? e : e.ownerDocument;
        t === null || t[Yc] || (t[Yc] = !0,
        Vf("selectionchange", !1, t))
    }
}
function u9(e, t, n, i) {
    switch (Y8(t)) {
    case 1:
        var r = RM;
        break;
    case 4:
        r = _M;
        break;
    default:
        r = km
    }
    n = r.bind(null, t, n, e),
    r = void 0,
    !o1 || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (r = !0),
    i ? r !== void 0 ? e.addEventListener(t, n, {
        capture: !0,
        passive: r
    }) : e.addEventListener(t, n, !0) : r !== void 0 ? e.addEventListener(t, n, {
        passive: r
    }) : e.addEventListener(t, n, !1)
}
function Wf(e, t, n, i, r) {
    var s = i;
    if (!(t & 1) && !(t & 2) && i !== null)
        e: for (; ; ) {
            if (i === null)
                return;
            var o = i.tag;
            if (o === 3 || o === 4) {
                var a = i.stateNode.containerInfo;
                if (a === r || a.nodeType === 8 && a.parentNode === r)
                    break;
                if (o === 4)
                    for (o = i.return; o !== null; ) {
                        var l = o.tag;
                        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo,
                        l === r || l.nodeType === 8 && l.parentNode === r))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = js(a),
                    o === null)
                        return;
                    if (l = o.tag,
                    l === 5 || l === 6) {
                        i = s = o;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            i = i.return
        }
    R8(function() {
        var c = s
          , u = bm(n)
          , h = [];
        e: {
            var d = l9.get(e);
            if (d !== void 0) {
                var m = Mm
                  , f = e;
                switch (e) {
                case "keypress":
                    if (Vu(n) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    m = KM;
                    break;
                case "focusin":
                    f = "focus",
                    m = Df;
                    break;
                case "focusout":
                    f = "blur",
                    m = Df;
                    break;
                case "beforeblur":
                case "afterblur":
                    m = Df;
                    break;
                case "click":
                    if (n.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    m = _v;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    m = FM;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    m = ZM;
                    break;
                case r9:
                case s9:
                case o9:
                    m = zM;
                    break;
                case a9:
                    m = eE;
                    break;
                case "scroll":
                    m = DM;
                    break;
                case "wheel":
                    m = nE;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    m = WM;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    m = Nv
                }
                var x = (t & 4) !== 0
                  , S = !x && e === "scroll"
                  , v = x ? d !== null ? d + "Capture" : null : d;
                x = [];
                for (var p = c, g; p !== null; ) {
                    g = p;
                    var C = g.stateNode;
                    if (g.tag === 5 && C !== null && (g = C,
                    v !== null && (C = Ml(p, v),
                    C != null && x.push(Rl(p, C, g)))),
                    S)
                        break;
                    p = p.return
                }
                0 < x.length && (d = new m(d,f,null,n,u),
                h.push({
                    event: d,
                    listeners: x
                }))
            }
        }
        if (!(t & 7)) {
            e: {
                if (d = e === "mouseover" || e === "pointerover",
                m = e === "mouseout" || e === "pointerout",
                d && n !== r1 && (f = n.relatedTarget || n.fromElement) && (js(f) || f[cr]))
                    break e;
                if ((m || d) && (d = u.window === u ? u : (d = u.ownerDocument) ? d.defaultView || d.parentWindow : window,
                m ? (f = n.relatedTarget || n.toElement,
                m = c,
                f = f ? js(f) : null,
                f !== null && (S = to(f),
                f !== S || f.tag !== 5 && f.tag !== 6) && (f = null)) : (m = null,
                f = c),
                m !== f)) {
                    if (x = _v,
                    C = "onMouseLeave",
                    v = "onMouseEnter",
                    p = "mouse",
                    (e === "pointerout" || e === "pointerover") && (x = Nv,
                    C = "onPointerLeave",
                    v = "onPointerEnter",
                    p = "pointer"),
                    S = m == null ? d : jo(m),
                    g = f == null ? d : jo(f),
                    d = new x(C,p + "leave",m,n,u),
                    d.target = S,
                    d.relatedTarget = g,
                    C = null,
                    js(u) === c && (x = new x(v,p + "enter",f,n,u),
                    x.target = g,
                    x.relatedTarget = S,
                    C = x),
                    S = C,
                    m && f)
                        t: {
                            for (x = m,
                            v = f,
                            p = 0,
                            g = x; g; g = go(g))
                                p++;
                            for (g = 0,
                            C = v; C; C = go(C))
                                g++;
                            for (; 0 < p - g; )
                                x = go(x),
                                p--;
                            for (; 0 < g - p; )
                                v = go(v),
                                g--;
                            for (; p--; ) {
                                if (x === v || v !== null && x === v.alternate)
                                    break t;
                                x = go(x),
                                v = go(v)
                            }
                            x = null
                        }
                    else
                        x = null;
                    m !== null && Yv(h, d, m, x, !1),
                    f !== null && S !== null && Yv(h, S, f, x, !0)
                }
            }
            e: {
                if (d = c ? jo(c) : window,
                m = d.nodeName && d.nodeName.toLowerCase(),
                m === "select" || m === "input" && d.type === "file")
                    var E = cE;
                else if (Bv(d))
                    if (J8)
                        E = fE;
                    else {
                        E = hE;
                        var O = uE
                    }
                else
                    (m = d.nodeName) && m.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (E = dE);
                if (E && (E = E(e, c))) {
                    Z8(h, E, n, u);
                    break e
                }
                O && O(e, d, c),
                e === "focusout" && (O = d._wrapperState) && O.controlled && d.type === "number" && J0(d, "number", d.value)
            }
            switch (O = c ? jo(c) : window,
            e) {
            case "focusin":
                (Bv(O) || O.contentEditable === "true") && (Po = O,
                h1 = c,
                al = null);
                break;
            case "focusout":
                al = h1 = Po = null;
                break;
            case "mousedown":
                d1 = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                d1 = !1,
                Uv(h, n, u);
                break;
            case "selectionchange":
                if (mE)
                    break;
            case "keydown":
            case "keyup":
                Uv(h, n, u)
            }
            var R;
            if (Pm)
                e: {
                    switch (e) {
                    case "compositionstart":
                        var F = "onCompositionStart";
                        break e;
                    case "compositionend":
                        F = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        F = "onCompositionUpdate";
                        break e
                    }
                    F = void 0
                }
            else
                Eo ? Q8(e, n) && (F = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (F = "onCompositionStart");
            F && (K8 && n.locale !== "ko" && (Eo || F !== "onCompositionStart" ? F === "onCompositionEnd" && Eo && (R = $8()) : (Mr = u,
            Am = "value"in Mr ? Mr.value : Mr.textContent,
            Eo = !0)),
            O = gh(c, F),
            0 < O.length && (F = new Dv(F,e,null,n,u),
            h.push({
                event: F,
                listeners: O
            }),
            R ? F.data = R : (R = q8(n),
            R !== null && (F.data = R)))),
            (R = rE ? sE(e, n) : oE(e, n)) && (c = gh(c, "onBeforeInput"),
            0 < c.length && (u = new Dv("onBeforeInput","beforeinput",null,n,u),
            h.push({
                event: u,
                listeners: c
            }),
            u.data = R))
        }
        c9(h, t)
    })
}
function Rl(e, t, n) {
    return {
        instance: e,
        listener: t,
        currentTarget: n
    }
}
function gh(e, t) {
    for (var n = t + "Capture", i = []; e !== null; ) {
        var r = e
          , s = r.stateNode;
        r.tag === 5 && s !== null && (r = s,
        s = Ml(e, n),
        s != null && i.unshift(Rl(e, s, r)),
        s = Ml(e, t),
        s != null && i.push(Rl(e, s, r))),
        e = e.return
    }
    return i
}
function go(e) {
    if (e === null)
        return null;
    do
        e = e.return;
    while (e && e.tag !== 5);
    return e || null
}
function Yv(e, t, n, i, r) {
    for (var s = t._reactName, o = []; n !== null && n !== i; ) {
        var a = n
          , l = a.alternate
          , c = a.stateNode;
        if (l !== null && l === i)
            break;
        a.tag === 5 && c !== null && (a = c,
        r ? (l = Ml(n, s),
        l != null && o.unshift(Rl(n, l, a))) : r || (l = Ml(n, s),
        l != null && o.push(Rl(n, l, a)))),
        n = n.return
    }
    o.length !== 0 && e.push({
        event: t,
        listeners: o
    })
}
var bE = /\r\n?/g
  , wE = /\u0000|\uFFFD/g;
function $v(e) {
    return (typeof e == "string" ? e : "" + e).replace(bE, `
`).replace(wE, "")
}
function $c(e, t, n) {
    if (t = $v(t),
    $v(e) !== t && n)
        throw Error(Se(425))
}
function mh() {}
var f1 = null
  , p1 = null;
function g1(e, t) {
    return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null
}
var m1 = typeof setTimeout == "function" ? setTimeout : void 0
  , SE = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Kv = typeof Promise == "function" ? Promise : void 0
  , CE = typeof queueMicrotask == "function" ? queueMicrotask : typeof Kv < "u" ? function(e) {
    return Kv.resolve(null).then(e).catch(kE)
}
: m1;
function kE(e) {
    setTimeout(function() {
        throw e
    })
}
function Hf(e, t) {
    var n = t
      , i = 0;
    do {
        var r = n.nextSibling;
        if (e.removeChild(n),
        r && r.nodeType === 8)
            if (n = r.data,
            n === "/$") {
                if (i === 0) {
                    e.removeChild(r),
                    Tl(t);
                    return
                }
                i--
            } else
                n !== "$" && n !== "$?" && n !== "$!" || i++;
        n = r
    } while (n);
    Tl(t)
}
function Fr(e) {
    for (; e != null; e = e.nextSibling) {
        var t = e.nodeType;
        if (t === 1 || t === 3)
            break;
        if (t === 8) {
            if (t = e.data,
            t === "$" || t === "$!" || t === "$?")
                break;
            if (t === "/$")
                return null
        }
    }
    return e
}
function Qv(e) {
    e = e.previousSibling;
    for (var t = 0; e; ) {
        if (e.nodeType === 8) {
            var n = e.data;
            if (n === "$" || n === "$!" || n === "$?") {
                if (t === 0)
                    return e;
                t--
            } else
                n === "/$" && t++
        }
        e = e.previousSibling
    }
    return null
}
var wa = Math.random().toString(36).slice(2)
  , _i = "__reactFiber$" + wa
  , _l = "__reactProps$" + wa
  , cr = "__reactContainer$" + wa
  , v1 = "__reactEvents$" + wa
  , AE = "__reactListeners$" + wa
  , ME = "__reactHandles$" + wa;
function js(e) {
    var t = e[_i];
    if (t)
        return t;
    for (var n = e.parentNode; n; ) {
        if (t = n[cr] || n[_i]) {
            if (n = t.alternate,
            t.child !== null || n !== null && n.child !== null)
                for (e = Qv(e); e !== null; ) {
                    if (n = e[_i])
                        return n;
                    e = Qv(e)
                }
            return t
        }
        e = n,
        n = e.parentNode
    }
    return null
}
function fc(e) {
    return e = e[_i] || e[cr],
    !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e
}
function jo(e) {
    if (e.tag === 5 || e.tag === 6)
        return e.stateNode;
    throw Error(Se(33))
}
function yd(e) {
    return e[_l] || null
}
var y1 = []
  , Oo = -1;
function ts(e) {
    return {
        current: e
    }
}
function pt(e) {
    0 > Oo || (e.current = y1[Oo],
    y1[Oo] = null,
    Oo--)
}
function lt(e, t) {
    Oo++,
    y1[Oo] = e.current,
    e.current = t
}
var $r = {}
  , ln = ts($r)
  , Mn = ts(!1)
  , Xs = $r;
function ra(e, t) {
    var n = e.type.contextTypes;
    if (!n)
        return $r;
    var i = e.stateNode;
    if (i && i.__reactInternalMemoizedUnmaskedChildContext === t)
        return i.__reactInternalMemoizedMaskedChildContext;
    var r = {}, s;
    for (s in n)
        r[s] = t[s];
    return i && (e = e.stateNode,
    e.__reactInternalMemoizedUnmaskedChildContext = t,
    e.__reactInternalMemoizedMaskedChildContext = r),
    r
}
function En(e) {
    return e = e.childContextTypes,
    e != null
}
function vh() {
    pt(Mn),
    pt(ln)
}
function qv(e, t, n) {
    if (ln.current !== $r)
        throw Error(Se(168));
    lt(ln, t),
    lt(Mn, n)
}
function h9(e, t, n) {
    var i = e.stateNode;
    if (t = t.childContextTypes,
    typeof i.getChildContext != "function")
        return n;
    i = i.getChildContext();
    for (var r in i)
        if (!(r in t))
            throw Error(Se(108, uM(e) || "Unknown", r));
    return Ct({}, n, i)
}
function yh(e) {
    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || $r,
    Xs = ln.current,
    lt(ln, e),
    lt(Mn, Mn.current),
    !0
}
function Zv(e, t, n) {
    var i = e.stateNode;
    if (!i)
        throw Error(Se(169));
    n ? (e = h9(e, t, Xs),
    i.__reactInternalMemoizedMergedChildContext = e,
    pt(Mn),
    pt(ln),
    lt(ln, e)) : pt(Mn),
    lt(Mn, n)
}
var Zi = null
  , xd = !1
  , Uf = !1;
function d9(e) {
    Zi === null ? Zi = [e] : Zi.push(e)
}
function EE(e) {
    xd = !0,
    d9(e)
}
function ns() {
    if (!Uf && Zi !== null) {
        Uf = !0;
        var e = 0
          , t = Je;
        try {
            var n = Zi;
            for (Je = 1; e < n.length; e++) {
                var i = n[e];
                do
                    i = i(!0);
                while (i !== null)
            }
            Zi = null,
            xd = !1
        } catch (r) {
            throw Zi !== null && (Zi = Zi.slice(e + 1)),
            F8(wm, ns),
            r
        } finally {
            Je = t,
            Uf = !1
        }
    }
    return null
}
var Lo = []
  , Ro = 0
  , xh = null
  , bh = 0
  , Zn = []
  , Jn = 0
  , Ys = null
  , tr = 1
  , nr = "";
function ws(e, t) {
    Lo[Ro++] = bh,
    Lo[Ro++] = xh,
    xh = e,
    bh = t
}
function f9(e, t, n) {
    Zn[Jn++] = tr,
    Zn[Jn++] = nr,
    Zn[Jn++] = Ys,
    Ys = e;
    var i = tr;
    e = nr;
    var r = 32 - xi(i) - 1;
    i &= ~(1 << r),
    n += 1;
    var s = 32 - xi(t) + r;
    if (30 < s) {
        var o = r - r % 5;
        s = (i & (1 << o) - 1).toString(32),
        i >>= o,
        r -= o,
        tr = 1 << 32 - xi(t) + r | n << r | i,
        nr = s + e
    } else
        tr = 1 << s | n << r | i,
        nr = e
}
function jm(e) {
    e.return !== null && (ws(e, 1),
    f9(e, 1, 0))
}
function Om(e) {
    for (; e === xh; )
        xh = Lo[--Ro],
        Lo[Ro] = null,
        bh = Lo[--Ro],
        Lo[Ro] = null;
    for (; e === Ys; )
        Ys = Zn[--Jn],
        Zn[Jn] = null,
        nr = Zn[--Jn],
        Zn[Jn] = null,
        tr = Zn[--Jn],
        Zn[Jn] = null
}
var Bn = null
  , Fn = null
  , vt = !1
  , vi = null;
function p9(e, t) {
    var n = ei(5, null, null, 0);
    n.elementType = "DELETED",
    n.stateNode = t,
    n.return = e,
    t = e.deletions,
    t === null ? (e.deletions = [n],
    e.flags |= 16) : t.push(n)
}
function Jv(e, t) {
    switch (e.tag) {
    case 5:
        var n = e.type;
        return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t,
        t !== null ? (e.stateNode = t,
        Bn = e,
        Fn = Fr(t.firstChild),
        !0) : !1;
    case 6:
        return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t,
        t !== null ? (e.stateNode = t,
        Bn = e,
        Fn = null,
        !0) : !1;
    case 13:
        return t = t.nodeType !== 8 ? null : t,
        t !== null ? (n = Ys !== null ? {
            id: tr,
            overflow: nr
        } : null,
        e.memoizedState = {
            dehydrated: t,
            treeContext: n,
            retryLane: 1073741824
        },
        n = ei(18, null, null, 0),
        n.stateNode = t,
        n.return = e,
        e.child = n,
        Bn = e,
        Fn = null,
        !0) : !1;
    default:
        return !1
    }
}
function x1(e) {
    return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}
function b1(e) {
    if (vt) {
        var t = Fn;
        if (t) {
            var n = t;
            if (!Jv(e, t)) {
                if (x1(e))
                    throw Error(Se(418));
                t = Fr(n.nextSibling);
                var i = Bn;
                t && Jv(e, t) ? p9(i, n) : (e.flags = e.flags & -4097 | 2,
                vt = !1,
                Bn = e)
            }
        } else {
            if (x1(e))
                throw Error(Se(418));
            e.flags = e.flags & -4097 | 2,
            vt = !1,
            Bn = e
        }
    }
}
function ey(e) {
    for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; )
        e = e.return;
    Bn = e
}
function Kc(e) {
    if (e !== Bn)
        return !1;
    if (!vt)
        return ey(e),
        vt = !0,
        !1;
    var t;
    if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type,
    t = t !== "head" && t !== "body" && !g1(e.type, e.memoizedProps)),
    t && (t = Fn)) {
        if (x1(e))
            throw g9(),
            Error(Se(418));
        for (; t; )
            p9(e, t),
            t = Fr(t.nextSibling)
    }
    if (ey(e),
    e.tag === 13) {
        if (e = e.memoizedState,
        e = e !== null ? e.dehydrated : null,
        !e)
            throw Error(Se(317));
        e: {
            for (e = e.nextSibling,
            t = 0; e; ) {
                if (e.nodeType === 8) {
                    var n = e.data;
                    if (n === "/$") {
                        if (t === 0) {
                            Fn = Fr(e.nextSibling);
                            break e
                        }
                        t--
                    } else
                        n !== "$" && n !== "$!" && n !== "$?" || t++
                }
                e = e.nextSibling
            }
            Fn = null
        }
    } else
        Fn = Bn ? Fr(e.stateNode.nextSibling) : null;
    return !0
}
function g9() {
    for (var e = Fn; e; )
        e = Fr(e.nextSibling)
}
function sa() {
    Fn = Bn = null,
    vt = !1
}
function Lm(e) {
    vi === null ? vi = [e] : vi.push(e)
}
var PE = fr.ReactCurrentBatchConfig;
function fi(e, t) {
    if (e && e.defaultProps) {
        t = Ct({}, t),
        e = e.defaultProps;
        for (var n in e)
            t[n] === void 0 && (t[n] = e[n]);
        return t
    }
    return t
}
var wh = ts(null)
  , Sh = null
  , _o = null
  , Rm = null;
function _m() {
    Rm = _o = Sh = null
}
function Dm(e) {
    var t = wh.current;
    pt(wh),
    e._currentValue = t
}
function w1(e, t, n) {
    for (; e !== null; ) {
        var i = e.alternate;
        if ((e.childLanes & t) !== t ? (e.childLanes |= t,
        i !== null && (i.childLanes |= t)) : i !== null && (i.childLanes & t) !== t && (i.childLanes |= t),
        e === n)
            break;
        e = e.return
    }
}
function Qo(e, t) {
    Sh = e,
    Rm = _o = null,
    e = e.dependencies,
    e !== null && e.firstContext !== null && (e.lanes & t && (kn = !0),
    e.firstContext = null)
}
function ri(e) {
    var t = e._currentValue;
    if (Rm !== e)
        if (e = {
            context: e,
            memoizedValue: t,
            next: null
        },
        _o === null) {
            if (Sh === null)
                throw Error(Se(308));
            _o = e,
            Sh.dependencies = {
                lanes: 0,
                firstContext: e
            }
        } else
            _o = _o.next = e;
    return t
}
var Os = null;
function Nm(e) {
    Os === null ? Os = [e] : Os.push(e)
}
function m9(e, t, n, i) {
    var r = t.interleaved;
    return r === null ? (n.next = n,
    Nm(t)) : (n.next = r.next,
    r.next = n),
    t.interleaved = n,
    ur(e, i)
}
function ur(e, t) {
    e.lanes |= t;
    var n = e.alternate;
    for (n !== null && (n.lanes |= t),
    n = e,
    e = e.return; e !== null; )
        e.childLanes |= t,
        n = e.alternate,
        n !== null && (n.childLanes |= t),
        n = e,
        e = e.return;
    return n.tag === 3 ? n.stateNode : null
}
var Sr = !1;
function Fm(e) {
    e.updateQueue = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function v9(e, t) {
    e = e.updateQueue,
    t.updateQueue === e && (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects
    })
}
function sr(e, t) {
    return {
        eventTime: e,
        lane: t,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function Ir(e, t, n) {
    var i = e.updateQueue;
    if (i === null)
        return null;
    if (i = i.shared,
    $e & 2) {
        var r = i.pending;
        return r === null ? t.next = t : (t.next = r.next,
        r.next = t),
        i.pending = t,
        ur(e, n)
    }
    return r = i.interleaved,
    r === null ? (t.next = t,
    Nm(i)) : (t.next = r.next,
    r.next = t),
    i.interleaved = t,
    ur(e, n)
}
function Wu(e, t, n) {
    if (t = t.updateQueue,
    t !== null && (t = t.shared,
    (n & 4194240) !== 0)) {
        var i = t.lanes;
        i &= e.pendingLanes,
        n |= i,
        t.lanes = n,
        Sm(e, n)
    }
}
function ty(e, t) {
    var n = e.updateQueue
      , i = e.alternate;
    if (i !== null && (i = i.updateQueue,
    n === i)) {
        var r = null
          , s = null;
        if (n = n.firstBaseUpdate,
        n !== null) {
            do {
                var o = {
                    eventTime: n.eventTime,
                    lane: n.lane,
                    tag: n.tag,
                    payload: n.payload,
                    callback: n.callback,
                    next: null
                };
                s === null ? r = s = o : s = s.next = o,
                n = n.next
            } while (n !== null);
            s === null ? r = s = t : s = s.next = t
        } else
            r = s = t;
        n = {
            baseState: i.baseState,
            firstBaseUpdate: r,
            lastBaseUpdate: s,
            shared: i.shared,
            effects: i.effects
        },
        e.updateQueue = n;
        return
    }
    e = n.lastBaseUpdate,
    e === null ? n.firstBaseUpdate = t : e.next = t,
    n.lastBaseUpdate = t
}
function Ch(e, t, n, i) {
    var r = e.updateQueue;
    Sr = !1;
    var s = r.firstBaseUpdate
      , o = r.lastBaseUpdate
      , a = r.shared.pending;
    if (a !== null) {
        r.shared.pending = null;
        var l = a
          , c = l.next;
        l.next = null,
        o === null ? s = c : o.next = c,
        o = l;
        var u = e.alternate;
        u !== null && (u = u.updateQueue,
        a = u.lastBaseUpdate,
        a !== o && (a === null ? u.firstBaseUpdate = c : a.next = c,
        u.lastBaseUpdate = l))
    }
    if (s !== null) {
        var h = r.baseState;
        o = 0,
        u = c = l = null,
        a = s;
        do {
            var d = a.lane
              , m = a.eventTime;
            if ((i & d) === d) {
                u !== null && (u = u.next = {
                    eventTime: m,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var f = e
                      , x = a;
                    switch (d = t,
                    m = n,
                    x.tag) {
                    case 1:
                        if (f = x.payload,
                        typeof f == "function") {
                            h = f.call(m, h, d);
                            break e
                        }
                        h = f;
                        break e;
                    case 3:
                        f.flags = f.flags & -65537 | 128;
                    case 0:
                        if (f = x.payload,
                        d = typeof f == "function" ? f.call(m, h, d) : f,
                        d == null)
                            break e;
                        h = Ct({}, h, d);
                        break e;
                    case 2:
                        Sr = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (e.flags |= 64,
                d = r.effects,
                d === null ? r.effects = [a] : d.push(a))
            } else
                m = {
                    eventTime: m,
                    lane: d,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                u === null ? (c = u = m,
                l = h) : u = u.next = m,
                o |= d;
            if (a = a.next,
            a === null) {
                if (a = r.shared.pending,
                a === null)
                    break;
                d = a,
                a = d.next,
                d.next = null,
                r.lastBaseUpdate = d,
                r.shared.pending = null
            }
        } while (!0);
        if (u === null && (l = h),
        r.baseState = l,
        r.firstBaseUpdate = c,
        r.lastBaseUpdate = u,
        t = r.shared.interleaved,
        t !== null) {
            r = t;
            do
                o |= r.lane,
                r = r.next;
            while (r !== t)
        } else
            s === null && (r.shared.lanes = 0);
        Ks |= o,
        e.lanes = o,
        e.memoizedState = h
    }
}
function ny(e, t, n) {
    if (e = t.effects,
    t.effects = null,
    e !== null)
        for (t = 0; t < e.length; t++) {
            var i = e[t]
              , r = i.callback;
            if (r !== null) {
                if (i.callback = null,
                i = n,
                typeof r != "function")
                    throw Error(Se(191, r));
                r.call(i)
            }
        }
}
var y9 = new m8.Component().refs;
function S1(e, t, n, i) {
    t = e.memoizedState,
    n = n(i, t),
    n = n == null ? t : Ct({}, t, n),
    e.memoizedState = n,
    e.lanes === 0 && (e.updateQueue.baseState = n)
}
var bd = {
    isMounted: function(e) {
        return (e = e._reactInternals) ? to(e) === e : !1
    },
    enqueueSetState: function(e, t, n) {
        e = e._reactInternals;
        var i = mn()
          , r = zr(e)
          , s = sr(i, r);
        s.payload = t,
        n != null && (s.callback = n),
        t = Ir(e, s, r),
        t !== null && (bi(t, e, r, i),
        Wu(t, e, r))
    },
    enqueueReplaceState: function(e, t, n) {
        e = e._reactInternals;
        var i = mn()
          , r = zr(e)
          , s = sr(i, r);
        s.tag = 1,
        s.payload = t,
        n != null && (s.callback = n),
        t = Ir(e, s, r),
        t !== null && (bi(t, e, r, i),
        Wu(t, e, r))
    },
    enqueueForceUpdate: function(e, t) {
        e = e._reactInternals;
        var n = mn()
          , i = zr(e)
          , r = sr(n, i);
        r.tag = 2,
        t != null && (r.callback = t),
        t = Ir(e, r, i),
        t !== null && (bi(t, e, i, n),
        Wu(t, e, i))
    }
};
function iy(e, t, n, i, r, s, o) {
    return e = e.stateNode,
    typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(i, s, o) : t.prototype && t.prototype.isPureReactComponent ? !Ol(n, i) || !Ol(r, s) : !0
}
function x9(e, t, n) {
    var i = !1
      , r = $r
      , s = t.contextType;
    return typeof s == "object" && s !== null ? s = ri(s) : (r = En(t) ? Xs : ln.current,
    i = t.contextTypes,
    s = (i = i != null) ? ra(e, r) : $r),
    t = new t(n,s),
    e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null,
    t.updater = bd,
    e.stateNode = t,
    t._reactInternals = e,
    i && (e = e.stateNode,
    e.__reactInternalMemoizedUnmaskedChildContext = r,
    e.__reactInternalMemoizedMaskedChildContext = s),
    t
}
function ry(e, t, n, i) {
    e = t.state,
    typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, i),
    typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, i),
    t.state !== e && bd.enqueueReplaceState(t, t.state, null)
}
function C1(e, t, n, i) {
    var r = e.stateNode;
    r.props = n,
    r.state = e.memoizedState,
    r.refs = y9,
    Fm(e);
    var s = t.contextType;
    typeof s == "object" && s !== null ? r.context = ri(s) : (s = En(t) ? Xs : ln.current,
    r.context = ra(e, s)),
    r.state = e.memoizedState,
    s = t.getDerivedStateFromProps,
    typeof s == "function" && (S1(e, t, s, n),
    r.state = e.memoizedState),
    typeof t.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (t = r.state,
    typeof r.componentWillMount == "function" && r.componentWillMount(),
    typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(),
    t !== r.state && bd.enqueueReplaceState(r, r.state, null),
    Ch(e, n, r, i),
    r.state = e.memoizedState),
    typeof r.componentDidMount == "function" && (e.flags |= 4194308)
}
function _a(e, t, n) {
    if (e = n.ref,
    e !== null && typeof e != "function" && typeof e != "object") {
        if (n._owner) {
            if (n = n._owner,
            n) {
                if (n.tag !== 1)
                    throw Error(Se(309));
                var i = n.stateNode
            }
            if (!i)
                throw Error(Se(147, e));
            var r = i
              , s = "" + e;
            return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === s ? t.ref : (t = function(o) {
                var a = r.refs;
                a === y9 && (a = r.refs = {}),
                o === null ? delete a[s] : a[s] = o
            }
            ,
            t._stringRef = s,
            t)
        }
        if (typeof e != "string")
            throw Error(Se(284));
        if (!n._owner)
            throw Error(Se(290, e))
    }
    return e
}
function Qc(e, t) {
    throw e = Object.prototype.toString.call(t),
    Error(Se(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
}
function sy(e) {
    var t = e._init;
    return t(e._payload)
}
function b9(e) {
    function t(v, p) {
        if (e) {
            var g = v.deletions;
            g === null ? (v.deletions = [p],
            v.flags |= 16) : g.push(p)
        }
    }
    function n(v, p) {
        if (!e)
            return null;
        for (; p !== null; )
            t(v, p),
            p = p.sibling;
        return null
    }
    function i(v, p) {
        for (v = new Map; p !== null; )
            p.key !== null ? v.set(p.key, p) : v.set(p.index, p),
            p = p.sibling;
        return v
    }
    function r(v, p) {
        return v = Vr(v, p),
        v.index = 0,
        v.sibling = null,
        v
    }
    function s(v, p, g) {
        return v.index = g,
        e ? (g = v.alternate,
        g !== null ? (g = g.index,
        g < p ? (v.flags |= 2,
        p) : g) : (v.flags |= 2,
        p)) : (v.flags |= 1048576,
        p)
    }
    function o(v) {
        return e && v.alternate === null && (v.flags |= 2),
        v
    }
    function a(v, p, g, C) {
        return p === null || p.tag !== 6 ? (p = qf(g, v.mode, C),
        p.return = v,
        p) : (p = r(p, g),
        p.return = v,
        p)
    }
    function l(v, p, g, C) {
        var E = g.type;
        return E === Mo ? u(v, p, g.props.children, C, g.key) : p !== null && (p.elementType === E || typeof E == "object" && E !== null && E.$$typeof === wr && sy(E) === p.type) ? (C = r(p, g.props),
        C.ref = _a(v, p, g),
        C.return = v,
        C) : (C = $u(g.type, g.key, g.props, null, v.mode, C),
        C.ref = _a(v, p, g),
        C.return = v,
        C)
    }
    function c(v, p, g, C) {
        return p === null || p.tag !== 4 || p.stateNode.containerInfo !== g.containerInfo || p.stateNode.implementation !== g.implementation ? (p = Zf(g, v.mode, C),
        p.return = v,
        p) : (p = r(p, g.children || []),
        p.return = v,
        p)
    }
    function u(v, p, g, C, E) {
        return p === null || p.tag !== 7 ? (p = Vs(g, v.mode, C, E),
        p.return = v,
        p) : (p = r(p, g),
        p.return = v,
        p)
    }
    function h(v, p, g) {
        if (typeof p == "string" && p !== "" || typeof p == "number")
            return p = qf("" + p, v.mode, g),
            p.return = v,
            p;
        if (typeof p == "object" && p !== null) {
            switch (p.$$typeof) {
            case Bc:
                return g = $u(p.type, p.key, p.props, null, v.mode, g),
                g.ref = _a(v, null, p),
                g.return = v,
                g;
            case Ao:
                return p = Zf(p, v.mode, g),
                p.return = v,
                p;
            case wr:
                var C = p._init;
                return h(v, C(p._payload), g)
            }
            if (Ya(p) || Ta(p))
                return p = Vs(p, v.mode, g, null),
                p.return = v,
                p;
            Qc(v, p)
        }
        return null
    }
    function d(v, p, g, C) {
        var E = p !== null ? p.key : null;
        if (typeof g == "string" && g !== "" || typeof g == "number")
            return E !== null ? null : a(v, p, "" + g, C);
        if (typeof g == "object" && g !== null) {
            switch (g.$$typeof) {
            case Bc:
                return g.key === E ? l(v, p, g, C) : null;
            case Ao:
                return g.key === E ? c(v, p, g, C) : null;
            case wr:
                return E = g._init,
                d(v, p, E(g._payload), C)
            }
            if (Ya(g) || Ta(g))
                return E !== null ? null : u(v, p, g, C, null);
            Qc(v, g)
        }
        return null
    }
    function m(v, p, g, C, E) {
        if (typeof C == "string" && C !== "" || typeof C == "number")
            return v = v.get(g) || null,
            a(p, v, "" + C, E);
        if (typeof C == "object" && C !== null) {
            switch (C.$$typeof) {
            case Bc:
                return v = v.get(C.key === null ? g : C.key) || null,
                l(p, v, C, E);
            case Ao:
                return v = v.get(C.key === null ? g : C.key) || null,
                c(p, v, C, E);
            case wr:
                var O = C._init;
                return m(v, p, g, O(C._payload), E)
            }
            if (Ya(C) || Ta(C))
                return v = v.get(g) || null,
                u(p, v, C, E, null);
            Qc(p, C)
        }
        return null
    }
    function f(v, p, g, C) {
        for (var E = null, O = null, R = p, F = p = 0, P = null; R !== null && F < g.length; F++) {
            R.index > F ? (P = R,
            R = null) : P = R.sibling;
            var _ = d(v, R, g[F], C);
            if (_ === null) {
                R === null && (R = P);
                break
            }
            e && R && _.alternate === null && t(v, R),
            p = s(_, p, F),
            O === null ? E = _ : O.sibling = _,
            O = _,
            R = P
        }
        if (F === g.length)
            return n(v, R),
            vt && ws(v, F),
            E;
        if (R === null) {
            for (; F < g.length; F++)
                R = h(v, g[F], C),
                R !== null && (p = s(R, p, F),
                O === null ? E = R : O.sibling = R,
                O = R);
            return vt && ws(v, F),
            E
        }
        for (R = i(v, R); F < g.length; F++)
            P = m(R, v, F, g[F], C),
            P !== null && (e && P.alternate !== null && R.delete(P.key === null ? F : P.key),
            p = s(P, p, F),
            O === null ? E = P : O.sibling = P,
            O = P);
        return e && R.forEach(function(T) {
            return t(v, T)
        }),
        vt && ws(v, F),
        E
    }
    function x(v, p, g, C) {
        var E = Ta(g);
        if (typeof E != "function")
            throw Error(Se(150));
        if (g = E.call(g),
        g == null)
            throw Error(Se(151));
        for (var O = E = null, R = p, F = p = 0, P = null, _ = g.next(); R !== null && !_.done; F++,
        _ = g.next()) {
            R.index > F ? (P = R,
            R = null) : P = R.sibling;
            var T = d(v, R, _.value, C);
            if (T === null) {
                R === null && (R = P);
                break
            }
            e && R && T.alternate === null && t(v, R),
            p = s(T, p, F),
            O === null ? E = T : O.sibling = T,
            O = T,
            R = P
        }
        if (_.done)
            return n(v, R),
            vt && ws(v, F),
            E;
        if (R === null) {
            for (; !_.done; F++,
            _ = g.next())
                _ = h(v, _.value, C),
                _ !== null && (p = s(_, p, F),
                O === null ? E = _ : O.sibling = _,
                O = _);
            return vt && ws(v, F),
            E
        }
        for (R = i(v, R); !_.done; F++,
        _ = g.next())
            _ = m(R, v, F, _.value, C),
            _ !== null && (e && _.alternate !== null && R.delete(_.key === null ? F : _.key),
            p = s(_, p, F),
            O === null ? E = _ : O.sibling = _,
            O = _);
        return e && R.forEach(function(L) {
            return t(v, L)
        }),
        vt && ws(v, F),
        E
    }
    function S(v, p, g, C) {
        if (typeof g == "object" && g !== null && g.type === Mo && g.key === null && (g = g.props.children),
        typeof g == "object" && g !== null) {
            switch (g.$$typeof) {
            case Bc:
                e: {
                    for (var E = g.key, O = p; O !== null; ) {
                        if (O.key === E) {
                            if (E = g.type,
                            E === Mo) {
                                if (O.tag === 7) {
                                    n(v, O.sibling),
                                    p = r(O, g.props.children),
                                    p.return = v,
                                    v = p;
                                    break e
                                }
                            } else if (O.elementType === E || typeof E == "object" && E !== null && E.$$typeof === wr && sy(E) === O.type) {
                                n(v, O.sibling),
                                p = r(O, g.props),
                                p.ref = _a(v, O, g),
                                p.return = v,
                                v = p;
                                break e
                            }
                            n(v, O);
                            break
                        } else
                            t(v, O);
                        O = O.sibling
                    }
                    g.type === Mo ? (p = Vs(g.props.children, v.mode, C, g.key),
                    p.return = v,
                    v = p) : (C = $u(g.type, g.key, g.props, null, v.mode, C),
                    C.ref = _a(v, p, g),
                    C.return = v,
                    v = C)
                }
                return o(v);
            case Ao:
                e: {
                    for (O = g.key; p !== null; ) {
                        if (p.key === O)
                            if (p.tag === 4 && p.stateNode.containerInfo === g.containerInfo && p.stateNode.implementation === g.implementation) {
                                n(v, p.sibling),
                                p = r(p, g.children || []),
                                p.return = v,
                                v = p;
                                break e
                            } else {
                                n(v, p);
                                break
                            }
                        else
                            t(v, p);
                        p = p.sibling
                    }
                    p = Zf(g, v.mode, C),
                    p.return = v,
                    v = p
                }
                return o(v);
            case wr:
                return O = g._init,
                S(v, p, O(g._payload), C)
            }
            if (Ya(g))
                return f(v, p, g, C);
            if (Ta(g))
                return x(v, p, g, C);
            Qc(v, g)
        }
        return typeof g == "string" && g !== "" || typeof g == "number" ? (g = "" + g,
        p !== null && p.tag === 6 ? (n(v, p.sibling),
        p = r(p, g),
        p.return = v,
        v = p) : (n(v, p),
        p = qf(g, v.mode, C),
        p.return = v,
        v = p),
        o(v)) : n(v, p)
    }
    return S
}
var oa = b9(!0)
  , w9 = b9(!1)
  , pc = {}
  , Ii = ts(pc)
  , Dl = ts(pc)
  , Nl = ts(pc);
function Ls(e) {
    if (e === pc)
        throw Error(Se(174));
    return e
}
function Im(e, t) {
    switch (lt(Nl, t),
    lt(Dl, e),
    lt(Ii, pc),
    e = t.nodeType,
    e) {
    case 9:
    case 11:
        t = (t = t.documentElement) ? t.namespaceURI : t1(null, "");
        break;
    default:
        e = e === 8 ? t.parentNode : t,
        t = e.namespaceURI || null,
        e = e.tagName,
        t = t1(t, e)
    }
    pt(Ii),
    lt(Ii, t)
}
function aa() {
    pt(Ii),
    pt(Dl),
    pt(Nl)
}
function S9(e) {
    Ls(Nl.current);
    var t = Ls(Ii.current)
      , n = t1(t, e.type);
    t !== n && (lt(Dl, e),
    lt(Ii, n))
}
function Bm(e) {
    Dl.current === e && (pt(Ii),
    pt(Dl))
}
var bt = ts(0);
function kh(e) {
    for (var t = e; t !== null; ) {
        if (t.tag === 13) {
            var n = t.memoizedState;
            if (n !== null && (n = n.dehydrated,
            n === null || n.data === "$?" || n.data === "$!"))
                return t
        } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
            if (t.flags & 128)
                return t
        } else if (t.child !== null) {
            t.child.return = t,
            t = t.child;
            continue
        }
        if (t === e)
            break;
        for (; t.sibling === null; ) {
            if (t.return === null || t.return === e)
                return null;
            t = t.return
        }
        t.sibling.return = t.return,
        t = t.sibling
    }
    return null
}
var Gf = [];
function zm() {
    for (var e = 0; e < Gf.length; e++)
        Gf[e]._workInProgressVersionPrimary = null;
    Gf.length = 0
}
var Hu = fr.ReactCurrentDispatcher
  , Xf = fr.ReactCurrentBatchConfig
  , $s = 0
  , St = null
  , Vt = null
  , $t = null
  , Ah = !1
  , ll = !1
  , Fl = 0
  , TE = 0;
function rn() {
    throw Error(Se(321))
}
function Vm(e, t) {
    if (t === null)
        return !1;
    for (var n = 0; n < t.length && n < e.length; n++)
        if (!Si(e[n], t[n]))
            return !1;
    return !0
}
function Wm(e, t, n, i, r, s) {
    if ($s = s,
    St = t,
    t.memoizedState = null,
    t.updateQueue = null,
    t.lanes = 0,
    Hu.current = e === null || e.memoizedState === null ? RE : _E,
    e = n(i, r),
    ll) {
        s = 0;
        do {
            if (ll = !1,
            Fl = 0,
            25 <= s)
                throw Error(Se(301));
            s += 1,
            $t = Vt = null,
            t.updateQueue = null,
            Hu.current = DE,
            e = n(i, r)
        } while (ll)
    }
    if (Hu.current = Mh,
    t = Vt !== null && Vt.next !== null,
    $s = 0,
    $t = Vt = St = null,
    Ah = !1,
    t)
        throw Error(Se(300));
    return e
}
function Hm() {
    var e = Fl !== 0;
    return Fl = 0,
    e
}
function ji() {
    var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return $t === null ? St.memoizedState = $t = e : $t = $t.next = e,
    $t
}
function si() {
    if (Vt === null) {
        var e = St.alternate;
        e = e !== null ? e.memoizedState : null
    } else
        e = Vt.next;
    var t = $t === null ? St.memoizedState : $t.next;
    if (t !== null)
        $t = t,
        Vt = e;
    else {
        if (e === null)
            throw Error(Se(310));
        Vt = e,
        e = {
            memoizedState: Vt.memoizedState,
            baseState: Vt.baseState,
            baseQueue: Vt.baseQueue,
            queue: Vt.queue,
            next: null
        },
        $t === null ? St.memoizedState = $t = e : $t = $t.next = e
    }
    return $t
}
function Il(e, t) {
    return typeof t == "function" ? t(e) : t
}
function Yf(e) {
    var t = si()
      , n = t.queue;
    if (n === null)
        throw Error(Se(311));
    n.lastRenderedReducer = e;
    var i = Vt
      , r = i.baseQueue
      , s = n.pending;
    if (s !== null) {
        if (r !== null) {
            var o = r.next;
            r.next = s.next,
            s.next = o
        }
        i.baseQueue = r = s,
        n.pending = null
    }
    if (r !== null) {
        s = r.next,
        i = i.baseState;
        var a = o = null
          , l = null
          , c = s;
        do {
            var u = c.lane;
            if (($s & u) === u)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                }),
                i = c.hasEagerState ? c.eagerState : e(i, c.action);
            else {
                var h = {
                    lane: u,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = h,
                o = i) : l = l.next = h,
                St.lanes |= u,
                Ks |= u
            }
            c = c.next
        } while (c !== null && c !== s);
        l === null ? o = i : l.next = a,
        Si(i, t.memoizedState) || (kn = !0),
        t.memoizedState = i,
        t.baseState = o,
        t.baseQueue = l,
        n.lastRenderedState = i
    }
    if (e = n.interleaved,
    e !== null) {
        r = e;
        do
            s = r.lane,
            St.lanes |= s,
            Ks |= s,
            r = r.next;
        while (r !== e)
    } else
        r === null && (n.lanes = 0);
    return [t.memoizedState, n.dispatch]
}
function $f(e) {
    var t = si()
      , n = t.queue;
    if (n === null)
        throw Error(Se(311));
    n.lastRenderedReducer = e;
    var i = n.dispatch
      , r = n.pending
      , s = t.memoizedState;
    if (r !== null) {
        n.pending = null;
        var o = r = r.next;
        do
            s = e(s, o.action),
            o = o.next;
        while (o !== r);
        Si(s, t.memoizedState) || (kn = !0),
        t.memoizedState = s,
        t.baseQueue === null && (t.baseState = s),
        n.lastRenderedState = s
    }
    return [s, i]
}
function C9() {}
function k9(e, t) {
    var n = St
      , i = si()
      , r = t()
      , s = !Si(i.memoizedState, r);
    if (s && (i.memoizedState = r,
    kn = !0),
    i = i.queue,
    Um(E9.bind(null, n, i, e), [e]),
    i.getSnapshot !== t || s || $t !== null && $t.memoizedState.tag & 1) {
        if (n.flags |= 2048,
        Bl(9, M9.bind(null, n, i, r, t), void 0, null),
        Kt === null)
            throw Error(Se(349));
        $s & 30 || A9(n, t, r)
    }
    return r
}
function A9(e, t, n) {
    e.flags |= 16384,
    e = {
        getSnapshot: t,
        value: n
    },
    t = St.updateQueue,
    t === null ? (t = {
        lastEffect: null,
        stores: null
    },
    St.updateQueue = t,
    t.stores = [e]) : (n = t.stores,
    n === null ? t.stores = [e] : n.push(e))
}
function M9(e, t, n, i) {
    t.value = n,
    t.getSnapshot = i,
    P9(t) && T9(e)
}
function E9(e, t, n) {
    return n(function() {
        P9(t) && T9(e)
    })
}
function P9(e) {
    var t = e.getSnapshot;
    e = e.value;
    try {
        var n = t();
        return !Si(e, n)
    } catch {
        return !0
    }
}
function T9(e) {
    var t = ur(e, 1);
    t !== null && bi(t, e, 1, -1)
}
function oy(e) {
    var t = ji();
    return typeof e == "function" && (e = e()),
    t.memoizedState = t.baseState = e,
    e = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Il,
        lastRenderedState: e
    },
    t.queue = e,
    e = e.dispatch = LE.bind(null, St, e),
    [t.memoizedState, e]
}
function Bl(e, t, n, i) {
    return e = {
        tag: e,
        create: t,
        destroy: n,
        deps: i,
        next: null
    },
    t = St.updateQueue,
    t === null ? (t = {
        lastEffect: null,
        stores: null
    },
    St.updateQueue = t,
    t.lastEffect = e.next = e) : (n = t.lastEffect,
    n === null ? t.lastEffect = e.next = e : (i = n.next,
    n.next = e,
    e.next = i,
    t.lastEffect = e)),
    e
}
function j9() {
    return si().memoizedState
}
function Uu(e, t, n, i) {
    var r = ji();
    St.flags |= e,
    r.memoizedState = Bl(1 | t, n, void 0, i === void 0 ? null : i)
}
function wd(e, t, n, i) {
    var r = si();
    i = i === void 0 ? null : i;
    var s = void 0;
    if (Vt !== null) {
        var o = Vt.memoizedState;
        if (s = o.destroy,
        i !== null && Vm(i, o.deps)) {
            r.memoizedState = Bl(t, n, s, i);
            return
        }
    }
    St.flags |= e,
    r.memoizedState = Bl(1 | t, n, s, i)
}
function ay(e, t) {
    return Uu(8390656, 8, e, t)
}
function Um(e, t) {
    return wd(2048, 8, e, t)
}
function O9(e, t) {
    return wd(4, 2, e, t)
}
function L9(e, t) {
    return wd(4, 4, e, t)
}
function R9(e, t) {
    if (typeof t == "function")
        return e = e(),
        t(e),
        function() {
            t(null)
        }
        ;
    if (t != null)
        return e = e(),
        t.current = e,
        function() {
            t.current = null
        }
}
function _9(e, t, n) {
    return n = n != null ? n.concat([e]) : null,
    wd(4, 4, R9.bind(null, t, e), n)
}
function Gm() {}
function D9(e, t) {
    var n = si();
    t = t === void 0 ? null : t;
    var i = n.memoizedState;
    return i !== null && t !== null && Vm(t, i[1]) ? i[0] : (n.memoizedState = [e, t],
    e)
}
function N9(e, t) {
    var n = si();
    t = t === void 0 ? null : t;
    var i = n.memoizedState;
    return i !== null && t !== null && Vm(t, i[1]) ? i[0] : (e = e(),
    n.memoizedState = [e, t],
    e)
}
function F9(e, t, n) {
    return $s & 21 ? (Si(n, t) || (n = z8(),
    St.lanes |= n,
    Ks |= n,
    e.baseState = !0),
    t) : (e.baseState && (e.baseState = !1,
    kn = !0),
    e.memoizedState = n)
}
function jE(e, t) {
    var n = Je;
    Je = n !== 0 && 4 > n ? n : 4,
    e(!0);
    var i = Xf.transition;
    Xf.transition = {};
    try {
        e(!1),
        t()
    } finally {
        Je = n,
        Xf.transition = i
    }
}
function I9() {
    return si().memoizedState
}
function OE(e, t, n) {
    var i = zr(e);
    if (n = {
        lane: i,
        action: n,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    B9(e))
        z9(t, n);
    else if (n = m9(e, t, n, i),
    n !== null) {
        var r = mn();
        bi(n, e, i, r),
        V9(n, t, i)
    }
}
function LE(e, t, n) {
    var i = zr(e)
      , r = {
        lane: i,
        action: n,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (B9(e))
        z9(t, r);
    else {
        var s = e.alternate;
        if (e.lanes === 0 && (s === null || s.lanes === 0) && (s = t.lastRenderedReducer,
        s !== null))
            try {
                var o = t.lastRenderedState
                  , a = s(o, n);
                if (r.hasEagerState = !0,
                r.eagerState = a,
                Si(a, o)) {
                    var l = t.interleaved;
                    l === null ? (r.next = r,
                    Nm(t)) : (r.next = l.next,
                    l.next = r),
                    t.interleaved = r;
                    return
                }
            } catch {} finally {}
        n = m9(e, t, r, i),
        n !== null && (r = mn(),
        bi(n, e, i, r),
        V9(n, t, i))
    }
}
function B9(e) {
    var t = e.alternate;
    return e === St || t !== null && t === St
}
function z9(e, t) {
    ll = Ah = !0;
    var n = e.pending;
    n === null ? t.next = t : (t.next = n.next,
    n.next = t),
    e.pending = t
}
function V9(e, t, n) {
    if (n & 4194240) {
        var i = t.lanes;
        i &= e.pendingLanes,
        n |= i,
        t.lanes = n,
        Sm(e, n)
    }
}
var Mh = {
    readContext: ri,
    useCallback: rn,
    useContext: rn,
    useEffect: rn,
    useImperativeHandle: rn,
    useInsertionEffect: rn,
    useLayoutEffect: rn,
    useMemo: rn,
    useReducer: rn,
    useRef: rn,
    useState: rn,
    useDebugValue: rn,
    useDeferredValue: rn,
    useTransition: rn,
    useMutableSource: rn,
    useSyncExternalStore: rn,
    useId: rn,
    unstable_isNewReconciler: !1
}
  , RE = {
    readContext: ri,
    useCallback: function(e, t) {
        return ji().memoizedState = [e, t === void 0 ? null : t],
        e
    },
    useContext: ri,
    useEffect: ay,
    useImperativeHandle: function(e, t, n) {
        return n = n != null ? n.concat([e]) : null,
        Uu(4194308, 4, R9.bind(null, t, e), n)
    },
    useLayoutEffect: function(e, t) {
        return Uu(4194308, 4, e, t)
    },
    useInsertionEffect: function(e, t) {
        return Uu(4, 2, e, t)
    },
    useMemo: function(e, t) {
        var n = ji();
        return t = t === void 0 ? null : t,
        e = e(),
        n.memoizedState = [e, t],
        e
    },
    useReducer: function(e, t, n) {
        var i = ji();
        return t = n !== void 0 ? n(t) : t,
        i.memoizedState = i.baseState = t,
        e = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: e,
            lastRenderedState: t
        },
        i.queue = e,
        e = e.dispatch = OE.bind(null, St, e),
        [i.memoizedState, e]
    },
    useRef: function(e) {
        var t = ji();
        return e = {
            current: e
        },
        t.memoizedState = e
    },
    useState: oy,
    useDebugValue: Gm,
    useDeferredValue: function(e) {
        return ji().memoizedState = e
    },
    useTransition: function() {
        var e = oy(!1)
          , t = e[0];
        return e = jE.bind(null, e[1]),
        ji().memoizedState = e,
        [t, e]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(e, t, n) {
        var i = St
          , r = ji();
        if (vt) {
            if (n === void 0)
                throw Error(Se(407));
            n = n()
        } else {
            if (n = t(),
            Kt === null)
                throw Error(Se(349));
            $s & 30 || A9(i, t, n)
        }
        r.memoizedState = n;
        var s = {
            value: n,
            getSnapshot: t
        };
        return r.queue = s,
        ay(E9.bind(null, i, s, e), [e]),
        i.flags |= 2048,
        Bl(9, M9.bind(null, i, s, n, t), void 0, null),
        n
    },
    useId: function() {
        var e = ji()
          , t = Kt.identifierPrefix;
        if (vt) {
            var n = nr
              , i = tr;
            n = (i & ~(1 << 32 - xi(i) - 1)).toString(32) + n,
            t = ":" + t + "R" + n,
            n = Fl++,
            0 < n && (t += "H" + n.toString(32)),
            t += ":"
        } else
            n = TE++,
            t = ":" + t + "r" + n.toString(32) + ":";
        return e.memoizedState = t
    },
    unstable_isNewReconciler: !1
}
  , _E = {
    readContext: ri,
    useCallback: D9,
    useContext: ri,
    useEffect: Um,
    useImperativeHandle: _9,
    useInsertionEffect: O9,
    useLayoutEffect: L9,
    useMemo: N9,
    useReducer: Yf,
    useRef: j9,
    useState: function() {
        return Yf(Il)
    },
    useDebugValue: Gm,
    useDeferredValue: function(e) {
        var t = si();
        return F9(t, Vt.memoizedState, e)
    },
    useTransition: function() {
        var e = Yf(Il)[0]
          , t = si().memoizedState;
        return [e, t]
    },
    useMutableSource: C9,
    useSyncExternalStore: k9,
    useId: I9,
    unstable_isNewReconciler: !1
}
  , DE = {
    readContext: ri,
    useCallback: D9,
    useContext: ri,
    useEffect: Um,
    useImperativeHandle: _9,
    useInsertionEffect: O9,
    useLayoutEffect: L9,
    useMemo: N9,
    useReducer: $f,
    useRef: j9,
    useState: function() {
        return $f(Il)
    },
    useDebugValue: Gm,
    useDeferredValue: function(e) {
        var t = si();
        return Vt === null ? t.memoizedState = e : F9(t, Vt.memoizedState, e)
    },
    useTransition: function() {
        var e = $f(Il)[0]
          , t = si().memoizedState;
        return [e, t]
    },
    useMutableSource: C9,
    useSyncExternalStore: k9,
    useId: I9,
    unstable_isNewReconciler: !1
};
function la(e, t) {
    try {
        var n = ""
          , i = t;
        do
            n += cM(i),
            i = i.return;
        while (i);
        var r = n
    } catch (s) {
        r = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: e,
        source: t,
        stack: r,
        digest: null
    }
}
function Kf(e, t, n) {
    return {
        value: e,
        source: null,
        stack: n ?? null,
        digest: t ?? null
    }
}
function k1(e, t) {
    try {
        console.error(t.value)
    } catch (n) {
        setTimeout(function() {
            throw n
        })
    }
}
var NE = typeof WeakMap == "function" ? WeakMap : Map;
function W9(e, t, n) {
    n = sr(-1, n),
    n.tag = 3,
    n.payload = {
        element: null
    };
    var i = t.value;
    return n.callback = function() {
        Ph || (Ph = !0,
        _1 = i),
        k1(e, t)
    }
    ,
    n
}
function H9(e, t, n) {
    n = sr(-1, n),
    n.tag = 3;
    var i = e.type.getDerivedStateFromError;
    if (typeof i == "function") {
        var r = t.value;
        n.payload = function() {
            return i(r)
        }
        ,
        n.callback = function() {
            k1(e, t)
        }
    }
    var s = e.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function() {
        k1(e, t),
        typeof i != "function" && (Br === null ? Br = new Set([this]) : Br.add(this));
        var o = t.stack;
        this.componentDidCatch(t.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    n
}
function ly(e, t, n) {
    var i = e.pingCache;
    if (i === null) {
        i = e.pingCache = new NE;
        var r = new Set;
        i.set(t, r)
    } else
        r = i.get(t),
        r === void 0 && (r = new Set,
        i.set(t, r));
    r.has(n) || (r.add(n),
    e = QE.bind(null, e, t, n),
    t.then(e, e))
}
function cy(e) {
    do {
        var t;
        if ((t = e.tag === 13) && (t = e.memoizedState,
        t = t !== null ? t.dehydrated !== null : !0),
        t)
            return e;
        e = e.return
    } while (e !== null);
    return null
}
function uy(e, t, n, i, r) {
    return e.mode & 1 ? (e.flags |= 65536,
    e.lanes = r,
    e) : (e === t ? e.flags |= 65536 : (e.flags |= 128,
    n.flags |= 131072,
    n.flags &= -52805,
    n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = sr(-1, 1),
    t.tag = 2,
    Ir(n, t, 1))),
    n.lanes |= 1),
    e)
}
var FE = fr.ReactCurrentOwner
  , kn = !1;
function fn(e, t, n, i) {
    t.child = e === null ? w9(t, null, n, i) : oa(t, e.child, n, i)
}
function hy(e, t, n, i, r) {
    n = n.render;
    var s = t.ref;
    return Qo(t, r),
    i = Wm(e, t, n, i, s, r),
    n = Hm(),
    e !== null && !kn ? (t.updateQueue = e.updateQueue,
    t.flags &= -2053,
    e.lanes &= ~r,
    hr(e, t, r)) : (vt && n && jm(t),
    t.flags |= 1,
    fn(e, t, i, r),
    t.child)
}
function dy(e, t, n, i, r) {
    if (e === null) {
        var s = n.type;
        return typeof s == "function" && !Jm(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15,
        t.type = s,
        U9(e, t, s, i, r)) : (e = $u(n.type, null, i, t, t.mode, r),
        e.ref = t.ref,
        e.return = t,
        t.child = e)
    }
    if (s = e.child,
    !(e.lanes & r)) {
        var o = s.memoizedProps;
        if (n = n.compare,
        n = n !== null ? n : Ol,
        n(o, i) && e.ref === t.ref)
            return hr(e, t, r)
    }
    return t.flags |= 1,
    e = Vr(s, i),
    e.ref = t.ref,
    e.return = t,
    t.child = e
}
function U9(e, t, n, i, r) {
    if (e !== null) {
        var s = e.memoizedProps;
        if (Ol(s, i) && e.ref === t.ref)
            if (kn = !1,
            t.pendingProps = i = s,
            (e.lanes & r) !== 0)
                e.flags & 131072 && (kn = !0);
            else
                return t.lanes = e.lanes,
                hr(e, t, r)
    }
    return A1(e, t, n, i, r)
}
function G9(e, t, n) {
    var i = t.pendingProps
      , r = i.children
      , s = e !== null ? e.memoizedState : null;
    if (i.mode === "hidden")
        if (!(t.mode & 1))
            t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            lt(No, Dn),
            Dn |= n;
        else {
            if (!(n & 1073741824))
                return e = s !== null ? s.baseLanes | n : n,
                t.lanes = t.childLanes = 1073741824,
                t.memoizedState = {
                    baseLanes: e,
                    cachePool: null,
                    transitions: null
                },
                t.updateQueue = null,
                lt(No, Dn),
                Dn |= e,
                null;
            t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            i = s !== null ? s.baseLanes : n,
            lt(No, Dn),
            Dn |= i
        }
    else
        s !== null ? (i = s.baseLanes | n,
        t.memoizedState = null) : i = n,
        lt(No, Dn),
        Dn |= i;
    return fn(e, t, r, n),
    t.child
}
function X9(e, t) {
    var n = t.ref;
    (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512,
    t.flags |= 2097152)
}
function A1(e, t, n, i, r) {
    var s = En(n) ? Xs : ln.current;
    return s = ra(t, s),
    Qo(t, r),
    n = Wm(e, t, n, i, s, r),
    i = Hm(),
    e !== null && !kn ? (t.updateQueue = e.updateQueue,
    t.flags &= -2053,
    e.lanes &= ~r,
    hr(e, t, r)) : (vt && i && jm(t),
    t.flags |= 1,
    fn(e, t, n, r),
    t.child)
}
function fy(e, t, n, i, r) {
    if (En(n)) {
        var s = !0;
        yh(t)
    } else
        s = !1;
    if (Qo(t, r),
    t.stateNode === null)
        Gu(e, t),
        x9(t, n, i),
        C1(t, n, i, r),
        i = !0;
    else if (e === null) {
        var o = t.stateNode
          , a = t.memoizedProps;
        o.props = a;
        var l = o.context
          , c = n.contextType;
        typeof c == "object" && c !== null ? c = ri(c) : (c = En(n) ? Xs : ln.current,
        c = ra(t, c));
        var u = n.getDerivedStateFromProps
          , h = typeof u == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        h || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== c) && ry(t, o, i, c),
        Sr = !1;
        var d = t.memoizedState;
        o.state = d,
        Ch(t, i, o, r),
        l = t.memoizedState,
        a !== i || d !== l || Mn.current || Sr ? (typeof u == "function" && (S1(t, n, u, i),
        l = t.memoizedState),
        (a = Sr || iy(t, n, a, i, d, l, c)) ? (h || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308),
        t.memoizedProps = i,
        t.memoizedState = l),
        o.props = i,
        o.state = l,
        o.context = c,
        i = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308),
        i = !1)
    } else {
        o = t.stateNode,
        v9(e, t),
        a = t.memoizedProps,
        c = t.type === t.elementType ? a : fi(t.type, a),
        o.props = c,
        h = t.pendingProps,
        d = o.context,
        l = n.contextType,
        typeof l == "object" && l !== null ? l = ri(l) : (l = En(n) ? Xs : ln.current,
        l = ra(t, l));
        var m = n.getDerivedStateFromProps;
        (u = typeof m == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== h || d !== l) && ry(t, o, i, l),
        Sr = !1,
        d = t.memoizedState,
        o.state = d,
        Ch(t, i, o, r);
        var f = t.memoizedState;
        a !== h || d !== f || Mn.current || Sr ? (typeof m == "function" && (S1(t, n, m, i),
        f = t.memoizedState),
        (c = Sr || iy(t, n, c, i, d, f, l) || !1) ? (u || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, f, l),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, f, l)),
        typeof o.componentDidUpdate == "function" && (t.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024),
        t.memoizedProps = i,
        t.memoizedState = f),
        o.props = i,
        o.state = f,
        o.context = l,
        i = c) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024),
        i = !1)
    }
    return M1(e, t, n, i, s, r)
}
function M1(e, t, n, i, r, s) {
    X9(e, t);
    var o = (t.flags & 128) !== 0;
    if (!i && !o)
        return r && Zv(t, n, !1),
        hr(e, t, s);
    i = t.stateNode,
    FE.current = t;
    var a = o && typeof n.getDerivedStateFromError != "function" ? null : i.render();
    return t.flags |= 1,
    e !== null && o ? (t.child = oa(t, e.child, null, s),
    t.child = oa(t, null, a, s)) : fn(e, t, a, s),
    t.memoizedState = i.state,
    r && Zv(t, n, !0),
    t.child
}
function Y9(e) {
    var t = e.stateNode;
    t.pendingContext ? qv(e, t.pendingContext, t.pendingContext !== t.context) : t.context && qv(e, t.context, !1),
    Im(e, t.containerInfo)
}
function py(e, t, n, i, r) {
    return sa(),
    Lm(r),
    t.flags |= 256,
    fn(e, t, n, i),
    t.child
}
var E1 = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function P1(e) {
    return {
        baseLanes: e,
        cachePool: null,
        transitions: null
    }
}
function $9(e, t, n) {
    var i = t.pendingProps, r = bt.current, s = !1, o = (t.flags & 128) !== 0, a;
    if ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (r & 2) !== 0),
    a ? (s = !0,
    t.flags &= -129) : (e === null || e.memoizedState !== null) && (r |= 1),
    lt(bt, r & 1),
    e === null)
        return b1(t),
        e = t.memoizedState,
        e !== null && (e = e.dehydrated,
        e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1,
        null) : (o = i.children,
        e = i.fallback,
        s ? (i = t.mode,
        s = t.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(i & 1) && s !== null ? (s.childLanes = 0,
        s.pendingProps = o) : s = kd(o, i, 0, null),
        e = Vs(e, i, n, null),
        s.return = t,
        e.return = t,
        s.sibling = e,
        t.child = s,
        t.child.memoizedState = P1(n),
        t.memoizedState = E1,
        e) : Xm(t, o));
    if (r = e.memoizedState,
    r !== null && (a = r.dehydrated,
    a !== null))
        return IE(e, t, o, i, a, r, n);
    if (s) {
        s = i.fallback,
        o = t.mode,
        r = e.child,
        a = r.sibling;
        var l = {
            mode: "hidden",
            children: i.children
        };
        return !(o & 1) && t.child !== r ? (i = t.child,
        i.childLanes = 0,
        i.pendingProps = l,
        t.deletions = null) : (i = Vr(r, l),
        i.subtreeFlags = r.subtreeFlags & 14680064),
        a !== null ? s = Vr(a, s) : (s = Vs(s, o, n, null),
        s.flags |= 2),
        s.return = t,
        i.return = t,
        i.sibling = s,
        t.child = i,
        i = s,
        s = t.child,
        o = e.child.memoizedState,
        o = o === null ? P1(n) : {
            baseLanes: o.baseLanes | n,
            cachePool: null,
            transitions: o.transitions
        },
        s.memoizedState = o,
        s.childLanes = e.childLanes & ~n,
        t.memoizedState = E1,
        i
    }
    return s = e.child,
    e = s.sibling,
    i = Vr(s, {
        mode: "visible",
        children: i.children
    }),
    !(t.mode & 1) && (i.lanes = n),
    i.return = t,
    i.sibling = null,
    e !== null && (n = t.deletions,
    n === null ? (t.deletions = [e],
    t.flags |= 16) : n.push(e)),
    t.child = i,
    t.memoizedState = null,
    i
}
function Xm(e, t) {
    return t = kd({
        mode: "visible",
        children: t
    }, e.mode, 0, null),
    t.return = e,
    e.child = t
}
function qc(e, t, n, i) {
    return i !== null && Lm(i),
    oa(t, e.child, null, n),
    e = Xm(t, t.pendingProps.children),
    e.flags |= 2,
    t.memoizedState = null,
    e
}
function IE(e, t, n, i, r, s, o) {
    if (n)
        return t.flags & 256 ? (t.flags &= -257,
        i = Kf(Error(Se(422))),
        qc(e, t, o, i)) : t.memoizedState !== null ? (t.child = e.child,
        t.flags |= 128,
        null) : (s = i.fallback,
        r = t.mode,
        i = kd({
            mode: "visible",
            children: i.children
        }, r, 0, null),
        s = Vs(s, r, o, null),
        s.flags |= 2,
        i.return = t,
        s.return = t,
        i.sibling = s,
        t.child = i,
        t.mode & 1 && oa(t, e.child, null, o),
        t.child.memoizedState = P1(o),
        t.memoizedState = E1,
        s);
    if (!(t.mode & 1))
        return qc(e, t, o, null);
    if (r.data === "$!") {
        if (i = r.nextSibling && r.nextSibling.dataset,
        i)
            var a = i.dgst;
        return i = a,
        s = Error(Se(419)),
        i = Kf(s, i, void 0),
        qc(e, t, o, i)
    }
    if (a = (o & e.childLanes) !== 0,
    kn || a) {
        if (i = Kt,
        i !== null) {
            switch (o & -o) {
            case 4:
                r = 2;
                break;
            case 16:
                r = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                r = 32;
                break;
            case 536870912:
                r = 268435456;
                break;
            default:
                r = 0
            }
            r = r & (i.suspendedLanes | o) ? 0 : r,
            r !== 0 && r !== s.retryLane && (s.retryLane = r,
            ur(e, r),
            bi(i, e, r, -1))
        }
        return Zm(),
        i = Kf(Error(Se(421))),
        qc(e, t, o, i)
    }
    return r.data === "$?" ? (t.flags |= 128,
    t.child = e.child,
    t = qE.bind(null, e),
    r._reactRetry = t,
    null) : (e = s.treeContext,
    Fn = Fr(r.nextSibling),
    Bn = t,
    vt = !0,
    vi = null,
    e !== null && (Zn[Jn++] = tr,
    Zn[Jn++] = nr,
    Zn[Jn++] = Ys,
    tr = e.id,
    nr = e.overflow,
    Ys = t),
    t = Xm(t, i.children),
    t.flags |= 4096,
    t)
}
function gy(e, t, n) {
    e.lanes |= t;
    var i = e.alternate;
    i !== null && (i.lanes |= t),
    w1(e.return, t, n)
}
function Qf(e, t, n, i, r) {
    var s = e.memoizedState;
    s === null ? e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: n,
        tailMode: r
    } : (s.isBackwards = t,
    s.rendering = null,
    s.renderingStartTime = 0,
    s.last = i,
    s.tail = n,
    s.tailMode = r)
}
function K9(e, t, n) {
    var i = t.pendingProps
      , r = i.revealOrder
      , s = i.tail;
    if (fn(e, t, i.children, n),
    i = bt.current,
    i & 2)
        i = i & 1 | 2,
        t.flags |= 128;
    else {
        if (e !== null && e.flags & 128)
            e: for (e = t.child; e !== null; ) {
                if (e.tag === 13)
                    e.memoizedState !== null && gy(e, n, t);
                else if (e.tag === 19)
                    gy(e, n, t);
                else if (e.child !== null) {
                    e.child.return = e,
                    e = e.child;
                    continue
                }
                if (e === t)
                    break e;
                for (; e.sibling === null; ) {
                    if (e.return === null || e.return === t)
                        break e;
                    e = e.return
                }
                e.sibling.return = e.return,
                e = e.sibling
            }
        i &= 1
    }
    if (lt(bt, i),
    !(t.mode & 1))
        t.memoizedState = null;
    else
        switch (r) {
        case "forwards":
            for (n = t.child,
            r = null; n !== null; )
                e = n.alternate,
                e !== null && kh(e) === null && (r = n),
                n = n.sibling;
            n = r,
            n === null ? (r = t.child,
            t.child = null) : (r = n.sibling,
            n.sibling = null),
            Qf(t, !1, r, n, s);
            break;
        case "backwards":
            for (n = null,
            r = t.child,
            t.child = null; r !== null; ) {
                if (e = r.alternate,
                e !== null && kh(e) === null) {
                    t.child = r;
                    break
                }
                e = r.sibling,
                r.sibling = n,
                n = r,
                r = e
            }
            Qf(t, !0, n, null, s);
            break;
        case "together":
            Qf(t, !1, null, null, void 0);
            break;
        default:
            t.memoizedState = null
        }
    return t.child
}
function Gu(e, t) {
    !(t.mode & 1) && e !== null && (e.alternate = null,
    t.alternate = null,
    t.flags |= 2)
}
function hr(e, t, n) {
    if (e !== null && (t.dependencies = e.dependencies),
    Ks |= t.lanes,
    !(n & t.childLanes))
        return null;
    if (e !== null && t.child !== e.child)
        throw Error(Se(153));
    if (t.child !== null) {
        for (e = t.child,
        n = Vr(e, e.pendingProps),
        t.child = n,
        n.return = t; e.sibling !== null; )
            e = e.sibling,
            n = n.sibling = Vr(e, e.pendingProps),
            n.return = t;
        n.sibling = null
    }
    return t.child
}
function BE(e, t, n) {
    switch (t.tag) {
    case 3:
        Y9(t),
        sa();
        break;
    case 5:
        S9(t);
        break;
    case 1:
        En(t.type) && yh(t);
        break;
    case 4:
        Im(t, t.stateNode.containerInfo);
        break;
    case 10:
        var i = t.type._context
          , r = t.memoizedProps.value;
        lt(wh, i._currentValue),
        i._currentValue = r;
        break;
    case 13:
        if (i = t.memoizedState,
        i !== null)
            return i.dehydrated !== null ? (lt(bt, bt.current & 1),
            t.flags |= 128,
            null) : n & t.child.childLanes ? $9(e, t, n) : (lt(bt, bt.current & 1),
            e = hr(e, t, n),
            e !== null ? e.sibling : null);
        lt(bt, bt.current & 1);
        break;
    case 19:
        if (i = (n & t.childLanes) !== 0,
        e.flags & 128) {
            if (i)
                return K9(e, t, n);
            t.flags |= 128
        }
        if (r = t.memoizedState,
        r !== null && (r.rendering = null,
        r.tail = null,
        r.lastEffect = null),
        lt(bt, bt.current),
        i)
            break;
        return null;
    case 22:
    case 23:
        return t.lanes = 0,
        G9(e, t, n)
    }
    return hr(e, t, n)
}
var Q9, T1, q9, Z9;
Q9 = function(e, t) {
    for (var n = t.child; n !== null; ) {
        if (n.tag === 5 || n.tag === 6)
            e.appendChild(n.stateNode);
        else if (n.tag !== 4 && n.child !== null) {
            n.child.return = n,
            n = n.child;
            continue
        }
        if (n === t)
            break;
        for (; n.sibling === null; ) {
            if (n.return === null || n.return === t)
                return;
            n = n.return
        }
        n.sibling.return = n.return,
        n = n.sibling
    }
}
;
T1 = function() {}
;
q9 = function(e, t, n, i) {
    var r = e.memoizedProps;
    if (r !== i) {
        e = t.stateNode,
        Ls(Ii.current);
        var s = null;
        switch (n) {
        case "input":
            r = q0(e, r),
            i = q0(e, i),
            s = [];
            break;
        case "select":
            r = Ct({}, r, {
                value: void 0
            }),
            i = Ct({}, i, {
                value: void 0
            }),
            s = [];
            break;
        case "textarea":
            r = e1(e, r),
            i = e1(e, i),
            s = [];
            break;
        default:
            typeof r.onClick != "function" && typeof i.onClick == "function" && (e.onclick = mh)
        }
        n1(n, i);
        var o;
        n = null;
        for (c in r)
            if (!i.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null)
                if (c === "style") {
                    var a = r[c];
                    for (o in a)
                        a.hasOwnProperty(o) && (n || (n = {}),
                        n[o] = "")
                } else
                    c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (kl.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null));
        for (c in i) {
            var l = i[c];
            if (a = r != null ? r[c] : void 0,
            i.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}),
                            n[o] = "");
                        for (o in l)
                            l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}),
                            n[o] = l[o])
                    } else
                        n || (s || (s = []),
                        s.push(c, n)),
                        n = l;
                else
                    c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (s = s || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (kl.hasOwnProperty(c) ? (l != null && c === "onScroll" && dt("scroll", e),
                    s || a === l || (s = [])) : (s = s || []).push(c, l))
        }
        n && (s = s || []).push("style", n);
        var c = s;
        (t.updateQueue = c) && (t.flags |= 4)
    }
}
;
Z9 = function(e, t, n, i) {
    n !== i && (t.flags |= 4)
}
;
function Da(e, t) {
    if (!vt)
        switch (e.tailMode) {
        case "hidden":
            t = e.tail;
            for (var n = null; t !== null; )
                t.alternate !== null && (n = t),
                t = t.sibling;
            n === null ? e.tail = null : n.sibling = null;
            break;
        case "collapsed":
            n = e.tail;
            for (var i = null; n !== null; )
                n.alternate !== null && (i = n),
                n = n.sibling;
            i === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : i.sibling = null
        }
}
function sn(e) {
    var t = e.alternate !== null && e.alternate.child === e.child
      , n = 0
      , i = 0;
    if (t)
        for (var r = e.child; r !== null; )
            n |= r.lanes | r.childLanes,
            i |= r.subtreeFlags & 14680064,
            i |= r.flags & 14680064,
            r.return = e,
            r = r.sibling;
    else
        for (r = e.child; r !== null; )
            n |= r.lanes | r.childLanes,
            i |= r.subtreeFlags,
            i |= r.flags,
            r.return = e,
            r = r.sibling;
    return e.subtreeFlags |= i,
    e.childLanes = n,
    t
}
function zE(e, t, n) {
    var i = t.pendingProps;
    switch (Om(t),
    t.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return sn(t),
        null;
    case 1:
        return En(t.type) && vh(),
        sn(t),
        null;
    case 3:
        return i = t.stateNode,
        aa(),
        pt(Mn),
        pt(ln),
        zm(),
        i.pendingContext && (i.context = i.pendingContext,
        i.pendingContext = null),
        (e === null || e.child === null) && (Kc(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024,
        vi !== null && (F1(vi),
        vi = null))),
        T1(e, t),
        sn(t),
        null;
    case 5:
        Bm(t);
        var r = Ls(Nl.current);
        if (n = t.type,
        e !== null && t.stateNode != null)
            q9(e, t, n, i, r),
            e.ref !== t.ref && (t.flags |= 512,
            t.flags |= 2097152);
        else {
            if (!i) {
                if (t.stateNode === null)
                    throw Error(Se(166));
                return sn(t),
                null
            }
            if (e = Ls(Ii.current),
            Kc(t)) {
                i = t.stateNode,
                n = t.type;
                var s = t.memoizedProps;
                switch (i[_i] = t,
                i[_l] = s,
                e = (t.mode & 1) !== 0,
                n) {
                case "dialog":
                    dt("cancel", i),
                    dt("close", i);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    dt("load", i);
                    break;
                case "video":
                case "audio":
                    for (r = 0; r < Ka.length; r++)
                        dt(Ka[r], i);
                    break;
                case "source":
                    dt("error", i);
                    break;
                case "img":
                case "image":
                case "link":
                    dt("error", i),
                    dt("load", i);
                    break;
                case "details":
                    dt("toggle", i);
                    break;
                case "input":
                    kv(i, s),
                    dt("invalid", i);
                    break;
                case "select":
                    i._wrapperState = {
                        wasMultiple: !!s.multiple
                    },
                    dt("invalid", i);
                    break;
                case "textarea":
                    Mv(i, s),
                    dt("invalid", i)
                }
                n1(n, s),
                r = null;
                for (var o in s)
                    if (s.hasOwnProperty(o)) {
                        var a = s[o];
                        o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && $c(i.textContent, a, e),
                        r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && $c(i.textContent, a, e),
                        r = ["children", "" + a]) : kl.hasOwnProperty(o) && a != null && o === "onScroll" && dt("scroll", i)
                    }
                switch (n) {
                case "input":
                    zc(i),
                    Av(i, s, !0);
                    break;
                case "textarea":
                    zc(i),
                    Ev(i);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof s.onClick == "function" && (i.onclick = mh)
                }
                i = r,
                t.updateQueue = i,
                i !== null && (t.flags |= 4)
            } else {
                o = r.nodeType === 9 ? r : r.ownerDocument,
                e === "http://www.w3.org/1999/xhtml" && (e = A8(n)),
                e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = o.createElement("div"),
                e.innerHTML = "<script><\/script>",
                e = e.removeChild(e.firstChild)) : typeof i.is == "string" ? e = o.createElement(n, {
                    is: i.is
                }) : (e = o.createElement(n),
                n === "select" && (o = e,
                i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : e = o.createElementNS(e, n),
                e[_i] = t,
                e[_l] = i,
                Q9(e, t, !1, !1),
                t.stateNode = e;
                e: {
                    switch (o = i1(n, i),
                    n) {
                    case "dialog":
                        dt("cancel", e),
                        dt("close", e),
                        r = i;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        dt("load", e),
                        r = i;
                        break;
                    case "video":
                    case "audio":
                        for (r = 0; r < Ka.length; r++)
                            dt(Ka[r], e);
                        r = i;
                        break;
                    case "source":
                        dt("error", e),
                        r = i;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        dt("error", e),
                        dt("load", e),
                        r = i;
                        break;
                    case "details":
                        dt("toggle", e),
                        r = i;
                        break;
                    case "input":
                        kv(e, i),
                        r = q0(e, i),
                        dt("invalid", e);
                        break;
                    case "option":
                        r = i;
                        break;
                    case "select":
                        e._wrapperState = {
                            wasMultiple: !!i.multiple
                        },
                        r = Ct({}, i, {
                            value: void 0
                        }),
                        dt("invalid", e);
                        break;
                    case "textarea":
                        Mv(e, i),
                        r = e1(e, i),
                        dt("invalid", e);
                        break;
                    default:
                        r = i
                    }
                    n1(n, r),
                    a = r;
                    for (s in a)
                        if (a.hasOwnProperty(s)) {
                            var l = a[s];
                            s === "style" ? P8(e, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && M8(e, l)) : s === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && Al(e, l) : typeof l == "number" && Al(e, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (kl.hasOwnProperty(s) ? l != null && s === "onScroll" && dt("scroll", e) : l != null && mm(e, s, l, o))
                        }
                    switch (n) {
                    case "input":
                        zc(e),
                        Av(e, i, !1);
                        break;
                    case "textarea":
                        zc(e),
                        Ev(e);
                        break;
                    case "option":
                        i.value != null && e.setAttribute("value", "" + Yr(i.value));
                        break;
                    case "select":
                        e.multiple = !!i.multiple,
                        s = i.value,
                        s != null ? Xo(e, !!i.multiple, s, !1) : i.defaultValue != null && Xo(e, !!i.multiple, i.defaultValue, !0);
                        break;
                    default:
                        typeof r.onClick == "function" && (e.onclick = mh)
                    }
                    switch (n) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        i = !!i.autoFocus;
                        break e;
                    case "img":
                        i = !0;
                        break e;
                    default:
                        i = !1
                    }
                }
                i && (t.flags |= 4)
            }
            t.ref !== null && (t.flags |= 512,
            t.flags |= 2097152)
        }
        return sn(t),
        null;
    case 6:
        if (e && t.stateNode != null)
            Z9(e, t, e.memoizedProps, i);
        else {
            if (typeof i != "string" && t.stateNode === null)
                throw Error(Se(166));
            if (n = Ls(Nl.current),
            Ls(Ii.current),
            Kc(t)) {
                if (i = t.stateNode,
                n = t.memoizedProps,
                i[_i] = t,
                (s = i.nodeValue !== n) && (e = Bn,
                e !== null))
                    switch (e.tag) {
                    case 3:
                        $c(i.nodeValue, n, (e.mode & 1) !== 0);
                        break;
                    case 5:
                        e.memoizedProps.suppressHydrationWarning !== !0 && $c(i.nodeValue, n, (e.mode & 1) !== 0)
                    }
                s && (t.flags |= 4)
            } else
                i = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(i),
                i[_i] = t,
                t.stateNode = i
        }
        return sn(t),
        null;
    case 13:
        if (pt(bt),
        i = t.memoizedState,
        e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            if (vt && Fn !== null && t.mode & 1 && !(t.flags & 128))
                g9(),
                sa(),
                t.flags |= 98560,
                s = !1;
            else if (s = Kc(t),
            i !== null && i.dehydrated !== null) {
                if (e === null) {
                    if (!s)
                        throw Error(Se(318));
                    if (s = t.memoizedState,
                    s = s !== null ? s.dehydrated : null,
                    !s)
                        throw Error(Se(317));
                    s[_i] = t
                } else
                    sa(),
                    !(t.flags & 128) && (t.memoizedState = null),
                    t.flags |= 4;
                sn(t),
                s = !1
            } else
                vi !== null && (F1(vi),
                vi = null),
                s = !0;
            if (!s)
                return t.flags & 65536 ? t : null
        }
        return t.flags & 128 ? (t.lanes = n,
        t) : (i = i !== null,
        i !== (e !== null && e.memoizedState !== null) && i && (t.child.flags |= 8192,
        t.mode & 1 && (e === null || bt.current & 1 ? Wt === 0 && (Wt = 3) : Zm())),
        t.updateQueue !== null && (t.flags |= 4),
        sn(t),
        null);
    case 4:
        return aa(),
        T1(e, t),
        e === null && Ll(t.stateNode.containerInfo),
        sn(t),
        null;
    case 10:
        return Dm(t.type._context),
        sn(t),
        null;
    case 17:
        return En(t.type) && vh(),
        sn(t),
        null;
    case 19:
        if (pt(bt),
        s = t.memoizedState,
        s === null)
            return sn(t),
            null;
        if (i = (t.flags & 128) !== 0,
        o = s.rendering,
        o === null)
            if (i)
                Da(s, !1);
            else {
                if (Wt !== 0 || e !== null && e.flags & 128)
                    for (e = t.child; e !== null; ) {
                        if (o = kh(e),
                        o !== null) {
                            for (t.flags |= 128,
                            Da(s, !1),
                            i = o.updateQueue,
                            i !== null && (t.updateQueue = i,
                            t.flags |= 4),
                            t.subtreeFlags = 0,
                            i = n,
                            n = t.child; n !== null; )
                                s = n,
                                e = i,
                                s.flags &= 14680066,
                                o = s.alternate,
                                o === null ? (s.childLanes = 0,
                                s.lanes = e,
                                s.child = null,
                                s.subtreeFlags = 0,
                                s.memoizedProps = null,
                                s.memoizedState = null,
                                s.updateQueue = null,
                                s.dependencies = null,
                                s.stateNode = null) : (s.childLanes = o.childLanes,
                                s.lanes = o.lanes,
                                s.child = o.child,
                                s.subtreeFlags = 0,
                                s.deletions = null,
                                s.memoizedProps = o.memoizedProps,
                                s.memoizedState = o.memoizedState,
                                s.updateQueue = o.updateQueue,
                                s.type = o.type,
                                e = o.dependencies,
                                s.dependencies = e === null ? null : {
                                    lanes: e.lanes,
                                    firstContext: e.firstContext
                                }),
                                n = n.sibling;
                            return lt(bt, bt.current & 1 | 2),
                            t.child
                        }
                        e = e.sibling
                    }
                s.tail !== null && Lt() > ca && (t.flags |= 128,
                i = !0,
                Da(s, !1),
                t.lanes = 4194304)
            }
        else {
            if (!i)
                if (e = kh(o),
                e !== null) {
                    if (t.flags |= 128,
                    i = !0,
                    n = e.updateQueue,
                    n !== null && (t.updateQueue = n,
                    t.flags |= 4),
                    Da(s, !0),
                    s.tail === null && s.tailMode === "hidden" && !o.alternate && !vt)
                        return sn(t),
                        null
                } else
                    2 * Lt() - s.renderingStartTime > ca && n !== 1073741824 && (t.flags |= 128,
                    i = !0,
                    Da(s, !1),
                    t.lanes = 4194304);
            s.isBackwards ? (o.sibling = t.child,
            t.child = o) : (n = s.last,
            n !== null ? n.sibling = o : t.child = o,
            s.last = o)
        }
        return s.tail !== null ? (t = s.tail,
        s.rendering = t,
        s.tail = t.sibling,
        s.renderingStartTime = Lt(),
        t.sibling = null,
        n = bt.current,
        lt(bt, i ? n & 1 | 2 : n & 1),
        t) : (sn(t),
        null);
    case 22:
    case 23:
        return qm(),
        i = t.memoizedState !== null,
        e !== null && e.memoizedState !== null !== i && (t.flags |= 8192),
        i && t.mode & 1 ? Dn & 1073741824 && (sn(t),
        t.subtreeFlags & 6 && (t.flags |= 8192)) : sn(t),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(Se(156, t.tag))
}
function VE(e, t) {
    switch (Om(t),
    t.tag) {
    case 1:
        return En(t.type) && vh(),
        e = t.flags,
        e & 65536 ? (t.flags = e & -65537 | 128,
        t) : null;
    case 3:
        return aa(),
        pt(Mn),
        pt(ln),
        zm(),
        e = t.flags,
        e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128,
        t) : null;
    case 5:
        return Bm(t),
        null;
    case 13:
        if (pt(bt),
        e = t.memoizedState,
        e !== null && e.dehydrated !== null) {
            if (t.alternate === null)
                throw Error(Se(340));
            sa()
        }
        return e = t.flags,
        e & 65536 ? (t.flags = e & -65537 | 128,
        t) : null;
    case 19:
        return pt(bt),
        null;
    case 4:
        return aa(),
        null;
    case 10:
        return Dm(t.type._context),
        null;
    case 22:
    case 23:
        return qm(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Zc = !1
  , an = !1
  , WE = typeof WeakSet == "function" ? WeakSet : Set
  , Ae = null;
function Do(e, t) {
    var n = e.ref;
    if (n !== null)
        if (typeof n == "function")
            try {
                n(null)
            } catch (i) {
                Mt(e, t, i)
            }
        else
            n.current = null
}
function j1(e, t, n) {
    try {
        n()
    } catch (i) {
        Mt(e, t, i)
    }
}
var my = !1;
function HE(e, t) {
    if (f1 = fh,
    e = n9(),
    Tm(e)) {
        if ("selectionStart"in e)
            var n = {
                start: e.selectionStart,
                end: e.selectionEnd
            };
        else
            e: {
                n = (n = e.ownerDocument) && n.defaultView || window;
                var i = n.getSelection && n.getSelection();
                if (i && i.rangeCount !== 0) {
                    n = i.anchorNode;
                    var r = i.anchorOffset
                      , s = i.focusNode;
                    i = i.focusOffset;
                    try {
                        n.nodeType,
                        s.nodeType
                    } catch {
                        n = null;
                        break e
                    }
                    var o = 0
                      , a = -1
                      , l = -1
                      , c = 0
                      , u = 0
                      , h = e
                      , d = null;
                    t: for (; ; ) {
                        for (var m; h !== n || r !== 0 && h.nodeType !== 3 || (a = o + r),
                        h !== s || i !== 0 && h.nodeType !== 3 || (l = o + i),
                        h.nodeType === 3 && (o += h.nodeValue.length),
                        (m = h.firstChild) !== null; )
                            d = h,
                            h = m;
                        for (; ; ) {
                            if (h === e)
                                break t;
                            if (d === n && ++c === r && (a = o),
                            d === s && ++u === i && (l = o),
                            (m = h.nextSibling) !== null)
                                break;
                            h = d,
                            d = h.parentNode
                        }
                        h = m
                    }
                    n = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    n = null
            }
        n = n || {
            start: 0,
            end: 0
        }
    } else
        n = null;
    for (p1 = {
        focusedElem: e,
        selectionRange: n
    },
    fh = !1,
    Ae = t; Ae !== null; )
        if (t = Ae,
        e = t.child,
        (t.subtreeFlags & 1028) !== 0 && e !== null)
            e.return = t,
            Ae = e;
        else
            for (; Ae !== null; ) {
                t = Ae;
                try {
                    var f = t.alternate;
                    if (t.flags & 1024)
                        switch (t.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (f !== null) {
                                var x = f.memoizedProps
                                  , S = f.memoizedState
                                  , v = t.stateNode
                                  , p = v.getSnapshotBeforeUpdate(t.elementType === t.type ? x : fi(t.type, x), S);
                                v.__reactInternalSnapshotBeforeUpdate = p
                            }
                            break;
                        case 3:
                            var g = t.stateNode.containerInfo;
                            g.nodeType === 1 ? g.textContent = "" : g.nodeType === 9 && g.documentElement && g.removeChild(g.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(Se(163))
                        }
                } catch (C) {
                    Mt(t, t.return, C)
                }
                if (e = t.sibling,
                e !== null) {
                    e.return = t.return,
                    Ae = e;
                    break
                }
                Ae = t.return
            }
    return f = my,
    my = !1,
    f
}
function cl(e, t, n) {
    var i = t.updateQueue;
    if (i = i !== null ? i.lastEffect : null,
    i !== null) {
        var r = i = i.next;
        do {
            if ((r.tag & e) === e) {
                var s = r.destroy;
                r.destroy = void 0,
                s !== void 0 && j1(t, n, s)
            }
            r = r.next
        } while (r !== i)
    }
}
function Sd(e, t) {
    if (t = t.updateQueue,
    t = t !== null ? t.lastEffect : null,
    t !== null) {
        var n = t = t.next;
        do {
            if ((n.tag & e) === e) {
                var i = n.create;
                n.destroy = i()
            }
            n = n.next
        } while (n !== t)
    }
}
function O1(e) {
    var t = e.ref;
    if (t !== null) {
        var n = e.stateNode;
        switch (e.tag) {
        case 5:
            e = n;
            break;
        default:
            e = n
        }
        typeof t == "function" ? t(e) : t.current = e
    }
}
function J9(e) {
    var t = e.alternate;
    t !== null && (e.alternate = null,
    J9(t)),
    e.child = null,
    e.deletions = null,
    e.sibling = null,
    e.tag === 5 && (t = e.stateNode,
    t !== null && (delete t[_i],
    delete t[_l],
    delete t[v1],
    delete t[AE],
    delete t[ME])),
    e.stateNode = null,
    e.return = null,
    e.dependencies = null,
    e.memoizedProps = null,
    e.memoizedState = null,
    e.pendingProps = null,
    e.stateNode = null,
    e.updateQueue = null
}
function ew(e) {
    return e.tag === 5 || e.tag === 3 || e.tag === 4
}
function vy(e) {
    e: for (; ; ) {
        for (; e.sibling === null; ) {
            if (e.return === null || ew(e.return))
                return null;
            e = e.return
        }
        for (e.sibling.return = e.return,
        e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
            if (e.flags & 2 || e.child === null || e.tag === 4)
                continue e;
            e.child.return = e,
            e = e.child
        }
        if (!(e.flags & 2))
            return e.stateNode
    }
}
function L1(e, t, n) {
    var i = e.tag;
    if (i === 5 || i === 6)
        e = e.stateNode,
        t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode,
        t.insertBefore(e, n)) : (t = n,
        t.appendChild(e)),
        n = n._reactRootContainer,
        n != null || t.onclick !== null || (t.onclick = mh));
    else if (i !== 4 && (e = e.child,
    e !== null))
        for (L1(e, t, n),
        e = e.sibling; e !== null; )
            L1(e, t, n),
            e = e.sibling
}
function R1(e, t, n) {
    var i = e.tag;
    if (i === 5 || i === 6)
        e = e.stateNode,
        t ? n.insertBefore(e, t) : n.appendChild(e);
    else if (i !== 4 && (e = e.child,
    e !== null))
        for (R1(e, t, n),
        e = e.sibling; e !== null; )
            R1(e, t, n),
            e = e.sibling
}
var Zt = null
  , pi = !1;
function mr(e, t, n) {
    for (n = n.child; n !== null; )
        tw(e, t, n),
        n = n.sibling
}
function tw(e, t, n) {
    if (Fi && typeof Fi.onCommitFiberUnmount == "function")
        try {
            Fi.onCommitFiberUnmount(pd, n)
        } catch {}
    switch (n.tag) {
    case 5:
        an || Do(n, t);
    case 6:
        var i = Zt
          , r = pi;
        Zt = null,
        mr(e, t, n),
        Zt = i,
        pi = r,
        Zt !== null && (pi ? (e = Zt,
        n = n.stateNode,
        e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : Zt.removeChild(n.stateNode));
        break;
    case 18:
        Zt !== null && (pi ? (e = Zt,
        n = n.stateNode,
        e.nodeType === 8 ? Hf(e.parentNode, n) : e.nodeType === 1 && Hf(e, n),
        Tl(e)) : Hf(Zt, n.stateNode));
        break;
    case 4:
        i = Zt,
        r = pi,
        Zt = n.stateNode.containerInfo,
        pi = !0,
        mr(e, t, n),
        Zt = i,
        pi = r;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!an && (i = n.updateQueue,
        i !== null && (i = i.lastEffect,
        i !== null))) {
            r = i = i.next;
            do {
                var s = r
                  , o = s.destroy;
                s = s.tag,
                o !== void 0 && (s & 2 || s & 4) && j1(n, t, o),
                r = r.next
            } while (r !== i)
        }
        mr(e, t, n);
        break;
    case 1:
        if (!an && (Do(n, t),
        i = n.stateNode,
        typeof i.componentWillUnmount == "function"))
            try {
                i.props = n.memoizedProps,
                i.state = n.memoizedState,
                i.componentWillUnmount()
            } catch (a) {
                Mt(n, t, a)
            }
        mr(e, t, n);
        break;
    case 21:
        mr(e, t, n);
        break;
    case 22:
        n.mode & 1 ? (an = (i = an) || n.memoizedState !== null,
        mr(e, t, n),
        an = i) : mr(e, t, n);
        break;
    default:
        mr(e, t, n)
    }
}
function yy(e) {
    var t = e.updateQueue;
    if (t !== null) {
        e.updateQueue = null;
        var n = e.stateNode;
        n === null && (n = e.stateNode = new WE),
        t.forEach(function(i) {
            var r = ZE.bind(null, e, i);
            n.has(i) || (n.add(i),
            i.then(r, r))
        })
    }
}
function hi(e, t) {
    var n = t.deletions;
    if (n !== null)
        for (var i = 0; i < n.length; i++) {
            var r = n[i];
            try {
                var s = e
                  , o = t
                  , a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        Zt = a.stateNode,
                        pi = !1;
                        break e;
                    case 3:
                        Zt = a.stateNode.containerInfo,
                        pi = !0;
                        break e;
                    case 4:
                        Zt = a.stateNode.containerInfo,
                        pi = !0;
                        break e
                    }
                    a = a.return
                }
                if (Zt === null)
                    throw Error(Se(160));
                tw(s, o, r),
                Zt = null,
                pi = !1;
                var l = r.alternate;
                l !== null && (l.return = null),
                r.return = null
            } catch (c) {
                Mt(r, t, c)
            }
        }
    if (t.subtreeFlags & 12854)
        for (t = t.child; t !== null; )
            nw(t, e),
            t = t.sibling
}
function nw(e, t) {
    var n = e.alternate
      , i = e.flags;
    switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (hi(t, e),
        Ei(e),
        i & 4) {
            try {
                cl(3, e, e.return),
                Sd(3, e)
            } catch (x) {
                Mt(e, e.return, x)
            }
            try {
                cl(5, e, e.return)
            } catch (x) {
                Mt(e, e.return, x)
            }
        }
        break;
    case 1:
        hi(t, e),
        Ei(e),
        i & 512 && n !== null && Do(n, n.return);
        break;
    case 5:
        if (hi(t, e),
        Ei(e),
        i & 512 && n !== null && Do(n, n.return),
        e.flags & 32) {
            var r = e.stateNode;
            try {
                Al(r, "")
            } catch (x) {
                Mt(e, e.return, x)
            }
        }
        if (i & 4 && (r = e.stateNode,
        r != null)) {
            var s = e.memoizedProps
              , o = n !== null ? n.memoizedProps : s
              , a = e.type
              , l = e.updateQueue;
            if (e.updateQueue = null,
            l !== null)
                try {
                    a === "input" && s.type === "radio" && s.name != null && C8(r, s),
                    i1(a, o);
                    var c = i1(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var u = l[o]
                          , h = l[o + 1];
                        u === "style" ? P8(r, h) : u === "dangerouslySetInnerHTML" ? M8(r, h) : u === "children" ? Al(r, h) : mm(r, u, h, c)
                    }
                    switch (a) {
                    case "input":
                        Z0(r, s);
                        break;
                    case "textarea":
                        k8(r, s);
                        break;
                    case "select":
                        var d = r._wrapperState.wasMultiple;
                        r._wrapperState.wasMultiple = !!s.multiple;
                        var m = s.value;
                        m != null ? Xo(r, !!s.multiple, m, !1) : d !== !!s.multiple && (s.defaultValue != null ? Xo(r, !!s.multiple, s.defaultValue, !0) : Xo(r, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    r[_l] = s
                } catch (x) {
                    Mt(e, e.return, x)
                }
        }
        break;
    case 6:
        if (hi(t, e),
        Ei(e),
        i & 4) {
            if (e.stateNode === null)
                throw Error(Se(162));
            r = e.stateNode,
            s = e.memoizedProps;
            try {
                r.nodeValue = s
            } catch (x) {
                Mt(e, e.return, x)
            }
        }
        break;
    case 3:
        if (hi(t, e),
        Ei(e),
        i & 4 && n !== null && n.memoizedState.isDehydrated)
            try {
                Tl(t.containerInfo)
            } catch (x) {
                Mt(e, e.return, x)
            }
        break;
    case 4:
        hi(t, e),
        Ei(e);
        break;
    case 13:
        hi(t, e),
        Ei(e),
        r = e.child,
        r.flags & 8192 && (s = r.memoizedState !== null,
        r.stateNode.isHidden = s,
        !s || r.alternate !== null && r.alternate.memoizedState !== null || (Km = Lt())),
        i & 4 && yy(e);
        break;
    case 22:
        if (u = n !== null && n.memoizedState !== null,
        e.mode & 1 ? (an = (c = an) || u,
        hi(t, e),
        an = c) : hi(t, e),
        Ei(e),
        i & 8192) {
            if (c = e.memoizedState !== null,
            (e.stateNode.isHidden = c) && !u && e.mode & 1)
                for (Ae = e,
                u = e.child; u !== null; ) {
                    for (h = Ae = u; Ae !== null; ) {
                        switch (d = Ae,
                        m = d.child,
                        d.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            cl(4, d, d.return);
                            break;
                        case 1:
                            Do(d, d.return);
                            var f = d.stateNode;
                            if (typeof f.componentWillUnmount == "function") {
                                i = d,
                                n = d.return;
                                try {
                                    t = i,
                                    f.props = t.memoizedProps,
                                    f.state = t.memoizedState,
                                    f.componentWillUnmount()
                                } catch (x) {
                                    Mt(i, n, x)
                                }
                            }
                            break;
                        case 5:
                            Do(d, d.return);
                            break;
                        case 22:
                            if (d.memoizedState !== null) {
                                by(h);
                                continue
                            }
                        }
                        m !== null ? (m.return = d,
                        Ae = m) : by(h)
                    }
                    u = u.sibling
                }
            e: for (u = null,
            h = e; ; ) {
                if (h.tag === 5) {
                    if (u === null) {
                        u = h;
                        try {
                            r = h.stateNode,
                            c ? (s = r.style,
                            typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = h.stateNode,
                            l = h.memoizedProps.style,
                            o = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = E8("display", o))
                        } catch (x) {
                            Mt(e, e.return, x)
                        }
                    }
                } else if (h.tag === 6) {
                    if (u === null)
                        try {
                            h.stateNode.nodeValue = c ? "" : h.memoizedProps
                        } catch (x) {
                            Mt(e, e.return, x)
                        }
                } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === e) && h.child !== null) {
                    h.child.return = h,
                    h = h.child;
                    continue
                }
                if (h === e)
                    break e;
                for (; h.sibling === null; ) {
                    if (h.return === null || h.return === e)
                        break e;
                    u === h && (u = null),
                    h = h.return
                }
                u === h && (u = null),
                h.sibling.return = h.return,
                h = h.sibling
            }
        }
        break;
    case 19:
        hi(t, e),
        Ei(e),
        i & 4 && yy(e);
        break;
    case 21:
        break;
    default:
        hi(t, e),
        Ei(e)
    }
}
function Ei(e) {
    var t = e.flags;
    if (t & 2) {
        try {
            e: {
                for (var n = e.return; n !== null; ) {
                    if (ew(n)) {
                        var i = n;
                        break e
                    }
                    n = n.return
                }
                throw Error(Se(160))
            }
            switch (i.tag) {
            case 5:
                var r = i.stateNode;
                i.flags & 32 && (Al(r, ""),
                i.flags &= -33);
                var s = vy(e);
                R1(e, s, r);
                break;
            case 3:
            case 4:
                var o = i.stateNode.containerInfo
                  , a = vy(e);
                L1(e, a, o);
                break;
            default:
                throw Error(Se(161))
            }
        } catch (l) {
            Mt(e, e.return, l)
        }
        e.flags &= -3
    }
    t & 4096 && (e.flags &= -4097)
}
function UE(e, t, n) {
    Ae = e,
    iw(e)
}
function iw(e, t, n) {
    for (var i = (e.mode & 1) !== 0; Ae !== null; ) {
        var r = Ae
          , s = r.child;
        if (r.tag === 22 && i) {
            var o = r.memoizedState !== null || Zc;
            if (!o) {
                var a = r.alternate
                  , l = a !== null && a.memoizedState !== null || an;
                a = Zc;
                var c = an;
                if (Zc = o,
                (an = l) && !c)
                    for (Ae = r; Ae !== null; )
                        o = Ae,
                        l = o.child,
                        o.tag === 22 && o.memoizedState !== null ? wy(r) : l !== null ? (l.return = o,
                        Ae = l) : wy(r);
                for (; s !== null; )
                    Ae = s,
                    iw(s),
                    s = s.sibling;
                Ae = r,
                Zc = a,
                an = c
            }
            xy(e)
        } else
            r.subtreeFlags & 8772 && s !== null ? (s.return = r,
            Ae = s) : xy(e)
    }
}
function xy(e) {
    for (; Ae !== null; ) {
        var t = Ae;
        if (t.flags & 8772) {
            var n = t.alternate;
            try {
                if (t.flags & 8772)
                    switch (t.tag) {
                    case 0:
                    case 11:
                    case 15:
                        an || Sd(5, t);
                        break;
                    case 1:
                        var i = t.stateNode;
                        if (t.flags & 4 && !an)
                            if (n === null)
                                i.componentDidMount();
                            else {
                                var r = t.elementType === t.type ? n.memoizedProps : fi(t.type, n.memoizedProps);
                                i.componentDidUpdate(r, n.memoizedState, i.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = t.updateQueue;
                        s !== null && ny(t, s, i);
                        break;
                    case 3:
                        var o = t.updateQueue;
                        if (o !== null) {
                            if (n = null,
                            t.child !== null)
                                switch (t.child.tag) {
                                case 5:
                                    n = t.child.stateNode;
                                    break;
                                case 1:
                                    n = t.child.stateNode
                                }
                            ny(t, o, n)
                        }
                        break;
                    case 5:
                        var a = t.stateNode;
                        if (n === null && t.flags & 4) {
                            n = a;
                            var l = t.memoizedProps;
                            switch (t.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && n.focus();
                                break;
                            case "img":
                                l.src && (n.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (t.memoizedState === null) {
                            var c = t.alternate;
                            if (c !== null) {
                                var u = c.memoizedState;
                                if (u !== null) {
                                    var h = u.dehydrated;
                                    h !== null && Tl(h)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(Se(163))
                    }
                an || t.flags & 512 && O1(t)
            } catch (d) {
                Mt(t, t.return, d)
            }
        }
        if (t === e) {
            Ae = null;
            break
        }
        if (n = t.sibling,
        n !== null) {
            n.return = t.return,
            Ae = n;
            break
        }
        Ae = t.return
    }
}
function by(e) {
    for (; Ae !== null; ) {
        var t = Ae;
        if (t === e) {
            Ae = null;
            break
        }
        var n = t.sibling;
        if (n !== null) {
            n.return = t.return,
            Ae = n;
            break
        }
        Ae = t.return
    }
}
function wy(e) {
    for (; Ae !== null; ) {
        var t = Ae;
        try {
            switch (t.tag) {
            case 0:
            case 11:
            case 15:
                var n = t.return;
                try {
                    Sd(4, t)
                } catch (l) {
                    Mt(t, n, l)
                }
                break;
            case 1:
                var i = t.stateNode;
                if (typeof i.componentDidMount == "function") {
                    var r = t.return;
                    try {
                        i.componentDidMount()
                    } catch (l) {
                        Mt(t, r, l)
                    }
                }
                var s = t.return;
                try {
                    O1(t)
                } catch (l) {
                    Mt(t, s, l)
                }
                break;
            case 5:
                var o = t.return;
                try {
                    O1(t)
                } catch (l) {
                    Mt(t, o, l)
                }
            }
        } catch (l) {
            Mt(t, t.return, l)
        }
        if (t === e) {
            Ae = null;
            break
        }
        var a = t.sibling;
        if (a !== null) {
            a.return = t.return,
            Ae = a;
            break
        }
        Ae = t.return
    }
}
var GE = Math.ceil
  , Eh = fr.ReactCurrentDispatcher
  , Ym = fr.ReactCurrentOwner
  , ni = fr.ReactCurrentBatchConfig
  , $e = 0
  , Kt = null
  , Nt = null
  , Jt = 0
  , Dn = 0
  , No = ts(0)
  , Wt = 0
  , zl = null
  , Ks = 0
  , Cd = 0
  , $m = 0
  , ul = null
  , Sn = null
  , Km = 0
  , ca = 1 / 0
  , qi = null
  , Ph = !1
  , _1 = null
  , Br = null
  , Jc = !1
  , Er = null
  , Th = 0
  , hl = 0
  , D1 = null
  , Xu = -1
  , Yu = 0;
function mn() {
    return $e & 6 ? Lt() : Xu !== -1 ? Xu : Xu = Lt()
}
function zr(e) {
    return e.mode & 1 ? $e & 2 && Jt !== 0 ? Jt & -Jt : PE.transition !== null ? (Yu === 0 && (Yu = z8()),
    Yu) : (e = Je,
    e !== 0 || (e = window.event,
    e = e === void 0 ? 16 : Y8(e.type)),
    e) : 1
}
function bi(e, t, n, i) {
    if (50 < hl)
        throw hl = 0,
        D1 = null,
        Error(Se(185));
    hc(e, n, i),
    (!($e & 2) || e !== Kt) && (e === Kt && (!($e & 2) && (Cd |= n),
    Wt === 4 && Ar(e, Jt)),
    Pn(e, i),
    n === 1 && $e === 0 && !(t.mode & 1) && (ca = Lt() + 500,
    xd && ns()))
}
function Pn(e, t) {
    var n = e.callbackNode;
    PM(e, t);
    var i = dh(e, e === Kt ? Jt : 0);
    if (i === 0)
        n !== null && jv(n),
        e.callbackNode = null,
        e.callbackPriority = 0;
    else if (t = i & -i,
    e.callbackPriority !== t) {
        if (n != null && jv(n),
        t === 1)
            e.tag === 0 ? EE(Sy.bind(null, e)) : d9(Sy.bind(null, e)),
            CE(function() {
                !($e & 6) && ns()
            }),
            n = null;
        else {
            switch (V8(i)) {
            case 1:
                n = wm;
                break;
            case 4:
                n = I8;
                break;
            case 16:
                n = hh;
                break;
            case 536870912:
                n = B8;
                break;
            default:
                n = hh
            }
            n = hw(n, rw.bind(null, e))
        }
        e.callbackPriority = t,
        e.callbackNode = n
    }
}
function rw(e, t) {
    if (Xu = -1,
    Yu = 0,
    $e & 6)
        throw Error(Se(327));
    var n = e.callbackNode;
    if (qo() && e.callbackNode !== n)
        return null;
    var i = dh(e, e === Kt ? Jt : 0);
    if (i === 0)
        return null;
    if (i & 30 || i & e.expiredLanes || t)
        t = jh(e, i);
    else {
        t = i;
        var r = $e;
        $e |= 2;
        var s = ow();
        (Kt !== e || Jt !== t) && (qi = null,
        ca = Lt() + 500,
        zs(e, t));
        do
            try {
                $E();
                break
            } catch (a) {
                sw(e, a)
            }
        while (!0);
        _m(),
        Eh.current = s,
        $e = r,
        Nt !== null ? t = 0 : (Kt = null,
        Jt = 0,
        t = Wt)
    }
    if (t !== 0) {
        if (t === 2 && (r = l1(e),
        r !== 0 && (i = r,
        t = N1(e, r))),
        t === 1)
            throw n = zl,
            zs(e, 0),
            Ar(e, i),
            Pn(e, Lt()),
            n;
        if (t === 6)
            Ar(e, i);
        else {
            if (r = e.current.alternate,
            !(i & 30) && !XE(r) && (t = jh(e, i),
            t === 2 && (s = l1(e),
            s !== 0 && (i = s,
            t = N1(e, s))),
            t === 1))
                throw n = zl,
                zs(e, 0),
                Ar(e, i),
                Pn(e, Lt()),
                n;
            switch (e.finishedWork = r,
            e.finishedLanes = i,
            t) {
            case 0:
            case 1:
                throw Error(Se(345));
            case 2:
                Ss(e, Sn, qi);
                break;
            case 3:
                if (Ar(e, i),
                (i & 130023424) === i && (t = Km + 500 - Lt(),
                10 < t)) {
                    if (dh(e, 0) !== 0)
                        break;
                    if (r = e.suspendedLanes,
                    (r & i) !== i) {
                        mn(),
                        e.pingedLanes |= e.suspendedLanes & r;
                        break
                    }
                    e.timeoutHandle = m1(Ss.bind(null, e, Sn, qi), t);
                    break
                }
                Ss(e, Sn, qi);
                break;
            case 4:
                if (Ar(e, i),
                (i & 4194240) === i)
                    break;
                for (t = e.eventTimes,
                r = -1; 0 < i; ) {
                    var o = 31 - xi(i);
                    s = 1 << o,
                    o = t[o],
                    o > r && (r = o),
                    i &= ~s
                }
                if (i = r,
                i = Lt() - i,
                i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * GE(i / 1960)) - i,
                10 < i) {
                    e.timeoutHandle = m1(Ss.bind(null, e, Sn, qi), i);
                    break
                }
                Ss(e, Sn, qi);
                break;
            case 5:
                Ss(e, Sn, qi);
                break;
            default:
                throw Error(Se(329))
            }
        }
    }
    return Pn(e, Lt()),
    e.callbackNode === n ? rw.bind(null, e) : null
}
function N1(e, t) {
    var n = ul;
    return e.current.memoizedState.isDehydrated && (zs(e, t).flags |= 256),
    e = jh(e, t),
    e !== 2 && (t = Sn,
    Sn = n,
    t !== null && F1(t)),
    e
}
function F1(e) {
    Sn === null ? Sn = e : Sn.push.apply(Sn, e)
}
function XE(e) {
    for (var t = e; ; ) {
        if (t.flags & 16384) {
            var n = t.updateQueue;
            if (n !== null && (n = n.stores,
            n !== null))
                for (var i = 0; i < n.length; i++) {
                    var r = n[i]
                      , s = r.getSnapshot;
                    r = r.value;
                    try {
                        if (!Si(s(), r))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (n = t.child,
        t.subtreeFlags & 16384 && n !== null)
            n.return = t,
            t = n;
        else {
            if (t === e)
                break;
            for (; t.sibling === null; ) {
                if (t.return === null || t.return === e)
                    return !0;
                t = t.return
            }
            t.sibling.return = t.return,
            t = t.sibling
        }
    }
    return !0
}
function Ar(e, t) {
    for (t &= ~$m,
    t &= ~Cd,
    e.suspendedLanes |= t,
    e.pingedLanes &= ~t,
    e = e.expirationTimes; 0 < t; ) {
        var n = 31 - xi(t)
          , i = 1 << n;
        e[n] = -1,
        t &= ~i
    }
}
function Sy(e) {
    if ($e & 6)
        throw Error(Se(327));
    qo();
    var t = dh(e, 0);
    if (!(t & 1))
        return Pn(e, Lt()),
        null;
    var n = jh(e, t);
    if (e.tag !== 0 && n === 2) {
        var i = l1(e);
        i !== 0 && (t = i,
        n = N1(e, i))
    }
    if (n === 1)
        throw n = zl,
        zs(e, 0),
        Ar(e, t),
        Pn(e, Lt()),
        n;
    if (n === 6)
        throw Error(Se(345));
    return e.finishedWork = e.current.alternate,
    e.finishedLanes = t,
    Ss(e, Sn, qi),
    Pn(e, Lt()),
    null
}
function Qm(e, t) {
    var n = $e;
    $e |= 1;
    try {
        return e(t)
    } finally {
        $e = n,
        $e === 0 && (ca = Lt() + 500,
        xd && ns())
    }
}
function Qs(e) {
    Er !== null && Er.tag === 0 && !($e & 6) && qo();
    var t = $e;
    $e |= 1;
    var n = ni.transition
      , i = Je;
    try {
        if (ni.transition = null,
        Je = 1,
        e)
            return e()
    } finally {
        Je = i,
        ni.transition = n,
        $e = t,
        !($e & 6) && ns()
    }
}
function qm() {
    Dn = No.current,
    pt(No)
}
function zs(e, t) {
    e.finishedWork = null,
    e.finishedLanes = 0;
    var n = e.timeoutHandle;
    if (n !== -1 && (e.timeoutHandle = -1,
    SE(n)),
    Nt !== null)
        for (n = Nt.return; n !== null; ) {
            var i = n;
            switch (Om(i),
            i.tag) {
            case 1:
                i = i.type.childContextTypes,
                i != null && vh();
                break;
            case 3:
                aa(),
                pt(Mn),
                pt(ln),
                zm();
                break;
            case 5:
                Bm(i);
                break;
            case 4:
                aa();
                break;
            case 13:
                pt(bt);
                break;
            case 19:
                pt(bt);
                break;
            case 10:
                Dm(i.type._context);
                break;
            case 22:
            case 23:
                qm()
            }
            n = n.return
        }
    if (Kt = e,
    Nt = e = Vr(e.current, null),
    Jt = Dn = t,
    Wt = 0,
    zl = null,
    $m = Cd = Ks = 0,
    Sn = ul = null,
    Os !== null) {
        for (t = 0; t < Os.length; t++)
            if (n = Os[t],
            i = n.interleaved,
            i !== null) {
                n.interleaved = null;
                var r = i.next
                  , s = n.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = r,
                    i.next = o
                }
                n.pending = i
            }
        Os = null
    }
    return e
}
function sw(e, t) {
    do {
        var n = Nt;
        try {
            if (_m(),
            Hu.current = Mh,
            Ah) {
                for (var i = St.memoizedState; i !== null; ) {
                    var r = i.queue;
                    r !== null && (r.pending = null),
                    i = i.next
                }
                Ah = !1
            }
            if ($s = 0,
            $t = Vt = St = null,
            ll = !1,
            Fl = 0,
            Ym.current = null,
            n === null || n.return === null) {
                Wt = 1,
                zl = t,
                Nt = null;
                break
            }
            e: {
                var s = e
                  , o = n.return
                  , a = n
                  , l = t;
                if (t = Jt,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l
                      , u = a
                      , h = u.tag;
                    if (!(u.mode & 1) && (h === 0 || h === 11 || h === 15)) {
                        var d = u.alternate;
                        d ? (u.updateQueue = d.updateQueue,
                        u.memoizedState = d.memoizedState,
                        u.lanes = d.lanes) : (u.updateQueue = null,
                        u.memoizedState = null)
                    }
                    var m = cy(o);
                    if (m !== null) {
                        m.flags &= -257,
                        uy(m, o, a, s, t),
                        m.mode & 1 && ly(s, c, t),
                        t = m,
                        l = c;
                        var f = t.updateQueue;
                        if (f === null) {
                            var x = new Set;
                            x.add(l),
                            t.updateQueue = x
                        } else
                            f.add(l);
                        break e
                    } else {
                        if (!(t & 1)) {
                            ly(s, c, t),
                            Zm();
                            break e
                        }
                        l = Error(Se(426))
                    }
                } else if (vt && a.mode & 1) {
                    var S = cy(o);
                    if (S !== null) {
                        !(S.flags & 65536) && (S.flags |= 256),
                        uy(S, o, a, s, t),
                        Lm(la(l, a));
                        break e
                    }
                }
                s = l = la(l, a),
                Wt !== 4 && (Wt = 2),
                ul === null ? ul = [s] : ul.push(s),
                s = o;
                do {
                    switch (s.tag) {
                    case 3:
                        s.flags |= 65536,
                        t &= -t,
                        s.lanes |= t;
                        var v = W9(s, l, t);
                        ty(s, v);
                        break e;
                    case 1:
                        a = l;
                        var p = s.type
                          , g = s.stateNode;
                        if (!(s.flags & 128) && (typeof p.getDerivedStateFromError == "function" || g !== null && typeof g.componentDidCatch == "function" && (Br === null || !Br.has(g)))) {
                            s.flags |= 65536,
                            t &= -t,
                            s.lanes |= t;
                            var C = H9(s, a, t);
                            ty(s, C);
                            break e
                        }
                    }
                    s = s.return
                } while (s !== null)
            }
            lw(n)
        } catch (E) {
            t = E,
            Nt === n && n !== null && (Nt = n = n.return);
            continue
        }
        break
    } while (!0)
}
function ow() {
    var e = Eh.current;
    return Eh.current = Mh,
    e === null ? Mh : e
}
function Zm() {
    (Wt === 0 || Wt === 3 || Wt === 2) && (Wt = 4),
    Kt === null || !(Ks & 268435455) && !(Cd & 268435455) || Ar(Kt, Jt)
}
function jh(e, t) {
    var n = $e;
    $e |= 2;
    var i = ow();
    (Kt !== e || Jt !== t) && (qi = null,
    zs(e, t));
    do
        try {
            YE();
            break
        } catch (r) {
            sw(e, r)
        }
    while (!0);
    if (_m(),
    $e = n,
    Eh.current = i,
    Nt !== null)
        throw Error(Se(261));
    return Kt = null,
    Jt = 0,
    Wt
}
function YE() {
    for (; Nt !== null; )
        aw(Nt)
}
function $E() {
    for (; Nt !== null && !xM(); )
        aw(Nt)
}
function aw(e) {
    var t = uw(e.alternate, e, Dn);
    e.memoizedProps = e.pendingProps,
    t === null ? lw(e) : Nt = t,
    Ym.current = null
}
function lw(e) {
    var t = e;
    do {
        var n = t.alternate;
        if (e = t.return,
        t.flags & 32768) {
            if (n = VE(n, t),
            n !== null) {
                n.flags &= 32767,
                Nt = n;
                return
            }
            if (e !== null)
                e.flags |= 32768,
                e.subtreeFlags = 0,
                e.deletions = null;
            else {
                Wt = 6,
                Nt = null;
                return
            }
        } else if (n = zE(n, t, Dn),
        n !== null) {
            Nt = n;
            return
        }
        if (t = t.sibling,
        t !== null) {
            Nt = t;
            return
        }
        Nt = t = e
    } while (t !== null);
    Wt === 0 && (Wt = 5)
}
function Ss(e, t, n) {
    var i = Je
      , r = ni.transition;
    try {
        ni.transition = null,
        Je = 1,
        KE(e, t, n, i)
    } finally {
        ni.transition = r,
        Je = i
    }
    return null
}
function KE(e, t, n, i) {
    do
        qo();
    while (Er !== null);
    if ($e & 6)
        throw Error(Se(327));
    n = e.finishedWork;
    var r = e.finishedLanes;
    if (n === null)
        return null;
    if (e.finishedWork = null,
    e.finishedLanes = 0,
    n === e.current)
        throw Error(Se(177));
    e.callbackNode = null,
    e.callbackPriority = 0;
    var s = n.lanes | n.childLanes;
    if (TM(e, s),
    e === Kt && (Nt = Kt = null,
    Jt = 0),
    !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Jc || (Jc = !0,
    hw(hh, function() {
        return qo(),
        null
    })),
    s = (n.flags & 15990) !== 0,
    n.subtreeFlags & 15990 || s) {
        s = ni.transition,
        ni.transition = null;
        var o = Je;
        Je = 1;
        var a = $e;
        $e |= 4,
        Ym.current = null,
        HE(e, n),
        nw(n, e),
        gE(p1),
        fh = !!f1,
        p1 = f1 = null,
        e.current = n,
        UE(n),
        bM(),
        $e = a,
        Je = o,
        ni.transition = s
    } else
        e.current = n;
    if (Jc && (Jc = !1,
    Er = e,
    Th = r),
    s = e.pendingLanes,
    s === 0 && (Br = null),
    CM(n.stateNode),
    Pn(e, Lt()),
    t !== null)
        for (i = e.onRecoverableError,
        n = 0; n < t.length; n++)
            r = t[n],
            i(r.value, {
                componentStack: r.stack,
                digest: r.digest
            });
    if (Ph)
        throw Ph = !1,
        e = _1,
        _1 = null,
        e;
    return Th & 1 && e.tag !== 0 && qo(),
    s = e.pendingLanes,
    s & 1 ? e === D1 ? hl++ : (hl = 0,
    D1 = e) : hl = 0,
    ns(),
    null
}
function qo() {
    if (Er !== null) {
        var e = V8(Th)
          , t = ni.transition
          , n = Je;
        try {
            if (ni.transition = null,
            Je = 16 > e ? 16 : e,
            Er === null)
                var i = !1;
            else {
                if (e = Er,
                Er = null,
                Th = 0,
                $e & 6)
                    throw Error(Se(331));
                var r = $e;
                for ($e |= 4,
                Ae = e.current; Ae !== null; ) {
                    var s = Ae
                      , o = s.child;
                    if (Ae.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (Ae = c; Ae !== null; ) {
                                    var u = Ae;
                                    switch (u.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        cl(8, u, s)
                                    }
                                    var h = u.child;
                                    if (h !== null)
                                        h.return = u,
                                        Ae = h;
                                    else
                                        for (; Ae !== null; ) {
                                            u = Ae;
                                            var d = u.sibling
                                              , m = u.return;
                                            if (J9(u),
                                            u === c) {
                                                Ae = null;
                                                break
                                            }
                                            if (d !== null) {
                                                d.return = m,
                                                Ae = d;
                                                break
                                            }
                                            Ae = m
                                        }
                                }
                            }
                            var f = s.alternate;
                            if (f !== null) {
                                var x = f.child;
                                if (x !== null) {
                                    f.child = null;
                                    do {
                                        var S = x.sibling;
                                        x.sibling = null,
                                        x = S
                                    } while (x !== null)
                                }
                            }
                            Ae = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null)
                        o.return = s,
                        Ae = o;
                    else
                        e: for (; Ae !== null; ) {
                            if (s = Ae,
                            s.flags & 2048)
                                switch (s.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    cl(9, s, s.return)
                                }
                            var v = s.sibling;
                            if (v !== null) {
                                v.return = s.return,
                                Ae = v;
                                break e
                            }
                            Ae = s.return
                        }
                }
                var p = e.current;
                for (Ae = p; Ae !== null; ) {
                    o = Ae;
                    var g = o.child;
                    if (o.subtreeFlags & 2064 && g !== null)
                        g.return = o,
                        Ae = g;
                    else
                        e: for (o = p; Ae !== null; ) {
                            if (a = Ae,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Sd(9, a)
                                    }
                                } catch (E) {
                                    Mt(a, a.return, E)
                                }
                            if (a === o) {
                                Ae = null;
                                break e
                            }
                            var C = a.sibling;
                            if (C !== null) {
                                C.return = a.return,
                                Ae = C;
                                break e
                            }
                            Ae = a.return
                        }
                }
                if ($e = r,
                ns(),
                Fi && typeof Fi.onPostCommitFiberRoot == "function")
                    try {
                        Fi.onPostCommitFiberRoot(pd, e)
                    } catch {}
                i = !0
            }
            return i
        } finally {
            Je = n,
            ni.transition = t
        }
    }
    return !1
}
function Cy(e, t, n) {
    t = la(n, t),
    t = W9(e, t, 1),
    e = Ir(e, t, 1),
    t = mn(),
    e !== null && (hc(e, 1, t),
    Pn(e, t))
}
function Mt(e, t, n) {
    if (e.tag === 3)
        Cy(e, e, n);
    else
        for (; t !== null; ) {
            if (t.tag === 3) {
                Cy(t, e, n);
                break
            } else if (t.tag === 1) {
                var i = t.stateNode;
                if (typeof t.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (Br === null || !Br.has(i))) {
                    e = la(n, e),
                    e = H9(t, e, 1),
                    t = Ir(t, e, 1),
                    e = mn(),
                    t !== null && (hc(t, 1, e),
                    Pn(t, e));
                    break
                }
            }
            t = t.return
        }
}
function QE(e, t, n) {
    var i = e.pingCache;
    i !== null && i.delete(t),
    t = mn(),
    e.pingedLanes |= e.suspendedLanes & n,
    Kt === e && (Jt & n) === n && (Wt === 4 || Wt === 3 && (Jt & 130023424) === Jt && 500 > Lt() - Km ? zs(e, 0) : $m |= n),
    Pn(e, t)
}
function cw(e, t) {
    t === 0 && (e.mode & 1 ? (t = Hc,
    Hc <<= 1,
    !(Hc & 130023424) && (Hc = 4194304)) : t = 1);
    var n = mn();
    e = ur(e, t),
    e !== null && (hc(e, t, n),
    Pn(e, n))
}
function qE(e) {
    var t = e.memoizedState
      , n = 0;
    t !== null && (n = t.retryLane),
    cw(e, n)
}
function ZE(e, t) {
    var n = 0;
    switch (e.tag) {
    case 13:
        var i = e.stateNode
          , r = e.memoizedState;
        r !== null && (n = r.retryLane);
        break;
    case 19:
        i = e.stateNode;
        break;
    default:
        throw Error(Se(314))
    }
    i !== null && i.delete(t),
    cw(e, n)
}
var uw;
uw = function(e, t, n) {
    if (e !== null)
        if (e.memoizedProps !== t.pendingProps || Mn.current)
            kn = !0;
        else {
            if (!(e.lanes & n) && !(t.flags & 128))
                return kn = !1,
                BE(e, t, n);
            kn = !!(e.flags & 131072)
        }
    else
        kn = !1,
        vt && t.flags & 1048576 && f9(t, bh, t.index);
    switch (t.lanes = 0,
    t.tag) {
    case 2:
        var i = t.type;
        Gu(e, t),
        e = t.pendingProps;
        var r = ra(t, ln.current);
        Qo(t, n),
        r = Wm(null, t, i, e, r, n);
        var s = Hm();
        return t.flags |= 1,
        typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (t.tag = 1,
        t.memoizedState = null,
        t.updateQueue = null,
        En(i) ? (s = !0,
        yh(t)) : s = !1,
        t.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null,
        Fm(t),
        r.updater = bd,
        t.stateNode = r,
        r._reactInternals = t,
        C1(t, i, e, n),
        t = M1(null, t, i, !0, s, n)) : (t.tag = 0,
        vt && s && jm(t),
        fn(null, t, r, n),
        t = t.child),
        t;
    case 16:
        i = t.elementType;
        e: {
            switch (Gu(e, t),
            e = t.pendingProps,
            r = i._init,
            i = r(i._payload),
            t.type = i,
            r = t.tag = eP(i),
            e = fi(i, e),
            r) {
            case 0:
                t = A1(null, t, i, e, n);
                break e;
            case 1:
                t = fy(null, t, i, e, n);
                break e;
            case 11:
                t = hy(null, t, i, e, n);
                break e;
            case 14:
                t = dy(null, t, i, fi(i.type, e), n);
                break e
            }
            throw Error(Se(306, i, ""))
        }
        return t;
    case 0:
        return i = t.type,
        r = t.pendingProps,
        r = t.elementType === i ? r : fi(i, r),
        A1(e, t, i, r, n);
    case 1:
        return i = t.type,
        r = t.pendingProps,
        r = t.elementType === i ? r : fi(i, r),
        fy(e, t, i, r, n);
    case 3:
        e: {
            if (Y9(t),
            e === null)
                throw Error(Se(387));
            i = t.pendingProps,
            s = t.memoizedState,
            r = s.element,
            v9(e, t),
            Ch(t, i, null, n);
            var o = t.memoizedState;
            if (i = o.element,
            s.isDehydrated)
                if (s = {
                    element: i,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                t.updateQueue.baseState = s,
                t.memoizedState = s,
                t.flags & 256) {
                    r = la(Error(Se(423)), t),
                    t = py(e, t, i, n, r);
                    break e
                } else if (i !== r) {
                    r = la(Error(Se(424)), t),
                    t = py(e, t, i, n, r);
                    break e
                } else
                    for (Fn = Fr(t.stateNode.containerInfo.firstChild),
                    Bn = t,
                    vt = !0,
                    vi = null,
                    n = w9(t, null, i, n),
                    t.child = n; n; )
                        n.flags = n.flags & -3 | 4096,
                        n = n.sibling;
            else {
                if (sa(),
                i === r) {
                    t = hr(e, t, n);
                    break e
                }
                fn(e, t, i, n)
            }
            t = t.child
        }
        return t;
    case 5:
        return S9(t),
        e === null && b1(t),
        i = t.type,
        r = t.pendingProps,
        s = e !== null ? e.memoizedProps : null,
        o = r.children,
        g1(i, r) ? o = null : s !== null && g1(i, s) && (t.flags |= 32),
        X9(e, t),
        fn(e, t, o, n),
        t.child;
    case 6:
        return e === null && b1(t),
        null;
    case 13:
        return $9(e, t, n);
    case 4:
        return Im(t, t.stateNode.containerInfo),
        i = t.pendingProps,
        e === null ? t.child = oa(t, null, i, n) : fn(e, t, i, n),
        t.child;
    case 11:
        return i = t.type,
        r = t.pendingProps,
        r = t.elementType === i ? r : fi(i, r),
        hy(e, t, i, r, n);
    case 7:
        return fn(e, t, t.pendingProps, n),
        t.child;
    case 8:
        return fn(e, t, t.pendingProps.children, n),
        t.child;
    case 12:
        return fn(e, t, t.pendingProps.children, n),
        t.child;
    case 10:
        e: {
            if (i = t.type._context,
            r = t.pendingProps,
            s = t.memoizedProps,
            o = r.value,
            lt(wh, i._currentValue),
            i._currentValue = o,
            s !== null)
                if (Si(s.value, o)) {
                    if (s.children === r.children && !Mn.current) {
                        t = hr(e, t, n);
                        break e
                    }
                } else
                    for (s = t.child,
                    s !== null && (s.return = t); s !== null; ) {
                        var a = s.dependencies;
                        if (a !== null) {
                            o = s.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === i) {
                                    if (s.tag === 1) {
                                        l = sr(-1, n & -n),
                                        l.tag = 2;
                                        var c = s.updateQueue;
                                        if (c !== null) {
                                            c = c.shared;
                                            var u = c.pending;
                                            u === null ? l.next = l : (l.next = u.next,
                                            u.next = l),
                                            c.pending = l
                                        }
                                    }
                                    s.lanes |= n,
                                    l = s.alternate,
                                    l !== null && (l.lanes |= n),
                                    w1(s.return, n, t),
                                    a.lanes |= n;
                                    break
                                }
                                l = l.next
                            }
                        } else if (s.tag === 10)
                            o = s.type === t.type ? null : s.child;
                        else if (s.tag === 18) {
                            if (o = s.return,
                            o === null)
                                throw Error(Se(341));
                            o.lanes |= n,
                            a = o.alternate,
                            a !== null && (a.lanes |= n),
                            w1(o, n, t),
                            o = s.sibling
                        } else
                            o = s.child;
                        if (o !== null)
                            o.return = s;
                        else
                            for (o = s; o !== null; ) {
                                if (o === t) {
                                    o = null;
                                    break
                                }
                                if (s = o.sibling,
                                s !== null) {
                                    s.return = o.return,
                                    o = s;
                                    break
                                }
                                o = o.return
                            }
                        s = o
                    }
            fn(e, t, r.children, n),
            t = t.child
        }
        return t;
    case 9:
        return r = t.type,
        i = t.pendingProps.children,
        Qo(t, n),
        r = ri(r),
        i = i(r),
        t.flags |= 1,
        fn(e, t, i, n),
        t.child;
    case 14:
        return i = t.type,
        r = fi(i, t.pendingProps),
        r = fi(i.type, r),
        dy(e, t, i, r, n);
    case 15:
        return U9(e, t, t.type, t.pendingProps, n);
    case 17:
        return i = t.type,
        r = t.pendingProps,
        r = t.elementType === i ? r : fi(i, r),
        Gu(e, t),
        t.tag = 1,
        En(i) ? (e = !0,
        yh(t)) : e = !1,
        Qo(t, n),
        x9(t, i, r),
        C1(t, i, r, n),
        M1(null, t, i, !0, e, n);
    case 19:
        return K9(e, t, n);
    case 22:
        return G9(e, t, n)
    }
    throw Error(Se(156, t.tag))
}
;
function hw(e, t) {
    return F8(e, t)
}
function JE(e, t, n, i) {
    this.tag = e,
    this.key = n,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = t,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = i,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function ei(e, t, n, i) {
    return new JE(e,t,n,i)
}
function Jm(e) {
    return e = e.prototype,
    !(!e || !e.isReactComponent)
}
function eP(e) {
    if (typeof e == "function")
        return Jm(e) ? 1 : 0;
    if (e != null) {
        if (e = e.$$typeof,
        e === ym)
            return 11;
        if (e === xm)
            return 14
    }
    return 2
}
function Vr(e, t) {
    var n = e.alternate;
    return n === null ? (n = ei(e.tag, t, e.key, e.mode),
    n.elementType = e.elementType,
    n.type = e.type,
    n.stateNode = e.stateNode,
    n.alternate = e,
    e.alternate = n) : (n.pendingProps = t,
    n.type = e.type,
    n.flags = 0,
    n.subtreeFlags = 0,
    n.deletions = null),
    n.flags = e.flags & 14680064,
    n.childLanes = e.childLanes,
    n.lanes = e.lanes,
    n.child = e.child,
    n.memoizedProps = e.memoizedProps,
    n.memoizedState = e.memoizedState,
    n.updateQueue = e.updateQueue,
    t = e.dependencies,
    n.dependencies = t === null ? null : {
        lanes: t.lanes,
        firstContext: t.firstContext
    },
    n.sibling = e.sibling,
    n.index = e.index,
    n.ref = e.ref,
    n
}
function $u(e, t, n, i, r, s) {
    var o = 2;
    if (i = e,
    typeof e == "function")
        Jm(e) && (o = 1);
    else if (typeof e == "string")
        o = 5;
    else
        e: switch (e) {
        case Mo:
            return Vs(n.children, r, s, t);
        case vm:
            o = 8,
            r |= 8;
            break;
        case Y0:
            return e = ei(12, n, t, r | 2),
            e.elementType = Y0,
            e.lanes = s,
            e;
        case $0:
            return e = ei(13, n, t, r),
            e.elementType = $0,
            e.lanes = s,
            e;
        case K0:
            return e = ei(19, n, t, r),
            e.elementType = K0,
            e.lanes = s,
            e;
        case b8:
            return kd(n, r, s, t);
        default:
            if (typeof e == "object" && e !== null)
                switch (e.$$typeof) {
                case y8:
                    o = 10;
                    break e;
                case x8:
                    o = 9;
                    break e;
                case ym:
                    o = 11;
                    break e;
                case xm:
                    o = 14;
                    break e;
                case wr:
                    o = 16,
                    i = null;
                    break e
                }
            throw Error(Se(130, e == null ? e : typeof e, ""))
        }
    return t = ei(o, n, t, r),
    t.elementType = e,
    t.type = i,
    t.lanes = s,
    t
}
function Vs(e, t, n, i) {
    return e = ei(7, e, i, t),
    e.lanes = n,
    e
}
function kd(e, t, n, i) {
    return e = ei(22, e, i, t),
    e.elementType = b8,
    e.lanes = n,
    e.stateNode = {
        isHidden: !1
    },
    e
}
function qf(e, t, n) {
    return e = ei(6, e, null, t),
    e.lanes = n,
    e
}
function Zf(e, t, n) {
    return t = ei(4, e.children !== null ? e.children : [], e.key, t),
    t.lanes = n,
    t.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        implementation: e.implementation
    },
    t
}
function tP(e, t, n, i, r) {
    this.tag = t,
    this.containerInfo = e,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = Lf(0),
    this.expirationTimes = Lf(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = Lf(0),
    this.identifierPrefix = i,
    this.onRecoverableError = r,
    this.mutableSourceEagerHydrationData = null
}
function e2(e, t, n, i, r, s, o, a, l) {
    return e = new tP(e,t,n,a,l),
    t === 1 ? (t = 1,
    s === !0 && (t |= 8)) : t = 0,
    s = ei(3, null, null, t),
    e.current = s,
    s.stateNode = e,
    s.memoizedState = {
        element: i,
        isDehydrated: n,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    Fm(s),
    e
}
function nP(e, t, n) {
    var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: Ao,
        key: i == null ? null : "" + i,
        children: e,
        containerInfo: t,
        implementation: n
    }
}
function dw(e) {
    if (!e)
        return $r;
    e = e._reactInternals;
    e: {
        if (to(e) !== e || e.tag !== 1)
            throw Error(Se(170));
        var t = e;
        do {
            switch (t.tag) {
            case 3:
                t = t.stateNode.context;
                break e;
            case 1:
                if (En(t.type)) {
                    t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            t = t.return
        } while (t !== null);
        throw Error(Se(171))
    }
    if (e.tag === 1) {
        var n = e.type;
        if (En(n))
            return h9(e, n, t)
    }
    return t
}
function fw(e, t, n, i, r, s, o, a, l) {
    return e = e2(n, i, !0, e, r, s, o, a, l),
    e.context = dw(null),
    n = e.current,
    i = mn(),
    r = zr(n),
    s = sr(i, r),
    s.callback = t ?? null,
    Ir(n, s, r),
    e.current.lanes = r,
    hc(e, r, i),
    Pn(e, i),
    e
}
function Ad(e, t, n, i) {
    var r = t.current
      , s = mn()
      , o = zr(r);
    return n = dw(n),
    t.context === null ? t.context = n : t.pendingContext = n,
    t = sr(s, o),
    t.payload = {
        element: e
    },
    i = i === void 0 ? null : i,
    i !== null && (t.callback = i),
    e = Ir(r, t, o),
    e !== null && (bi(e, r, o, s),
    Wu(e, r, o)),
    o
}
function Oh(e) {
    if (e = e.current,
    !e.child)
        return null;
    switch (e.child.tag) {
    case 5:
        return e.child.stateNode;
    default:
        return e.child.stateNode
    }
}
function ky(e, t) {
    if (e = e.memoizedState,
    e !== null && e.dehydrated !== null) {
        var n = e.retryLane;
        e.retryLane = n !== 0 && n < t ? n : t
    }
}
function t2(e, t) {
    ky(e, t),
    (e = e.alternate) && ky(e, t)
}
function iP() {
    return null
}
var pw = typeof reportError == "function" ? reportError : function(e) {
    console.error(e)
}
;
function n2(e) {
    this._internalRoot = e
}
Md.prototype.render = n2.prototype.render = function(e) {
    var t = this._internalRoot;
    if (t === null)
        throw Error(Se(409));
    Ad(e, t, null, null)
}
;
Md.prototype.unmount = n2.prototype.unmount = function() {
    var e = this._internalRoot;
    if (e !== null) {
        this._internalRoot = null;
        var t = e.containerInfo;
        Qs(function() {
            Ad(null, e, null, null)
        }),
        t[cr] = null
    }
}
;
function Md(e) {
    this._internalRoot = e
}
Md.prototype.unstable_scheduleHydration = function(e) {
    if (e) {
        var t = U8();
        e = {
            blockedOn: null,
            target: e,
            priority: t
        };
        for (var n = 0; n < kr.length && t !== 0 && t < kr[n].priority; n++)
            ;
        kr.splice(n, 0, e),
        n === 0 && X8(e)
    }
}
;
function i2(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11)
}
function Ed(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
}
function Ay() {}
function rP(e, t, n, i, r) {
    if (r) {
        if (typeof i == "function") {
            var s = i;
            i = function() {
                var c = Oh(o);
                s.call(c)
            }
        }
        var o = fw(t, i, e, 0, null, !1, !1, "", Ay);
        return e._reactRootContainer = o,
        e[cr] = o.current,
        Ll(e.nodeType === 8 ? e.parentNode : e),
        Qs(),
        o
    }
    for (; r = e.lastChild; )
        e.removeChild(r);
    if (typeof i == "function") {
        var a = i;
        i = function() {
            var c = Oh(l);
            a.call(c)
        }
    }
    var l = e2(e, 0, !1, null, null, !1, !1, "", Ay);
    return e._reactRootContainer = l,
    e[cr] = l.current,
    Ll(e.nodeType === 8 ? e.parentNode : e),
    Qs(function() {
        Ad(t, l, n, i)
    }),
    l
}
function Pd(e, t, n, i, r) {
    var s = n._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof r == "function") {
            var a = r;
            r = function() {
                var l = Oh(o);
                a.call(l)
            }
        }
        Ad(t, o, e, r)
    } else
        o = rP(n, t, e, r, i);
    return Oh(o)
}
W8 = function(e) {
    switch (e.tag) {
    case 3:
        var t = e.stateNode;
        if (t.current.memoizedState.isDehydrated) {
            var n = $a(t.pendingLanes);
            n !== 0 && (Sm(t, n | 1),
            Pn(t, Lt()),
            !($e & 6) && (ca = Lt() + 500,
            ns()))
        }
        break;
    case 13:
        Qs(function() {
            var i = ur(e, 1);
            if (i !== null) {
                var r = mn();
                bi(i, e, 1, r)
            }
        }),
        t2(e, 1)
    }
}
;
Cm = function(e) {
    if (e.tag === 13) {
        var t = ur(e, 134217728);
        if (t !== null) {
            var n = mn();
            bi(t, e, 134217728, n)
        }
        t2(e, 134217728)
    }
}
;
H8 = function(e) {
    if (e.tag === 13) {
        var t = zr(e)
          , n = ur(e, t);
        if (n !== null) {
            var i = mn();
            bi(n, e, t, i)
        }
        t2(e, t)
    }
}
;
U8 = function() {
    return Je
}
;
G8 = function(e, t) {
    var n = Je;
    try {
        return Je = e,
        t()
    } finally {
        Je = n
    }
}
;
s1 = function(e, t, n) {
    switch (t) {
    case "input":
        if (Z0(e, n),
        t = n.name,
        n.type === "radio" && t != null) {
            for (n = e; n.parentNode; )
                n = n.parentNode;
            for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'),
            t = 0; t < n.length; t++) {
                var i = n[t];
                if (i !== e && i.form === e.form) {
                    var r = yd(i);
                    if (!r)
                        throw Error(Se(90));
                    S8(i),
                    Z0(i, r)
                }
            }
        }
        break;
    case "textarea":
        k8(e, n);
        break;
    case "select":
        t = n.value,
        t != null && Xo(e, !!n.multiple, t, !1)
    }
}
;
O8 = Qm;
L8 = Qs;
var sP = {
    usingClientEntryPoint: !1,
    Events: [fc, jo, yd, T8, j8, Qm]
}
  , Na = {
    findFiberByHostInstance: js,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
}
  , oP = {
    bundleType: Na.bundleType,
    version: Na.version,
    rendererPackageName: Na.rendererPackageName,
    rendererConfig: Na.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: fr.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(e) {
        return e = D8(e),
        e === null ? null : e.stateNode
    },
    findFiberByHostInstance: Na.findFiberByHostInstance || iP,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var eu = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!eu.isDisabled && eu.supportsFiber)
        try {
            pd = eu.inject(oP),
            Fi = eu
        } catch {}
}
Un.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sP;
Un.createPortal = function(e, t) {
    var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!i2(t))
        throw Error(Se(200));
    return nP(e, t, null, n)
}
;
Un.createRoot = function(e, t) {
    if (!i2(e))
        throw Error(Se(299));
    var n = !1
      , i = ""
      , r = pw;
    return t != null && (t.unstable_strictMode === !0 && (n = !0),
    t.identifierPrefix !== void 0 && (i = t.identifierPrefix),
    t.onRecoverableError !== void 0 && (r = t.onRecoverableError)),
    t = e2(e, 1, !1, null, null, n, !1, i, r),
    e[cr] = t.current,
    Ll(e.nodeType === 8 ? e.parentNode : e),
    new n2(t)
}
;
Un.findDOMNode = function(e) {
    if (e == null)
        return null;
    if (e.nodeType === 1)
        return e;
    var t = e._reactInternals;
    if (t === void 0)
        throw typeof e.render == "function" ? Error(Se(188)) : (e = Object.keys(e).join(","),
        Error(Se(268, e)));
    return e = D8(t),
    e = e === null ? null : e.stateNode,
    e
}
;
Un.flushSync = function(e) {
    return Qs(e)
}
;
Un.hydrate = function(e, t, n) {
    if (!Ed(t))
        throw Error(Se(200));
    return Pd(null, e, t, !0, n)
}
;
Un.hydrateRoot = function(e, t, n) {
    if (!i2(e))
        throw Error(Se(405));
    var i = n != null && n.hydratedSources || null
      , r = !1
      , s = ""
      , o = pw;
    if (n != null && (n.unstable_strictMode === !0 && (r = !0),
    n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
    n.onRecoverableError !== void 0 && (o = n.onRecoverableError)),
    t = fw(t, null, e, 1, n ?? null, r, !1, s, o),
    e[cr] = t.current,
    Ll(e),
    i)
        for (e = 0; e < i.length; e++)
            n = i[e],
            r = n._getVersion,
            r = r(n._source),
            t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, r] : t.mutableSourceEagerHydrationData.push(n, r);
    return new Md(t)
}
;
Un.render = function(e, t, n) {
    if (!Ed(t))
        throw Error(Se(200));
    return Pd(null, e, t, !1, n)
}
;
Un.unmountComponentAtNode = function(e) {
    if (!Ed(e))
        throw Error(Se(40));
    return e._reactRootContainer ? (Qs(function() {
        Pd(null, null, e, !1, function() {
            e._reactRootContainer = null,
            e[cr] = null
        })
    }),
    !0) : !1
}
;
Un.unstable_batchedUpdates = Qm;
Un.unstable_renderSubtreeIntoContainer = function(e, t, n, i) {
    if (!Ed(n))
        throw Error(Se(200));
    if (e == null || e._reactInternals === void 0)
        throw Error(Se(38));
    return Pd(e, t, n, !1, i)
}
;
Un.version = "18.2.0-next-9e3b772b8-20220608";
function gw() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(gw)
        } catch (e) {
            console.error(e)
        }
}
gw(),
f8.exports = Un;
var Td = f8.exports;
const mw = Jr(Td)
  , aP = t8({
    __proto__: null,
    default: mw
}, [Td]);
var My = Td;
G0.createRoot = My.createRoot,
G0.hydrateRoot = My.hydrateRoot;
/**
 * @remix-run/router v1.13.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Vl() {
    return Vl = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Vl.apply(this, arguments)
}
var Pr;
(function(e) {
    e.Pop = "POP",
    e.Push = "PUSH",
    e.Replace = "REPLACE"
}
)(Pr || (Pr = {}));
const Ey = "popstate";
function lP(e) {
    e === void 0 && (e = {});
    function t(i, r) {
        let {pathname: s, search: o, hash: a} = i.location;
        return I1("", {
            pathname: s,
            search: o,
            hash: a
        }, r.state && r.state.usr || null, r.state && r.state.key || "default")
    }
    function n(i, r) {
        return typeof r == "string" ? r : Lh(r)
    }
    return uP(t, n, null, e)
}
function Ft(e, t) {
    if (e === !1 || e === null || typeof e > "u")
        throw new Error(t)
}
function r2(e, t) {
    if (!e) {
        typeof console < "u" && console.warn(t);
        try {
            throw new Error(t)
        } catch {}
    }
}
function cP() {
    return Math.random().toString(36).substr(2, 8)
}
function Py(e, t) {
    return {
        usr: e.state,
        key: e.key,
        idx: t
    }
}
function I1(e, t, n, i) {
    return n === void 0 && (n = null),
    Vl({
        pathname: typeof e == "string" ? e : e.pathname,
        search: "",
        hash: ""
    }, typeof t == "string" ? Sa(t) : t, {
        state: n,
        key: t && t.key || i || cP()
    })
}
function Lh(e) {
    let {pathname: t="/", search: n="", hash: i=""} = e;
    return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n),
    i && i !== "#" && (t += i.charAt(0) === "#" ? i : "#" + i),
    t
}
function Sa(e) {
    let t = {};
    if (e) {
        let n = e.indexOf("#");
        n >= 0 && (t.hash = e.substr(n),
        e = e.substr(0, n));
        let i = e.indexOf("?");
        i >= 0 && (t.search = e.substr(i),
        e = e.substr(0, i)),
        e && (t.pathname = e)
    }
    return t
}
function uP(e, t, n, i) {
    i === void 0 && (i = {});
    let {window: r=document.defaultView, v5Compat: s=!1} = i
      , o = r.history
      , a = Pr.Pop
      , l = null
      , c = u();
    c == null && (c = 0,
    o.replaceState(Vl({}, o.state, {
        idx: c
    }), ""));
    function u() {
        return (o.state || {
            idx: null
        }).idx
    }
    function h() {
        a = Pr.Pop;
        let S = u()
          , v = S == null ? null : S - c;
        c = S,
        l && l({
            action: a,
            location: x.location,
            delta: v
        })
    }
    function d(S, v) {
        a = Pr.Push;
        let p = I1(x.location, S, v);
        n && n(p, S),
        c = u() + 1;
        let g = Py(p, c)
          , C = x.createHref(p);
        try {
            o.pushState(g, "", C)
        } catch (E) {
            if (E instanceof DOMException && E.name === "DataCloneError")
                throw E;
            r.location.assign(C)
        }
        s && l && l({
            action: a,
            location: x.location,
            delta: 1
        })
    }
    function m(S, v) {
        a = Pr.Replace;
        let p = I1(x.location, S, v);
        n && n(p, S),
        c = u();
        let g = Py(p, c)
          , C = x.createHref(p);
        o.replaceState(g, "", C),
        s && l && l({
            action: a,
            location: x.location,
            delta: 0
        })
    }
    function f(S) {
        let v = r.location.origin !== "null" ? r.location.origin : r.location.href
          , p = typeof S == "string" ? S : Lh(S);
        return Ft(v, "No window.location.(origin|href) available to create URL for href: " + p),
        new URL(p,v)
    }
    let x = {
        get action() {
            return a
        },
        get location() {
            return e(r, o)
        },
        listen(S) {
            if (l)
                throw new Error("A history only accepts one active listener");
            return r.addEventListener(Ey, h),
            l = S,
            ()=>{
                r.removeEventListener(Ey, h),
                l = null
            }
        },
        createHref(S) {
            return t(r, S)
        },
        createURL: f,
        encodeLocation(S) {
            let v = f(S);
            return {
                pathname: v.pathname,
                search: v.search,
                hash: v.hash
            }
        },
        push: d,
        replace: m,
        go(S) {
            return o.go(S)
        }
    };
    return x
}
var Ty;
(function(e) {
    e.data = "data",
    e.deferred = "deferred",
    e.redirect = "redirect",
    e.error = "error"
}
)(Ty || (Ty = {}));
function hP(e, t, n) {
    n === void 0 && (n = "/");
    let i = typeof t == "string" ? Sa(t) : t
      , r = s2(i.pathname || "/", n);
    if (r == null)
        return null;
    let s = vw(e);
    dP(s);
    let o = null;
    for (let a = 0; o == null && a < s.length; ++a)
        o = wP(s[a], kP(r));
    return o
}
function vw(e, t, n, i) {
    t === void 0 && (t = []),
    n === void 0 && (n = []),
    i === void 0 && (i = "");
    let r = (s,o,a)=>{
        let l = {
            relativePath: a === void 0 ? s.path || "" : a,
            caseSensitive: s.caseSensitive === !0,
            childrenIndex: o,
            route: s
        };
        l.relativePath.startsWith("/") && (Ft(l.relativePath.startsWith(i), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + i + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."),
        l.relativePath = l.relativePath.slice(i.length));
        let c = Wr([i, l.relativePath])
          , u = n.concat(l);
        s.children && s.children.length > 0 && (Ft(s.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + c + '".')),
        vw(s.children, t, u, c)),
        !(s.path == null && !s.index) && t.push({
            path: c,
            score: xP(c, s.index),
            routesMeta: u
        })
    }
    ;
    return e.forEach((s,o)=>{
        var a;
        if (s.path === "" || !((a = s.path) != null && a.includes("?")))
            r(s, o);
        else
            for (let l of yw(s.path))
                r(s, o, l)
    }
    ),
    t
}
function yw(e) {
    let t = e.split("/");
    if (t.length === 0)
        return [];
    let[n,...i] = t
      , r = n.endsWith("?")
      , s = n.replace(/\?$/, "");
    if (i.length === 0)
        return r ? [s, ""] : [s];
    let o = yw(i.join("/"))
      , a = [];
    return a.push(...o.map(l=>l === "" ? s : [s, l].join("/"))),
    r && a.push(...o),
    a.map(l=>e.startsWith("/") && l === "" ? "/" : l)
}
function dP(e) {
    e.sort((t,n)=>t.score !== n.score ? n.score - t.score : bP(t.routesMeta.map(i=>i.childrenIndex), n.routesMeta.map(i=>i.childrenIndex)))
}
const fP = /^:\w+$/
  , pP = 3
  , gP = 2
  , mP = 1
  , vP = 10
  , yP = -2
  , jy = e=>e === "*";
function xP(e, t) {
    let n = e.split("/")
      , i = n.length;
    return n.some(jy) && (i += yP),
    t && (i += gP),
    n.filter(r=>!jy(r)).reduce((r,s)=>r + (fP.test(s) ? pP : s === "" ? mP : vP), i)
}
function bP(e, t) {
    return e.length === t.length && e.slice(0, -1).every((i,r)=>i === t[r]) ? e[e.length - 1] - t[t.length - 1] : 0
}
function wP(e, t) {
    let {routesMeta: n} = e
      , i = {}
      , r = "/"
      , s = [];
    for (let o = 0; o < n.length; ++o) {
        let a = n[o]
          , l = o === n.length - 1
          , c = r === "/" ? t : t.slice(r.length) || "/"
          , u = SP({
            path: a.relativePath,
            caseSensitive: a.caseSensitive,
            end: l
        }, c);
        if (!u)
            return null;
        Object.assign(i, u.params);
        let h = a.route;
        s.push({
            params: i,
            pathname: Wr([r, u.pathname]),
            pathnameBase: TP(Wr([r, u.pathnameBase])),
            route: h
        }),
        u.pathnameBase !== "/" && (r = Wr([r, u.pathnameBase]))
    }
    return s
}
function SP(e, t) {
    typeof e == "string" && (e = {
        path: e,
        caseSensitive: !1,
        end: !0
    });
    let[n,i] = CP(e.path, e.caseSensitive, e.end)
      , r = t.match(n);
    if (!r)
        return null;
    let s = r[0]
      , o = s.replace(/(.)\/+$/, "$1")
      , a = r.slice(1);
    return {
        params: i.reduce((c,u,h)=>{
            let {paramName: d, isOptional: m} = u;
            if (d === "*") {
                let x = a[h] || "";
                o = s.slice(0, s.length - x.length).replace(/(.)\/+$/, "$1")
            }
            const f = a[h];
            return m && !f ? c[d] = void 0 : c[d] = AP(f || "", d),
            c
        }
        , {}),
        pathname: s,
        pathnameBase: o,
        pattern: e
    }
}
function CP(e, t, n) {
    t === void 0 && (t = !1),
    n === void 0 && (n = !0),
    r2(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".'));
    let i = []
      , r = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:(\w+)(\?)?/g, (o,a,l)=>(i.push({
        paramName: a,
        isOptional: l != null
    }),
    l ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return e.endsWith("*") ? (i.push({
        paramName: "*"
    }),
    r += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? r += "\\/*$" : e !== "" && e !== "/" && (r += "(?:(?=\\/|$))"),
    [new RegExp(r,t ? void 0 : "i"), i]
}
function kP(e) {
    try {
        return decodeURI(e)
    } catch (t) {
        return r2(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")),
        e
    }
}
function AP(e, t) {
    try {
        return decodeURIComponent(e)
    } catch (n) {
        return r2(!1, 'The value for the URL param "' + t + '" will not be decoded because' + (' the string "' + e + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + n + ").")),
        e
    }
}
function s2(e, t) {
    if (t === "/")
        return e;
    if (!e.toLowerCase().startsWith(t.toLowerCase()))
        return null;
    let n = t.endsWith("/") ? t.length - 1 : t.length
      , i = e.charAt(n);
    return i && i !== "/" ? null : e.slice(n) || "/"
}
function MP(e, t) {
    t === void 0 && (t = "/");
    let {pathname: n, search: i="", hash: r=""} = typeof e == "string" ? Sa(e) : e;
    return {
        pathname: n ? n.startsWith("/") ? n : EP(n, t) : t,
        search: jP(i),
        hash: OP(r)
    }
}
function EP(e, t) {
    let n = t.replace(/\/+$/, "").split("/");
    return e.split("/").forEach(r=>{
        r === ".." ? n.length > 1 && n.pop() : r !== "." && n.push(r)
    }
    ),
    n.length > 1 ? n.join("/") : "/"
}
function Jf(e, t, n, i) {
    return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(i) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}
function PP(e) {
    return e.filter((t,n)=>n === 0 || t.route.path && t.route.path.length > 0)
}
function xw(e) {
    return PP(e).map((t,n)=>n === e.length - 1 ? t.pathname : t.pathnameBase)
}
function bw(e, t, n, i) {
    i === void 0 && (i = !1);
    let r;
    typeof e == "string" ? r = Sa(e) : (r = Vl({}, e),
    Ft(!r.pathname || !r.pathname.includes("?"), Jf("?", "pathname", "search", r)),
    Ft(!r.pathname || !r.pathname.includes("#"), Jf("#", "pathname", "hash", r)),
    Ft(!r.search || !r.search.includes("#"), Jf("#", "search", "hash", r)));
    let s = e === "" || r.pathname === "", o = s ? "/" : r.pathname, a;
    if (o == null)
        a = n;
    else if (i) {
        let h = t[t.length - 1].replace(/^\//, "").split("/");
        if (o.startsWith("..")) {
            let d = o.split("/");
            for (; d[0] === ".."; )
                d.shift(),
                h.pop();
            r.pathname = d.join("/")
        }
        a = "/" + h.join("/")
    } else {
        let h = t.length - 1;
        if (o.startsWith("..")) {
            let d = o.split("/");
            for (; d[0] === ".."; )
                d.shift(),
                h -= 1;
            r.pathname = d.join("/")
        }
        a = h >= 0 ? t[h] : "/"
    }
    let l = MP(r, a)
      , c = o && o !== "/" && o.endsWith("/")
      , u = (s || o === ".") && n.endsWith("/");
    return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"),
    l
}
const Wr = e=>e.join("/").replace(/\/\/+/g, "/")
  , TP = e=>e.replace(/\/+$/, "").replace(/^\/*/, "/")
  , jP = e=>!e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e
  , OP = e=>!e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;
function LP(e) {
    return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data"in e
}
const ww = ["post", "put", "patch", "delete"];
new Set(ww);
const RP = ["get", ...ww];
new Set(RP);
/**
 * React Router v6.20.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Rh() {
    return Rh = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Rh.apply(this, arguments)
}
const o2 = M.createContext(null)
  , _P = M.createContext(null)
  , Ca = M.createContext(null)
  , jd = M.createContext(null)
  , is = M.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
})
  , Sw = M.createContext(null);
function DP(e, t) {
    let {relative: n} = t === void 0 ? {} : t;
    gc() || Ft(!1);
    let {basename: i, navigator: r} = M.useContext(Ca)
      , {hash: s, pathname: o, search: a} = kw(e, {
        relative: n
    })
      , l = o;
    return i !== "/" && (l = o === "/" ? i : Wr([i, o])),
    r.createHref({
        pathname: l,
        search: a,
        hash: s
    })
}
function gc() {
    return M.useContext(jd) != null
}
function rs() {
    return gc() || Ft(!1),
    M.useContext(jd).location
}
function Cw(e) {
    M.useContext(Ca).static || M.useLayoutEffect(e)
}
function NP() {
    let {isDataRoute: e} = M.useContext(is);
    return e ? qP() : FP()
}
function FP() {
    gc() || Ft(!1);
    let e = M.useContext(o2)
      , {basename: t, navigator: n} = M.useContext(Ca)
      , {matches: i} = M.useContext(is)
      , {pathname: r} = rs()
      , s = JSON.stringify(xw(i))
      , o = M.useRef(!1);
    return Cw(()=>{
        o.current = !0
    }
    ),
    M.useCallback(function(l, c) {
        if (c === void 0 && (c = {}),
        !o.current)
            return;
        if (typeof l == "number") {
            n.go(l);
            return
        }
        let u = bw(l, JSON.parse(s), r, c.relative === "path");
        e == null && t !== "/" && (u.pathname = u.pathname === "/" ? t : Wr([t, u.pathname])),
        (c.replace ? n.replace : n.push)(u, c.state, c)
    }, [t, n, s, r, e])
}
const IP = M.createContext(null);
function BP(e) {
    let t = M.useContext(is).outlet;
    return t && M.createElement(IP.Provider, {
        value: e
    }, t)
}
function kw(e, t) {
    let {relative: n} = t === void 0 ? {} : t
      , {matches: i} = M.useContext(is)
      , {pathname: r} = rs()
      , s = JSON.stringify(xw(i));
    return M.useMemo(()=>bw(e, JSON.parse(s), r, n === "path"), [e, s, r, n])
}
function zP(e, t) {
    return VP(e, t)
}
function VP(e, t, n) {
    gc() || Ft(!1);
    let {navigator: i} = M.useContext(Ca)
      , {matches: r} = M.useContext(is)
      , s = r[r.length - 1]
      , o = s ? s.params : {};
    s && s.pathname;
    let a = s ? s.pathnameBase : "/";
    s && s.route;
    let l = rs(), c;
    if (t) {
        var u;
        let x = typeof t == "string" ? Sa(t) : t;
        a === "/" || (u = x.pathname) != null && u.startsWith(a) || Ft(!1),
        c = x
    } else
        c = l;
    let h = c.pathname || "/"
      , d = a === "/" ? h : h.slice(a.length) || "/"
      , m = hP(e, {
        pathname: d
    })
      , f = XP(m && m.map(x=>Object.assign({}, x, {
        params: Object.assign({}, o, x.params),
        pathname: Wr([a, i.encodeLocation ? i.encodeLocation(x.pathname).pathname : x.pathname]),
        pathnameBase: x.pathnameBase === "/" ? a : Wr([a, i.encodeLocation ? i.encodeLocation(x.pathnameBase).pathname : x.pathnameBase])
    })), r, n);
    return t && f ? M.createElement(jd.Provider, {
        value: {
            location: Rh({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
            }, c),
            navigationType: Pr.Pop
        }
    }, f) : f
}
function WP() {
    let e = QP()
      , t = LP(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e)
      , n = e instanceof Error ? e.stack : null
      , r = {
        padding: "0.5rem",
        backgroundColor: "rgba(200,200,200, 0.5)"
    }
      , s = null;
    return M.createElement(M.Fragment, null, M.createElement("h2", null, "Unexpected Application Error!"), M.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, t), n ? M.createElement("pre", {
        style: r
    }, n) : null, s)
}
const HP = M.createElement(WP, null);
class UP extends M.Component {
    constructor(t) {
        super(t),
        this.state = {
            location: t.location,
            revalidation: t.revalidation,
            error: t.error
        }
    }
    static getDerivedStateFromError(t) {
        return {
            error: t
        }
    }
    static getDerivedStateFromProps(t, n) {
        return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? {
            error: t.error,
            location: t.location,
            revalidation: t.revalidation
        } : {
            error: t.error || n.error,
            location: n.location,
            revalidation: t.revalidation || n.revalidation
        }
    }
    componentDidCatch(t, n) {
        console.error("React Router caught the following error during render", t, n)
    }
    render() {
        return this.state.error ? M.createElement(is.Provider, {
            value: this.props.routeContext
        }, M.createElement(Sw.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
function GP(e) {
    let {routeContext: t, match: n, children: i} = e
      , r = M.useContext(o2);
    return r && r.static && r.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = n.route.id),
    M.createElement(is.Provider, {
        value: t
    }, i)
}
function XP(e, t, n) {
    var i;
    if (t === void 0 && (t = []),
    n === void 0 && (n = null),
    e == null) {
        var r;
        if ((r = n) != null && r.errors)
            e = n.matches;
        else
            return null
    }
    let s = e
      , o = (i = n) == null ? void 0 : i.errors;
    if (o != null) {
        let a = s.findIndex(l=>l.route.id && (o == null ? void 0 : o[l.route.id]));
        a >= 0 || Ft(!1),
        s = s.slice(0, Math.min(s.length, a + 1))
    }
    return s.reduceRight((a,l,c)=>{
        let u = l.route.id ? o == null ? void 0 : o[l.route.id] : null
          , h = null;
        n && (h = l.route.errorElement || HP);
        let d = t.concat(s.slice(0, c + 1))
          , m = ()=>{
            let f;
            return u ? f = h : l.route.Component ? f = M.createElement(l.route.Component, null) : l.route.element ? f = l.route.element : f = a,
            M.createElement(GP, {
                match: l,
                routeContext: {
                    outlet: a,
                    matches: d,
                    isDataRoute: n != null
                },
                children: f
            })
        }
        ;
        return n && (l.route.ErrorBoundary || l.route.errorElement || c === 0) ? M.createElement(UP, {
            location: n.location,
            revalidation: n.revalidation,
            component: h,
            error: u,
            children: m(),
            routeContext: {
                outlet: null,
                matches: d,
                isDataRoute: !0
            }
        }) : m()
    }
    , null)
}
var Aw = function(e) {
    return e.UseBlocker = "useBlocker",
    e.UseRevalidator = "useRevalidator",
    e.UseNavigateStable = "useNavigate",
    e
}(Aw || {})
  , _h = function(e) {
    return e.UseBlocker = "useBlocker",
    e.UseLoaderData = "useLoaderData",
    e.UseActionData = "useActionData",
    e.UseRouteError = "useRouteError",
    e.UseNavigation = "useNavigation",
    e.UseRouteLoaderData = "useRouteLoaderData",
    e.UseMatches = "useMatches",
    e.UseRevalidator = "useRevalidator",
    e.UseNavigateStable = "useNavigate",
    e.UseRouteId = "useRouteId",
    e
}(_h || {});
function YP(e) {
    let t = M.useContext(o2);
    return t || Ft(!1),
    t
}
function $P(e) {
    let t = M.useContext(_P);
    return t || Ft(!1),
    t
}
function KP(e) {
    let t = M.useContext(is);
    return t || Ft(!1),
    t
}
function Mw(e) {
    let t = KP()
      , n = t.matches[t.matches.length - 1];
    return n.route.id || Ft(!1),
    n.route.id
}
function QP() {
    var e;
    let t = M.useContext(Sw)
      , n = $P(_h.UseRouteError)
      , i = Mw(_h.UseRouteError);
    return t || ((e = n.errors) == null ? void 0 : e[i])
}
function qP() {
    let {router: e} = YP(Aw.UseNavigateStable)
      , t = Mw(_h.UseNavigateStable)
      , n = M.useRef(!1);
    return Cw(()=>{
        n.current = !0
    }
    ),
    M.useCallback(function(r, s) {
        s === void 0 && (s = {}),
        n.current && (typeof r == "number" ? e.navigate(r) : e.navigate(r, Rh({
            fromRouteId: t
        }, s)))
    }, [e, t])
}
function ZP(e) {
    return BP(e.context)
}
function Pi(e) {
    Ft(!1)
}
function JP(e) {
    let {basename: t="/", children: n=null, location: i, navigationType: r=Pr.Pop, navigator: s, static: o=!1} = e;
    gc() && Ft(!1);
    let a = t.replace(/^\/*/, "/")
      , l = M.useMemo(()=>({
        basename: a,
        navigator: s,
        static: o
    }), [a, s, o]);
    typeof i == "string" && (i = Sa(i));
    let {pathname: c="/", search: u="", hash: h="", state: d=null, key: m="default"} = i
      , f = M.useMemo(()=>{
        let x = s2(c, a);
        return x == null ? null : {
            location: {
                pathname: x,
                search: u,
                hash: h,
                state: d,
                key: m
            },
            navigationType: r
        }
    }
    , [a, c, u, h, d, m, r]);
    return f == null ? null : M.createElement(Ca.Provider, {
        value: l
    }, M.createElement(jd.Provider, {
        children: n,
        value: f
    }))
}
function eT(e) {
    let {children: t, location: n} = e;
    return zP(B1(t), n)
}
new Promise(()=>{}
);
function B1(e, t) {
    t === void 0 && (t = []);
    let n = [];
    return M.Children.forEach(e, (i,r)=>{
        if (!M.isValidElement(i))
            return;
        let s = [...t, r];
        if (i.type === M.Fragment) {
            n.push.apply(n, B1(i.props.children, s));
            return
        }
        i.type !== Pi && Ft(!1),
        !i.props.index || !i.props.children || Ft(!1);
        let o = {
            id: i.props.id || s.join("-"),
            caseSensitive: i.props.caseSensitive,
            element: i.props.element,
            Component: i.props.Component,
            index: i.props.index,
            path: i.props.path,
            loader: i.props.loader,
            action: i.props.action,
            errorElement: i.props.errorElement,
            ErrorBoundary: i.props.ErrorBoundary,
            hasErrorBoundary: i.props.ErrorBoundary != null || i.props.errorElement != null,
            shouldRevalidate: i.props.shouldRevalidate,
            handle: i.props.handle,
            lazy: i.props.lazy
        };
        i.props.children && (o.children = B1(i.props.children, s)),
        n.push(o)
    }
    ),
    n
}
/**
 * React Router DOM v6.20.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function z1() {
    return z1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    z1.apply(this, arguments)
}
function tT(e, t) {
    if (e == null)
        return {};
    var n = {}, i = Object.keys(e), r, s;
    for (s = 0; s < i.length; s++)
        r = i[s],
        !(t.indexOf(r) >= 0) && (n[r] = e[r]);
    return n
}
function nT(e) {
    return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
}
function iT(e, t) {
    return e.button === 0 && (!t || t === "_self") && !nT(e)
}
const rT = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"]
  , sT = "startTransition"
  , Oy = uc[sT];
function oT(e) {
    let {basename: t, children: n, future: i, window: r} = e
      , s = M.useRef();
    s.current == null && (s.current = lP({
        window: r,
        v5Compat: !0
    }));
    let o = s.current
      , [a,l] = M.useState({
        action: o.action,
        location: o.location
    })
      , {v7_startTransition: c} = i || {}
      , u = M.useCallback(h=>{
        c && Oy ? Oy(()=>l(h)) : l(h)
    }
    , [l, c]);
    return M.useLayoutEffect(()=>o.listen(u), [o, u]),
    M.createElement(JP, {
        basename: t,
        children: n,
        location: a.location,
        navigationType: a.action,
        navigator: o
    })
}
const aT = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , lT = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , Vn = M.forwardRef(function(t, n) {
    let {onClick: i, relative: r, reloadDocument: s, replace: o, state: a, target: l, to: c, preventScrollReset: u, unstable_viewTransition: h} = t, d = tT(t, rT), {basename: m} = M.useContext(Ca), f, x = !1;
    if (typeof c == "string" && lT.test(c) && (f = c,
    aT))
        try {
            let g = new URL(window.location.href)
              , C = c.startsWith("//") ? new URL(g.protocol + c) : new URL(c)
              , E = s2(C.pathname, m);
            C.origin === g.origin && E != null ? c = E + C.search + C.hash : x = !0
        } catch {}
    let S = DP(c, {
        relative: r
    })
      , v = cT(c, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: u,
        relative: r,
        unstable_viewTransition: h
    });
    function p(g) {
        i && i(g),
        g.defaultPrevented || v(g)
    }
    return M.createElement("a", z1({}, d, {
        href: f || S,
        onClick: x || s ? i : p,
        ref: n,
        target: l
    }))
});
var Ly;
(function(e) {
    e.UseScrollRestoration = "useScrollRestoration",
    e.UseSubmit = "useSubmit",
    e.UseSubmitFetcher = "useSubmitFetcher",
    e.UseFetcher = "useFetcher",
    e.useViewTransitionState = "useViewTransitionState"
}
)(Ly || (Ly = {}));
var Ry;
(function(e) {
    e.UseFetcher = "useFetcher",
    e.UseFetchers = "useFetchers",
    e.UseScrollRestoration = "useScrollRestoration"
}
)(Ry || (Ry = {}));
function cT(e, t) {
    let {target: n, replace: i, state: r, preventScrollReset: s, relative: o, unstable_viewTransition: a} = t === void 0 ? {} : t
      , l = NP()
      , c = rs()
      , u = kw(e, {
        relative: o
    });
    return M.useCallback(h=>{
        if (iT(h, n)) {
            h.preventDefault();
            let d = i !== void 0 ? i : Lh(c) === Lh(u);
            l(e, {
                replace: d,
                state: r,
                preventScrollReset: s,
                relative: o,
                unstable_viewTransition: a
            })
        }
    }
    , [c, l, u, i, r, n, e, s, o, a])
}
const uT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAzCAYAAADVY1sUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAfOSURBVHgB7VhbbBxnFf7murP3XXt3bSdObCehDilxiqKkKqBCQBRC6QNCQiIIISQkHnigqnhA4iGOECAeUIuEoj7AQysuUiUSiaKERiq0btIqceLNxU7t+LK247t37b3Ozn04/2+p6uusXakP+1mr2VnP5Xz/+c75zgzQRhtttNFGG2208amDgE8IhfzLKd90vm03Sk95rrnfNo2MpTdqtUpt0Wi4IyMja+/+7vKtEvYIe05k5c4r33Dc2i8dS/+K79jw6Q6ubcFzXdhGE77v0daGoeu+Gg69pmipC5//zqvz2CX2jEhp+q/HmrWVi/DtLzuWibn8BCbvFbAwX+REohEFiqIimYnj8JP70ZmL0e8ORFFGIpN96djZP72MXWBPiKzcv/iS59Z/69l6qHB9FB/eyCPZm0XP0X6kc0mIskhB23AsC1sbZRQXNrG2Wseprz4JNaIBIhBJdl44/vzFYbSIXRNZGP3NecF3h51GBXNX/g01k0Pv6ZOQNA2eQzKyTfhMVqbBiXiuA9+hj2th6k4BciyBvsFuSLKMzMGjLw584fwf0QJ2ReTxzV+f90Vv2K1sYDs/guTnTiOcOwCHJOMLInyPETDRrGxB0UJwiVizug2fbus5LmQJWJ5ZQTjdgUxPClo0he7B5090HDp7HwEhokUs3f3L9zzfGXabZTRmbiL3xW8i0t0H12NXlYmEg+Z2mbY+QtEorwXagVgqwqqU+RJatofeJ/ZBNOowDQuWWUd1894raAEtEVkc+8c+W5/5ve8Y8B/fQMeJZyHTaroeRUeZEET6CBIimS4oIZVnxTJ02JUaDCKX6CIpcWI+nSMid6QHjVKZ75v19TONxWv7EBAtEWmW7/6MVrjfW5+A1PkERC1BsnG5lBjYVpRDvA70pSlMXnkb1SJlRxWhDQ7CpbTFUYG5scYzQ30AmVxih5ilo7w9dQ4BEZhI/vKLKUUVf+w2a3DqJWjdR+CQ9l2XkRB4MQuCvOMXxQLc5Uk89a3TgF7B6vQK1Y8NV9ex+aiAjr4egKTHzpMoc/DAz3NN/RkERGAiAhov0JL32OuziPQP8dVlhc1W0/dZGYvwPBs2I+oriB07CQsatGwGVO+obVQAVYUXisF0iDid43keBFmBHJIhSjKrsacREMGJiPguk4PXqEJJdvFOxAyQ0sCNj+igOHEPD299CDESR9NWuNSY+WnpBCIJjX/XixVqwy6dRtRF1uHomkxjAsuqu3/8jTfUIHEFJiJpkQHWs0VFogxQ8GwM4XKp0Y8C6oVxeGvTyMUdLD4sMLUQUReS4NNCy3BJSapbhRYP82wwKfEPWxzyF0lSKEMu6rFCLkhcQYkIpmked40q1GSKk7BNi8vCp/HDWJ6CtfAQnae+hPThQxB8C4uTy3BIfo634x1hUk6tMA8t00Gy9HmNsKxQoUGNp0haEtUR+U25aQQJLBCR54a6sol4WGADIKVmhxllobi4AjYgOpaA9NBJ+NSxLMNA9mA3RM8iKXnceYs3xzH79iiccBqOopGcvJ1r0D99FgplTSAi1e1q48y54WKA0CAHOVj3Dduj1ZUoULu0BjXHOpWHZDZJq2jRfje12XVofoNFBnZs16EeOE2LFQDSWRnygROwfZEbpyTtDBakMJKqyrMh0N/co8VxBESgjFx/UNmu1w3LJzNjLZf1MNdyYFI7nbh2G+uP1yHFk9SZSjR+eODNjPkLBRySXHL+TtAITHclw5TEnSIX2K5EMnX4vFXXBdx4fzKPgAhc7KViZZYtt6FTp/Kp69C8pG8zVzbRmY1zPxHjCRh1k8uJ0yVjNJdmIYSjPBMCMRSlj5GhOlHDGjfRkXfGsd1svo6ACCQtBsOy/kV+8VklnYW+tkIZSCOaSaNzsJ8c2sHS7XGU/Aj6P5ODSJqpbZZRn5xG5kgXYqEo/KbD60oiEhJJSVVDvC5Eahj1uoM7Y7Njr781+QECQkJAWHqzdvpE70/CqTiqC4uId3XQsEcdJ6RgbmwKIbdJ02wMly4/wPV3H6FWrGLg+EEk9pPnuLx0OAHWqQQiKtEIrIYj0GIpXP3PQyw+3vz++PzWAgKipTH+zxeeu/LMqf6znkUeUi0i3N2FRp0NhiZkCswjqbBRxDbtj+7A5MNkxCAp8s5xRCQci9F0HMfN26t461r+D3/778wv0AJaGhrzdyd+uLK8VSQbgxuKw9wqQ9PIIKkALCp+i7zFsV3eV9nKK6rCp2CB14VERBT+TCLTqCJRt7r3YB1Xr+ant0L4FVpEYGkxjE7Wmpro53u7oueiCU2kJ28azyvQaLqV2dhOmWIzGJ+/wLyOSJFnqFqUb2VF5sWu0FPkyAdLuPzm/Rmqu6+/+b+5lt+qtESEYWyqOEc2/97A/viZUEhOMcvzqC27lA0trFLNqBSwwpXFvvusxZLXMFkxidXqNv5+aRzvvL/wT9MVX7g6Or+OXWDXz+z9Ka3/pz8YGh4c6PhRNh3i9cFNU9kpaDaCsJbMssDMbqPUwHv5ddy4s7pGpX7h1tTqq9gD7NnroMPZ0JGvPX3g54cPJJ6VJXEoHgvRDCnAJuPc3NKxvNHEwlodc8uNEbKRS6aM1+bny2XsET6RN419fZke2XSOUlkf9EQvSrZpUjYWPN29TbHvWfBttNFGG2200UYbbbQRCP8HSknoSNjgvb4AAAAASUVORK5CYII="
  , hT = "/assets/bg-cards-user-ik8j1yp-.png"
  , dT = "/assets/user-photo-Cs7FdCBg.png"
  , fT = "data:image/svg+xml,%3csvg%20width='14'%20height='14'%20viewBox='0%200%2014%2014'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M4.98356%207L6.32785%208.3443L9.01644%205.6557M4.2005%202.09131C4.68264%202.05282%205.14036%201.86325%205.5085%201.54955C5.9245%201.19484%206.4533%201%207%201C7.5467%201%208.0755%201.19484%208.4915%201.54955C8.85964%201.86325%209.31736%202.05282%209.7995%202.09131C10.3444%202.13466%2010.8561%202.3708%2011.2426%202.75735C11.6292%203.1439%2011.8653%203.65556%2011.9087%204.2005C11.9472%204.68264%2012.1368%205.14036%2012.4504%205.5085C12.8052%205.9245%2013%206.4533%2013%207C13%207.5467%2012.8052%208.0755%2012.4504%208.4915C12.1368%208.85964%2011.9472%209.31736%2011.9087%209.7995C11.8653%2010.3444%2011.6292%2010.8561%2011.2426%2011.2426C10.8561%2011.6292%2010.3444%2011.8653%209.7995%2011.9087C9.31736%2011.9472%208.85964%2012.1368%208.4915%2012.4504C8.0755%2012.8052%207.5467%2013%207%2013C6.4533%2013%205.9245%2012.8052%205.5085%2012.4504C5.14036%2012.1368%204.68264%2011.9472%204.2005%2011.9087C3.65556%2011.8653%203.1439%2011.6292%202.75735%2011.2426C2.3708%2010.8561%202.13466%2010.3444%202.09131%209.7995C2.05282%209.31736%201.86325%208.85964%201.54955%208.4915C1.19484%208.0755%201%207.5467%201%207C1%206.4533%201.19484%205.9245%201.54955%205.5085C1.86325%205.14036%202.05282%204.68264%202.09131%204.2005C2.13466%203.65556%202.3708%203.1439%202.75735%202.75735C3.1439%202.3708%203.65556%202.13466%204.2005%202.09131Z'%20stroke='%2303A66D'%20stroke-width='1.2'%20strokeLinecap='round'%20strokeLinejoin='round'/%3e%3c/svg%3e"
  , pT = "data:image/svg+xml,%3csvg%20width='60'%20height='52'%20viewBox='0%200%2060%2052'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_78_43)'%3e%3cpath%20d='M10.0634%200C7.39517%200.00421999%204.83752%201.07364%202.9511%202.9738C1.06468%204.87397%200.00342723%207.44983%200%2010.1367V19.6919H5.69619V10.1367C5.69733%208.97082%206.15785%207.85306%206.97665%207.0288C7.79545%206.20455%208.90559%205.74117%2010.0634%205.7404H17.7149V0H10.0634Z'%20fill='url(%23paint0_linear_78_43)'/%3e%3cpath%20d='M11.1073%2046.2654H10.0634C8.90559%2046.2646%207.79545%2045.8012%206.97665%2044.977C6.15785%2044.1527%205.69733%2043.035%205.69619%2041.8691V32.5487H0V41.8691C0.00495006%2044.5549%201.06687%2047.1293%202.95313%2049.0282C4.83938%2050.9272%207.39617%2051.9958%2010.0634%2052H16.802V31.6788H18.6264L16.802%2029.108V28.9064H16.658L16.2894%2028.3873L13.9525%2025.0945L11.617%2028.3873L11.2484%2028.9064H11.1044V29.108L9.28006%2031.6788H11.1044L11.1073%2046.2654Z'%20fill='url(%23paint1_linear_78_43)'/%3e%3cpath%20d='M24.0157%2017.4663L21.6802%2020.7577L19.3433%2024.0506H21.1676V46.2655V52.0001H26.8638V46.2655V24.0506H28.6881L26.3512%2020.7577L24.0157%2017.4663Z'%20fill='url(%23paint2_linear_78_43)'/%3e%3cpath%20d='M42.4463%2052C41.3333%2052%2040.2102%2051.9725%2039.0223%2051.9435C37.8344%2051.9145%2036.6206%2051.884%2035.4226%2051.884C34.8308%2051.884%2034.2808%2051.8913%2033.761%2051.9058V35.4516H40.3182V45.2751L41.4701%2045.3113C42.2217%2045.3345%2042.9316%2045.3563%2043.6155%2045.3563C44.9546%2045.3563%2046.5111%2045.2823%2047.8877%2044.7285C49.6122%2044.03%2051.0736%2042.801%2052.0633%2041.2166C53.2255%2039.3492%2053.669%2037.1181%2053.3103%2034.9441C52.969%2032.9997%2052.131%2031.4642%2050.5947%2029.9823C49.1461%2028.5817%2047.3491%2027.7769%2045.2556%2027.5913C44.5356%2027.529%2043.0957%2027.4971%2040.8164%2027.4971C39.0223%2027.4971%2037.0165%2027.5174%2035.4053%2027.5319L33.6386%2027.5478L33.6947%2020.9317C35.6904%2020.9491%2036.8337%2020.9766%2037.6242%2020.9969C38.0878%2021.0085%2038.4233%2021.0158%2038.717%2021.0158C39.1773%2021.0153%2039.6371%2020.9915%2040.095%2020.9447C42.7948%2020.7011%2045.6602%2018.0346%2045.653%2013.5746C45.6443%208.82448%2042.3599%206.85398%2039.5507%206.61474H39.5133H28.5615H28.5111C28.2685%206.64393%2028.0466%206.76712%2027.8926%206.95821C27.7386%207.1493%2027.6645%207.39327%2027.6861%207.63841V13.4716H21.0972V0.00146484H37.9669C39.6659%200.00146484%2041.2988%200.027562%2042.622%200.343654C46.9244%201.36733%2050.1627%204.4572%2051.5061%208.82303C52.4939%2012.0362%2051.9885%2018.7698%2050.5903%2021.0332L50.0633%2021.8814L50.9618%2022.3164C54.7329%2024.1259%2057.4024%2026.9563%2058.8941%2030.7088C59.7726%2032.9456%2060.134%2035.3544%2059.951%2037.7527C59.7854%2039.9494%2059.1467%2042.0834%2058.0792%2044.0064C56.1051%2047.5776%2052.9892%2050.0962%2049.0713%2051.2895C47.0021%2051.9203%2044.4463%2052%2042.4478%2052H42.4463Z'%20fill='url(%23paint3_linear_78_43)'/%3e%3c/g%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_78_43'%20x1='8.85745'%20y1='0'%20x2='8.85745'%20y2='19.6919'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%232B7AFF'/%3e%3cstop%20offset='1'%20stop-color='%2302245E'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_78_43'%20x1='9.31318'%20y1='25.0945'%20x2='9.31318'%20y2='52'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%232B7AFF'/%3e%3cstop%20offset='1'%20stop-color='%2302245E'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint2_linear_78_43'%20x1='24.0157'%20y1='17.4663'%20x2='24.0157'%20y2='52.0001'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%232B7AFF'/%3e%3cstop%20offset='1'%20stop-color='%2302245E'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint3_linear_78_43'%20x1='40.5472'%20y1='0.00146484'%20x2='40.5472'%20y2='52'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%232B7AFF'/%3e%3cstop%20offset='1'%20stop-color='%2302245E'/%3e%3c/linearGradient%3e%3cclipPath%20id='clip0_78_43'%3e%3crect%20width='60'%20height='52'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";
var _y;
function V1() {
    return V1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    V1.apply(this, arguments)
}
const gT = e=>M.createElement("svg", V1({
    xmlns: "http://www.w3.org/2000/svg",
    width: 20,
    height: 20,
    fill: "none"
}, e), _y || (_y = M.createElement("path", {
    stroke: "#2C406E",
    strokeOpacity: .7,
    strokeWidth: 1.5,
    d: "M10 2.354a4 4 0 1 1 0 5.292M13 19H1v-1a6 6 0 1 1 12 0zm0 0h6v-1a6 6 0 0 0-9-5.197M11 5a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"
})));
var Dy;
function W1() {
    return W1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    W1.apply(this, arguments)
}
const mT = e=>M.createElement("svg", W1({
    xmlns: "http://www.w3.org/2000/svg",
    width: 20,
    height: 20,
    fill: "none"
}, e), Dy || (Dy = M.createElement("path", {
    stroke: "#2C406E",
    strokeOpacity: .7,
    strokeWidth: 1.5,
    d: "M5.98 5.98h.01m-4.873-.34-.043.818C.992 8.023.951 8.806 1.1 9.547c.132.656.373 1.285.714 1.861.384.65.939 1.204 2.047 2.313l2.412 2.412c1.311 1.31 1.966 1.966 2.67 2.324a4.98 4.98 0 0 0 4.52 0c.704-.358 1.36-1.013 2.67-2.324 1.31-1.31 1.966-1.966 2.324-2.67a4.98 4.98 0 0 0 0-4.52c-.358-.704-1.013-1.359-2.324-2.67L13.72 3.861c-1.109-1.108-1.663-1.663-2.313-2.047A5.976 5.976 0 0 0 9.547 1.1c-.74-.15-1.524-.108-3.09-.026l-.817.043c-1.519.08-2.278.12-2.866.436a2.988 2.988 0 0 0-1.221 1.22c-.316.589-.356 1.348-.436 2.867Zm5.35.328a.498.498 0 1 1-.996 0 .498.498 0 0 1 .996 0Z"
})));
var Ny;
function H1() {
    return H1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    H1.apply(this, arguments)
}
const vT = e=>M.createElement("svg", H1({
    xmlns: "http://www.w3.org/2000/svg",
    width: 20,
    height: 18,
    fill: "none"
}, e), Ny || (Ny = M.createElement("path", {
    stroke: "#2C406E",
    strokeOpacity: .7,
    strokeWidth: 1.5,
    d: "M10 17.198c.9 0 9-4.52 9-10.85 0-4.894-6.154-7.454-9-3.165C7.149-1.114 1 1.45 1 6.348c0 6.33 8.1 10.85 9 10.85Z"
})));
var Fy, Iy;
function U1() {
    return U1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    U1.apply(this, arguments)
}
const yT = e=>M.createElement("svg", U1({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 19.5 14.7"
}, e), Fy || (Fy = M.createElement("defs", null, M.createElement("style", null, ".asset-2_svg__cls-222{fill:none;stroke:#2c406e;strokeLinecap:round;strokeLinejoin:round;stroke-opacity:.7;stroke-width:1.5px}"))), Iy || (Iy = M.createElement("g", {
    id: "asset-2_svg__Layer_2",
    "data-name": "Layer 2"
}, M.createElement("g", {
    id: "asset-2_svg__Layer_1-2",
    "data-name": "Layer 1"
}, M.createElement("path", {
    d: "M11.75 9.35a2.82 2.82 0 1 0-2 .83 2.83 2.83 0 0 0 2-.83Z",
    className: "asset-2_svg__cls-222"
}), M.createElement("path", {
    d: "M.75 7.35a9.44 9.44 0 0 1 18 0 9.44 9.44 0 0 1-18 0Z",
    className: "asset-2_svg__cls-222"
})))));
function G1() {
    return G1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    G1.apply(this, arguments)
}
const xT = e=>M.createElement("svg", G1({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 19.5 20.5"
}, e), M.createElement("g", {
    "data-name": "Layer 2"
}, M.createElement("path", {
    d: "M10.5.75a.75.75 0 0 0-1.5 0V5H7.59A12.48 12.48 0 0 0 4 5.28 5.75 5.75 0 0 0 .28 9 12.48 12.48 0 0 0 0 12.59v.32a12.48 12.48 0 0 0 .28 3.62A5.75 5.75 0 0 0 4 20.22a12.48 12.48 0 0 0 3.62.28h4.32a12.48 12.48 0 0 0 3.62-.28 5.75 5.75 0 0 0 3.69-3.69 12.48 12.48 0 0 0 .28-3.62v-.32A12.48 12.48 0 0 0 19.22 9a5.75 5.75 0 0 0-3.69-3.69A12.48 12.48 0 0 0 11.91 5H10.5Zm-6.06 6a11.93 11.93 0 0 1 3.31-.25h4a11.93 11.93 0 0 1 3.31.21 4.23 4.23 0 0 1 2.73 2.73 11.93 11.93 0 0 1 .21 3.31 11.93 11.93 0 0 1-.21 3.31 4.23 4.23 0 0 1-2.73 2.73 11.93 11.93 0 0 1-3.31.21h-4a11.93 11.93 0 0 1-3.31-.21 4.23 4.23 0 0 1-2.73-2.73 11.93 11.93 0 0 1-.21-3.31 11.93 11.93 0 0 1 .21-3.31 4.23 4.23 0 0 1 2.73-2.73ZM6.75 10a1.75 1.75 0 1 0 1.75 1.75A1.75 1.75 0 0 0 6.75 10m6 0a1.75 1.75 0 1 0 1.75 1.75A1.75 1.75 0 0 0 12.75 10",
    "data-name": "Layer 1",
    style: {
        fill: "#2c406e",
        fillOpacity: .7,
        fillRule: "evenodd"
    }
})));
function X1() {
    return X1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    X1.apply(this, arguments)
}
const bT = e=>M.createElement("svg", X1({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 19.5 15.9"
}, e), M.createElement("g", {
    "data-name": "Layer 2"
}, M.createElement("path", {
    d: "M6.51 0c-1 0-1.76 0-2.4.05a4.52 4.52 0 0 0-1.7.42A4.41 4.41 0 0 0 .47 2.38a4.52 4.52 0 0 0-.42 1.7v1.07a.34.34 0 0 0 0 .1v4.17c0 1 0 1.76.05 2.4a4.52 4.52 0 0 0 .42 1.7 4.41 4.41 0 0 0 1.91 1.91 4.52 4.52 0 0 0 1.7.42c.64.05 1.42.05 2.4.05H13c1 0 1.76 0 2.4-.05a4.52 4.52 0 0 0 1.7-.42 4.41 4.41 0 0 0 1.9-1.91 4.52 4.52 0 0 0 .42-1.7c.05-.64.05-1.42.05-2.4V5.25a.34.34 0 0 0 0-.1V4.08a4.52 4.52 0 0 0-.47-1.7A4.41 4.41 0 0 0 17.12.47a4.52 4.52 0 0 0-1.7-.42C14.78 0 14 0 13 0zm-5 6.51V6H18v3.39c0 1 0 1.74-.05 2.3a3 3 0 0 1-.26 1.15 2.8 2.8 0 0 1-1.25 1.25 3 3 0 0 1-1.15.26c-.56.05-1.28.05-2.3.05H6.51c-1 0-1.74 0-2.3-.05a3 3 0 0 1-1.15-.26 2.8 2.8 0 0 1-1.25-1.25 3 3 0 0 1-.26-1.15c-.05-.56-.05-1.28-.05-2.3Zm0-2H18a2.64 2.64 0 0 0 0-.29 3 3 0 0 0-.26-1.15 2.8 2.8 0 0 0-1.25-1.25 3 3 0 0 0-1.15-.26C14.73 1.5 14 1.5 13 1.5H6.51c-1 0-1.74 0-2.3.05a3 3 0 0 0-1.15.26 2.8 2.8 0 0 0-1.25 1.25 3 3 0 0 0-.26 1.15 2.64 2.64 0 0 0-.02.29ZM12.45 8.1a.75.75 0 0 0 0 1.5h2.7a.75.75 0 0 0 0-1.5Z",
    "data-name": "Layer 1",
    style: {
        fill: "#2c406e",
        fillOpacity: .7,
        fillRule: "evenodd"
    }
})));
function Y1() {
    return Y1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Y1.apply(this, arguments)
}
const wT = e=>M.createElement("svg", Y1({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 19.5 17.25"
}, e), M.createElement("g", {
    "data-name": "Layer 2"
}, M.createElement("path", {
    d: "M1.08 9a1.15 1.15 0 0 0-.33.8v5.63a1.13 1.13 0 0 0 1.13 1.07h2.24a1.13 1.13 0 0 0 1.13-1.12V9.75A1.15 1.15 0 0 0 4.92 9a1.14 1.14 0 0 0-.8-.33H1.88a1.14 1.14 0 0 0-.8.33Zm6.75-4.5a1.15 1.15 0 0 0-.33.8v10.08a1.13 1.13 0 0 0 1.12 1.12h2.26A1.13 1.13 0 0 0 12 15.38V5.25a1.15 1.15 0 0 0-.33-.8 1.13 1.13 0 0 0-.79-.33H8.62a1.13 1.13 0 0 0-.79.33Zm6.75-3.37a1.14 1.14 0 0 0-.33.8v13.5a1.13 1.13 0 0 0 1.13 1.12h2.24a1.13 1.13 0 0 0 1.13-1.12V1.88A1.13 1.13 0 0 0 17.62.75h-2.24a1.14 1.14 0 0 0-.8.33Z",
    "data-name": "Layer 1",
    style: {
        fill: "none",
        stroke: "#2c406e",
        strokelinecap: "round",
        strokelinejoin: "round",
        strokeOpacity: .7,
        strokeWidth: "1.5px"
    }
})));
var By;
function $1() {
    return $1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    $1.apply(this, arguments)
}
const ST = e=>M.createElement("svg", $1({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    style: {
        enableBackground: "new 0 0 19.5 17.2"
    },
    viewBox: "0 0 19.5 17.2"
}, e), By || (By = M.createElement("path", {
    d: "M1.1 9c-.2.2-.3.5-.3.8v5.6c0 .6.5 1.1 1.1 1.1h2.2c.6 0 1.1-.5 1.1-1.1V9.7c0-.3-.1-.5-.3-.8-.2-.1-.5-.2-.8-.2H1.9c-.3 0-.6.1-.8.3m6.7-4.5c-.2.2-.3.5-.3.8v10.1c0 .6.5 1.1 1.1 1.1h2.3c.6 0 1.1-.5 1.1-1.1V5.2c0-.3-.1-.6-.3-.8-.2-.2-.5-.3-.8-.3H8.6c-.3 0-.6.1-.8.4m6.8-3.4c-.2.2-.3.5-.3.8v13.5c0 .6.5 1.1 1.1 1.1h2.2c.6 0 1.1-.5 1.1-1.1V1.9c0-.6-.5-1.1-1.1-1.1h-2.2c-.3 0-.6.1-.8.3",
    className: "21Asset1_svg__21a1"
})));
var zy, Vy;
function K1() {
    return K1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    K1.apply(this, arguments)
}
const CT = e=>M.createElement("svg", K1({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 19.5 14.7"
}, e), zy || (zy = M.createElement("defs", null, M.createElement("style", null, ".21Asset2_svg__cls-232{fill:none!important;stroke:#fff;strokeLinecap:round;strokeLinejoin:round;stroke-opacity:1;stroke-width:1.5px}"))), Vy || (Vy = M.createElement("g", {
    id: "21Asset2_svg__Layer_2",
    "data-name": "Layer 2"
}, M.createElement("g", {
    id: "21Asset2_svg__Layer_1-2",
    "data-name": "Layer 1"
}, M.createElement("path", {
    d: "M11.75 9.35a2.82 2.82 0 1 0-2 .83 2.83 2.83 0 0 0 2-.83Z",
    className: "21Asset2_svg__cls-232"
}), M.createElement("path", {
    d: "M.75 7.35a9.44 9.44 0 0 1 18 0 9.44 9.44 0 0 1-18 0Z",
    className: "21Asset2_svg__cls-232"
})))));
var Wy;
function Q1() {
    return Q1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Q1.apply(this, arguments)
}
const kT = e=>M.createElement("svg", Q1({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    style: {
        enableBackground: "new 0 0 19.5 20.5"
    },
    viewBox: "0 0 19.5 20.5"
}, e), Wy || (Wy = M.createElement("path", {
    d: "M10.5.7c0-.4-.3-.8-.8-.8S9 .3 9 .7V5H7.6c-1.2-.1-2.4 0-3.6.3C2.2 5.8.8 7.2.3 9c-.3 1.2-.4 2.4-.3 3.6v.3c-.1 1.2 0 2.4.3 3.6.6 1.8 2 3.1 3.7 3.7 1.2.3 2.4.4 3.6.3h4.3c1.2.1 2.4 0 3.6-.3 1.7-.6 3.1-1.9 3.7-3.7.3-1.2.4-2.4.3-3.6v-.3c.1-1.2 0-2.4-.3-3.6-.6-1.7-1.9-3.1-3.7-3.7-1.2-.3-2.4-.4-3.6-.3h-1.4V.7zm-6.1 6c1.1-.2 2.2-.3 3.3-.2h4c1.1-.1 2.2 0 3.3.2 1.3.4 2.3 1.4 2.7 2.7.2 1.1.3 2.2.2 3.3.1 1.1 0 2.2-.2 3.3-.4 1.3-1.4 2.3-2.7 2.7-1 .3-2.1.4-3.2.3h-4c-1.1.1-2.2 0-3.3-.2-1.3-.4-2.3-1.4-2.7-2.7-.2-1.1-.3-2.2-.2-3.3-.1-1.1 0-2.2.2-3.3.3-1.4 1.3-2.4 2.6-2.8M6.8 10c-1 0-1.8.8-1.8 1.8s.8 1.8 1.8 1.8 1.8-.8 1.8-1.8S7.7 10 6.8 10m6 0c-1 0-1.8.8-1.8 1.8s.8 1.8 1.8 1.8 1.8-.8 1.8-1.8-.9-1.8-1.8-1.8",
    className: "21Asset3_svg__21a3"
})));
var Hy;
function q1() {
    return q1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    q1.apply(this, arguments)
}
const AT = e=>M.createElement("svg", q1({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    style: {
        enableBackground: "new 0 0 19.5 15.9"
    },
    viewBox: "0 0 19.5 15.9"
}, e), Hy || (Hy = M.createElement("path", {
    d: "M6.5 0H4.1c-.6 0-1.2.2-1.7.4C1.6.9.9 1.6.5 2.4.2 2.9.1 3.5.1 4.1V11.9c0 .6.2 1.2.4 1.7.4.8 1.1 1.5 1.9 1.9.5.2 1.1.4 1.7.4.6.1 1.4.1 2.4.1H13c1 0 1.8 0 2.4-.1.6 0 1.2-.2 1.7-.4.8-.4 1.5-1.1 1.9-1.9.2-.5.4-1.1.4-1.7V4c0-.6-.2-1.2-.5-1.7-.4-.8-1.1-1.5-1.9-1.9-.4-.2-1-.3-1.6-.4H13zm-5 6.5V6H18V11.7c0 .4-.1.8-.3 1.1-.3.5-.7 1-1.2 1.2-.4.2-.8.3-1.1.3-.6.1-1.3.1-2.3.1H6.5c-1 0-1.7 0-2.3-.1-.4 0-.8-.1-1.2-.3-.5-.3-1-.7-1.2-1.2-.2-.4-.3-.8-.3-1.1V9.4zm0-2H18v-.3c0-.4-.1-.8-.3-1.1-.3-.5-.7-1-1.2-1.3-.4-.2-.8-.3-1.1-.3H4.2c-.4 0-.8.1-1.2.3-.5.3-1 .7-1.2 1.3-.2.3-.2.7-.3 1.1zm10.9 3.6c-.4 0-.8.3-.8.8s.3.8.8.8h2.7c.4 0 .8-.3.8-.8s-.3-.8-.8-.8z",
    className: "21Asset4_svg__21a4"
})));
var Uy;
function Z1() {
    return Z1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Z1.apply(this, arguments)
}
const MT = e=>M.createElement("svg", Z1({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    style: {
        enableBackground: "new 0 0 19.5 19.5"
    },
    viewBox: "0 0 19.5 19.5"
}, e), Uy || (Uy = M.createElement("path", {
    d: "m.9 5.4-.1.8c-.1 1-.1 2.1 0 3.1.2.7.4 1.3.7 1.9.6.8 1.3 1.6 2 2.3L6 15.9c.8.9 1.7 1.7 2.7 2.3 1.4.7 3.1.7 4.5 0 1-.6 1.9-1.4 2.7-2.3.9-.8 1.7-1.7 2.3-2.7.7-1.4.7-3.1 0-4.5-.6-1-1.4-1.9-2.3-2.7l-2.4-2.4c-.7-.8-1.5-1.4-2.3-2-.6-.3-1.2-.6-1.9-.8-1-.1-2.1-.1-3.1 0h-.8c-1 0-2 .1-2.9.4-.5.4-.9.8-1.2 1.3C1 3.4.8 4.4.9 5.4zm5.3.3c0 .3-.2.5-.5.5s-.5-.2-.5-.5.2-.5.5-.5.5.2.5.5",
    className: "21Asset5_svg__21a5"
})));
var Gy;
function J1() {
    return J1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    J1.apply(this, arguments)
}
const ET = e=>M.createElement("svg", J1({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    style: {
        enableBackground: "new 0 0 19.5 19.5"
    },
    viewBox: "0 0 19.5 19.5"
}, e), Gy || (Gy = M.createElement("path", {
    d: "M9.8 2.1c.5-.6 1.2-1 2-1.2.8-.2 1.6-.2 2.4.1 2.1.8 3.1 3.1 2.3 5.2-.4 1.1-1.3 1.9-2.3 2.3-1.6.6-3.3.2-4.4-1.1m3 11.3H.8v-1c0-3.3 2.7-6 6-6s6 2.7 6 6zm0 0h6v-1c0-3.3-2.7-6-6-6-1.1 0-2.1.3-3 .8m1-7.8c0 2.2-1.8 4-4 4s-4-1.8-4-4 1.8-4 4-4c1.1 0 2.1.4 2.8 1.2.7.8 1.2 1.8 1.2 2.8",
    className: "21Asset6_svg__21a6"
})));
var Xy;
function ep() {
    return ep = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    ep.apply(this, arguments)
}
const PT = e=>M.createElement("svg", ep({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    style: {
        enableBackground: "new 0 0 19.5 17.7"
    },
    viewBox: "0 0 19.5 17.7"
}, e), Xy || (Xy = M.createElement("path", {
    d: "M9.8 17c.9 0 9-4.5 9-10.9 0-4.9-6.1-7.5-9-3.2C7-1.4.8 1.1.8 6c0 6.4 8.1 11 9 11",
    className: "21Asset7_svg__21a7"
})))
  , Yy = [{
    name: "Markets",
    svgActive: ST,
    svg: wT,
    link: "/"
}, {
    name: "Watchlist",
    svgActive: CT,
    svg: yT,
    link: "/watchlist"
}, {
    name: "AI Trading Bots",
    svgActive: kT,
    svg: xT,
    link: "/ai-trading-bots"
}, {
    name: "Wallet",
    svgActive: AT,
    svg: bT,
    link: "/wallet"
}, {
    name: "Guides",
    svgActive: MT,
    svg: mT,
    link: "/guides"
}, {
    name: "Community",
    svgActive: ET,
    svg: gT,
    link: "/community"
}, {
    name: "Support",
    svgActive: PT,
    svg: vT,
    link: "/support"
}]
  , TT = ({hendlActiveTitle: e, hendlUnactiveSidebar: t})=>{
    const n = rs().pathname
      , [i,r] = Ce.useState(10);
    Ce.useEffect(()=>{
        t()
    }
    , [n]);
    const s = a=>n.includes("market/") ? "Markets" : n.includes("ai-trading-bots/") || n.includes("create-strategy") ? "AI Trading Bots" : a.filter(c=>c.link === n)[0].name;
    Ce.useEffect(()=>{
        e(s(Yy))
    }
    , [n]);
    const o = (a,l)=>{
        const c = n === a;
        return l === 0 && n.includes("market/") || l === 2 && n.includes("ai-trading-bots/") || l === 2 && n.includes("create-strategy") || c ? "active" : ""
    }
    ;
    return y.jsx("nav", {
        children: Yy.map(({name: a, svgActive: l, svg: c, link: u},h)=>{
            const d = h;
            return y.jsx(Vn, {
                to: u,
                onMouseEnter: ()=>r(d),
                onMouseLeave: ()=>r(10),
                children: y.jsxs("button", {
                    className: o(u, d),
                    children: [i === d || o(u, d) === "active" ? y.jsx(l, {
                        className: "svg svg-active"
                    }) : y.jsx(c, {
                        className: "svg"
                    }), y.jsx("div", {
                        children: a
                    })]
                })
            }, d)
        }
        )
    })
}
  , jT = "data:image/svg+xml,%3csvg%20width='16'%20height='17'%20viewBox='0%200%2016%2017'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M8%201L3%201C2.46957%201%201.96086%201.22576%201.58579%201.62763C1.21071%202.02949%201%202.57454%201%203.14286V13.8571C1%2014.4255%201.21071%2014.9705%201.58579%2015.3724C1.96086%2015.7742%202.46957%2016%203%2016H8M12%2011.7143L15%208.5M15%208.5L12%205.28571M15%208.5H5'%20stroke='%232C406E'%20stroke-width='1.2'%20strokeLinecap='round'%20strokeLinejoin='round'/%3e%3c/svg%3e"
  , OT = "data:image/svg+xml,%3csvg%20width='12'%20height='16'%20viewBox='0%200%2012%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M6.79196%200.791224C6.79196%200.354243%206.43772%200%206.00074%200C5.56376%200%205.20951%200.354243%205.20951%200.791224V1.38464H4.76847C3.00794%201.38464%201.55082%202.75347%201.44092%204.51057L1.26606%207.30632C1.19939%208.37226%200.841531%209.39947%200.231449%2010.2761C-0.319782%2011.0681%200.170951%2012.1621%201.12907%2012.2771L3.82487%2012.6005V13.4508C3.82487%2014.6525%204.79904%2015.6267%206.00074%2015.6267C7.20243%2015.6267%208.1766%2014.6525%208.1766%2013.4508V12.6005L10.8724%2012.2771C11.8305%2012.1621%2012.3212%2011.0681%2011.77%2010.2761C11.1599%209.39947%2010.8021%208.37226%2010.7354%207.30632L10.5605%204.51057C10.4506%202.75347%208.99352%201.38464%207.23299%201.38464H6.79196V0.791224ZM4.76847%202.57148C3.63464%202.57148%202.69622%203.45304%202.62545%204.58465L2.45058%207.38041C2.37036%208.66309%201.93973%209.89917%201.20559%2010.954C1.16575%2011.0113%201.20122%2011.0904%201.27047%2011.0987L4.2278%2011.4535C5.40553%2011.5949%206.59594%2011.5949%207.77366%2011.4535L10.731%2011.0987C10.8002%2011.0904%2010.8357%2011.0113%2010.7959%2010.954C10.0617%209.89917%209.63111%208.66309%209.55088%207.38041L9.37602%204.58465C9.30524%203.45304%208.36682%202.57148%207.23299%202.57148H4.76847ZM6.00074%2014.4398C5.45451%2014.4398%205.01171%2013.997%205.01171%2013.4508V12.8574H6.98977V13.4508C6.98977%2013.997%206.54696%2014.4398%206.00074%2014.4398Z'%20fill='%232C406E'/%3e%3c/svg%3e"
  , LT = "data:image/svg+xml,%3csvg%20width='17'%20height='14'%20viewBox='0%200%2017%2014'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='1.00073'%20y='1'%20width='15'%20height='12'%20rx='2'%20stroke='%232C406E'%20stroke-width='1.2'/%3e%3cpath%20d='M1.00073%204L7.55956%207.49804C8.14779%207.81176%208.85367%207.81176%209.44191%207.49804L16.0007%204'%20stroke='%232C406E'%20stroke-width='1.2'/%3e%3c/svg%3e";
var $y, Ky;
function tp() {
    return tp = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    tp.apply(this, arguments)
}
const Ew = e=>M.createElement("svg", tp({
    xmlns: "http://www.w3.org/2000/svg",
    width: 13,
    height: 13,
    fill: "none"
}, e), $y || ($y = M.createElement("circle", {
    cx: 5.584,
    cy: 5.583,
    r: 4.583,
    stroke: "#2C406E",
    strokeWidth: 1.2
})), Ky || (Ky = M.createElement("path", {
    stroke: "#2C406E",
    strokeWidth: 1.2,
    d: "M12 12 9.25 9.25"
})))
  , RT = "data:image/svg+xml,%3csvg%20width='13'%20height='13'%20viewBox='0%200%2013%2013'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='5.58407'%20cy='5.58333'%20r='4.58333'%20stroke='%232C406E'%20stroke-width='1.2'%20strokeLinecap='round'/%3e%3cpath%20d='M12.0007%2012L9.25073%209.25'%20stroke='%232C406E'%20stroke-width='1.2'%20strokeLinecap='round'/%3e%3c/svg%3e"
  , _T = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M10.8369%2010.8263C12.2318%2011.1113%2013.6798%2010.9801%2015.0007%2010.4489C14.46%2011.7945%2013.529%2012.9475%2012.3274%2013.7595C11.1259%2014.5716%209.70889%2015.0055%208.2587%2015.0054C6.57228%2015.0036%204.93902%2014.4152%203.6389%2013.3411C2.33878%2012.267%201.45277%2010.7741%201.13276%209.11837C0.812748%207.46259%201.07867%205.74707%201.88493%204.26588C2.6912%202.78469%203.98759%201.63008%205.55187%201C5.02068%202.32095%204.88941%203.76888%205.1744%205.16382C5.45939%206.55876%206.14805%207.83919%207.1548%208.84593C8.16155%209.85268%209.44197%2010.5413%2010.8369%2010.8263Z'%20stroke='%232C406E'%20stroke-width='1.2'%20strokeLinecap='round'%20strokeLinejoin='round'/%3e%3c/svg%3e"
  , DT = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M8%201V1.77778M8%2014.2222V15M15%208H14.2222M1.77778%208H1M12.9498%2012.9498L12.3999%2012.3999M3.60011%203.60011L3.05022%203.05022M12.9498%203.05022L12.3999%203.60011M3.60011%2012.3999L3.05022%2012.9498M11.1111%208C11.1111%208.82512%2010.7833%209.61644%2010.1999%2010.1999C9.61644%2010.7833%208.82512%2011.1111%208%2011.1111C7.17488%2011.1111%206.38356%2010.7833%205.80011%2010.1999C5.21667%209.61644%204.88889%208.82512%204.88889%208C4.88889%207.17488%205.21667%206.38356%205.80011%205.80011C6.38356%205.21667%207.17488%204.88889%208%204.88889C8.82512%204.88889%209.61644%205.21667%2010.1999%205.80011C10.7833%206.38356%2011.1111%207.17488%2011.1111%208Z'%20stroke='white'%20stroke-width='1.2'%20strokeLinecap='round'%20strokeLinejoin='round'/%3e%3c/svg%3e";
var Qy;
function np() {
    return np = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    np.apply(this, arguments)
}
const Kr = e=>M.createElement("svg", np({
    xmlns: "http://www.w3.org/2000/svg",
    width: 3,
    height: 3,
    fill: "none"
}, e), Qy || (Qy = M.createElement("path", {
    fill: "#2C406E",
    d: "m.125.838 1.082 1.269a.374.374 0 0 0 .589 0L2.878.837C3.14.53 2.953 0 2.58 0H.417C.045 0-.139.53.125.838Z"
})))
  , NT = "data:image/svg+xml,%3csvg%20width='3'%20height='3'%20viewBox='0%200%203%203'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0.124599%200.837779L1.20671%202.1067C1.36965%202.29777%201.63286%202.29777%201.7958%202.1067L2.8779%200.837779C3.14111%200.529124%202.9531%200%202.58126%200H0.417057C0.0452184%200%20-0.138612%200.529124%200.124599%200.837779Z'%20fill='%232C406E'/%3e%3c/svg%3e";
var qy;
function ip() {
    return ip = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    ip.apply(this, arguments)
}
const FT = e=>M.createElement("svg", ip({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), qy || (qy = M.createElement("g", {
    "data-name": "Layer 2"
}, M.createElement("path", {
    d: "M28 10H4a1 1 0 0 1 0-2h24a1 1 0 0 1 0 2M28 17H4a1 1 0 0 1 0-2h24a1 1 0 0 1 0 2M28 24H4a1 1 0 0 1 0-2h24a1 1 0 0 1 0 2"
}))), M.createElement("rect", {
    style: {
        fill: "none"
    }
}));
var Zy;
function rp() {
    return rp = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    rp.apply(this, arguments)
}
const IT = e=>M.createElement("svg", rp({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
}, e), Zy || (Zy = M.createElement("path", {
    d: "M4.293 18.293 10.586 12 4.293 5.707a1 1 0 0 1 1.414-1.414L12 10.586l6.293-6.293a1 1 0 1 1 1.414 1.414L13.414 12l6.293 6.293a1 1 0 1 1-1.414 1.414L12 13.414l-6.293 6.293a1 1 0 0 1-1.414-1.414"
})))
  , BT = ({hendlActiveSidebar: e, isActiveSidebar: t, activeNameInHeaderTitle: n})=>y.jsxs("header", {
    className: "mobile",
    children: [y.jsx("h1", {
        children: n
    }), y.jsx("div", {
        className: "user-panel",
        children: y.jsx(Pw, {})
    }), y.jsx("button", {
        className: "burger-menu",
        onClick: e,
        children: t ? y.jsx(IT, {
            className: "burger-menu__svg"
        }) : y.jsx(FT, {
            className: "burger-menu__svg"
        })
    })]
})
  , Pw = ()=>y.jsxs(y.Fragment, {
    children: [y.jsxs("div", {
        children: [y.jsx("img", {
            src: RT,
            alt: "Search"
        }), y.jsx("img", {
            src: LT,
            alt: "Messages"
        }), y.jsx("img", {
            src: OT,
            alt: "Notifications"
        })]
    }), y.jsxs("div", {
        children: [y.jsx("h6", {
            children: "EN/USD"
        }), y.jsx("img", {
            src: NT,
            alt: "Language"
        })]
    }), y.jsxs("div", {
        children: [y.jsx("img", {
            src: _T,
            alt: "Theme Dark"
        }), y.jsx("img", {
            src: DT,
            alt: "Theme Light"
        }), y.jsx("img", {
            src: jT,
            alt: "Exit"
        })]
    })]
})
  , zT = ({isActiveSidebar: e, hendlActiveTitle: t, hendlUnactiveSidebar: n})=>y.jsx("aside", {
    className: `sidebar ${e ? "mobile-version" : ""}`,
    children: y.jsxs("div", {
        className: "sidebar__wrapper ",
        children: [y.jsxs("div", {
            className: "sidebar__header",
            children: [y.jsx("a", {
                href: "/",
                children: y.jsx("img", {
                    src: pT,
                    alt: "Logo"
                })
            }), y.jsx("h2", {
                children: "IUH"
            })]
        }), y.jsxs("div", {
            className: "sidebar__card",
            style: {
                backgroundImage: `url(${hT})`
            },
            children: [y.jsx("img", {
                src: dT,
                alt: "user"
            }), y.jsx("p", {
                children: "Paul Nichols"
            }), y.jsxs("div", {
                children: [y.jsx("p", {
                    children: "Verified"
                }), y.jsx("img", {
                    src: fT,
                    alt: "Checked User"
                })]
            })]
        }), y.jsxs("div", {
            className: "all-amount",
            children: [y.jsx("p", {
                children: "Total Balance"
            }), y.jsxs("h3", {
                children: ["$15,453.05 ", y.jsx("span", {
                    children: "+9.34%"
                })]
            })]
        }), y.jsx(TT, {
            hendlActiveTitle: t,
            hendlUnactiveSidebar: n
        }), y.jsxs("div", {
            className: "upgreide-ad shadow",
            style: {
                marginTop: e ? "40px" : "200px"
            },
            children: [y.jsxs("div", {
                children: [y.jsx("h5", {
                    children: "UPGRADE TO"
                }), y.jsx("h3", {
                    children: "Professional Tier"
                })]
            }), y.jsx("img", {
                src: uT,
                alt: "Upbgreide Coin"
            })]
        }), e && y.jsx("div", {
            className: "user-panel-mobile",
            children: y.jsx(Pw, {})
        })]
    })
})
  , Tw = Ce.createContext({
    activeBlackout: !0,
    setActiveBlackout: ()=>{}
})
  , VT = ()=>{
    const [e,t] = Ce.useState(!1)
      , [n,i] = Ce.useState("")
      , [r,s] = Ce.useState(!1)
      , o = ()=>{
        t(!e)
    }
      , a = ()=>{
        t(!1)
    }
      , l = c=>{
        i(c)
    }
    ;
    return y.jsxs(Tw.Provider, {
        value: {
            activeBlackout: r,
            setActiveBlackout: s
        },
        children: [y.jsxs("div", {
            className: "app",
            children: [y.jsx(zT, {
                hendlUnactiveSidebar: a,
                isActiveSidebar: e,
                hendlActiveTitle: l
            }), y.jsxs("div", {
                className: "content",
                children: [y.jsx(BT, {
                    hendlActiveSidebar: o,
                    isActiveSidebar: e,
                    activeNameInHeaderTitle: n
                }), y.jsx(ZP, {}), y.jsx("div", {
                    className: e ? "blackout" : ""
                })]
            })]
        }), y.jsx("div", {
            className: r ? "blackout-all-screen" : "",
            onClick: ()=>s(!1)
        })]
    })
}
;
var jw = {
    exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
    (function() {
        var t = {}.hasOwnProperty;
        function n() {
            for (var i = [], r = 0; r < arguments.length; r++) {
                var s = arguments[r];
                if (s) {
                    var o = typeof s;
                    if (o === "string" || o === "number")
                        i.push(s);
                    else if (Array.isArray(s)) {
                        if (s.length) {
                            var a = n.apply(null, s);
                            a && i.push(a)
                        }
                    } else if (o === "object") {
                        if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) {
                            i.push(s.toString());
                            continue
                        }
                        for (var l in s)
                            t.call(s, l) && s[l] && i.push(l)
                    }
                }
            }
            return i.join(" ")
        }
        e.exports ? (n.default = n,
        e.exports = n) : window.classNames = n
    }
    )()
}
)(jw);
var WT = jw.exports;
const nt = Jr(WT);
function Wn() {
    return Wn = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Wn.apply(this, arguments)
}
var Ow = {
    exports: {}
}
  , et = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var a2 = Symbol.for("react.element"), l2 = Symbol.for("react.portal"), Od = Symbol.for("react.fragment"), Ld = Symbol.for("react.strict_mode"), Rd = Symbol.for("react.profiler"), _d = Symbol.for("react.provider"), Dd = Symbol.for("react.context"), HT = Symbol.for("react.server_context"), Nd = Symbol.for("react.forward_ref"), Fd = Symbol.for("react.suspense"), Id = Symbol.for("react.suspense_list"), Bd = Symbol.for("react.memo"), zd = Symbol.for("react.lazy"), UT = Symbol.for("react.offscreen"), Lw;
Lw = Symbol.for("react.module.reference");
function ai(e) {
    if (typeof e == "object" && e !== null) {
        var t = e.$$typeof;
        switch (t) {
        case a2:
            switch (e = e.type,
            e) {
            case Od:
            case Rd:
            case Ld:
            case Fd:
            case Id:
                return e;
            default:
                switch (e = e && e.$$typeof,
                e) {
                case HT:
                case Dd:
                case Nd:
                case zd:
                case Bd:
                case _d:
                    return e;
                default:
                    return t
                }
            }
        case l2:
            return t
        }
    }
}
et.ContextConsumer = Dd;
et.ContextProvider = _d;
et.Element = a2;
et.ForwardRef = Nd;
et.Fragment = Od;
et.Lazy = zd;
et.Memo = Bd;
et.Portal = l2;
et.Profiler = Rd;
et.StrictMode = Ld;
et.Suspense = Fd;
et.SuspenseList = Id;
et.isAsyncMode = function() {
    return !1
}
;
et.isConcurrentMode = function() {
    return !1
}
;
et.isContextConsumer = function(e) {
    return ai(e) === Dd
}
;
et.isContextProvider = function(e) {
    return ai(e) === _d
}
;
et.isElement = function(e) {
    return typeof e == "object" && e !== null && e.$$typeof === a2
}
;
et.isForwardRef = function(e) {
    return ai(e) === Nd
}
;
et.isFragment = function(e) {
    return ai(e) === Od
}
;
et.isLazy = function(e) {
    return ai(e) === zd
}
;
et.isMemo = function(e) {
    return ai(e) === Bd
}
;
et.isPortal = function(e) {
    return ai(e) === l2
}
;
et.isProfiler = function(e) {
    return ai(e) === Rd
}
;
et.isStrictMode = function(e) {
    return ai(e) === Ld
}
;
et.isSuspense = function(e) {
    return ai(e) === Fd
}
;
et.isSuspenseList = function(e) {
    return ai(e) === Id
}
;
et.isValidElementType = function(e) {
    return typeof e == "string" || typeof e == "function" || e === Od || e === Rd || e === Ld || e === Fd || e === Id || e === UT || typeof e == "object" && e !== null && (e.$$typeof === zd || e.$$typeof === Bd || e.$$typeof === _d || e.$$typeof === Dd || e.$$typeof === Nd || e.$$typeof === Lw || e.getModuleId !== void 0)
}
;
et.typeOf = ai;
Ow.exports = et;
var Rw = Ow.exports;
function Dh(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , n = [];
    return Ce.Children.forEach(e, function(i) {
        i == null && !t.keepEmpty || (Array.isArray(i) ? n = n.concat(Dh(i)) : Rw.isFragment(i) && i.props ? n = n.concat(Dh(i.props.children, t)) : n.push(i))
    }),
    n
}
var sp = {}
  , GT = function(t) {};
function XT(e, t) {}
function YT(e, t) {}
function $T() {
    sp = {}
}
function _w(e, t, n) {
    !t && !sp[n] && (e(!1, n),
    sp[n] = !0)
}
function ii(e, t) {
    _w(XT, e, t)
}
function KT(e, t) {
    _w(YT, e, t)
}
ii.preMessage = GT;
ii.resetWarned = $T;
ii.noteOnce = KT;
function it(e) {
    "@babel/helpers - typeof";
    return it = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    it(e)
}
function QT(e, t) {
    if (it(e) !== "object" || e === null)
        return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var i = n.call(e, t || "default");
        if (it(i) !== "object")
            return i;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
function Dw(e) {
    var t = QT(e, "string");
    return it(t) === "symbol" ? t : String(t)
}
function me(e, t, n) {
    return t = Dw(t),
    t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
function Jy(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(e);
        t && (i = i.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable
        })),
        n.push.apply(n, i)
    }
    return n
}
function be(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? Jy(Object(n), !0).forEach(function(i) {
            me(e, i, n[i])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Jy(Object(n)).forEach(function(i) {
            Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i))
        })
    }
    return e
}
function Nh(e) {
    return e instanceof HTMLElement || e instanceof SVGElement
}
function Ku(e) {
    return Nh(e) ? e : e instanceof Ce.Component ? mw.findDOMNode(e) : null
}
function c2(e, t, n) {
    var i = M.useRef({});
    return (!("value"in i.current) || n(i.current.condition, t)) && (i.current.value = e(),
    i.current.condition = t),
    i.current.value
}
function u2(e, t) {
    typeof e == "function" ? e(t) : it(e) === "object" && e && "current"in e && (e.current = t)
}
function Vd() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    var i = t.filter(function(r) {
        return r
    });
    return i.length <= 1 ? i[0] : function(r) {
        t.forEach(function(s) {
            u2(s, r)
        })
    }
}
function h2() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return c2(function() {
        return Vd.apply(void 0, t)
    }, t, function(i, r) {
        return i.length !== r.length || i.every(function(s, o) {
            return s !== r[o]
        })
    })
}
function mc(e) {
    var t, n, i = Rw.isMemo(e) ? e.type.type : e.type;
    return !(typeof i == "function" && !((t = i.prototype) !== null && t !== void 0 && t.render) || typeof e == "function" && !((n = e.prototype) !== null && n !== void 0 && n.render))
}
var op = M.createContext(null);
function qT(e) {
    var t = e.children
      , n = e.onBatchResize
      , i = M.useRef(0)
      , r = M.useRef([])
      , s = M.useContext(op)
      , o = M.useCallback(function(a, l, c) {
        i.current += 1;
        var u = i.current;
        r.current.push({
            size: a,
            element: l,
            data: c
        }),
        Promise.resolve().then(function() {
            u === i.current && (n == null || n(r.current),
            r.current = [])
        }),
        s == null || s(a, l, c)
    }, [n, s]);
    return M.createElement(op.Provider, {
        value: o
    }, t)
}
var Nw = function() {
    if (typeof Map < "u")
        return Map;
    function e(t, n) {
        var i = -1;
        return t.some(function(r, s) {
            return r[0] === n ? (i = s,
            !0) : !1
        }),
        i
    }
    return function() {
        function t() {
            this.__entries__ = []
        }
        return Object.defineProperty(t.prototype, "size", {
            get: function() {
                return this.__entries__.length
            },
            enumerable: !0,
            configurable: !0
        }),
        t.prototype.get = function(n) {
            var i = e(this.__entries__, n)
              , r = this.__entries__[i];
            return r && r[1]
        }
        ,
        t.prototype.set = function(n, i) {
            var r = e(this.__entries__, n);
            ~r ? this.__entries__[r][1] = i : this.__entries__.push([n, i])
        }
        ,
        t.prototype.delete = function(n) {
            var i = this.__entries__
              , r = e(i, n);
            ~r && i.splice(r, 1)
        }
        ,
        t.prototype.has = function(n) {
            return !!~e(this.__entries__, n)
        }
        ,
        t.prototype.clear = function() {
            this.__entries__.splice(0)
        }
        ,
        t.prototype.forEach = function(n, i) {
            i === void 0 && (i = null);
            for (var r = 0, s = this.__entries__; r < s.length; r++) {
                var o = s[r];
                n.call(i, o[1], o[0])
            }
        }
        ,
        t
    }()
}()
  , ap = typeof window < "u" && typeof document < "u" && window.document === document
  , Fh = function() {
    return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")()
}()
  , ZT = function() {
    return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(Fh) : function(e) {
        return setTimeout(function() {
            return e(Date.now())
        }, 1e3 / 60)
    }
}()
  , JT = 2;
function ej(e, t) {
    var n = !1
      , i = !1
      , r = 0;
    function s() {
        n && (n = !1,
        e()),
        i && a()
    }
    function o() {
        ZT(s)
    }
    function a() {
        var l = Date.now();
        if (n) {
            if (l - r < JT)
                return;
            i = !0
        } else
            n = !0,
            i = !1,
            setTimeout(o, t);
        r = l
    }
    return a
}
var tj = 20
  , nj = ["top", "right", "bottom", "left", "width", "height", "size", "weight"]
  , ij = typeof MutationObserver < "u"
  , rj = function() {
    function e() {
        this.connected_ = !1,
        this.mutationEventsAdded_ = !1,
        this.mutationsObserver_ = null,
        this.observers_ = [],
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this),
        this.refresh = ej(this.refresh.bind(this), tj)
    }
    return e.prototype.addObserver = function(t) {
        ~this.observers_.indexOf(t) || this.observers_.push(t),
        this.connected_ || this.connect_()
    }
    ,
    e.prototype.removeObserver = function(t) {
        var n = this.observers_
          , i = n.indexOf(t);
        ~i && n.splice(i, 1),
        !n.length && this.connected_ && this.disconnect_()
    }
    ,
    e.prototype.refresh = function() {
        var t = this.updateObservers_();
        t && this.refresh()
    }
    ,
    e.prototype.updateObservers_ = function() {
        var t = this.observers_.filter(function(n) {
            return n.gatherActive(),
            n.hasActive()
        });
        return t.forEach(function(n) {
            return n.broadcastActive()
        }),
        t.length > 0
    }
    ,
    e.prototype.connect_ = function() {
        !ap || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_),
        window.addEventListener("resize", this.refresh),
        ij ? (this.mutationsObserver_ = new MutationObserver(this.refresh),
        this.mutationsObserver_.observe(document, {
            attributes: !0,
            childList: !0,
            characterData: !0,
            subtree: !0
        })) : (document.addEventListener("DOMSubtreeModified", this.refresh),
        this.mutationEventsAdded_ = !0),
        this.connected_ = !0)
    }
    ,
    e.prototype.disconnect_ = function() {
        !ap || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_),
        window.removeEventListener("resize", this.refresh),
        this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
        this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh),
        this.mutationsObserver_ = null,
        this.mutationEventsAdded_ = !1,
        this.connected_ = !1)
    }
    ,
    e.prototype.onTransitionEnd_ = function(t) {
        var n = t.propertyName
          , i = n === void 0 ? "" : n
          , r = nj.some(function(s) {
            return !!~i.indexOf(s)
        });
        r && this.refresh()
    }
    ,
    e.getInstance = function() {
        return this.instance_ || (this.instance_ = new e),
        this.instance_
    }
    ,
    e.instance_ = null,
    e
}()
  , Fw = function(e, t) {
    for (var n = 0, i = Object.keys(t); n < i.length; n++) {
        var r = i[n];
        Object.defineProperty(e, r, {
            value: t[r],
            enumerable: !1,
            writable: !1,
            configurable: !0
        })
    }
    return e
}
  , ua = function(e) {
    var t = e && e.ownerDocument && e.ownerDocument.defaultView;
    return t || Fh
}
  , Iw = Wd(0, 0, 0, 0);
function Ih(e) {
    return parseFloat(e) || 0
}
function e3(e) {
    for (var t = [], n = 1; n < arguments.length; n++)
        t[n - 1] = arguments[n];
    return t.reduce(function(i, r) {
        var s = e["border-" + r + "-width"];
        return i + Ih(s)
    }, 0)
}
function sj(e) {
    for (var t = ["top", "right", "bottom", "left"], n = {}, i = 0, r = t; i < r.length; i++) {
        var s = r[i]
          , o = e["padding-" + s];
        n[s] = Ih(o)
    }
    return n
}
function oj(e) {
    var t = e.getBBox();
    return Wd(0, 0, t.width, t.height)
}
function aj(e) {
    var t = e.clientWidth
      , n = e.clientHeight;
    if (!t && !n)
        return Iw;
    var i = ua(e).getComputedStyle(e)
      , r = sj(i)
      , s = r.left + r.right
      , o = r.top + r.bottom
      , a = Ih(i.width)
      , l = Ih(i.height);
    if (i.boxSizing === "border-box" && (Math.round(a + s) !== t && (a -= e3(i, "left", "right") + s),
    Math.round(l + o) !== n && (l -= e3(i, "top", "bottom") + o)),
    !cj(e)) {
        var c = Math.round(a + s) - t
          , u = Math.round(l + o) - n;
        Math.abs(c) !== 1 && (a -= c),
        Math.abs(u) !== 1 && (l -= u)
    }
    return Wd(r.left, r.top, a, l)
}
var lj = function() {
    return typeof SVGGraphicsElement < "u" ? function(e) {
        return e instanceof ua(e).SVGGraphicsElement
    }
    : function(e) {
        return e instanceof ua(e).SVGElement && typeof e.getBBox == "function"
    }
}();
function cj(e) {
    return e === ua(e).document.documentElement
}
function uj(e) {
    return ap ? lj(e) ? oj(e) : aj(e) : Iw
}
function hj(e) {
    var t = e.x
      , n = e.y
      , i = e.width
      , r = e.height
      , s = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object
      , o = Object.create(s.prototype);
    return Fw(o, {
        x: t,
        y: n,
        width: i,
        height: r,
        top: n,
        right: t + i,
        bottom: r + n,
        left: t
    }),
    o
}
function Wd(e, t, n, i) {
    return {
        x: e,
        y: t,
        width: n,
        height: i
    }
}
var dj = function() {
    function e(t) {
        this.broadcastWidth = 0,
        this.broadcastHeight = 0,
        this.contentRect_ = Wd(0, 0, 0, 0),
        this.target = t
    }
    return e.prototype.isActive = function() {
        var t = uj(this.target);
        return this.contentRect_ = t,
        t.width !== this.broadcastWidth || t.height !== this.broadcastHeight
    }
    ,
    e.prototype.broadcastRect = function() {
        var t = this.contentRect_;
        return this.broadcastWidth = t.width,
        this.broadcastHeight = t.height,
        t
    }
    ,
    e
}()
  , fj = function() {
    function e(t, n) {
        var i = hj(n);
        Fw(this, {
            target: t,
            contentRect: i
        })
    }
    return e
}()
  , pj = function() {
    function e(t, n, i) {
        if (this.activeObservations_ = [],
        this.observations_ = new Nw,
        typeof t != "function")
            throw new TypeError("The callback provided as parameter 1 is not a function.");
        this.callback_ = t,
        this.controller_ = n,
        this.callbackCtx_ = i
    }
    return e.prototype.observe = function(t) {
        if (!arguments.length)
            throw new TypeError("1 argument required, but only 0 present.");
        if (!(typeof Element > "u" || !(Element instanceof Object))) {
            if (!(t instanceof ua(t).Element))
                throw new TypeError('parameter 1 is not of type "Element".');
            var n = this.observations_;
            n.has(t) || (n.set(t, new dj(t)),
            this.controller_.addObserver(this),
            this.controller_.refresh())
        }
    }
    ,
    e.prototype.unobserve = function(t) {
        if (!arguments.length)
            throw new TypeError("1 argument required, but only 0 present.");
        if (!(typeof Element > "u" || !(Element instanceof Object))) {
            if (!(t instanceof ua(t).Element))
                throw new TypeError('parameter 1 is not of type "Element".');
            var n = this.observations_;
            n.has(t) && (n.delete(t),
            n.size || this.controller_.removeObserver(this))
        }
    }
    ,
    e.prototype.disconnect = function() {
        this.clearActive(),
        this.observations_.clear(),
        this.controller_.removeObserver(this)
    }
    ,
    e.prototype.gatherActive = function() {
        var t = this;
        this.clearActive(),
        this.observations_.forEach(function(n) {
            n.isActive() && t.activeObservations_.push(n)
        })
    }
    ,
    e.prototype.broadcastActive = function() {
        if (this.hasActive()) {
            var t = this.callbackCtx_
              , n = this.activeObservations_.map(function(i) {
                return new fj(i.target,i.broadcastRect())
            });
            this.callback_.call(t, n, t),
            this.clearActive()
        }
    }
    ,
    e.prototype.clearActive = function() {
        this.activeObservations_.splice(0)
    }
    ,
    e.prototype.hasActive = function() {
        return this.activeObservations_.length > 0
    }
    ,
    e
}()
  , Bw = typeof WeakMap < "u" ? new WeakMap : new Nw
  , zw = function() {
    function e(t) {
        if (!(this instanceof e))
            throw new TypeError("Cannot call a class as a function.");
        if (!arguments.length)
            throw new TypeError("1 argument required, but only 0 present.");
        var n = rj.getInstance()
          , i = new pj(t,n,this);
        Bw.set(this, i)
    }
    return e
}();
["observe", "unobserve", "disconnect"].forEach(function(e) {
    zw.prototype[e] = function() {
        var t;
        return (t = Bw.get(this))[e].apply(t, arguments)
    }
});
var gj = function() {
    return typeof Fh.ResizeObserver < "u" ? Fh.ResizeObserver : zw
}()
  , Tr = new Map;
function mj(e) {
    e.forEach(function(t) {
        var n, i = t.target;
        (n = Tr.get(i)) === null || n === void 0 || n.forEach(function(r) {
            return r(i)
        })
    })
}
var Vw = new gj(mj);
function vj(e, t) {
    Tr.has(e) || (Tr.set(e, new Set),
    Vw.observe(e)),
    Tr.get(e).add(t)
}
function yj(e, t) {
    Tr.has(e) && (Tr.get(e).delete(t),
    Tr.get(e).size || (Vw.unobserve(e),
    Tr.delete(e)))
}
function zi(e, t) {
    if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function")
}
function t3(e, t) {
    for (var n = 0; n < t.length; n++) {
        var i = t[n];
        i.enumerable = i.enumerable || !1,
        i.configurable = !0,
        "value"in i && (i.writable = !0),
        Object.defineProperty(e, Dw(i.key), i)
    }
}
function Vi(e, t, n) {
    return t && t3(e.prototype, t),
    n && t3(e, n),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    e
}
function lp(e, t) {
    return lp = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, r) {
        return i.__proto__ = r,
        i
    }
    ,
    lp(e, t)
}
function Hd(e, t) {
    if (typeof t != "function" && t !== null)
        throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    t && lp(e, t)
}
function Bh(e) {
    return Bh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }
    ,
    Bh(e)
}
function xj() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
        !0
    } catch {
        return !1
    }
}
function Ye(e) {
    if (e === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}
function bj(e, t) {
    if (t && (it(t) === "object" || typeof t == "function"))
        return t;
    if (t !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
    return Ye(e)
}
function Ud(e) {
    var t = xj();
    return function() {
        var i = Bh(e), r;
        if (t) {
            var s = Bh(this).constructor;
            r = Reflect.construct(i, arguments, s)
        } else
            r = i.apply(this, arguments);
        return bj(this, r)
    }
}
var wj = function(e) {
    Hd(n, e);
    var t = Ud(n);
    function n() {
        return zi(this, n),
        t.apply(this, arguments)
    }
    return Vi(n, [{
        key: "render",
        value: function() {
            return this.props.children
        }
    }]),
    n
}(M.Component);
function Sj(e, t) {
    var n = e.children
      , i = e.disabled
      , r = M.useRef(null)
      , s = M.useRef(null)
      , o = M.useContext(op)
      , a = typeof n == "function"
      , l = a ? n(r) : n
      , c = M.useRef({
        width: -1,
        height: -1,
        offsetWidth: -1,
        offsetHeight: -1
    })
      , u = !a && M.isValidElement(l) && mc(l)
      , h = u ? l.ref : null
      , d = h2(h, r)
      , m = function() {
        var v;
        return Ku(r.current) || (r.current && it(r.current) === "object" ? Ku((v = r.current) === null || v === void 0 ? void 0 : v.nativeElement) : null) || Ku(s.current)
    };
    M.useImperativeHandle(t, function() {
        return m()
    });
    var f = M.useRef(e);
    f.current = e;
    var x = M.useCallback(function(S) {
        var v = f.current
          , p = v.onResize
          , g = v.data
          , C = S.getBoundingClientRect()
          , E = C.width
          , O = C.height
          , R = S.offsetWidth
          , F = S.offsetHeight
          , P = Math.floor(E)
          , _ = Math.floor(O);
        if (c.current.width !== P || c.current.height !== _ || c.current.offsetWidth !== R || c.current.offsetHeight !== F) {
            var T = {
                width: P,
                height: _,
                offsetWidth: R,
                offsetHeight: F
            };
            c.current = T;
            var L = R === Math.round(E) ? E : R
              , I = F === Math.round(O) ? O : F
              , k = be(be({}, T), {}, {
                offsetWidth: L,
                offsetHeight: I
            });
            o == null || o(k, S, g),
            p && Promise.resolve().then(function() {
                p(k, S)
            })
        }
    }, []);
    return M.useEffect(function() {
        var S = m();
        return S && !i && vj(S, x),
        function() {
            return yj(S, x)
        }
    }, [r.current, i]),
    M.createElement(wj, {
        ref: s
    }, u ? M.cloneElement(l, {
        ref: d
    }) : l)
}
var Cj = M.forwardRef(Sj)
  , kj = "rc-observer-key";
function Aj(e, t) {
    var n = e.children
      , i = typeof n == "function" ? [n] : Dh(n);
    return i.map(function(r, s) {
        var o = (r == null ? void 0 : r.key) || "".concat(kj, "-").concat(s);
        return M.createElement(Cj, Wn({}, e, {
            key: o,
            ref: s === 0 ? t : void 0
        }), r)
    })
}
var d2 = M.forwardRef(Aj);
d2.Collection = qT;
function Mj(e, t) {
    var n = be({}, e);
    return Array.isArray(t) && t.forEach(function(i) {
        delete n[i]
    }),
    n
}
function cp(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, i = new Array(t); n < t; n++)
        i[n] = e[n];
    return i
}
function Ej(e) {
    if (Array.isArray(e))
        return cp(e)
}
function Ww(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
        return Array.from(e)
}
function f2(e, t) {
    if (e) {
        if (typeof e == "string")
            return cp(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name),
        n === "Map" || n === "Set")
            return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return cp(e, t)
    }
}
function Pj() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function Re(e) {
    return Ej(e) || Ww(e) || f2(e) || Pj()
}
var Hw = function(t) {
    return +setTimeout(t, 16)
}
  , Uw = function(t) {
    return clearTimeout(t)
};
typeof window < "u" && "requestAnimationFrame"in window && (Hw = function(t) {
    return window.requestAnimationFrame(t)
}
,
Uw = function(t) {
    return window.cancelAnimationFrame(t)
}
);
var n3 = 0
  , p2 = new Map;
function Gw(e) {
    p2.delete(e)
}
var Ci = function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    n3 += 1;
    var i = n3;
    function r(s) {
        if (s === 0)
            Gw(i),
            t();
        else {
            var o = Hw(function() {
                r(s - 1)
            });
            p2.set(i, o)
        }
    }
    return r(n),
    i
};
Ci.cancel = function(e) {
    var t = p2.get(e);
    return Gw(e),
    Uw(t)
}
;
function g2(e) {
    for (var t = 0, n, i = 0, r = e.length; r >= 4; ++i,
    r -= 4)
        n = e.charCodeAt(i) & 255 | (e.charCodeAt(++i) & 255) << 8 | (e.charCodeAt(++i) & 255) << 16 | (e.charCodeAt(++i) & 255) << 24,
        n = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16),
        n ^= n >>> 24,
        t = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    switch (r) {
    case 3:
        t ^= (e.charCodeAt(i + 2) & 255) << 16;
    case 2:
        t ^= (e.charCodeAt(i + 1) & 255) << 8;
    case 1:
        t ^= e.charCodeAt(i) & 255,
        t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16)
    }
    return t ^= t >>> 13,
    t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16),
    ((t ^ t >>> 15) >>> 0).toString(36)
}
function Tj(e, t) {
    if (e == null)
        return {};
    var n = {}, i = Object.keys(e), r, s;
    for (s = 0; s < i.length; s++)
        r = i[s],
        !(t.indexOf(r) >= 0) && (n[r] = e[r]);
    return n
}
function ki(e, t) {
    if (e == null)
        return {};
    var n = Tj(e, t), i, r;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for (r = 0; r < s.length; r++)
            i = s[r],
            !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i])
    }
    return n
}
function m2(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1
      , i = new Set;
    function r(s, o) {
        var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
          , l = i.has(s);
        if (ii(!l, "Warning: There may be circular references"),
        l)
            return !1;
        if (s === o)
            return !0;
        if (n && a > 1)
            return !1;
        i.add(s);
        var c = a + 1;
        if (Array.isArray(s)) {
            if (!Array.isArray(o) || s.length !== o.length)
                return !1;
            for (var u = 0; u < s.length; u++)
                if (!r(s[u], o[u], c))
                    return !1;
            return !0
        }
        if (s && o && it(s) === "object" && it(o) === "object") {
            var h = Object.keys(s);
            return h.length !== Object.keys(o).length ? !1 : h.every(function(d) {
                return r(s[d], o[d], c)
            })
        }
        return !1
    }
    return r(e, t)
}
var i3 = "%"
  , jj = function() {
    function e(t) {
        zi(this, e),
        me(this, "instanceId", void 0),
        me(this, "cache", new Map),
        this.instanceId = t
    }
    return Vi(e, [{
        key: "get",
        value: function(n) {
            return this.cache.get(n.join(i3)) || null
        }
    }, {
        key: "update",
        value: function(n, i) {
            var r = n.join(i3)
              , s = this.cache.get(r)
              , o = i(s);
            o === null ? this.cache.delete(r) : this.cache.set(r, o)
        }
    }]),
    e
}()
  , up = "data-token-hash"
  , Ws = "data-css-hash"
  , Fo = "__cssinjs_instance__";
function Oj() {
    var e = Math.random().toString(12).slice(2);
    if (typeof document < "u" && document.head && document.body) {
        var t = document.body.querySelectorAll("style[".concat(Ws, "]")) || []
          , n = document.head.firstChild;
        Array.from(t).forEach(function(r) {
            r[Fo] = r[Fo] || e,
            r[Fo] === e && document.head.insertBefore(r, n)
        });
        var i = {};
        Array.from(document.querySelectorAll("style[".concat(Ws, "]"))).forEach(function(r) {
            var s = r.getAttribute(Ws);
            if (i[s]) {
                if (r[Fo] === e) {
                    var o;
                    (o = r.parentNode) === null || o === void 0 || o.removeChild(r)
                }
            } else
                i[s] = !0
        })
    }
    return new jj(e)
}
var Lj = M.createContext({
    hashPriority: "low",
    cache: Oj(),
    defaultCache: !0
});
const v2 = Lj;
function Tn() {
    return !!(typeof window < "u" && window.document && window.document.createElement)
}
function Rj(e, t) {
    if (!e)
        return !1;
    if (e.contains)
        return e.contains(t);
    for (var n = t; n; ) {
        if (n === e)
            return !0;
        n = n.parentNode
    }
    return !1
}
var r3 = "data-rc-order"
  , s3 = "data-rc-priority"
  , _j = "rc-util-key"
  , hp = new Map;
function Xw() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
      , t = e.mark;
    return t ? t.startsWith("data-") ? t : "data-".concat(t) : _j
}
function Gd(e) {
    if (e.attachTo)
        return e.attachTo;
    var t = document.querySelector("head");
    return t || document.body
}
function Dj(e) {
    return e === "queue" ? "prependQueue" : e ? "prepend" : "append"
}
function Yw(e) {
    return Array.from((hp.get(e) || e).children).filter(function(t) {
        return t.tagName === "STYLE"
    })
}
function $w(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!Tn())
        return null;
    var n = t.csp
      , i = t.prepend
      , r = t.priority
      , s = r === void 0 ? 0 : r
      , o = Dj(i)
      , a = o === "prependQueue"
      , l = document.createElement("style");
    l.setAttribute(r3, o),
    a && s && l.setAttribute(s3, "".concat(s)),
    n != null && n.nonce && (l.nonce = n == null ? void 0 : n.nonce),
    l.innerHTML = e;
    var c = Gd(t)
      , u = c.firstChild;
    if (i) {
        if (a) {
            var h = Yw(c).filter(function(d) {
                if (!["prepend", "prependQueue"].includes(d.getAttribute(r3)))
                    return !1;
                var m = Number(d.getAttribute(s3) || 0);
                return s >= m
            });
            if (h.length)
                return c.insertBefore(l, h[h.length - 1].nextSibling),
                l
        }
        c.insertBefore(l, u)
    } else
        c.appendChild(l);
    return l
}
function Kw(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , n = Gd(t);
    return Yw(n).find(function(i) {
        return i.getAttribute(Xw(t)) === e
    })
}
function zh(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , n = Kw(e, t);
    if (n) {
        var i = Gd(t);
        i.removeChild(n)
    }
}
function Nj(e, t) {
    var n = hp.get(e);
    if (!n || !Rj(document, n)) {
        var i = $w("", t)
          , r = i.parentNode;
        hp.set(e, r),
        e.removeChild(i)
    }
}
function Wl(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
      , i = Gd(n);
    Nj(i, n);
    var r = Kw(t, n);
    if (r) {
        var s, o;
        if ((s = n.csp) !== null && s !== void 0 && s.nonce && r.nonce !== ((o = n.csp) === null || o === void 0 ? void 0 : o.nonce)) {
            var a;
            r.nonce = (a = n.csp) === null || a === void 0 ? void 0 : a.nonce
        }
        return r.innerHTML !== e && (r.innerHTML = e),
        r
    }
    var l = $w(e, n);
    return l.setAttribute(Xw(n), t),
    l
}
function Qw(e) {
    if (Array.isArray(e))
        return e
}
function Fj(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var i, r, s, o, a = [], l = !0, c = !1;
        try {
            if (s = (n = n.call(e)).next,
            t === 0) {
                if (Object(n) !== n)
                    return;
                l = !1
            } else
                for (; !(l = (i = s.call(n)).done) && (a.push(i.value),
                a.length !== t); l = !0)
                    ;
        } catch (u) {
            c = !0,
            r = u
        } finally {
            try {
                if (!l && n.return != null && (o = n.return(),
                Object(o) !== o))
                    return
            } finally {
                if (c)
                    throw r
            }
        }
        return a
    }
}
function qw() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function Me(e, t) {
    return Qw(e) || Fj(e, t) || f2(e, t) || qw()
}
function Ij(e, t) {
    if (e.length !== t.length)
        return !1;
    for (var n = 0; n < e.length; n++)
        if (e[n] !== t[n])
            return !1;
    return !0
}
var y2 = function() {
    function e() {
        zi(this, e),
        me(this, "cache", void 0),
        me(this, "keys", void 0),
        me(this, "cacheCallTimes", void 0),
        this.cache = new Map,
        this.keys = [],
        this.cacheCallTimes = 0
    }
    return Vi(e, [{
        key: "size",
        value: function() {
            return this.keys.length
        }
    }, {
        key: "internalGet",
        value: function(n) {
            var i, r, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, o = {
                map: this.cache
            };
            return n.forEach(function(a) {
                if (!o)
                    o = void 0;
                else {
                    var l;
                    o = (l = o) === null || l === void 0 || (l = l.map) === null || l === void 0 ? void 0 : l.get(a)
                }
            }),
            (i = o) !== null && i !== void 0 && i.value && s && (o.value[1] = this.cacheCallTimes++),
            (r = o) === null || r === void 0 ? void 0 : r.value
        }
    }, {
        key: "get",
        value: function(n) {
            var i;
            return (i = this.internalGet(n, !0)) === null || i === void 0 ? void 0 : i[0]
        }
    }, {
        key: "has",
        value: function(n) {
            return !!this.internalGet(n)
        }
    }, {
        key: "set",
        value: function(n, i) {
            var r = this;
            if (!this.has(n)) {
                if (this.size() + 1 > e.MAX_CACHE_SIZE + e.MAX_CACHE_OFFSET) {
                    var s = this.keys.reduce(function(c, u) {
                        var h = Me(c, 2)
                          , d = h[1];
                        return r.internalGet(u)[1] < d ? [u, r.internalGet(u)[1]] : c
                    }, [this.keys[0], this.cacheCallTimes])
                      , o = Me(s, 1)
                      , a = o[0];
                    this.delete(a)
                }
                this.keys.push(n)
            }
            var l = this.cache;
            n.forEach(function(c, u) {
                if (u === n.length - 1)
                    l.set(c, {
                        value: [i, r.cacheCallTimes++]
                    });
                else {
                    var h = l.get(c);
                    h ? h.map || (h.map = new Map) : l.set(c, {
                        map: new Map
                    }),
                    l = l.get(c).map
                }
            })
        }
    }, {
        key: "deleteByPath",
        value: function(n, i) {
            var r = n.get(i[0]);
            if (i.length === 1) {
                var s;
                return r.map ? n.set(i[0], {
                    map: r.map
                }) : n.delete(i[0]),
                (s = r.value) === null || s === void 0 ? void 0 : s[0]
            }
            var o = this.deleteByPath(r.map, i.slice(1));
            return (!r.map || r.map.size === 0) && !r.value && n.delete(i[0]),
            o
        }
    }, {
        key: "delete",
        value: function(n) {
            if (this.has(n))
                return this.keys = this.keys.filter(function(i) {
                    return !Ij(i, n)
                }),
                this.deleteByPath(this.cache, n)
        }
    }]),
    e
}();
me(y2, "MAX_CACHE_SIZE", 20);
me(y2, "MAX_CACHE_OFFSET", 5);
var o3 = 0
  , Zw = function() {
    function e(t) {
        zi(this, e),
        me(this, "derivatives", void 0),
        me(this, "id", void 0),
        this.derivatives = Array.isArray(t) ? t : [t],
        this.id = o3,
        t.length === 0 && (t.length > 0,
        void 0),
        o3 += 1
    }
    return Vi(e, [{
        key: "getDerivativeToken",
        value: function(n) {
            return this.derivatives.reduce(function(i, r) {
                return r(n, i)
            }, void 0)
        }
    }]),
    e
}()
  , e0 = new y2;
function dp(e) {
    var t = Array.isArray(e) ? e : [e];
    return e0.has(t) || e0.set(t, new Zw(t)),
    e0.get(t)
}
var Bj = new WeakMap
  , t0 = {};
function zj(e, t) {
    for (var n = Bj, i = 0; i < t.length; i += 1) {
        var r = t[i];
        n.has(r) || n.set(r, new WeakMap),
        n = n.get(r)
    }
    return n.has(t0) || n.set(t0, e()),
    n.get(t0)
}
var a3 = new WeakMap;
function Vh(e) {
    var t = a3.get(e) || "";
    return t || (Object.keys(e).forEach(function(n) {
        var i = e[n];
        t += n,
        i instanceof Zw ? t += i.id : i && it(i) === "object" ? t += Vh(i) : t += i
    }),
    a3.set(e, t)),
    t
}
function Vj(e, t) {
    return g2("".concat(t, "_").concat(Vh(e)))
}
var dl = "random-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, "")
  , Jw = "_bAmBoO_";
function Wj(e, t, n) {
    if (Tn()) {
        var i, r;
        Wl(e, dl);
        var s = document.createElement("div");
        s.style.position = "fixed",
        s.style.left = "0",
        s.style.top = "0",
        t == null || t(s),
        document.body.appendChild(s);
        var o = n ? n(s) : (i = getComputedStyle(s).content) === null || i === void 0 ? void 0 : i.includes(Jw);
        return (r = s.parentNode) === null || r === void 0 || r.removeChild(s),
        zh(dl),
        o
    }
    return !1
}
var n0 = void 0;
function Hj() {
    return n0 === void 0 && (n0 = Wj("@layer ".concat(dl, " { .").concat(dl, ' { content: "').concat(Jw, '"!important; } }'), function(e) {
        e.className = dl
    })),
    n0
}
var l3 = Tn() ? M.useLayoutEffect : M.useEffect
  , pn = function(t, n) {
    var i = M.useRef(!0);
    l3(function() {
        return t(i.current)
    }, n),
    l3(function() {
        return i.current = !1,
        function() {
            i.current = !0
        }
    }, [])
}
  , c3 = function(t, n) {
    pn(function(i) {
        if (!i)
            return t()
    }, n)
}
  , Uj = be({}, uc)
  , u3 = Uj.useInsertionEffect
  , Gj = function(t, n, i) {
    M.useMemo(t, i),
    pn(function() {
        return n(!0)
    }, i)
}
  , Xj = u3 ? function(e, t, n) {
    return u3(function() {
        return e(),
        t()
    }, n)
}
: Gj;
const Yj = Xj;
var $j = be({}, uc)
  , Kj = $j.useInsertionEffect
  , Qj = function(t) {
    var n = []
      , i = !1;
    function r(s) {
        i || n.push(s)
    }
    return M.useEffect(function() {
        return i = !1,
        function() {
            i = !0,
            n.length && n.forEach(function(s) {
                return s()
            })
        }
    }, t),
    r
}
  , qj = function() {
    return function(t) {
        t()
    }
}
  , Zj = typeof Kj < "u" ? Qj : qj;
const Jj = Zj;
function eS(e, t, n, i, r) {
    var s = M.useContext(v2)
      , o = s.cache
      , a = [e].concat(Re(t))
      , l = a.join("_")
      , c = Jj([l])
      , u = function(f) {
        o.update(a, function(x) {
            var S = x || []
              , v = Me(S, 2)
              , p = v[0]
              , g = p === void 0 ? 0 : p
              , C = v[1]
              , E = C
              , O = E || n()
              , R = [g, O];
            return f ? f(R) : R
        })
    };
    M.useMemo(function() {
        u()
    }, [l]);
    var h = o.get(a)
      , d = h[1];
    return Yj(function() {
        r == null || r(d)
    }, function(m) {
        return u(function(f) {
            var x = Me(f, 2)
              , S = x[0]
              , v = x[1];
            return m && S === 0 && (r == null || r(d)),
            [S + 1, v]
        }),
        function() {
            o.update(a, function(f) {
                var x = f || []
                  , S = Me(x, 2)
                  , v = S[0]
                  , p = v === void 0 ? 0 : v
                  , g = S[1]
                  , C = p - 1;
                return C === 0 ? (c(function() {
                    return i == null ? void 0 : i(g, !1)
                }),
                null) : [p - 1, g]
            })
        }
    }, [l]),
    d
}
var eO = {}
  , tO = "css"
  , Ts = new Map;
function nO(e) {
    Ts.set(e, (Ts.get(e) || 0) + 1)
}
function iO(e, t) {
    if (typeof document < "u") {
        var n = document.querySelectorAll("style[".concat(up, '="').concat(e, '"]'));
        n.forEach(function(i) {
            if (i[Fo] === t) {
                var r;
                (r = i.parentNode) === null || r === void 0 || r.removeChild(i)
            }
        })
    }
}
var rO = 0;
function sO(e, t) {
    Ts.set(e, (Ts.get(e) || 0) - 1);
    var n = Array.from(Ts.keys())
      , i = n.filter(function(r) {
        var s = Ts.get(r) || 0;
        return s <= 0
    });
    n.length - i.length > rO && i.forEach(function(r) {
        iO(r, t),
        Ts.delete(r)
    })
}
var oO = function(t, n, i, r) {
    var s = i.getDerivativeToken(t)
      , o = be(be({}, s), n);
    return r && (o = r(o)),
    o
};
function aO(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
      , i = M.useContext(v2)
      , r = i.cache.instanceId
      , s = n.salt
      , o = s === void 0 ? "" : s
      , a = n.override
      , l = a === void 0 ? eO : a
      , c = n.formatToken
      , u = n.getComputedToken
      , h = zj(function() {
        return Object.assign.apply(Object, [{}].concat(Re(t)))
    }, t)
      , d = Vh(h)
      , m = Vh(l)
      , f = eS("token", [o, e.id, d, m], function() {
        var x = u ? u(h, l, e) : oO(h, l, e, c)
          , S = Vj(x, o);
        x._tokenKey = S,
        nO(S);
        var v = "".concat(tO, "-").concat(g2(S));
        return x._hashId = v,
        [x, v]
    }, function(x) {
        sO(x[0]._tokenKey, r)
    });
    return f
}
var lO = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
}
  , tS = "comm"
  , nS = "rule"
  , iS = "decl"
  , cO = "@import"
  , uO = "@keyframes"
  , hO = "@layer"
  , dO = Math.abs
  , x2 = String.fromCharCode;
function rS(e) {
    return e.trim()
}
function Qu(e, t, n) {
    return e.replace(t, n)
}
function fO(e, t) {
    return e.indexOf(t)
}
function Hl(e, t) {
    return e.charCodeAt(t) | 0
}
function Ul(e, t, n) {
    return e.slice(t, n)
}
function Ji(e) {
    return e.length
}
function pO(e) {
    return e.length
}
function tu(e, t) {
    return t.push(e),
    e
}
var Xd = 1
  , ha = 1
  , sS = 0
  , oi = 0
  , Dt = 0
  , ka = "";
function b2(e, t, n, i, r, s, o, a) {
    return {
        value: e,
        root: t,
        parent: n,
        type: i,
        props: r,
        children: s,
        line: Xd,
        column: ha,
        length: o,
        return: "",
        siblings: a
    }
}
function gO() {
    return Dt
}
function mO() {
    return Dt = oi > 0 ? Hl(ka, --oi) : 0,
    ha--,
    Dt === 10 && (ha = 1,
    Xd--),
    Dt
}
function wi() {
    return Dt = oi < sS ? Hl(ka, oi++) : 0,
    ha++,
    Dt === 10 && (ha = 1,
    Xd++),
    Dt
}
function Hs() {
    return Hl(ka, oi)
}
function qu() {
    return oi
}
function Yd(e, t) {
    return Ul(ka, e, t)
}
function fp(e) {
    switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
        return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
        return 4;
    case 58:
        return 3;
    case 34:
    case 39:
    case 40:
    case 91:
        return 2;
    case 41:
    case 93:
        return 1
    }
    return 0
}
function vO(e) {
    return Xd = ha = 1,
    sS = Ji(ka = e),
    oi = 0,
    []
}
function yO(e) {
    return ka = "",
    e
}
function i0(e) {
    return rS(Yd(oi - 1, pp(e === 91 ? e + 2 : e === 40 ? e + 1 : e)))
}
function xO(e) {
    for (; (Dt = Hs()) && Dt < 33; )
        wi();
    return fp(e) > 2 || fp(Dt) > 3 ? "" : " "
}
function bO(e, t) {
    for (; --t && wi() && !(Dt < 48 || Dt > 102 || Dt > 57 && Dt < 65 || Dt > 70 && Dt < 97); )
        ;
    return Yd(e, qu() + (t < 6 && Hs() == 32 && wi() == 32))
}
function pp(e) {
    for (; wi(); )
        switch (Dt) {
        case e:
            return oi;
        case 34:
        case 39:
            e !== 34 && e !== 39 && pp(Dt);
            break;
        case 40:
            e === 41 && pp(e);
            break;
        case 92:
            wi();
            break
        }
    return oi
}
function wO(e, t) {
    for (; wi() && e + Dt !== 57; )
        if (e + Dt === 84 && Hs() === 47)
            break;
    return "/*" + Yd(t, oi - 1) + "*" + x2(e === 47 ? e : wi())
}
function SO(e) {
    for (; !fp(Hs()); )
        wi();
    return Yd(e, oi)
}
function CO(e) {
    return yO(Zu("", null, null, null, [""], e = vO(e), 0, [0], e))
}
function Zu(e, t, n, i, r, s, o, a, l) {
    for (var c = 0, u = 0, h = o, d = 0, m = 0, f = 0, x = 1, S = 1, v = 1, p = 0, g = "", C = r, E = s, O = i, R = g; S; )
        switch (f = p,
        p = wi()) {
        case 40:
            if (f != 108 && Hl(R, h - 1) == 58) {
                fO(R += Qu(i0(p), "&", "&\f"), "&\f") != -1 && (v = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            R += i0(p);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            R += xO(f);
            break;
        case 92:
            R += bO(qu() - 1, 7);
            continue;
        case 47:
            switch (Hs()) {
            case 42:
            case 47:
                tu(kO(wO(wi(), qu()), t, n, l), l);
                break;
            default:
                R += "/"
            }
            break;
        case 123 * x:
            a[c++] = Ji(R) * v;
        case 125 * x:
        case 59:
        case 0:
            switch (p) {
            case 0:
            case 125:
                S = 0;
            case 59 + u:
                v == -1 && (R = Qu(R, /\f/g, "")),
                m > 0 && Ji(R) - h && tu(m > 32 ? d3(R + ";", i, n, h - 1, l) : d3(Qu(R, " ", "") + ";", i, n, h - 2, l), l);
                break;
            case 59:
                R += ";";
            default:
                if (tu(O = h3(R, t, n, c, u, r, a, g, C = [], E = [], h, s), s),
                p === 123)
                    if (u === 0)
                        Zu(R, t, O, O, C, s, h, a, E);
                    else
                        switch (d === 99 && Hl(R, 3) === 110 ? 100 : d) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                            Zu(e, O, O, i && tu(h3(e, O, O, 0, 0, r, a, g, r, C = [], h, E), E), r, E, h, a, i ? C : E);
                            break;
                        default:
                            Zu(R, O, O, O, [""], E, 0, a, E)
                        }
            }
            c = u = m = 0,
            x = v = 1,
            g = R = "",
            h = o;
            break;
        case 58:
            h = 1 + Ji(R),
            m = f;
        default:
            if (x < 1) {
                if (p == 123)
                    --x;
                else if (p == 125 && x++ == 0 && mO() == 125)
                    continue
            }
            switch (R += x2(p),
            p * x) {
            case 38:
                v = u > 0 ? 1 : (R += "\f",
                -1);
                break;
            case 44:
                a[c++] = (Ji(R) - 1) * v,
                v = 1;
                break;
            case 64:
                Hs() === 45 && (R += i0(wi())),
                d = Hs(),
                u = h = Ji(g = R += SO(qu())),
                p++;
                break;
            case 45:
                f === 45 && Ji(R) == 2 && (x = 0)
            }
        }
    return s
}
function h3(e, t, n, i, r, s, o, a, l, c, u, h) {
    for (var d = r - 1, m = r === 0 ? s : [""], f = pO(m), x = 0, S = 0, v = 0; x < i; ++x)
        for (var p = 0, g = Ul(e, d + 1, d = dO(S = o[x])), C = e; p < f; ++p)
            (C = rS(S > 0 ? m[p] + " " + g : Qu(g, /&\f/g, m[p]))) && (l[v++] = C);
    return b2(e, t, n, r === 0 ? nS : a, l, c, u, h)
}
function kO(e, t, n, i) {
    return b2(e, t, n, tS, x2(gO()), Ul(e, 2, -2), 0, i)
}
function d3(e, t, n, i, r) {
    return b2(e, t, n, iS, Ul(e, 0, i), Ul(e, i + 1, -1), i, r)
}
function gp(e, t) {
    for (var n = "", i = 0; i < e.length; i++)
        n += t(e[i], i, e, t) || "";
    return n
}
function AO(e, t, n, i) {
    switch (e.type) {
    case hO:
        if (e.children.length)
            break;
    case cO:
    case iS:
        return e.return = e.return || e.value;
    case tS:
        return "";
    case uO:
        return e.return = e.value + "{" + gp(e.children, i) + "}";
    case nS:
        if (!Ji(e.value = e.props.join(",")))
            return ""
    }
    return Ji(n = gp(e.children, i)) ? e.return = e.value + "{" + n + "}" : ""
}
var f3 = "data-ant-cssinjs-cache-path", oS = "_FILE_STYLE__", Us, aS = !0;
function MO() {
    if (!Us && (Us = {},
    Tn())) {
        var e = document.createElement("div");
        e.className = f3,
        e.style.position = "fixed",
        e.style.visibility = "hidden",
        e.style.top = "-9999px",
        document.body.appendChild(e);
        var t = getComputedStyle(e).content || "";
        t = t.replace(/^"/, "").replace(/"$/, ""),
        t.split(";").forEach(function(r) {
            var s = r.split(":")
              , o = Me(s, 2)
              , a = o[0]
              , l = o[1];
            Us[a] = l
        });
        var n = document.querySelector("style[".concat(f3, "]"));
        if (n) {
            var i;
            aS = !1,
            (i = n.parentNode) === null || i === void 0 || i.removeChild(n)
        }
        document.body.removeChild(e)
    }
}
function EO(e) {
    return MO(),
    !!Us[e]
}
function PO(e) {
    var t = Us[e]
      , n = null;
    if (t && Tn())
        if (aS)
            n = oS;
        else {
            var i = document.querySelector("style[".concat(Ws, '="').concat(Us[e], '"]'));
            i ? n = i.innerHTML : delete Us[e]
        }
    return [n, t]
}
var p3 = Tn()
  , TO = "_skip_check_"
  , lS = "_multi_value_";
function g3(e) {
    var t = gp(CO(e), AO);
    return t.replace(/\{%%%\:[^;];}/g, ";")
}
function jO(e) {
    return it(e) === "object" && e && (TO in e || lS in e)
}
function OO(e, t, n) {
    if (!t)
        return e;
    var i = ".".concat(t)
      , r = n === "low" ? ":where(".concat(i, ")") : i
      , s = e.split(",").map(function(o) {
        var a, l = o.trim().split(/\s+/), c = l[0] || "", u = ((a = c.match(/^\w+/)) === null || a === void 0 ? void 0 : a[0]) || "";
        return c = "".concat(u).concat(r).concat(c.slice(u.length)),
        [c].concat(Re(l.slice(1))).join(" ")
    });
    return s.join(",")
}
var LO = function e(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        root: !0,
        parentSelectors: []
    }
      , r = i.root
      , s = i.injectHash
      , o = i.parentSelectors
      , a = n.hashId
      , l = n.layer;
    n.path;
    var c = n.hashPriority
      , u = n.transformers
      , h = u === void 0 ? [] : u;
    n.linters;
    var d = ""
      , m = {};
    function f(g) {
        var C = g.getName(a);
        if (!m[C]) {
            var E = e(g.style, n, {
                root: !1,
                parentSelectors: o
            })
              , O = Me(E, 1)
              , R = O[0];
            m[C] = "@keyframes ".concat(g.getName(a)).concat(R)
        }
    }
    function x(g) {
        var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        return g.forEach(function(E) {
            Array.isArray(E) ? x(E, C) : E && C.push(E)
        }),
        C
    }
    var S = x(Array.isArray(t) ? t : [t]);
    if (S.forEach(function(g) {
        var C = typeof g == "string" && !r ? {} : g;
        if (typeof C == "string")
            d += "".concat(C, `
`);
        else if (C._keyframe)
            f(C);
        else {
            var E = h.reduce(function(O, R) {
                var F;
                return (R == null || (F = R.visit) === null || F === void 0 ? void 0 : F.call(R, O)) || O
            }, C);
            Object.keys(E).forEach(function(O) {
                var R = E[O];
                if (it(R) === "object" && R && (O !== "animationName" || !R._keyframe) && !jO(R)) {
                    var F = !1
                      , P = O.trim()
                      , _ = !1;
                    (r || s) && a ? P.startsWith("@") ? F = !0 : P = OO(O, a, c) : r && !a && (P === "&" || P === "") && (P = "",
                    _ = !0);
                    var T = e(R, n, {
                        root: _,
                        injectHash: F,
                        parentSelectors: [].concat(Re(o), [P])
                    })
                      , L = Me(T, 2)
                      , I = L[0]
                      , k = L[1];
                    m = be(be({}, m), k),
                    d += "".concat(P).concat(I)
                } else {
                    let A = function(j, B) {
                        var W = j.replace(/[A-Z]/g, function(H) {
                            return "-".concat(H.toLowerCase())
                        })
                          , N = B;
                        !lO[j] && typeof N == "number" && N !== 0 && (N = "".concat(N, "px")),
                        j === "animationName" && B !== null && B !== void 0 && B._keyframe && (f(B),
                        N = B.getName(a)),
                        d += "".concat(W, ":").concat(N, ";")
                    };
                    var w, b = (w = R == null ? void 0 : R.value) !== null && w !== void 0 ? w : R;
                    it(R) === "object" && R !== null && R !== void 0 && R[lS] && Array.isArray(b) ? b.forEach(function(j) {
                        A(O, j)
                    }) : A(O, b)
                }
            })
        }
    }),
    !r)
        d = "{".concat(d, "}");
    else if (l && Hj()) {
        var v = l.split(",")
          , p = v[v.length - 1].trim();
        d = "@layer ".concat(p, " {").concat(d, "}"),
        v.length > 1 && (d = "@layer ".concat(l, "{%%%:%}").concat(d))
    }
    return [d, m]
};
function RO(e, t) {
    return g2("".concat(e.join("%")).concat(t))
}
function _O() {
    return null
}
function mp(e, t) {
    var n = e.token
      , i = e.path
      , r = e.hashId
      , s = e.layer
      , o = e.nonce
      , a = e.clientOnly
      , l = e.order
      , c = l === void 0 ? 0 : l
      , u = M.useContext(v2)
      , h = u.autoClear;
    u.mock;
    var d = u.defaultCache
      , m = u.hashPriority
      , f = u.container
      , x = u.ssrInline
      , S = u.transformers
      , v = u.linters
      , p = u.cache
      , g = n._tokenKey
      , C = [g].concat(Re(i))
      , E = p3
      , O = eS("style", C, function() {
        var T = C.join("|");
        if (EO(T)) {
            var L = PO(T)
              , I = Me(L, 2)
              , k = I[0]
              , w = I[1];
            if (k)
                return [k, g, w, {}, a, c]
        }
        var b = t()
          , A = LO(b, {
            hashId: r,
            hashPriority: m,
            layer: s,
            path: i.join("-"),
            transformers: S,
            linters: v
        })
          , j = Me(A, 2)
          , B = j[0]
          , W = j[1]
          , N = g3(B)
          , H = RO(C, N);
        return [N, g, H, W, a, c]
    }, function(T, L) {
        var I = Me(T, 3)
          , k = I[2];
        (L || h) && p3 && zh(k, {
            mark: Ws
        })
    }, function(T) {
        var L = Me(T, 4)
          , I = L[0];
        L[1];
        var k = L[2]
          , w = L[3];
        if (E && I !== oS) {
            var b = {
                mark: Ws,
                prepend: "queue",
                attachTo: f,
                priority: c
            }
              , A = typeof o == "function" ? o() : o;
            A && (b.csp = {
                nonce: A
            });
            var j = Wl(I, k, b);
            j[Fo] = p.instanceId,
            j.setAttribute(up, g),
            Object.keys(w).forEach(function(B) {
                Wl(g3(w[B]), "_effect-".concat(B), b)
            })
        }
    })
      , R = Me(O, 3)
      , F = R[0]
      , P = R[1]
      , _ = R[2];
    return function(T) {
        var L;
        if (!x || E || !d)
            L = M.createElement(_O, null);
        else {
            var I;
            L = M.createElement("style", Wn({}, (I = {},
            me(I, up, P),
            me(I, Ws, _),
            I), {
                dangerouslySetInnerHTML: {
                    __html: F
                }
            }))
        }
        return M.createElement(M.Fragment, null, L, T)
    }
}
var li = function() {
    function e(t, n) {
        zi(this, e),
        me(this, "name", void 0),
        me(this, "style", void 0),
        me(this, "_keyframe", !0),
        this.name = t,
        this.style = n
    }
    return Vi(e, [{
        key: "getName",
        value: function() {
            var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            return n ? "".concat(n, "-").concat(this.name) : this.name
        }
    }]),
    e
}();
function mo(e) {
    return e.notSplit = !0,
    e
}
mo(["borderTop", "borderBottom"]),
mo(["borderTop"]),
mo(["borderBottom"]),
mo(["borderLeft", "borderRight"]),
mo(["borderLeft"]),
mo(["borderRight"]);
var DO = M.createContext({});
const NO = DO;
function FO(e) {
    return Qw(e) || Ww(e) || f2(e) || qw()
}
function yi(e, t) {
    for (var n = e, i = 0; i < t.length; i += 1) {
        if (n == null)
            return;
        n = n[t[i]]
    }
    return n
}
function cS(e, t, n, i) {
    if (!t.length)
        return n;
    var r = FO(t), s = r[0], o = r.slice(1), a;
    return !e && typeof s == "number" ? a = [] : Array.isArray(e) ? a = Re(e) : a = be({}, e),
    i && n === void 0 && o.length === 1 ? delete a[s][o[0]] : a[s] = cS(a[s], o, n, i),
    a
}
function gi(e, t, n) {
    var i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
    return t.length && i && n === void 0 && !yi(e, t.slice(0, -1)) ? e : cS(e, t, n, i)
}
function IO(e) {
    return it(e) === "object" && e !== null && Object.getPrototypeOf(e) === Object.prototype
}
function m3(e) {
    return Array.isArray(e) ? [] : {}
}
var BO = typeof Reflect > "u" ? Object.keys : Reflect.ownKeys;
function Io() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    var i = m3(t[0]);
    return t.forEach(function(r) {
        function s(o, a) {
            var l = new Set(a)
              , c = yi(r, o)
              , u = Array.isArray(c);
            if (u || IO(c)) {
                if (!l.has(c)) {
                    l.add(c);
                    var h = yi(i, o);
                    u ? i = gi(i, o, []) : (!h || it(h) !== "object") && (i = gi(i, o, m3(c))),
                    BO(c).forEach(function(d) {
                        s([].concat(Re(o), [d]), l)
                    })
                }
            } else
                i = gi(i, o, c)
        }
        s([])
    }),
    i
}
function zO() {}
const VO = M.createContext({})
  , WO = ()=>{
    const e = ()=>{}
    ;
    return e.deprecated = zO,
    e
}
  , HO = M.createContext(void 0)
  , UO = {
    items_per_page: "/ page",
    jump_to: "Go to",
    jump_to_confirm: "confirm",
    page: "Page",
    prev_page: "Previous Page",
    next_page: "Next Page",
    prev_5: "Previous 5 Pages",
    next_5: "Next 5 Pages",
    prev_3: "Previous 3 Pages",
    next_3: "Next 3 Pages",
    page_size: "Page Size"
};
var GO = {
    locale: "en_US",
    today: "Today",
    now: "Now",
    backToToday: "Back to today",
    ok: "OK",
    clear: "Clear",
    month: "Month",
    year: "Year",
    timeSelect: "select time",
    dateSelect: "select date",
    weekSelect: "Choose a week",
    monthSelect: "Choose a month",
    yearSelect: "Choose a year",
    decadeSelect: "Choose a decade",
    yearFormat: "YYYY",
    dateFormat: "M/D/YYYY",
    dayFormat: "D",
    dateTimeFormat: "M/D/YYYY HH:mm:ss",
    monthBeforeYear: !0,
    previousMonth: "Previous month (PageUp)",
    nextMonth: "Next month (PageDown)",
    previousYear: "Last year (Control + left)",
    nextYear: "Next year (Control + right)",
    previousDecade: "Last decade",
    nextDecade: "Next decade",
    previousCentury: "Last century",
    nextCentury: "Next century"
};
const XO = {
    placeholder: "Select time",
    rangePlaceholder: ["Start time", "End time"]
}
  , uS = XO
  , YO = {
    lang: Object.assign({
        placeholder: "Select date",
        yearPlaceholder: "Select year",
        quarterPlaceholder: "Select quarter",
        monthPlaceholder: "Select month",
        weekPlaceholder: "Select week",
        rangePlaceholder: ["Start date", "End date"],
        rangeYearPlaceholder: ["Start year", "End year"],
        rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
        rangeMonthPlaceholder: ["Start month", "End month"],
        rangeWeekPlaceholder: ["Start week", "End week"]
    }, GO),
    timePickerLocale: Object.assign({}, uS)
}
  , v3 = YO
  , On = "${label} is not a valid ${type}"
  , $O = {
    locale: "en",
    Pagination: UO,
    DatePicker: v3,
    TimePicker: uS,
    Calendar: v3,
    global: {
        placeholder: "Please select"
    },
    Table: {
        filterTitle: "Filter menu",
        filterConfirm: "OK",
        filterReset: "Reset",
        filterEmptyText: "No filters",
        filterCheckall: "Select all items",
        filterSearchPlaceholder: "Search in filters",
        emptyText: "No data",
        selectAll: "Select current page",
        selectInvert: "Invert current page",
        selectNone: "Clear all data",
        selectionAll: "Select all data",
        sortTitle: "Sort",
        expand: "Expand row",
        collapse: "Collapse row",
        triggerDesc: "Click to sort descending",
        triggerAsc: "Click to sort ascending",
        cancelSort: "Click to cancel sorting"
    },
    Tour: {
        Next: "Next",
        Previous: "Previous",
        Finish: "Finish"
    },
    Modal: {
        okText: "OK",
        cancelText: "Cancel",
        justOkText: "OK"
    },
    Popconfirm: {
        okText: "OK",
        cancelText: "Cancel"
    },
    Transfer: {
        titles: ["", ""],
        searchPlaceholder: "Search here",
        itemUnit: "item",
        itemsUnit: "items",
        remove: "Remove",
        selectCurrent: "Select current page",
        removeCurrent: "Remove current page",
        selectAll: "Select all data",
        removeAll: "Remove all data",
        selectInvert: "Invert current page"
    },
    Upload: {
        uploading: "Uploading...",
        removeFile: "Remove file",
        uploadError: "Upload error",
        previewFile: "Preview file",
        downloadFile: "Download file"
    },
    Empty: {
        description: "No data"
    },
    Icon: {
        icon: "icon"
    },
    Text: {
        edit: "Edit",
        copy: "Copy",
        copied: "Copied",
        expand: "Expand"
    },
    PageHeader: {
        back: "Back"
    },
    Form: {
        optional: "(optional)",
        defaultValidateMessages: {
            default: "Field validation error for ${label}",
            required: "Please enter ${label}",
            enum: "${label} must be one of [${enum}]",
            whitespace: "${label} cannot be a blank character",
            date: {
                format: "${label} date format is invalid",
                parse: "${label} cannot be converted to a date",
                invalid: "${label} is an invalid date"
            },
            types: {
                string: On,
                method: On,
                array: On,
                object: On,
                number: On,
                date: On,
                boolean: On,
                integer: On,
                float: On,
                regexp: On,
                email: On,
                url: On,
                hex: On
            },
            string: {
                len: "${label} must be ${len} characters",
                min: "${label} must be at least ${min} characters",
                max: "${label} must be up to ${max} characters",
                range: "${label} must be between ${min}-${max} characters"
            },
            number: {
                len: "${label} must be equal to ${len}",
                min: "${label} must be minimum ${min}",
                max: "${label} must be maximum ${max}",
                range: "${label} must be between ${min}-${max}"
            },
            array: {
                len: "Must be ${len} ${label}",
                min: "At least ${min} ${label}",
                max: "At most ${max} ${label}",
                range: "The amount of ${label} must be between ${min}-${max}"
            },
            pattern: {
                mismatch: "${label} does not match the pattern ${pattern}"
            }
        }
    },
    Image: {
        preview: "Preview"
    },
    QRCode: {
        expired: "QR code expired",
        refresh: "Refresh"
    },
    ColorPicker: {
        presetEmpty: "Empty"
    }
}
  , $d = $O;
Object.assign({}, $d.Modal);
let Ju = [];
const y3 = ()=>Ju.reduce((e,t)=>Object.assign(Object.assign({}, e), t), $d.Modal);
function KO(e) {
    if (e) {
        const t = Object.assign({}, e);
        return Ju.push(t),
        y3(),
        ()=>{
            Ju = Ju.filter(n=>n !== t),
            y3()
        }
    }
    Object.assign({}, $d.Modal)
}
const QO = M.createContext(void 0)
  , hS = QO
  , qO = "internalMark"
  , ZO = e=>{
    const {locale: t={}, children: n, _ANT_MARK__: i} = e;
    M.useEffect(()=>KO(t && t.Modal), [t]);
    const r = M.useMemo(()=>Object.assign(Object.assign({}, t), {
        exist: !0
    }), [t]);
    return M.createElement(hS.Provider, {
        value: r
    }, n)
}
  , JO = ZO;
function en(e, t) {
    eL(e) && (e = "100%");
    var n = tL(e);
    return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))),
    n && (e = parseInt(String(e * t), 10) / 100),
    Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)),
    e)
}
function nu(e) {
    return Math.min(1, Math.max(0, e))
}
function eL(e) {
    return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1
}
function tL(e) {
    return typeof e == "string" && e.indexOf("%") !== -1
}
function dS(e) {
    return e = parseFloat(e),
    (isNaN(e) || e < 0 || e > 1) && (e = 1),
    e
}
function iu(e) {
    return e <= 1 ? "".concat(Number(e) * 100, "%") : e
}
function Rs(e) {
    return e.length === 1 ? "0" + e : String(e)
}
function nL(e, t, n) {
    return {
        r: en(e, 255) * 255,
        g: en(t, 255) * 255,
        b: en(n, 255) * 255
    }
}
function x3(e, t, n) {
    e = en(e, 255),
    t = en(t, 255),
    n = en(n, 255);
    var i = Math.max(e, t, n)
      , r = Math.min(e, t, n)
      , s = 0
      , o = 0
      , a = (i + r) / 2;
    if (i === r)
        o = 0,
        s = 0;
    else {
        var l = i - r;
        switch (o = a > .5 ? l / (2 - i - r) : l / (i + r),
        i) {
        case e:
            s = (t - n) / l + (t < n ? 6 : 0);
            break;
        case t:
            s = (n - e) / l + 2;
            break;
        case n:
            s = (e - t) / l + 4;
            break
        }
        s /= 6
    }
    return {
        h: s,
        s: o,
        l: a
    }
}
function r0(e, t, n) {
    return n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? e + (t - e) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
}
function iL(e, t, n) {
    var i, r, s;
    if (e = en(e, 360),
    t = en(t, 100),
    n = en(n, 100),
    t === 0)
        r = n,
        s = n,
        i = n;
    else {
        var o = n < .5 ? n * (1 + t) : n + t - n * t
          , a = 2 * n - o;
        i = r0(a, o, e + 1 / 3),
        r = r0(a, o, e),
        s = r0(a, o, e - 1 / 3)
    }
    return {
        r: i * 255,
        g: r * 255,
        b: s * 255
    }
}
function vp(e, t, n) {
    e = en(e, 255),
    t = en(t, 255),
    n = en(n, 255);
    var i = Math.max(e, t, n)
      , r = Math.min(e, t, n)
      , s = 0
      , o = i
      , a = i - r
      , l = i === 0 ? 0 : a / i;
    if (i === r)
        s = 0;
    else {
        switch (i) {
        case e:
            s = (t - n) / a + (t < n ? 6 : 0);
            break;
        case t:
            s = (n - e) / a + 2;
            break;
        case n:
            s = (e - t) / a + 4;
            break
        }
        s /= 6
    }
    return {
        h: s,
        s: l,
        v: o
    }
}
function rL(e, t, n) {
    e = en(e, 360) * 6,
    t = en(t, 100),
    n = en(n, 100);
    var i = Math.floor(e)
      , r = e - i
      , s = n * (1 - t)
      , o = n * (1 - r * t)
      , a = n * (1 - (1 - r) * t)
      , l = i % 6
      , c = [n, o, s, s, a, n][l]
      , u = [a, n, n, o, s, s][l]
      , h = [s, s, a, n, n, o][l];
    return {
        r: c * 255,
        g: u * 255,
        b: h * 255
    }
}
function yp(e, t, n, i) {
    var r = [Rs(Math.round(e).toString(16)), Rs(Math.round(t).toString(16)), Rs(Math.round(n).toString(16))];
    return i && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1)) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join("")
}
function sL(e, t, n, i, r) {
    var s = [Rs(Math.round(e).toString(16)), Rs(Math.round(t).toString(16)), Rs(Math.round(n).toString(16)), Rs(oL(i))];
    return r && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("")
}
function oL(e) {
    return Math.round(parseFloat(e) * 255).toString(16)
}
function b3(e) {
    return Rn(e) / 255
}
function Rn(e) {
    return parseInt(e, 16)
}
function aL(e) {
    return {
        r: e >> 16,
        g: (e & 65280) >> 8,
        b: e & 255
    }
}
var xp = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
};
function ko(e) {
    var t = {
        r: 0,
        g: 0,
        b: 0
    }
      , n = 1
      , i = null
      , r = null
      , s = null
      , o = !1
      , a = !1;
    return typeof e == "string" && (e = uL(e)),
    typeof e == "object" && (Gi(e.r) && Gi(e.g) && Gi(e.b) ? (t = nL(e.r, e.g, e.b),
    o = !0,
    a = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : Gi(e.h) && Gi(e.s) && Gi(e.v) ? (i = iu(e.s),
    r = iu(e.v),
    t = rL(e.h, i, r),
    o = !0,
    a = "hsv") : Gi(e.h) && Gi(e.s) && Gi(e.l) && (i = iu(e.s),
    s = iu(e.l),
    t = iL(e.h, i, s),
    o = !0,
    a = "hsl"),
    Object.prototype.hasOwnProperty.call(e, "a") && (n = e.a)),
    n = dS(n),
    {
        ok: o,
        format: e.format || a,
        r: Math.min(255, Math.max(t.r, 0)),
        g: Math.min(255, Math.max(t.g, 0)),
        b: Math.min(255, Math.max(t.b, 0)),
        a: n
    }
}
var lL = "[-\\+]?\\d+%?"
  , cL = "[-\\+]?\\d*\\.\\d+%?"
  , jr = "(?:".concat(cL, ")|(?:").concat(lL, ")")
  , s0 = "[\\s|\\(]+(".concat(jr, ")[,|\\s]+(").concat(jr, ")[,|\\s]+(").concat(jr, ")\\s*\\)?")
  , o0 = "[\\s|\\(]+(".concat(jr, ")[,|\\s]+(").concat(jr, ")[,|\\s]+(").concat(jr, ")[,|\\s]+(").concat(jr, ")\\s*\\)?")
  , di = {
    CSS_UNIT: new RegExp(jr),
    rgb: new RegExp("rgb" + s0),
    rgba: new RegExp("rgba" + o0),
    hsl: new RegExp("hsl" + s0),
    hsla: new RegExp("hsla" + o0),
    hsv: new RegExp("hsv" + s0),
    hsva: new RegExp("hsva" + o0),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function uL(e) {
    if (e = e.trim().toLowerCase(),
    e.length === 0)
        return !1;
    var t = !1;
    if (xp[e])
        e = xp[e],
        t = !0;
    else if (e === "transparent")
        return {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            format: "name"
        };
    var n = di.rgb.exec(e);
    return n ? {
        r: n[1],
        g: n[2],
        b: n[3]
    } : (n = di.rgba.exec(e),
    n ? {
        r: n[1],
        g: n[2],
        b: n[3],
        a: n[4]
    } : (n = di.hsl.exec(e),
    n ? {
        h: n[1],
        s: n[2],
        l: n[3]
    } : (n = di.hsla.exec(e),
    n ? {
        h: n[1],
        s: n[2],
        l: n[3],
        a: n[4]
    } : (n = di.hsv.exec(e),
    n ? {
        h: n[1],
        s: n[2],
        v: n[3]
    } : (n = di.hsva.exec(e),
    n ? {
        h: n[1],
        s: n[2],
        v: n[3],
        a: n[4]
    } : (n = di.hex8.exec(e),
    n ? {
        r: Rn(n[1]),
        g: Rn(n[2]),
        b: Rn(n[3]),
        a: b3(n[4]),
        format: t ? "name" : "hex8"
    } : (n = di.hex6.exec(e),
    n ? {
        r: Rn(n[1]),
        g: Rn(n[2]),
        b: Rn(n[3]),
        format: t ? "name" : "hex"
    } : (n = di.hex4.exec(e),
    n ? {
        r: Rn(n[1] + n[1]),
        g: Rn(n[2] + n[2]),
        b: Rn(n[3] + n[3]),
        a: b3(n[4] + n[4]),
        format: t ? "name" : "hex8"
    } : (n = di.hex3.exec(e),
    n ? {
        r: Rn(n[1] + n[1]),
        g: Rn(n[2] + n[2]),
        b: Rn(n[3] + n[3]),
        format: t ? "name" : "hex"
    } : !1)))))))))
}
function Gi(e) {
    return !!di.CSS_UNIT.exec(String(e))
}
var An = function() {
    function e(t, n) {
        t === void 0 && (t = ""),
        n === void 0 && (n = {});
        var i;
        if (t instanceof e)
            return t;
        typeof t == "number" && (t = aL(t)),
        this.originalInput = t;
        var r = ko(t);
        this.originalInput = t,
        this.r = r.r,
        this.g = r.g,
        this.b = r.b,
        this.a = r.a,
        this.roundA = Math.round(100 * this.a) / 100,
        this.format = (i = n.format) !== null && i !== void 0 ? i : r.format,
        this.gradientType = n.gradientType,
        this.r < 1 && (this.r = Math.round(this.r)),
        this.g < 1 && (this.g = Math.round(this.g)),
        this.b < 1 && (this.b = Math.round(this.b)),
        this.isValid = r.ok
    }
    return e.prototype.isDark = function() {
        return this.getBrightness() < 128
    }
    ,
    e.prototype.isLight = function() {
        return !this.isDark()
    }
    ,
    e.prototype.getBrightness = function() {
        var t = this.toRgb();
        return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3
    }
    ,
    e.prototype.getLuminance = function() {
        var t = this.toRgb(), n, i, r, s = t.r / 255, o = t.g / 255, a = t.b / 255;
        return s <= .03928 ? n = s / 12.92 : n = Math.pow((s + .055) / 1.055, 2.4),
        o <= .03928 ? i = o / 12.92 : i = Math.pow((o + .055) / 1.055, 2.4),
        a <= .03928 ? r = a / 12.92 : r = Math.pow((a + .055) / 1.055, 2.4),
        .2126 * n + .7152 * i + .0722 * r
    }
    ,
    e.prototype.getAlpha = function() {
        return this.a
    }
    ,
    e.prototype.setAlpha = function(t) {
        return this.a = dS(t),
        this.roundA = Math.round(100 * this.a) / 100,
        this
    }
    ,
    e.prototype.isMonochrome = function() {
        var t = this.toHsl().s;
        return t === 0
    }
    ,
    e.prototype.toHsv = function() {
        var t = vp(this.r, this.g, this.b);
        return {
            h: t.h * 360,
            s: t.s,
            v: t.v,
            a: this.a
        }
    }
    ,
    e.prototype.toHsvString = function() {
        var t = vp(this.r, this.g, this.b)
          , n = Math.round(t.h * 360)
          , i = Math.round(t.s * 100)
          , r = Math.round(t.v * 100);
        return this.a === 1 ? "hsv(".concat(n, ", ").concat(i, "%, ").concat(r, "%)") : "hsva(".concat(n, ", ").concat(i, "%, ").concat(r, "%, ").concat(this.roundA, ")")
    }
    ,
    e.prototype.toHsl = function() {
        var t = x3(this.r, this.g, this.b);
        return {
            h: t.h * 360,
            s: t.s,
            l: t.l,
            a: this.a
        }
    }
    ,
    e.prototype.toHslString = function() {
        var t = x3(this.r, this.g, this.b)
          , n = Math.round(t.h * 360)
          , i = Math.round(t.s * 100)
          , r = Math.round(t.l * 100);
        return this.a === 1 ? "hsl(".concat(n, ", ").concat(i, "%, ").concat(r, "%)") : "hsla(".concat(n, ", ").concat(i, "%, ").concat(r, "%, ").concat(this.roundA, ")")
    }
    ,
    e.prototype.toHex = function(t) {
        return t === void 0 && (t = !1),
        yp(this.r, this.g, this.b, t)
    }
    ,
    e.prototype.toHexString = function(t) {
        return t === void 0 && (t = !1),
        "#" + this.toHex(t)
    }
    ,
    e.prototype.toHex8 = function(t) {
        return t === void 0 && (t = !1),
        sL(this.r, this.g, this.b, this.a, t)
    }
    ,
    e.prototype.toHex8String = function(t) {
        return t === void 0 && (t = !1),
        "#" + this.toHex8(t)
    }
    ,
    e.prototype.toHexShortString = function(t) {
        return t === void 0 && (t = !1),
        this.a === 1 ? this.toHexString(t) : this.toHex8String(t)
    }
    ,
    e.prototype.toRgb = function() {
        return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
        }
    }
    ,
    e.prototype.toRgbString = function() {
        var t = Math.round(this.r)
          , n = Math.round(this.g)
          , i = Math.round(this.b);
        return this.a === 1 ? "rgb(".concat(t, ", ").concat(n, ", ").concat(i, ")") : "rgba(".concat(t, ", ").concat(n, ", ").concat(i, ", ").concat(this.roundA, ")")
    }
    ,
    e.prototype.toPercentageRgb = function() {
        var t = function(n) {
            return "".concat(Math.round(en(n, 255) * 100), "%")
        };
        return {
            r: t(this.r),
            g: t(this.g),
            b: t(this.b),
            a: this.a
        }
    }
    ,
    e.prototype.toPercentageRgbString = function() {
        var t = function(n) {
            return Math.round(en(n, 255) * 100)
        };
        return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")")
    }
    ,
    e.prototype.toName = function() {
        if (this.a === 0)
            return "transparent";
        if (this.a < 1)
            return !1;
        for (var t = "#" + yp(this.r, this.g, this.b, !1), n = 0, i = Object.entries(xp); n < i.length; n++) {
            var r = i[n]
              , s = r[0]
              , o = r[1];
            if (t === o)
                return s
        }
        return !1
    }
    ,
    e.prototype.toString = function(t) {
        var n = !!t;
        t = t ?? this.format;
        var i = !1
          , r = this.a < 1 && this.a >= 0
          , s = !n && r && (t.startsWith("hex") || t === "name");
        return s ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (i = this.toRgbString()),
        t === "prgb" && (i = this.toPercentageRgbString()),
        (t === "hex" || t === "hex6") && (i = this.toHexString()),
        t === "hex3" && (i = this.toHexString(!0)),
        t === "hex4" && (i = this.toHex8String(!0)),
        t === "hex8" && (i = this.toHex8String()),
        t === "name" && (i = this.toName()),
        t === "hsl" && (i = this.toHslString()),
        t === "hsv" && (i = this.toHsvString()),
        i || this.toHexString())
    }
    ,
    e.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
    }
    ,
    e.prototype.clone = function() {
        return new e(this.toString())
    }
    ,
    e.prototype.lighten = function(t) {
        t === void 0 && (t = 10);
        var n = this.toHsl();
        return n.l += t / 100,
        n.l = nu(n.l),
        new e(n)
    }
    ,
    e.prototype.brighten = function(t) {
        t === void 0 && (t = 10);
        var n = this.toRgb();
        return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100)))),
        n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100)))),
        n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100)))),
        new e(n)
    }
    ,
    e.prototype.darken = function(t) {
        t === void 0 && (t = 10);
        var n = this.toHsl();
        return n.l -= t / 100,
        n.l = nu(n.l),
        new e(n)
    }
    ,
    e.prototype.tint = function(t) {
        return t === void 0 && (t = 10),
        this.mix("white", t)
    }
    ,
    e.prototype.shade = function(t) {
        return t === void 0 && (t = 10),
        this.mix("black", t)
    }
    ,
    e.prototype.desaturate = function(t) {
        t === void 0 && (t = 10);
        var n = this.toHsl();
        return n.s -= t / 100,
        n.s = nu(n.s),
        new e(n)
    }
    ,
    e.prototype.saturate = function(t) {
        t === void 0 && (t = 10);
        var n = this.toHsl();
        return n.s += t / 100,
        n.s = nu(n.s),
        new e(n)
    }
    ,
    e.prototype.greyscale = function() {
        return this.desaturate(100)
    }
    ,
    e.prototype.spin = function(t) {
        var n = this.toHsl()
          , i = (n.h + t) % 360;
        return n.h = i < 0 ? 360 + i : i,
        new e(n)
    }
    ,
    e.prototype.mix = function(t, n) {
        n === void 0 && (n = 50);
        var i = this.toRgb()
          , r = new e(t).toRgb()
          , s = n / 100
          , o = {
            r: (r.r - i.r) * s + i.r,
            g: (r.g - i.g) * s + i.g,
            b: (r.b - i.b) * s + i.b,
            a: (r.a - i.a) * s + i.a
        };
        return new e(o)
    }
    ,
    e.prototype.analogous = function(t, n) {
        t === void 0 && (t = 6),
        n === void 0 && (n = 30);
        var i = this.toHsl()
          , r = 360 / n
          , s = [this];
        for (i.h = (i.h - (r * t >> 1) + 720) % 360; --t; )
            i.h = (i.h + r) % 360,
            s.push(new e(i));
        return s
    }
    ,
    e.prototype.complement = function() {
        var t = this.toHsl();
        return t.h = (t.h + 180) % 360,
        new e(t)
    }
    ,
    e.prototype.monochromatic = function(t) {
        t === void 0 && (t = 6);
        for (var n = this.toHsv(), i = n.h, r = n.s, s = n.v, o = [], a = 1 / t; t--; )
            o.push(new e({
                h: i,
                s: r,
                v: s
            })),
            s = (s + a) % 1;
        return o
    }
    ,
    e.prototype.splitcomplement = function() {
        var t = this.toHsl()
          , n = t.h;
        return [this, new e({
            h: (n + 72) % 360,
            s: t.s,
            l: t.l
        }), new e({
            h: (n + 216) % 360,
            s: t.s,
            l: t.l
        })]
    }
    ,
    e.prototype.onBackground = function(t) {
        var n = this.toRgb()
          , i = new e(t).toRgb()
          , r = n.a + i.a * (1 - n.a);
        return new e({
            r: (n.r * n.a + i.r * i.a * (1 - n.a)) / r,
            g: (n.g * n.a + i.g * i.a * (1 - n.a)) / r,
            b: (n.b * n.a + i.b * i.a * (1 - n.a)) / r,
            a: r
        })
    }
    ,
    e.prototype.triad = function() {
        return this.polyad(3)
    }
    ,
    e.prototype.tetrad = function() {
        return this.polyad(4)
    }
    ,
    e.prototype.polyad = function(t) {
        for (var n = this.toHsl(), i = n.h, r = [this], s = 360 / t, o = 1; o < t; o++)
            r.push(new e({
                h: (i + o * s) % 360,
                s: n.s,
                l: n.l
            }));
        return r
    }
    ,
    e.prototype.equals = function(t) {
        return this.toRgbString() === new e(t).toRgbString()
    }
    ,
    e
}()
  , ru = 2
  , w3 = .16
  , hL = .05
  , dL = .05
  , fL = .15
  , fS = 5
  , pS = 4
  , pL = [{
    index: 7,
    opacity: .15
}, {
    index: 6,
    opacity: .25
}, {
    index: 5,
    opacity: .3
}, {
    index: 5,
    opacity: .45
}, {
    index: 5,
    opacity: .65
}, {
    index: 5,
    opacity: .85
}, {
    index: 4,
    opacity: .9
}, {
    index: 3,
    opacity: .95
}, {
    index: 2,
    opacity: .97
}, {
    index: 1,
    opacity: .98
}];
function S3(e) {
    var t = e.r
      , n = e.g
      , i = e.b
      , r = vp(t, n, i);
    return {
        h: r.h * 360,
        s: r.s,
        v: r.v
    }
}
function su(e) {
    var t = e.r
      , n = e.g
      , i = e.b;
    return "#".concat(yp(t, n, i, !1))
}
function gL(e, t, n) {
    var i = n / 100
      , r = {
        r: (t.r - e.r) * i + e.r,
        g: (t.g - e.g) * i + e.g,
        b: (t.b - e.b) * i + e.b
    };
    return r
}
function C3(e, t, n) {
    var i;
    return Math.round(e.h) >= 60 && Math.round(e.h) <= 240 ? i = n ? Math.round(e.h) - ru * t : Math.round(e.h) + ru * t : i = n ? Math.round(e.h) + ru * t : Math.round(e.h) - ru * t,
    i < 0 ? i += 360 : i >= 360 && (i -= 360),
    i
}
function k3(e, t, n) {
    if (e.h === 0 && e.s === 0)
        return e.s;
    var i;
    return n ? i = e.s - w3 * t : t === pS ? i = e.s + w3 : i = e.s + hL * t,
    i > 1 && (i = 1),
    n && t === fS && i > .1 && (i = .1),
    i < .06 && (i = .06),
    Number(i.toFixed(2))
}
function A3(e, t, n) {
    var i;
    return n ? i = e.v + dL * t : i = e.v - fL * t,
    i > 1 && (i = 1),
    Number(i.toFixed(2))
}
function da(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = [], i = ko(e), r = fS; r > 0; r -= 1) {
        var s = S3(i)
          , o = su(ko({
            h: C3(s, r, !0),
            s: k3(s, r, !0),
            v: A3(s, r, !0)
        }));
        n.push(o)
    }
    n.push(su(i));
    for (var a = 1; a <= pS; a += 1) {
        var l = S3(i)
          , c = su(ko({
            h: C3(l, a),
            s: k3(l, a),
            v: A3(l, a)
        }));
        n.push(c)
    }
    return t.theme === "dark" ? pL.map(function(u) {
        var h = u.index
          , d = u.opacity
          , m = su(gL(ko(t.backgroundColor || "#141414"), ko(n[h]), d * 100));
        return m
    }) : n
}
var a0 = {
    red: "#F5222D",
    volcano: "#FA541C",
    orange: "#FA8C16",
    gold: "#FAAD14",
    yellow: "#FADB14",
    lime: "#A0D911",
    green: "#52C41A",
    cyan: "#13C2C2",
    blue: "#1677FF",
    geekblue: "#2F54EB",
    purple: "#722ED1",
    magenta: "#EB2F96",
    grey: "#666666"
}
  , l0 = {}
  , c0 = {};
Object.keys(a0).forEach(function(e) {
    l0[e] = da(a0[e]),
    l0[e].primary = l0[e][5],
    c0[e] = da(a0[e], {
        theme: "dark",
        backgroundColor: "#141414"
    }),
    c0[e].primary = c0[e][5]
});
const mL = e=>{
    const {controlHeight: t} = e;
    return {
        controlHeightSM: t * .75,
        controlHeightXS: t * .5,
        controlHeightLG: t * 1.25
    }
}
  , vL = mL;
function yL(e) {
    const {sizeUnit: t, sizeStep: n} = e;
    return {
        sizeXXL: t * (n + 8),
        sizeXL: t * (n + 4),
        sizeLG: t * (n + 2),
        sizeMD: t * (n + 1),
        sizeMS: t * n,
        size: t * n,
        sizeSM: t * (n - 1),
        sizeXS: t * (n - 2),
        sizeXXS: t * (n - 3)
    }
}
const gS = {
    blue: "#1677ff",
    purple: "#722ED1",
    cyan: "#13C2C2",
    green: "#52C41A",
    magenta: "#EB2F96",
    pink: "#eb2f96",
    red: "#F5222D",
    orange: "#FA8C16",
    yellow: "#FADB14",
    volcano: "#FA541C",
    geekblue: "#2F54EB",
    gold: "#FAAD14",
    lime: "#A0D911"
}
  , xL = Object.assign(Object.assign({}, gS), {
    colorPrimary: "#1677ff",
    colorSuccess: "#52c41a",
    colorWarning: "#faad14",
    colorError: "#ff4d4f",
    colorInfo: "#1677ff",
    colorLink: "",
    colorTextBase: "",
    colorBgBase: "",
    fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
    fontFamilyCode: "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
    fontSize: 14,
    lineWidth: 1,
    lineType: "solid",
    motionUnit: .1,
    motionBase: 0,
    motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
    motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
    motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
    motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
    motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
    borderRadius: 6,
    sizeUnit: 4,
    sizeStep: 4,
    sizePopupArrow: 16,
    controlHeight: 32,
    zIndexBase: 0,
    zIndexPopupBase: 1e3,
    opacityImage: 1,
    wireframe: !1,
    motion: !0
})
  , Gl = xL;
function bL(e, t) {
    let {generateColorPalettes: n, generateNeutralColorPalettes: i} = t;
    const {colorSuccess: r, colorWarning: s, colorError: o, colorInfo: a, colorPrimary: l, colorBgBase: c, colorTextBase: u} = e
      , h = n(l)
      , d = n(r)
      , m = n(s)
      , f = n(o)
      , x = n(a)
      , S = i(c, u)
      , v = e.colorLink || e.colorInfo
      , p = n(v);
    return Object.assign(Object.assign({}, S), {
        colorPrimaryBg: h[1],
        colorPrimaryBgHover: h[2],
        colorPrimaryBorder: h[3],
        colorPrimaryBorderHover: h[4],
        colorPrimaryHover: h[5],
        colorPrimary: h[6],
        colorPrimaryActive: h[7],
        colorPrimaryTextHover: h[8],
        colorPrimaryText: h[9],
        colorPrimaryTextActive: h[10],
        colorSuccessBg: d[1],
        colorSuccessBgHover: d[2],
        colorSuccessBorder: d[3],
        colorSuccessBorderHover: d[4],
        colorSuccessHover: d[4],
        colorSuccess: d[6],
        colorSuccessActive: d[7],
        colorSuccessTextHover: d[8],
        colorSuccessText: d[9],
        colorSuccessTextActive: d[10],
        colorErrorBg: f[1],
        colorErrorBgHover: f[2],
        colorErrorBorder: f[3],
        colorErrorBorderHover: f[4],
        colorErrorHover: f[5],
        colorError: f[6],
        colorErrorActive: f[7],
        colorErrorTextHover: f[8],
        colorErrorText: f[9],
        colorErrorTextActive: f[10],
        colorWarningBg: m[1],
        colorWarningBgHover: m[2],
        colorWarningBorder: m[3],
        colorWarningBorderHover: m[4],
        colorWarningHover: m[4],
        colorWarning: m[6],
        colorWarningActive: m[7],
        colorWarningTextHover: m[8],
        colorWarningText: m[9],
        colorWarningTextActive: m[10],
        colorInfoBg: x[1],
        colorInfoBgHover: x[2],
        colorInfoBorder: x[3],
        colorInfoBorderHover: x[4],
        colorInfoHover: x[4],
        colorInfo: x[6],
        colorInfoActive: x[7],
        colorInfoTextHover: x[8],
        colorInfoText: x[9],
        colorInfoTextActive: x[10],
        colorLinkHover: p[4],
        colorLink: p[6],
        colorLinkActive: p[7],
        colorBgMask: new An("#000").setAlpha(.45).toRgbString(),
        colorWhite: "#fff"
    })
}
const wL = e=>{
    let t = e
      , n = e
      , i = e
      , r = e;
    return e < 6 && e >= 5 ? t = e + 1 : e < 16 && e >= 6 ? t = e + 2 : e >= 16 && (t = 16),
    e < 7 && e >= 5 ? n = 4 : e < 8 && e >= 7 ? n = 5 : e < 14 && e >= 8 ? n = 6 : e < 16 && e >= 14 ? n = 7 : e >= 16 && (n = 8),
    e < 6 && e >= 2 ? i = 1 : e >= 6 && (i = 2),
    e > 4 && e < 8 ? r = 4 : e >= 8 && (r = 6),
    {
        borderRadius: e,
        borderRadiusXS: i,
        borderRadiusSM: n,
        borderRadiusLG: t,
        borderRadiusOuter: r
    }
}
  , SL = wL;
function CL(e) {
    const {motionUnit: t, motionBase: n, borderRadius: i, lineWidth: r} = e;
    return Object.assign({
        motionDurationFast: `${(n + t).toFixed(1)}s`,
        motionDurationMid: `${(n + t * 2).toFixed(1)}s`,
        motionDurationSlow: `${(n + t * 3).toFixed(1)}s`,
        lineWidthBold: r + 1
    }, SL(i))
}
const Xi = (e,t)=>new An(e).setAlpha(t).toRgbString()
  , Fa = (e,t)=>new An(e).darken(t).toHexString()
  , kL = e=>{
    const t = da(e);
    return {
        1: t[0],
        2: t[1],
        3: t[2],
        4: t[3],
        5: t[4],
        6: t[5],
        7: t[6],
        8: t[4],
        9: t[5],
        10: t[6]
    }
}
  , AL = (e,t)=>{
    const n = e || "#fff"
      , i = t || "#000";
    return {
        colorBgBase: n,
        colorTextBase: i,
        colorText: Xi(i, .88),
        colorTextSecondary: Xi(i, .65),
        colorTextTertiary: Xi(i, .45),
        colorTextQuaternary: Xi(i, .25),
        colorFill: Xi(i, .15),
        colorFillSecondary: Xi(i, .06),
        colorFillTertiary: Xi(i, .04),
        colorFillQuaternary: Xi(i, .02),
        colorBgLayout: Fa(n, 4),
        colorBgContainer: Fa(n, 0),
        colorBgElevated: Fa(n, 0),
        colorBgSpotlight: Xi(i, .85),
        colorBgBlur: "transparent",
        colorBorder: Fa(n, 15),
        colorBorderSecondary: Fa(n, 6)
    }
}
;
function ML(e) {
    const t = new Array(10).fill(null).map((n,i)=>{
        const r = i - 1
          , s = e * Math.pow(2.71828, r / 5)
          , o = i > 1 ? Math.floor(s) : Math.ceil(s);
        return Math.floor(o / 2) * 2
    }
    );
    return t[1] = e,
    t.map(n=>{
        const i = n + 8;
        return {
            size: n,
            lineHeight: i / n
        }
    }
    )
}
const EL = e=>{
    const t = ML(e)
      , n = t.map(r=>r.size)
      , i = t.map(r=>r.lineHeight);
    return {
        fontSizeSM: n[0],
        fontSize: n[1],
        fontSizeLG: n[2],
        fontSizeXL: n[3],
        fontSizeHeading1: n[6],
        fontSizeHeading2: n[5],
        fontSizeHeading3: n[4],
        fontSizeHeading4: n[3],
        fontSizeHeading5: n[2],
        lineHeight: i[1],
        lineHeightLG: i[2],
        lineHeightSM: i[0],
        lineHeightHeading1: i[6],
        lineHeightHeading2: i[5],
        lineHeightHeading3: i[4],
        lineHeightHeading4: i[3],
        lineHeightHeading5: i[2]
    }
}
  , PL = EL;
function TL(e) {
    const t = Object.keys(gS).map(n=>{
        const i = da(e[n]);
        return new Array(10).fill(1).reduce((r,s,o)=>(r[`${n}-${o + 1}`] = i[o],
        r[`${n}${o + 1}`] = i[o],
        r), {})
    }
    ).reduce((n,i)=>(n = Object.assign(Object.assign({}, n), i),
    n), {});
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, e), t), bL(e, {
        generateColorPalettes: kL,
        generateNeutralColorPalettes: AL
    })), PL(e.fontSize)), yL(e)), vL(e)), CL(e))
}
const mS = dp(TL)
  , vS = {
    token: Gl,
    override: {
        override: Gl
    },
    hashed: !0
}
  , yS = Ce.createContext(vS)
  , xS = "anticon"
  , jL = (e,t)=>t || (e ? `ant-${e}` : "ant")
  , Xn = M.createContext({
    getPrefixCls: jL,
    iconPrefixCls: xS
})
  , OL = `-ant-${Date.now()}-${Math.random()}`;
function LL(e, t) {
    const n = {}
      , i = (o,a)=>{
        let l = o.clone();
        return l = (a == null ? void 0 : a(l)) || l,
        l.toRgbString()
    }
      , r = (o,a)=>{
        const l = new An(o)
          , c = da(l.toRgbString());
        n[`${a}-color`] = i(l),
        n[`${a}-color-disabled`] = c[1],
        n[`${a}-color-hover`] = c[4],
        n[`${a}-color-active`] = c[6],
        n[`${a}-color-outline`] = l.clone().setAlpha(.2).toRgbString(),
        n[`${a}-color-deprecated-bg`] = c[0],
        n[`${a}-color-deprecated-border`] = c[2]
    }
    ;
    if (t.primaryColor) {
        r(t.primaryColor, "primary");
        const o = new An(t.primaryColor)
          , a = da(o.toRgbString());
        a.forEach((c,u)=>{
            n[`primary-${u + 1}`] = c
        }
        ),
        n["primary-color-deprecated-l-35"] = i(o, c=>c.lighten(35)),
        n["primary-color-deprecated-l-20"] = i(o, c=>c.lighten(20)),
        n["primary-color-deprecated-t-20"] = i(o, c=>c.tint(20)),
        n["primary-color-deprecated-t-50"] = i(o, c=>c.tint(50)),
        n["primary-color-deprecated-f-12"] = i(o, c=>c.setAlpha(c.getAlpha() * .12));
        const l = new An(a[0]);
        n["primary-color-active-deprecated-f-30"] = i(l, c=>c.setAlpha(c.getAlpha() * .3)),
        n["primary-color-active-deprecated-d-02"] = i(l, c=>c.darken(2))
    }
    return t.successColor && r(t.successColor, "success"),
    t.warningColor && r(t.warningColor, "warning"),
    t.errorColor && r(t.errorColor, "error"),
    t.infoColor && r(t.infoColor, "info"),
    `
  :root {
    ${Object.keys(n).map(o=>`--${e}-${o}: ${n[o]};`).join(`
`)}
  }
  `.trim()
}
function RL(e, t) {
    const n = LL(e, t);
    Tn() && Wl(n, `${OL}-dynamic-theme`)
}
const bp = M.createContext(!1)
  , _L = e=>{
    let {children: t, disabled: n} = e;
    const i = M.useContext(bp);
    return M.createElement(bp.Provider, {
        value: n ?? i
    }, t)
}
  , w2 = bp
  , wp = M.createContext(void 0)
  , DL = e=>{
    let {children: t, size: n} = e;
    const i = M.useContext(wp);
    return M.createElement(wp.Provider, {
        value: n || i
    }, t)
}
  , S2 = wp;
function NL() {
    const e = M.useContext(w2)
      , t = M.useContext(S2);
    return {
        componentDisabled: e,
        componentSize: t
    }
}
const Wh = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"]
  , FL = "5.11.5";
function u0(e) {
    return e >= 0 && e <= 255
}
function ou(e, t) {
    const {r: n, g: i, b: r, a: s} = new An(e).toRgb();
    if (s < 1)
        return e;
    const {r: o, g: a, b: l} = new An(t).toRgb();
    for (let c = .01; c <= 1; c += .01) {
        const u = Math.round((n - o * (1 - c)) / c)
          , h = Math.round((i - a * (1 - c)) / c)
          , d = Math.round((r - l * (1 - c)) / c);
        if (u0(u) && u0(h) && u0(d))
            return new An({
                r: u,
                g: h,
                b: d,
                a: Math.round(c * 100) / 100
            }).toRgbString()
    }
    return new An({
        r: n,
        g: i,
        b: r,
        a: 1
    }).toRgbString()
}
var IL = function(e, t) {
    var n = {};
    for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++)
            t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
    return n
};
function bS(e) {
    const {override: t} = e
      , n = IL(e, ["override"])
      , i = Object.assign({}, t);
    Object.keys(Gl).forEach(d=>{
        delete i[d]
    }
    );
    const r = Object.assign(Object.assign({}, n), i)
      , s = 480
      , o = 576
      , a = 768
      , l = 992
      , c = 1200
      , u = 1600;
    if (r.motion === !1) {
        const d = "0s";
        r.motionDurationFast = d,
        r.motionDurationMid = d,
        r.motionDurationSlow = d
    }
    return Object.assign(Object.assign(Object.assign({}, r), {
        colorFillContent: r.colorFillSecondary,
        colorFillContentHover: r.colorFill,
        colorFillAlter: r.colorFillQuaternary,
        colorBgContainerDisabled: r.colorFillTertiary,
        colorBorderBg: r.colorBgContainer,
        colorSplit: ou(r.colorBorderSecondary, r.colorBgContainer),
        colorTextPlaceholder: r.colorTextQuaternary,
        colorTextDisabled: r.colorTextQuaternary,
        colorTextHeading: r.colorText,
        colorTextLabel: r.colorTextSecondary,
        colorTextDescription: r.colorTextTertiary,
        colorTextLightSolid: r.colorWhite,
        colorHighlight: r.colorError,
        colorBgTextHover: r.colorFillSecondary,
        colorBgTextActive: r.colorFill,
        colorIcon: r.colorTextTertiary,
        colorIconHover: r.colorText,
        colorErrorOutline: ou(r.colorErrorBg, r.colorBgContainer),
        colorWarningOutline: ou(r.colorWarningBg, r.colorBgContainer),
        fontSizeIcon: r.fontSizeSM,
        lineWidthFocus: r.lineWidth * 4,
        lineWidth: r.lineWidth,
        controlOutlineWidth: r.lineWidth * 2,
        controlInteractiveSize: r.controlHeight / 2,
        controlItemBgHover: r.colorFillTertiary,
        controlItemBgActive: r.colorPrimaryBg,
        controlItemBgActiveHover: r.colorPrimaryBgHover,
        controlItemBgActiveDisabled: r.colorFill,
        controlTmpOutline: r.colorFillQuaternary,
        controlOutline: ou(r.colorPrimaryBg, r.colorBgContainer),
        lineType: r.lineType,
        borderRadius: r.borderRadius,
        borderRadiusXS: r.borderRadiusXS,
        borderRadiusSM: r.borderRadiusSM,
        borderRadiusLG: r.borderRadiusLG,
        fontWeightStrong: 600,
        opacityLoading: .65,
        linkDecoration: "none",
        linkHoverDecoration: "none",
        linkFocusDecoration: "none",
        controlPaddingHorizontal: 12,
        controlPaddingHorizontalSM: 8,
        paddingXXS: r.sizeXXS,
        paddingXS: r.sizeXS,
        paddingSM: r.sizeSM,
        padding: r.size,
        paddingMD: r.sizeMD,
        paddingLG: r.sizeLG,
        paddingXL: r.sizeXL,
        paddingContentHorizontalLG: r.sizeLG,
        paddingContentVerticalLG: r.sizeMS,
        paddingContentHorizontal: r.sizeMS,
        paddingContentVertical: r.sizeSM,
        paddingContentHorizontalSM: r.size,
        paddingContentVerticalSM: r.sizeXS,
        marginXXS: r.sizeXXS,
        marginXS: r.sizeXS,
        marginSM: r.sizeSM,
        margin: r.size,
        marginMD: r.sizeMD,
        marginLG: r.sizeLG,
        marginXL: r.sizeXL,
        marginXXL: r.sizeXXL,
        boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
        screenXS: s,
        screenXSMin: s,
        screenXSMax: o - 1,
        screenSM: o,
        screenSMMin: o,
        screenSMMax: a - 1,
        screenMD: a,
        screenMDMin: a,
        screenMDMax: l - 1,
        screenLG: l,
        screenLGMin: l,
        screenLGMax: c - 1,
        screenXL: c,
        screenXLMin: c,
        screenXLMax: u - 1,
        screenXXL: u,
        screenXXLMin: u,
        boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
        boxShadowCard: `
      0 1px 2px -2px ${new An("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new An("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new An("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
        boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
    }), i)
}
var M3 = function(e, t) {
    var n = {};
    for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++)
            t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
    return n
};
const wS = (e,t,n)=>{
    const i = n.getDerivativeToken(e)
      , {override: r} = t
      , s = M3(t, ["override"]);
    let o = Object.assign(Object.assign({}, i), {
        override: r
    });
    return o = bS(o),
    s && Object.entries(s).forEach(a=>{
        let[l,c] = a;
        const {theme: u} = c
          , h = M3(c, ["theme"]);
        let d = h;
        u && (d = wS(Object.assign(Object.assign({}, o), h), {
            override: h
        }, u)),
        o[l] = d
    }
    ),
    o
}
;
function no() {
    const {token: e, hashed: t, theme: n, override: i} = Ce.useContext(yS)
      , r = `${FL}-${t || ""}`
      , s = n || mS
      , [o,a] = aO(s, [Gl, e], {
        salt: r,
        override: i,
        getComputedToken: wS,
        formatToken: bS
    });
    return [s, o, t ? a : ""]
}
function Ri(e) {
    var t = M.useRef();
    t.current = e;
    var n = M.useCallback(function() {
        for (var i, r = arguments.length, s = new Array(r), o = 0; o < r; o++)
            s[o] = arguments[o];
        return (i = t.current) === null || i === void 0 ? void 0 : i.call.apply(i, [t].concat(s))
    }, []);
    return n
}
function Zo(e) {
    var t = M.useRef(!1)
      , n = M.useState(e)
      , i = Me(n, 2)
      , r = i[0]
      , s = i[1];
    M.useEffect(function() {
        return t.current = !1,
        function() {
            t.current = !0
        }
    }, []);
    function o(a, l) {
        l && t.current || s(a)
    }
    return [r, o]
}
function h0(e) {
    return e !== void 0
}
function C2(e, t) {
    var n = t || {}
      , i = n.defaultValue
      , r = n.value
      , s = n.onChange
      , o = n.postState
      , a = Zo(function() {
        return h0(r) ? r : h0(i) ? typeof i == "function" ? i() : i : typeof e == "function" ? e() : e
    })
      , l = Me(a, 2)
      , c = l[0]
      , u = l[1]
      , h = r !== void 0 ? r : c
      , d = o ? o(h) : h
      , m = Ri(s)
      , f = Zo([h])
      , x = Me(f, 2)
      , S = x[0]
      , v = x[1];
    c3(function() {
        var g = S[0];
        c !== g && m(c, g)
    }, [S]),
    c3(function() {
        h0(r) || u(r)
    }, [r]);
    var p = Ri(function(g, C) {
        u(g, C),
        v([h], C)
    });
    return [d, p]
}
const BL = (e,t,n,i,r)=>{
    const s = e / 2
      , o = 0
      , a = s
      , l = n * 1 / Math.sqrt(2)
      , c = s - n * (1 - 1 / Math.sqrt(2))
      , u = s - t * (1 / Math.sqrt(2))
      , h = n * (Math.sqrt(2) - 1) + t * (1 / Math.sqrt(2))
      , d = 2 * s - u
      , m = h
      , f = 2 * s - l
      , x = c
      , S = 2 * s - o
      , v = a
      , p = s * Math.sqrt(2) + n * (Math.sqrt(2) - 2)
      , g = n * (Math.sqrt(2) - 1);
    return {
        pointerEvents: "none",
        width: e,
        height: e,
        overflow: "hidden",
        "&::before": {
            position: "absolute",
            bottom: 0,
            insetInlineStart: 0,
            width: e,
            height: e / 2,
            background: i,
            clipPath: {
                _multi_value_: !0,
                value: [`polygon(${g}px 100%, 50% ${g}px, ${2 * s - g}px 100%, ${g}px 100%)`, `path('M ${o} ${a} A ${n} ${n} 0 0 0 ${l} ${c} L ${u} ${h} A ${t} ${t} 0 0 1 ${d} ${m} L ${f} ${x} A ${n} ${n} 0 0 0 ${S} ${v} Z')`]
            },
            content: '""'
        },
        "&::after": {
            content: '""',
            position: "absolute",
            width: p,
            height: p,
            bottom: 0,
            insetInline: 0,
            margin: "auto",
            borderRadius: {
                _skip_check_: !0,
                value: `0 0 ${t}px 0`
            },
            transform: "translateY(50%) rotate(-135deg)",
            boxShadow: r,
            zIndex: 0,
            background: "transparent"
        }
    }
}
  , fl = function(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return {
        boxSizing: "border-box",
        margin: 0,
        padding: 0,
        color: e.colorText,
        fontSize: e.fontSize,
        lineHeight: e.lineHeight,
        listStyle: "none",
        fontFamily: t ? "inherit" : e.fontFamily
    }
}
  , zL = ()=>({
    display: "inline-flex",
    alignItems: "center",
    color: "inherit",
    fontStyle: "normal",
    lineHeight: 0,
    textAlign: "center",
    textTransform: "none",
    verticalAlign: "-0.125em",
    textRendering: "optimizeLegibility",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "> *": {
        lineHeight: 1
    },
    svg: {
        display: "inline-block"
    }
})
  , VL = e=>({
    a: {
        color: e.colorLink,
        textDecoration: e.linkDecoration,
        backgroundColor: "transparent",
        outline: "none",
        cursor: "pointer",
        transition: `color ${e.motionDurationSlow}`,
        "-webkit-text-decoration-skip": "objects",
        "&:hover": {
            color: e.colorLinkHover
        },
        "&:active": {
            color: e.colorLinkActive
        },
        "&:active,\n  &:hover": {
            textDecoration: e.linkHoverDecoration,
            outline: 0
        },
        "&:focus": {
            textDecoration: e.linkFocusDecoration,
            outline: 0
        },
        "&[disabled]": {
            color: e.colorTextDisabled,
            cursor: "not-allowed"
        }
    }
})
  , WL = (e,t)=>{
    const {fontFamily: n, fontSize: i} = e
      , r = `[class^="${t}"], [class*=" ${t}"]`;
    return {
        [r]: {
            fontFamily: n,
            fontSize: i,
            boxSizing: "border-box",
            "&::before, &::after": {
                boxSizing: "border-box"
            },
            [r]: {
                boxSizing: "border-box",
                "&::before, &::after": {
                    boxSizing: "border-box"
                }
            }
        }
    }
}
  , HL = e=>({
    outline: `${e.lineWidthFocus}px solid ${e.colorPrimaryBorder}`,
    outlineOffset: 1,
    transition: "outline-offset 0s, outline 0s"
})
  , SS = typeof CSSINJS_STATISTIC < "u";
let Sp = !0;
function qs() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    if (!SS)
        return Object.assign.apply(Object, [{}].concat(t));
    Sp = !1;
    const i = {};
    return t.forEach(r=>{
        Object.keys(r).forEach(o=>{
            Object.defineProperty(i, o, {
                configurable: !0,
                enumerable: !0,
                get: ()=>r[o]
            })
        }
        )
    }
    ),
    Sp = !0,
    i
}
const E3 = {};
function UL() {}
function GL(e) {
    let t, n = e, i = UL;
    return SS && typeof Proxy < "u" && (t = new Set,
    n = new Proxy(e,{
        get(r, s) {
            return Sp && t.add(s),
            r[s]
        }
    }),
    i = (r,s)=>{
        var o;
        E3[r] = {
            global: Array.from(t),
            component: Object.assign(Object.assign({}, (o = E3[r]) === null || o === void 0 ? void 0 : o.component), s)
        }
    }
    ),
    {
        token: n,
        keys: t,
        flush: i
    }
}
const XL = (e,t)=>{
    const [n,i] = no();
    return mp({
        theme: n,
        token: i,
        hashId: "",
        path: ["ant-design-icons", e],
        nonce: ()=>t == null ? void 0 : t.nonce
    }, ()=>[{
        [`.${e}`]: Object.assign(Object.assign({}, zL()), {
            [`.${e} .${e}-icon`]: {
                display: "block"
            }
        })
    }])
}
  , CS = XL;
function Aa(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const r = Array.isArray(e) ? e : [e, e]
      , [s] = r
      , o = r.join("-");
    return a=>{
        const [l,c,u] = no()
          , {getPrefixCls: h, iconPrefixCls: d, csp: m} = M.useContext(Xn)
          , f = h()
          , x = {
            theme: l,
            token: c,
            hashId: u,
            nonce: ()=>m == null ? void 0 : m.nonce,
            clientOnly: i.clientOnly,
            order: i.order || -999
        };
        return mp(Object.assign(Object.assign({}, x), {
            clientOnly: !1,
            path: ["Shared", f]
        }), ()=>[{
            "&": VL(c)
        }]),
        CS(d, m),
        [mp(Object.assign(Object.assign({}, x), {
            path: [o, a, d]
        }), ()=>{
            const {token: S, flush: v} = GL(c)
              , p = Object.assign({}, c[s]);
            if (i.deprecatedTokens) {
                const {deprecatedTokens: F} = i;
                F.forEach(P=>{
                    let[_,T] = P;
                    var L;
                    (p != null && p[_] || p != null && p[T]) && ((L = p[T]) !== null && L !== void 0 || (p[T] = p == null ? void 0 : p[_]))
                }
                )
            }
            const g = typeof n == "function" ? n(qs(S, p ?? {})) : n
              , C = Object.assign(Object.assign({}, g), p)
              , E = `.${a}`
              , O = qs(S, {
                componentCls: E,
                prefixCls: a,
                iconCls: `.${d}`,
                antCls: `.${f}`
            }, C)
              , R = t(O, {
                hashId: u,
                prefixCls: a,
                rootPrefixCls: f,
                iconPrefixCls: d,
                overrideComponentToken: p
            });
            return v(s, C),
            [i.resetStyle === !1 ? null : WL(O, a), R]
        }
        ), u]
    }
}
function YL(e, t) {
    return Wh.reduce((n,i)=>{
        const r = e[`${i}1`]
          , s = e[`${i}3`]
          , o = e[`${i}6`]
          , a = e[`${i}7`];
        return Object.assign(Object.assign({}, n), t(i, {
            lightColor: r,
            lightBorderColor: s,
            darkColor: o,
            textColor: a
        }))
    }
    , {})
}
function $L(e, t) {
    const n = e || {}
      , i = n.inherit === !1 || !t ? vS : t;
    return c2(()=>{
        if (!e)
            return t;
        const r = Object.assign({}, i.components);
        return Object.keys(e.components || {}).forEach(s=>{
            r[s] = Object.assign(Object.assign({}, r[s]), e.components[s])
        }
        ),
        Object.assign(Object.assign(Object.assign({}, i), n), {
            token: Object.assign(Object.assign({}, i.token), n.token),
            components: r
        })
    }
    , [n, i], (r,s)=>r.some((o,a)=>{
        const l = s[a];
        return !m2(o, l, !0)
    }
    ))
}
var KL = ["children"]
  , kS = M.createContext({});
function QL(e) {
    var t = e.children
      , n = ki(e, KL);
    return M.createElement(kS.Provider, {
        value: n
    }, t)
}
var qL = function(e) {
    Hd(n, e);
    var t = Ud(n);
    function n() {
        return zi(this, n),
        t.apply(this, arguments)
    }
    return Vi(n, [{
        key: "render",
        value: function() {
            return this.props.children
        }
    }]),
    n
}(M.Component)
  , Cs = "none"
  , au = "appear"
  , lu = "enter"
  , cu = "leave"
  , P3 = "none"
  , mi = "prepare"
  , Bo = "start"
  , zo = "active"
  , k2 = "end"
  , AS = "prepared";
function T3(e, t) {
    var n = {};
    return n[e.toLowerCase()] = t.toLowerCase(),
    n["Webkit".concat(e)] = "webkit".concat(t),
    n["Moz".concat(e)] = "moz".concat(t),
    n["ms".concat(e)] = "MS".concat(t),
    n["O".concat(e)] = "o".concat(t.toLowerCase()),
    n
}
function ZL(e, t) {
    var n = {
        animationend: T3("Animation", "AnimationEnd"),
        transitionend: T3("Transition", "TransitionEnd")
    };
    return e && ("AnimationEvent"in t || delete n.animationend.animation,
    "TransitionEvent"in t || delete n.transitionend.transition),
    n
}
var JL = ZL(Tn(), typeof window < "u" ? window : {})
  , MS = {};
if (Tn()) {
    var eR = document.createElement("div");
    MS = eR.style
}
var uu = {};
function ES(e) {
    if (uu[e])
        return uu[e];
    var t = JL[e];
    if (t)
        for (var n = Object.keys(t), i = n.length, r = 0; r < i; r += 1) {
            var s = n[r];
            if (Object.prototype.hasOwnProperty.call(t, s) && s in MS)
                return uu[e] = t[s],
                uu[e]
        }
    return ""
}
var PS = ES("animationend")
  , TS = ES("transitionend")
  , jS = !!(PS && TS)
  , j3 = PS || "animationend"
  , O3 = TS || "transitionend";
function L3(e, t) {
    if (!e)
        return null;
    if (it(e) === "object") {
        var n = t.replace(/-\w/g, function(i) {
            return i[1].toUpperCase()
        });
        return e[n]
    }
    return "".concat(e, "-").concat(t)
}
const tR = function(e) {
    var t = M.useRef()
      , n = M.useRef(e);
    n.current = e;
    var i = M.useCallback(function(o) {
        n.current(o)
    }, []);
    function r(o) {
        o && (o.removeEventListener(O3, i),
        o.removeEventListener(j3, i))
    }
    function s(o) {
        t.current && t.current !== o && r(t.current),
        o && o !== t.current && (o.addEventListener(O3, i),
        o.addEventListener(j3, i),
        t.current = o)
    }
    return M.useEffect(function() {
        return function() {
            r(t.current)
        }
    }, []),
    [s, r]
};
var OS = Tn() ? M.useLayoutEffect : M.useEffect;
const nR = function() {
    var e = M.useRef(null);
    function t() {
        Ci.cancel(e.current)
    }
    function n(i) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        t();
        var s = Ci(function() {
            r <= 1 ? i({
                isCanceled: function() {
                    return s !== e.current
                }
            }) : n(i, r - 1)
        });
        e.current = s
    }
    return M.useEffect(function() {
        return function() {
            t()
        }
    }, []),
    [n, t]
};
var iR = [mi, Bo, zo, k2]
  , rR = [mi, AS]
  , LS = !1
  , sR = !0;
function RS(e) {
    return e === zo || e === k2
}
const oR = function(e, t, n) {
    var i = Zo(P3)
      , r = Me(i, 2)
      , s = r[0]
      , o = r[1]
      , a = nR()
      , l = Me(a, 2)
      , c = l[0]
      , u = l[1];
    function h() {
        o(mi, !0)
    }
    var d = t ? rR : iR;
    return OS(function() {
        if (s !== P3 && s !== k2) {
            var m = d.indexOf(s)
              , f = d[m + 1]
              , x = n(s);
            x === LS ? o(f, !0) : f && c(function(S) {
                function v() {
                    S.isCanceled() || o(f, !0)
                }
                x === !0 ? v() : Promise.resolve(x).then(v)
            })
        }
    }, [e, s]),
    M.useEffect(function() {
        return function() {
            u()
        }
    }, []),
    [h, s]
};
function aR(e, t, n, i) {
    var r = i.motionEnter
      , s = r === void 0 ? !0 : r
      , o = i.motionAppear
      , a = o === void 0 ? !0 : o
      , l = i.motionLeave
      , c = l === void 0 ? !0 : l
      , u = i.motionDeadline
      , h = i.motionLeaveImmediately
      , d = i.onAppearPrepare
      , m = i.onEnterPrepare
      , f = i.onLeavePrepare
      , x = i.onAppearStart
      , S = i.onEnterStart
      , v = i.onLeaveStart
      , p = i.onAppearActive
      , g = i.onEnterActive
      , C = i.onLeaveActive
      , E = i.onAppearEnd
      , O = i.onEnterEnd
      , R = i.onLeaveEnd
      , F = i.onVisibleChanged
      , P = Zo()
      , _ = Me(P, 2)
      , T = _[0]
      , L = _[1]
      , I = Zo(Cs)
      , k = Me(I, 2)
      , w = k[0]
      , b = k[1]
      , A = Zo(null)
      , j = Me(A, 2)
      , B = j[0]
      , W = j[1]
      , N = M.useRef(!1)
      , H = M.useRef(null);
    function X() {
        return n()
    }
    var ie = M.useRef(!1);
    function K() {
        b(Cs, !0),
        W(null, !0)
    }
    function D(se) {
        var le = X();
        if (!(se && !se.deadline && se.target !== le)) {
            var he = ie.current, Q;
            w === au && he ? Q = E == null ? void 0 : E(le, se) : w === lu && he ? Q = O == null ? void 0 : O(le, se) : w === cu && he && (Q = R == null ? void 0 : R(le, se)),
            w !== Cs && he && Q !== !1 && K()
        }
    }
    var V = tR(D)
      , G = Me(V, 1)
      , ee = G[0]
      , J = function(le) {
        var he, Q, q;
        switch (le) {
        case au:
            return he = {},
            me(he, mi, d),
            me(he, Bo, x),
            me(he, zo, p),
            he;
        case lu:
            return Q = {},
            me(Q, mi, m),
            me(Q, Bo, S),
            me(Q, zo, g),
            Q;
        case cu:
            return q = {},
            me(q, mi, f),
            me(q, Bo, v),
            me(q, zo, C),
            q;
        default:
            return {}
        }
    }
      , te = M.useMemo(function() {
        return J(w)
    }, [w])
      , z = oR(w, !e, function(se) {
        if (se === mi) {
            var le = te[mi];
            return le ? le(X()) : LS
        }
        if (Z in te) {
            var he;
            W(((he = te[Z]) === null || he === void 0 ? void 0 : he.call(te, X(), null)) || null)
        }
        return Z === zo && (ee(X()),
        u > 0 && (clearTimeout(H.current),
        H.current = setTimeout(function() {
            D({
                deadline: !0
            })
        }, u))),
        Z === AS && K(),
        sR
    })
      , Y = Me(z, 2)
      , U = Y[0]
      , Z = Y[1]
      , $ = RS(Z);
    ie.current = $,
    OS(function() {
        L(t);
        var se = N.current;
        N.current = !0;
        var le;
        !se && t && a && (le = au),
        se && t && s && (le = lu),
        (se && !t && c || !se && h && !t && c) && (le = cu);
        var he = J(le);
        le && (e || he[mi]) ? (b(le),
        U()) : b(Cs)
    }, [t]),
    M.useEffect(function() {
        (w === au && !a || w === lu && !s || w === cu && !c) && b(Cs)
    }, [a, s, c]),
    M.useEffect(function() {
        return function() {
            N.current = !1,
            clearTimeout(H.current)
        }
    }, []);
    var ne = M.useRef(!1);
    M.useEffect(function() {
        T && (ne.current = !0),
        T !== void 0 && w === Cs && ((ne.current || T) && (F == null || F(T)),
        ne.current = !0)
    }, [T, w]);
    var oe = B;
    return te[mi] && Z === Bo && (oe = be({
        transition: "none"
    }, oe)),
    [w, Z, oe, T ?? t]
}
function lR(e) {
    var t = e;
    it(e) === "object" && (t = e.transitionSupport);
    function n(r, s) {
        return !!(r.motionName && t && s !== !1)
    }
    var i = M.forwardRef(function(r, s) {
        var o = r.visible
          , a = o === void 0 ? !0 : o
          , l = r.removeOnLeave
          , c = l === void 0 ? !0 : l
          , u = r.forceRender
          , h = r.children
          , d = r.motionName
          , m = r.leavedClassName
          , f = r.eventProps
          , x = M.useContext(kS)
          , S = x.motion
          , v = n(r, S)
          , p = M.useRef()
          , g = M.useRef();
        function C() {
            try {
                return p.current instanceof HTMLElement ? p.current : Ku(g.current)
            } catch {
                return null
            }
        }
        var E = aR(v, a, C, r)
          , O = Me(E, 4)
          , R = O[0]
          , F = O[1]
          , P = O[2]
          , _ = O[3]
          , T = M.useRef(_);
        _ && (T.current = !0);
        var L = M.useCallback(function(W) {
            p.current = W,
            u2(s, W)
        }, [s]), I, k = be(be({}, f), {}, {
            visible: a
        });
        if (!h)
            I = null;
        else if (R === Cs)
            _ ? I = h(be({}, k), L) : !c && T.current && m ? I = h(be(be({}, k), {}, {
                className: m
            }), L) : u || !c && !m ? I = h(be(be({}, k), {}, {
                style: {
                    display: "none"
                }
            }), L) : I = null;
        else {
            var w, b;
            F === mi ? b = "prepare" : RS(F) ? b = "active" : F === Bo && (b = "start");
            var A = L3(d, "".concat(R, "-").concat(b));
            I = h(be(be({}, k), {}, {
                className: nt(L3(d, R), (w = {},
                me(w, A, A && b),
                me(w, d, typeof d == "string"),
                w)),
                style: P
            }), L)
        }
        if (M.isValidElement(I) && mc(I)) {
            var j = I
              , B = j.ref;
            B || (I = M.cloneElement(I, {
                ref: L
            }))
        }
        return M.createElement(qL, {
            ref: g
        }, I)
    });
    return i.displayName = "CSSMotion",
    i
}
const Kd = lR(jS);
var Cp = "add"
  , kp = "keep"
  , Ap = "remove"
  , d0 = "removed";
function cR(e) {
    var t;
    return e && it(e) === "object" && "key"in e ? t = e : t = {
        key: e
    },
    be(be({}, t), {}, {
        key: String(t.key)
    })
}
function Mp() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return e.map(cR)
}
function uR() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []
      , t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []
      , n = []
      , i = 0
      , r = t.length
      , s = Mp(e)
      , o = Mp(t);
    s.forEach(function(c) {
        for (var u = !1, h = i; h < r; h += 1) {
            var d = o[h];
            if (d.key === c.key) {
                i < h && (n = n.concat(o.slice(i, h).map(function(m) {
                    return be(be({}, m), {}, {
                        status: Cp
                    })
                })),
                i = h),
                n.push(be(be({}, d), {}, {
                    status: kp
                })),
                i += 1,
                u = !0;
                break
            }
        }
        u || n.push(be(be({}, c), {}, {
            status: Ap
        }))
    }),
    i < r && (n = n.concat(o.slice(i).map(function(c) {
        return be(be({}, c), {}, {
            status: Cp
        })
    })));
    var a = {};
    n.forEach(function(c) {
        var u = c.key;
        a[u] = (a[u] || 0) + 1
    });
    var l = Object.keys(a).filter(function(c) {
        return a[c] > 1
    });
    return l.forEach(function(c) {
        n = n.filter(function(u) {
            var h = u.key
              , d = u.status;
            return h !== c || d !== Ap
        }),
        n.forEach(function(u) {
            u.key === c && (u.status = kp)
        })
    }),
    n
}
var hR = ["component", "children", "onVisibleChanged", "onAllRemoved"]
  , dR = ["status"]
  , fR = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function pR(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Kd
      , n = function(i) {
        Hd(s, i);
        var r = Ud(s);
        function s() {
            var o;
            zi(this, s);
            for (var a = arguments.length, l = new Array(a), c = 0; c < a; c++)
                l[c] = arguments[c];
            return o = r.call.apply(r, [this].concat(l)),
            me(Ye(o), "state", {
                keyEntities: []
            }),
            me(Ye(o), "removeKey", function(u) {
                var h = o.state.keyEntities
                  , d = h.map(function(m) {
                    return m.key !== u ? m : be(be({}, m), {}, {
                        status: d0
                    })
                });
                return o.setState({
                    keyEntities: d
                }),
                d.filter(function(m) {
                    var f = m.status;
                    return f !== d0
                }).length
            }),
            o
        }
        return Vi(s, [{
            key: "render",
            value: function() {
                var a = this
                  , l = this.state.keyEntities
                  , c = this.props
                  , u = c.component
                  , h = c.children
                  , d = c.onVisibleChanged
                  , m = c.onAllRemoved
                  , f = ki(c, hR)
                  , x = u || M.Fragment
                  , S = {};
                return fR.forEach(function(v) {
                    S[v] = f[v],
                    delete f[v]
                }),
                delete f.keys,
                M.createElement(x, f, l.map(function(v, p) {
                    var g = v.status
                      , C = ki(v, dR)
                      , E = g === Cp || g === kp;
                    return M.createElement(t, Wn({}, S, {
                        key: C.key,
                        visible: E,
                        eventProps: C,
                        onVisibleChanged: function(R) {
                            if (d == null || d(R, {
                                key: C.key
                            }),
                            !R) {
                                var F = a.removeKey(C.key);
                                F === 0 && m && m()
                            }
                        }
                    }), function(O, R) {
                        return h(be(be({}, O), {}, {
                            index: p
                        }), R)
                    })
                }))
            }
        }], [{
            key: "getDerivedStateFromProps",
            value: function(a, l) {
                var c = a.keys
                  , u = l.keyEntities
                  , h = Mp(c)
                  , d = uR(u, h);
                return {
                    keyEntities: d.filter(function(m) {
                        var f = u.find(function(x) {
                            var S = x.key;
                            return m.key === S
                        });
                        return !(f && f.status === d0 && m.status === Ap)
                    })
                }
            }
        }]),
        s
    }(M.Component);
    return me(n, "defaultProps", {
        component: "div"
    }),
    n
}
pR(jS);
function gR(e) {
    const {children: t} = e
      , [,n] = no()
      , {motion: i} = n
      , r = M.useRef(!1);
    return r.current = r.current || i === !1,
    r.current ? M.createElement(QL, {
        motion: i
    }, t) : t
}
const mR = ()=>null;
var vR = function(e, t) {
    var n = {};
    for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++)
            t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
    return n
};
const yR = ["getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form", "select", "button"]
  , xR = "ant";
let _S;
function bR() {
    return _S || xR
}
function wR(e) {
    return Object.keys(e).some(t=>t.endsWith("Color"))
}
const SR = e=>{
    let {prefixCls: t, iconPrefixCls: n, theme: i} = e;
    t !== void 0 && (_S = t),
    i && wR(i) && RL(bR(), i)
}
  , CR = e=>{
    const {children: t, csp: n, autoInsertSpaceInButton: i, alert: r, anchor: s, form: o, locale: a, componentSize: l, direction: c, space: u, virtual: h, dropdownMatchSelectWidth: d, popupMatchSelectWidth: m, popupOverflow: f, legacyLocale: x, parentContext: S, iconPrefixCls: v, theme: p, componentDisabled: g, segmented: C, statistic: E, spin: O, calendar: R, carousel: F, cascader: P, collapse: _, typography: T, checkbox: L, descriptions: I, divider: k, drawer: w, skeleton: b, steps: A, image: j, layout: B, list: W, mentions: N, modal: H, progress: X, result: ie, slider: K, breadcrumb: D, menu: V, pagination: G, input: ee, empty: J, badge: te, radio: z, rate: Y, switch: U, transfer: Z, avatar: $, message: ne, tag: oe, table: se, card: le, tabs: he, timeline: Q, timePicker: q, upload: ae, notification: re, tree: ce, colorPicker: ue, datePicker: fe, rangePicker: de, flex: ge, wave: ye, dropdown: pe, warning: xe} = e
      , ke = M.useCallback((Te,Ve)=>{
        const {prefixCls: Ke} = e;
        if (Ve)
            return Ve;
        const st = Ke || S.getPrefixCls("");
        return Te ? `${st}-${Te}` : st
    }
    , [S.getPrefixCls, e.prefixCls])
      , Ee = v || S.iconPrefixCls || xS
      , we = n || S.csp;
    CS(Ee, we);
    const ve = $L(p, S.theme)
      , _e = {
        csp: we,
        autoInsertSpaceInButton: i,
        alert: r,
        anchor: s,
        locale: a || x,
        direction: c,
        space: u,
        virtual: h,
        popupMatchSelectWidth: m ?? d,
        popupOverflow: f,
        getPrefixCls: ke,
        iconPrefixCls: Ee,
        theme: ve,
        segmented: C,
        statistic: E,
        spin: O,
        calendar: R,
        carousel: F,
        cascader: P,
        collapse: _,
        typography: T,
        checkbox: L,
        descriptions: I,
        divider: k,
        drawer: w,
        skeleton: b,
        steps: A,
        image: j,
        input: ee,
        layout: B,
        list: W,
        mentions: N,
        modal: H,
        progress: X,
        result: ie,
        slider: K,
        breadcrumb: D,
        menu: V,
        pagination: G,
        empty: J,
        badge: te,
        radio: z,
        rate: Y,
        switch: U,
        transfer: Z,
        avatar: $,
        message: ne,
        tag: oe,
        table: se,
        card: le,
        tabs: he,
        timeline: Q,
        timePicker: q,
        upload: ae,
        notification: re,
        tree: ce,
        colorPicker: ue,
        datePicker: fe,
        rangePicker: de,
        flex: ge,
        wave: ye,
        dropdown: pe,
        warning: xe
    }
      , Oe = Object.assign({}, S);
    Object.keys(_e).forEach(Te=>{
        _e[Te] !== void 0 && (Oe[Te] = _e[Te])
    }
    ),
    yR.forEach(Te=>{
        const Ve = e[Te];
        Ve && (Oe[Te] = Ve)
    }
    );
    const ze = c2(()=>Oe, Oe, (Te,Ve)=>{
        const Ke = Object.keys(Te)
          , st = Object.keys(Ve);
        return Ke.length !== st.length || Ke.some(Qt=>Te[Qt] !== Ve[Qt])
    }
    )
      , Qe = M.useMemo(()=>({
        prefixCls: Ee,
        csp: we
    }), [Ee, we]);
    let Fe = M.createElement(M.Fragment, null, M.createElement(mR, {
        dropdownMatchSelectWidth: d
    }), t);
    const rt = M.useMemo(()=>{
        var Te, Ve, Ke, st;
        return Io(((Te = $d.Form) === null || Te === void 0 ? void 0 : Te.defaultValidateMessages) || {}, ((Ke = (Ve = ze.locale) === null || Ve === void 0 ? void 0 : Ve.Form) === null || Ke === void 0 ? void 0 : Ke.defaultValidateMessages) || {}, ((st = ze.form) === null || st === void 0 ? void 0 : st.validateMessages) || {}, (o == null ? void 0 : o.validateMessages) || {})
    }
    , [ze, o == null ? void 0 : o.validateMessages]);
    Object.keys(rt).length > 0 && (Fe = M.createElement(HO.Provider, {
        value: rt
    }, Fe)),
    a && (Fe = M.createElement(JO, {
        locale: a,
        _ANT_MARK__: qO
    }, Fe)),
    (Ee || we) && (Fe = M.createElement(NO.Provider, {
        value: Qe
    }, Fe)),
    l && (Fe = M.createElement(DL, {
        size: l
    }, Fe)),
    Fe = M.createElement(gR, null, Fe);
    const Ne = M.useMemo(()=>{
        const Te = ve || {}
          , {algorithm: Ve, token: Ke, components: st} = Te
          , Qt = vR(Te, ["algorithm", "token", "components"])
          , un = Ve && (!Array.isArray(Ve) || Ve.length > 0) ? dp(Ve) : mS
          , bn = {};
        Object.entries(st || {}).forEach(Yn=>{
            let[pr,ci] = Yn;
            const Gt = Object.assign({}, ci);
            "algorithm"in Gt && (Gt.algorithm === !0 ? Gt.theme = un : (Array.isArray(Gt.algorithm) || typeof Gt.algorithm == "function") && (Gt.theme = dp(Gt.algorithm)),
            delete Gt.algorithm),
            bn[pr] = Gt
        }
        );
        const ct = Object.assign(Object.assign({}, Gl), Ke);
        return Object.assign(Object.assign({}, Qt), {
            theme: un,
            token: ct,
            components: bn,
            override: Object.assign({
                override: ct
            }, bn)
        })
    }
    , [ve]);
    return p && (Fe = M.createElement(yS.Provider, {
        value: Ne
    }, Fe)),
    ze.warning && (Fe = M.createElement(VO.Provider, {
        value: ze.warning
    }, Fe)),
    g !== void 0 && (Fe = M.createElement(_L, {
        disabled: g
    }, Fe)),
    M.createElement(Xn.Provider, {
        value: ze
    }, Fe)
}
  , Ma = e=>{
    const t = M.useContext(Xn)
      , n = M.useContext(hS);
    return M.createElement(CR, Object.assign({
        parentContext: t,
        legacyLocale: n
    }, e))
}
;
Ma.ConfigContext = Xn;
Ma.SizeContext = S2;
Ma.config = SR;
Ma.useConfig = NL;
Object.defineProperty(Ma, "SizeContext", {
    get: ()=>S2
});
function DS(e) {
    var t;
    return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e)
}
function kR(e) {
    return DS(e)instanceof ShadowRoot
}
function Ep(e) {
    return kR(e) ? DS(e) : null
}
const {isValidElement: A2} = uc;
function AR(e) {
    return e && A2(e) && e.type === M.Fragment
}
function MR(e, t, n) {
    return A2(e) ? M.cloneElement(e, typeof n == "function" ? n(e.props || {}) : n) : t
}
function NS(e, t) {
    return MR(e, e, t)
}
var Le = {
    MAC_ENTER: 3,
    BACKSPACE: 8,
    TAB: 9,
    NUM_CENTER: 12,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    PRINT_SCREEN: 44,
    INSERT: 45,
    DELETE: 46,
    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,
    QUESTION_MARK: 63,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    META: 91,
    WIN_KEY_RIGHT: 92,
    CONTEXT_MENU: 93,
    NUM_ZERO: 96,
    NUM_ONE: 97,
    NUM_TWO: 98,
    NUM_THREE: 99,
    NUM_FOUR: 100,
    NUM_FIVE: 101,
    NUM_SIX: 102,
    NUM_SEVEN: 103,
    NUM_EIGHT: 104,
    NUM_NINE: 105,
    NUM_MULTIPLY: 106,
    NUM_PLUS: 107,
    NUM_MINUS: 109,
    NUM_PERIOD: 110,
    NUM_DIVISION: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    NUMLOCK: 144,
    SEMICOLON: 186,
    DASH: 189,
    EQUALS: 187,
    COMMA: 188,
    PERIOD: 190,
    SLASH: 191,
    APOSTROPHE: 192,
    SINGLE_QUOTE: 222,
    OPEN_SQUARE_BRACKET: 219,
    BACKSLASH: 220,
    CLOSE_SQUARE_BRACKET: 221,
    WIN_KEY: 224,
    MAC_FF_META: 224,
    WIN_IME: 229,
    isTextModifyingKeyEvent: function(t) {
        var n = t.keyCode;
        if (t.altKey && !t.ctrlKey || t.metaKey || n >= Le.F1 && n <= Le.F12)
            return !1;
        switch (n) {
        case Le.ALT:
        case Le.CAPS_LOCK:
        case Le.CONTEXT_MENU:
        case Le.CTRL:
        case Le.DOWN:
        case Le.END:
        case Le.ESC:
        case Le.HOME:
        case Le.INSERT:
        case Le.LEFT:
        case Le.MAC_FF_META:
        case Le.META:
        case Le.NUMLOCK:
        case Le.NUM_CENTER:
        case Le.PAGE_DOWN:
        case Le.PAGE_UP:
        case Le.PAUSE:
        case Le.PRINT_SCREEN:
        case Le.RIGHT:
        case Le.SHIFT:
        case Le.UP:
        case Le.WIN_KEY:
        case Le.WIN_KEY_RIGHT:
            return !1;
        default:
            return !0
        }
    },
    isCharacterKey: function(t) {
        if (t >= Le.ZERO && t <= Le.NINE || t >= Le.NUM_ZERO && t <= Le.NUM_MULTIPLY || t >= Le.A && t <= Le.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && t === 0)
            return !0;
        switch (t) {
        case Le.SPACE:
        case Le.QUESTION_MARK:
        case Le.NUM_PLUS:
        case Le.NUM_MINUS:
        case Le.NUM_PERIOD:
        case Le.NUM_DIVISION:
        case Le.SEMICOLON:
        case Le.DASH:
        case Le.EQUALS:
        case Le.COMMA:
        case Le.PERIOD:
        case Le.SLASH:
        case Le.APOSTROPHE:
        case Le.SINGLE_QUOTE:
        case Le.OPEN_SQUARE_BRACKET:
        case Le.BACKSLASH:
        case Le.CLOSE_SQUARE_BRACKET:
            return !0;
        default:
            return !1
        }
    }
};
const ER = Ce.createContext(void 0)
  , FS = ER
  , ks = 100
  , PR = 10
  , TR = ks * PR
  , IS = {
    Modal: ks,
    Drawer: ks,
    Popover: ks,
    Popconfirm: ks,
    Tooltip: ks,
    Tour: ks
}
  , jR = {
    SelectLike: 50,
    Dropdown: 50,
    DatePicker: 50,
    Menu: 50,
    ImagePreview: 1
};
function OR(e) {
    return e in IS
}
function LR(e, t) {
    const [,n] = no()
      , i = Ce.useContext(FS)
      , r = OR(e);
    if (t !== void 0)
        return [t, t];
    let s = i ?? 0;
    return r ? (s += (i ? 0 : n.zIndexPopupBase) + IS[e],
    s = Math.min(s, n.zIndexPopupBase + TR)) : s += jR[e],
    [i === void 0 ? t : s, s]
}
function vn() {
    vn = function() {
        return t
    }
    ;
    var e, t = {}, n = Object.prototype, i = n.hasOwnProperty, r = Object.defineProperty || function(b, A, j) {
        b[A] = j.value
    }
    , s = typeof Symbol == "function" ? Symbol : {}, o = s.iterator || "@@iterator", a = s.asyncIterator || "@@asyncIterator", l = s.toStringTag || "@@toStringTag";
    function c(b, A, j) {
        return Object.defineProperty(b, A, {
            value: j,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }),
        b[A]
    }
    try {
        c({}, "")
    } catch {
        c = function(j, B, W) {
            return j[B] = W
        }
    }
    function u(b, A, j, B) {
        var W = A && A.prototype instanceof v ? A : v
          , N = Object.create(W.prototype)
          , H = new k(B || []);
        return r(N, "_invoke", {
            value: _(b, j, H)
        }),
        N
    }
    function h(b, A, j) {
        try {
            return {
                type: "normal",
                arg: b.call(A, j)
            }
        } catch (B) {
            return {
                type: "throw",
                arg: B
            }
        }
    }
    t.wrap = u;
    var d = "suspendedStart"
      , m = "suspendedYield"
      , f = "executing"
      , x = "completed"
      , S = {};
    function v() {}
    function p() {}
    function g() {}
    var C = {};
    c(C, o, function() {
        return this
    });
    var E = Object.getPrototypeOf
      , O = E && E(E(w([])));
    O && O !== n && i.call(O, o) && (C = O);
    var R = g.prototype = v.prototype = Object.create(C);
    function F(b) {
        ["next", "throw", "return"].forEach(function(A) {
            c(b, A, function(j) {
                return this._invoke(A, j)
            })
        })
    }
    function P(b, A) {
        function j(W, N, H, X) {
            var ie = h(b[W], b, N);
            if (ie.type !== "throw") {
                var K = ie.arg
                  , D = K.value;
                return D && it(D) == "object" && i.call(D, "__await") ? A.resolve(D.__await).then(function(V) {
                    j("next", V, H, X)
                }, function(V) {
                    j("throw", V, H, X)
                }) : A.resolve(D).then(function(V) {
                    K.value = V,
                    H(K)
                }, function(V) {
                    return j("throw", V, H, X)
                })
            }
            X(ie.arg)
        }
        var B;
        r(this, "_invoke", {
            value: function(N, H) {
                function X() {
                    return new A(function(ie, K) {
                        j(N, H, ie, K)
                    }
                    )
                }
                return B = B ? B.then(X, X) : X()
            }
        })
    }
    function _(b, A, j) {
        var B = d;
        return function(W, N) {
            if (B === f)
                throw new Error("Generator is already running");
            if (B === x) {
                if (W === "throw")
                    throw N;
                return {
                    value: e,
                    done: !0
                }
            }
            for (j.method = W,
            j.arg = N; ; ) {
                var H = j.delegate;
                if (H) {
                    var X = T(H, j);
                    if (X) {
                        if (X === S)
                            continue;
                        return X
                    }
                }
                if (j.method === "next")
                    j.sent = j._sent = j.arg;
                else if (j.method === "throw") {
                    if (B === d)
                        throw B = x,
                        j.arg;
                    j.dispatchException(j.arg)
                } else
                    j.method === "return" && j.abrupt("return", j.arg);
                B = f;
                var ie = h(b, A, j);
                if (ie.type === "normal") {
                    if (B = j.done ? x : m,
                    ie.arg === S)
                        continue;
                    return {
                        value: ie.arg,
                        done: j.done
                    }
                }
                ie.type === "throw" && (B = x,
                j.method = "throw",
                j.arg = ie.arg)
            }
        }
    }
    function T(b, A) {
        var j = A.method
          , B = b.iterator[j];
        if (B === e)
            return A.delegate = null,
            j === "throw" && b.iterator.return && (A.method = "return",
            A.arg = e,
            T(b, A),
            A.method === "throw") || j !== "return" && (A.method = "throw",
            A.arg = new TypeError("The iterator does not provide a '" + j + "' method")),
            S;
        var W = h(B, b.iterator, A.arg);
        if (W.type === "throw")
            return A.method = "throw",
            A.arg = W.arg,
            A.delegate = null,
            S;
        var N = W.arg;
        return N ? N.done ? (A[b.resultName] = N.value,
        A.next = b.nextLoc,
        A.method !== "return" && (A.method = "next",
        A.arg = e),
        A.delegate = null,
        S) : N : (A.method = "throw",
        A.arg = new TypeError("iterator result is not an object"),
        A.delegate = null,
        S)
    }
    function L(b) {
        var A = {
            tryLoc: b[0]
        };
        1 in b && (A.catchLoc = b[1]),
        2 in b && (A.finallyLoc = b[2],
        A.afterLoc = b[3]),
        this.tryEntries.push(A)
    }
    function I(b) {
        var A = b.completion || {};
        A.type = "normal",
        delete A.arg,
        b.completion = A
    }
    function k(b) {
        this.tryEntries = [{
            tryLoc: "root"
        }],
        b.forEach(L, this),
        this.reset(!0)
    }
    function w(b) {
        if (b || b === "") {
            var A = b[o];
            if (A)
                return A.call(b);
            if (typeof b.next == "function")
                return b;
            if (!isNaN(b.length)) {
                var j = -1
                  , B = function W() {
                    for (; ++j < b.length; )
                        if (i.call(b, j))
                            return W.value = b[j],
                            W.done = !1,
                            W;
                    return W.value = e,
                    W.done = !0,
                    W
                };
                return B.next = B
            }
        }
        throw new TypeError(it(b) + " is not iterable")
    }
    return p.prototype = g,
    r(R, "constructor", {
        value: g,
        configurable: !0
    }),
    r(g, "constructor", {
        value: p,
        configurable: !0
    }),
    p.displayName = c(g, l, "GeneratorFunction"),
    t.isGeneratorFunction = function(b) {
        var A = typeof b == "function" && b.constructor;
        return !!A && (A === p || (A.displayName || A.name) === "GeneratorFunction")
    }
    ,
    t.mark = function(b) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(b, g) : (b.__proto__ = g,
        c(b, l, "GeneratorFunction")),
        b.prototype = Object.create(R),
        b
    }
    ,
    t.awrap = function(b) {
        return {
            __await: b
        }
    }
    ,
    F(P.prototype),
    c(P.prototype, a, function() {
        return this
    }),
    t.AsyncIterator = P,
    t.async = function(b, A, j, B, W) {
        W === void 0 && (W = Promise);
        var N = new P(u(b, A, j, B),W);
        return t.isGeneratorFunction(A) ? N : N.next().then(function(H) {
            return H.done ? H.value : N.next()
        })
    }
    ,
    F(R),
    c(R, l, "Generator"),
    c(R, o, function() {
        return this
    }),
    c(R, "toString", function() {
        return "[object Generator]"
    }),
    t.keys = function(b) {
        var A = Object(b)
          , j = [];
        for (var B in A)
            j.push(B);
        return j.reverse(),
        function W() {
            for (; j.length; ) {
                var N = j.pop();
                if (N in A)
                    return W.value = N,
                    W.done = !1,
                    W
            }
            return W.done = !0,
            W
        }
    }
    ,
    t.values = w,
    k.prototype = {
        constructor: k,
        reset: function(A) {
            if (this.prev = 0,
            this.next = 0,
            this.sent = this._sent = e,
            this.done = !1,
            this.delegate = null,
            this.method = "next",
            this.arg = e,
            this.tryEntries.forEach(I),
            !A)
                for (var j in this)
                    j.charAt(0) === "t" && i.call(this, j) && !isNaN(+j.slice(1)) && (this[j] = e)
        },
        stop: function() {
            this.done = !0;
            var A = this.tryEntries[0].completion;
            if (A.type === "throw")
                throw A.arg;
            return this.rval
        },
        dispatchException: function(A) {
            if (this.done)
                throw A;
            var j = this;
            function B(K, D) {
                return H.type = "throw",
                H.arg = A,
                j.next = K,
                D && (j.method = "next",
                j.arg = e),
                !!D
            }
            for (var W = this.tryEntries.length - 1; W >= 0; --W) {
                var N = this.tryEntries[W]
                  , H = N.completion;
                if (N.tryLoc === "root")
                    return B("end");
                if (N.tryLoc <= this.prev) {
                    var X = i.call(N, "catchLoc")
                      , ie = i.call(N, "finallyLoc");
                    if (X && ie) {
                        if (this.prev < N.catchLoc)
                            return B(N.catchLoc, !0);
                        if (this.prev < N.finallyLoc)
                            return B(N.finallyLoc)
                    } else if (X) {
                        if (this.prev < N.catchLoc)
                            return B(N.catchLoc, !0)
                    } else {
                        if (!ie)
                            throw new Error("try statement without catch or finally");
                        if (this.prev < N.finallyLoc)
                            return B(N.finallyLoc)
                    }
                }
            }
        },
        abrupt: function(A, j) {
            for (var B = this.tryEntries.length - 1; B >= 0; --B) {
                var W = this.tryEntries[B];
                if (W.tryLoc <= this.prev && i.call(W, "finallyLoc") && this.prev < W.finallyLoc) {
                    var N = W;
                    break
                }
            }
            N && (A === "break" || A === "continue") && N.tryLoc <= j && j <= N.finallyLoc && (N = null);
            var H = N ? N.completion : {};
            return H.type = A,
            H.arg = j,
            N ? (this.method = "next",
            this.next = N.finallyLoc,
            S) : this.complete(H)
        },
        complete: function(A, j) {
            if (A.type === "throw")
                throw A.arg;
            return A.type === "break" || A.type === "continue" ? this.next = A.arg : A.type === "return" ? (this.rval = this.arg = A.arg,
            this.method = "return",
            this.next = "end") : A.type === "normal" && j && (this.next = j),
            S
        },
        finish: function(A) {
            for (var j = this.tryEntries.length - 1; j >= 0; --j) {
                var B = this.tryEntries[j];
                if (B.finallyLoc === A)
                    return this.complete(B.completion, B.afterLoc),
                    I(B),
                    S
            }
        },
        catch: function(A) {
            for (var j = this.tryEntries.length - 1; j >= 0; --j) {
                var B = this.tryEntries[j];
                if (B.tryLoc === A) {
                    var W = B.completion;
                    if (W.type === "throw") {
                        var N = W.arg;
                        I(B)
                    }
                    return N
                }
            }
            throw new Error("illegal catch attempt")
        },
        delegateYield: function(A, j, B) {
            return this.delegate = {
                iterator: w(A),
                resultName: j,
                nextLoc: B
            },
            this.method === "next" && (this.arg = e),
            S
        }
    },
    t
}
function R3(e, t, n, i, r, s, o) {
    try {
        var a = e[s](o)
          , l = a.value
    } catch (c) {
        n(c);
        return
    }
    a.done ? t(l) : Promise.resolve(l).then(i, r)
}
function io(e) {
    return function() {
        var t = this
          , n = arguments;
        return new Promise(function(i, r) {
            var s = e.apply(t, n);
            function o(l) {
                R3(s, i, r, o, a, "next", l)
            }
            function a(l) {
                R3(s, i, r, o, a, "throw", l)
            }
            o(void 0)
        }
        )
    }
}
var vc = be({}, aP), RR = vc.version, _R = vc.render, DR = vc.unmountComponentAtNode, Qd;
try {
    var NR = Number((RR || "").split(".")[0]);
    NR >= 18 && (Qd = vc.createRoot)
} catch {}
function _3(e) {
    var t = vc.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    t && it(t) === "object" && (t.usingClientEntryPoint = e)
}
var Hh = "__rc_react_root__";
function FR(e, t) {
    _3(!0);
    var n = t[Hh] || Qd(t);
    _3(!1),
    n.render(e),
    t[Hh] = n
}
function IR(e, t) {
    _R(e, t)
}
function BR(e, t) {
    if (Qd) {
        FR(e, t);
        return
    }
    IR(e, t)
}
function zR(e) {
    return Pp.apply(this, arguments)
}
function Pp() {
    return Pp = io(vn().mark(function e(t) {
        return vn().wrap(function(i) {
            for (; ; )
                switch (i.prev = i.next) {
                case 0:
                    return i.abrupt("return", Promise.resolve().then(function() {
                        var r;
                        (r = t[Hh]) === null || r === void 0 || r.unmount(),
                        delete t[Hh]
                    }));
                case 1:
                case "end":
                    return i.stop()
                }
        }, e)
    })),
    Pp.apply(this, arguments)
}
function VR(e) {
    DR(e)
}
function WR(e) {
    return Tp.apply(this, arguments)
}
function Tp() {
    return Tp = io(vn().mark(function e(t) {
        return vn().wrap(function(i) {
            for (; ; )
                switch (i.prev = i.next) {
                case 0:
                    if (Qd === void 0) {
                        i.next = 2;
                        break
                    }
                    return i.abrupt("return", zR(t));
                case 2:
                    VR(t);
                case 3:
                case "end":
                    return i.stop()
                }
        }, e)
    })),
    Tp.apply(this, arguments)
}
const HR = (e,t,n)=>n !== void 0 ? n : `${e}-${t}`
  , BS = function(e) {
    if (!e)
        return !1;
    if (e instanceof Element) {
        if (e.offsetParent)
            return !0;
        if (e.getBBox) {
            var t = e.getBBox()
              , n = t.width
              , i = t.height;
            if (n || i)
                return !0
        }
        if (e.getBoundingClientRect) {
            var r = e.getBoundingClientRect()
              , s = r.width
              , o = r.height;
            if (s || o)
                return !0
        }
    }
    return !1
}
  , UR = e=>{
    const {componentCls: t, colorPrimary: n} = e;
    return {
        [t]: {
            position: "absolute",
            background: "transparent",
            pointerEvents: "none",
            boxSizing: "border-box",
            color: `var(--wave-color, ${n})`,
            boxShadow: "0 0 0 0 currentcolor",
            opacity: .2,
            "&.wave-motion-appear": {
                transition: [`box-shadow 0.4s ${e.motionEaseOutCirc}`, `opacity 2s ${e.motionEaseOutCirc}`].join(","),
                "&-active": {
                    boxShadow: "0 0 0 6px currentcolor",
                    opacity: 0
                },
                "&.wave-quick": {
                    transition: [`box-shadow 0.3s ${e.motionEaseInOut}`, `opacity 0.35s ${e.motionEaseInOut}`].join(",")
                }
            }
        }
    }
}
  , GR = Aa("Wave", e=>[UR(e)]);
function XR(e) {
    const t = (e || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
    return t && t[1] && t[2] && t[3] ? !(t[1] === t[2] && t[2] === t[3]) : !0
}
function f0(e) {
    return e && e !== "#fff" && e !== "#ffffff" && e !== "rgb(255, 255, 255)" && e !== "rgba(255, 255, 255, 1)" && XR(e) && !/rgba\((?:\d*, ){3}0\)/.test(e) && e !== "transparent"
}
function YR(e) {
    const {borderTopColor: t, borderColor: n, backgroundColor: i} = getComputedStyle(e);
    return f0(t) ? t : f0(n) ? n : f0(i) ? i : null
}
const M2 = "ant-wave-target";
function p0(e) {
    return Number.isNaN(e) ? 0 : e
}
const $R = e=>{
    const {className: t, target: n, component: i} = e
      , r = M.useRef(null)
      , [s,o] = M.useState(null)
      , [a,l] = M.useState([])
      , [c,u] = M.useState(0)
      , [h,d] = M.useState(0)
      , [m,f] = M.useState(0)
      , [x,S] = M.useState(0)
      , [v,p] = M.useState(!1)
      , g = {
        left: c,
        top: h,
        width: m,
        height: x,
        borderRadius: a.map(O=>`${O}px`).join(" ")
    };
    s && (g["--wave-color"] = s);
    function C() {
        const O = getComputedStyle(n);
        o(YR(n));
        const R = O.position === "static"
          , {borderLeftWidth: F, borderTopWidth: P} = O;
        u(R ? n.offsetLeft : p0(-parseFloat(F))),
        d(R ? n.offsetTop : p0(-parseFloat(P))),
        f(n.offsetWidth),
        S(n.offsetHeight);
        const {borderTopLeftRadius: _, borderTopRightRadius: T, borderBottomLeftRadius: L, borderBottomRightRadius: I} = O;
        l([_, T, I, L].map(k=>p0(parseFloat(k))))
    }
    if (M.useEffect(()=>{
        if (n) {
            const O = Ci(()=>{
                C(),
                p(!0)
            }
            );
            let R;
            return typeof ResizeObserver < "u" && (R = new ResizeObserver(C),
            R.observe(n)),
            ()=>{
                Ci.cancel(O),
                R == null || R.disconnect()
            }
        }
    }
    , []),
    !v)
        return null;
    const E = (i === "Checkbox" || i === "Radio") && (n == null ? void 0 : n.classList.contains(M2));
    return M.createElement(Kd, {
        visible: !0,
        motionAppear: !0,
        motionName: "wave-motion",
        motionDeadline: 5e3,
        onAppearEnd: (O,R)=>{
            var F;
            if (R.deadline || R.propertyName === "opacity") {
                const P = (F = r.current) === null || F === void 0 ? void 0 : F.parentElement;
                WR(P).then(()=>{
                    P == null || P.remove()
                }
                )
            }
            return !1
        }
    }, O=>{
        let {className: R} = O;
        return M.createElement("div", {
            ref: r,
            className: nt(t, {
                "wave-quick": E
            }, R),
            style: g
        })
    }
    )
}
  , KR = (e,t)=>{
    var n;
    const {component: i} = t;
    if (i === "Checkbox" && !(!((n = e.querySelector("input")) === null || n === void 0) && n.checked))
        return;
    const r = document.createElement("div");
    r.style.position = "absolute",
    r.style.left = "0px",
    r.style.top = "0px",
    e == null || e.insertBefore(r, e == null ? void 0 : e.firstChild),
    BR(M.createElement($R, Object.assign({}, t, {
        target: e
    })), r)
}
  , QR = KR;
function qR(e, t, n) {
    const {wave: i} = M.useContext(Xn)
      , [,r,s] = no()
      , o = Ri(c=>{
        const u = e.current;
        if (i != null && i.disabled || !u)
            return;
        const h = u.querySelector(`.${M2}`) || u
          , {showEffect: d} = i || {};
        (d || QR)(h, {
            className: t,
            token: r,
            component: n,
            event: c,
            hashId: s
        })
    }
    )
      , a = M.useRef();
    return c=>{
        Ci.cancel(a.current),
        a.current = Ci(()=>{
            o(c)
        }
        )
    }
}
const ZR = e=>{
    const {children: t, disabled: n, component: i} = e
      , {getPrefixCls: r} = M.useContext(Xn)
      , s = M.useRef(null)
      , o = r("wave")
      , [,a] = GR(o)
      , l = qR(s, nt(o, a), i);
    if (Ce.useEffect(()=>{
        const u = s.current;
        if (!u || u.nodeType !== 1 || n)
            return;
        const h = d=>{
            !BS(d.target) || !u.getAttribute || u.getAttribute("disabled") || u.disabled || u.className.includes("disabled") || u.className.includes("-leave") || l(d)
        }
        ;
        return u.addEventListener("click", h, !0),
        ()=>{
            u.removeEventListener("click", h, !0)
        }
    }
    , [n]),
    !Ce.isValidElement(t))
        return t ?? null;
    const c = mc(t) ? Vd(t.ref, s) : s;
    return NS(t, {
        ref: c
    })
}
  , JR = ZR
  , e_ = M.createContext(null)
  , t_ = e=>{
    let {children: t} = e;
    return M.createElement(e_.Provider, {
        value: null
    }, t)
}
;
var zS = M.createContext(null)
  , D3 = [];
function n_(e, t) {
    var n = M.useState(function() {
        if (!Tn())
            return null;
        var f = document.createElement("div");
        return f
    })
      , i = Me(n, 1)
      , r = i[0]
      , s = M.useRef(!1)
      , o = M.useContext(zS)
      , a = M.useState(D3)
      , l = Me(a, 2)
      , c = l[0]
      , u = l[1]
      , h = o || (s.current ? void 0 : function(f) {
        u(function(x) {
            var S = [f].concat(Re(x));
            return S
        })
    }
    );
    function d() {
        r.parentElement || document.body.appendChild(r),
        s.current = !0
    }
    function m() {
        var f;
        (f = r.parentElement) === null || f === void 0 || f.removeChild(r),
        s.current = !1
    }
    return pn(function() {
        return e ? o ? o(d) : d() : m(),
        m
    }, [e]),
    pn(function() {
        c.length && (c.forEach(function(f) {
            return f()
        }),
        u(D3))
    }, [c]),
    [r, h]
}
var g0;
function i_(e) {
    if (typeof document > "u")
        return 0;
    if (e || g0 === void 0) {
        var t = document.createElement("div");
        t.style.width = "100%",
        t.style.height = "200px";
        var n = document.createElement("div")
          , i = n.style;
        i.position = "absolute",
        i.top = "0",
        i.left = "0",
        i.pointerEvents = "none",
        i.visibility = "hidden",
        i.width = "200px",
        i.height = "150px",
        i.overflow = "hidden",
        n.appendChild(t),
        document.body.appendChild(n);
        var r = t.offsetWidth;
        n.style.overflow = "scroll";
        var s = t.offsetWidth;
        r === s && (s = n.clientWidth),
        document.body.removeChild(n),
        g0 = r - s
    }
    return g0
}
function N3(e) {
    var t = e.match(/^(.*)px$/)
      , n = Number(t == null ? void 0 : t[1]);
    return Number.isNaN(n) ? i_() : n
}
function r_(e) {
    if (typeof document > "u" || !e || !(e instanceof Element))
        return {
            width: 0,
            height: 0
        };
    var t = getComputedStyle(e, "::-webkit-scrollbar")
      , n = t.width
      , i = t.height;
    return {
        width: N3(n),
        height: N3(i)
    }
}
function s_() {
    return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth
}
var o_ = "rc-util-locker-".concat(Date.now())
  , F3 = 0;
function a_(e) {
    var t = !!e
      , n = M.useState(function() {
        return F3 += 1,
        "".concat(o_, "_").concat(F3)
    })
      , i = Me(n, 1)
      , r = i[0];
    pn(function() {
        if (t) {
            var s = r_(document.body).width
              , o = s_();
            Wl(`
html body {
  overflow-y: hidden;
  `.concat(o ? "width: calc(100% - ".concat(s, "px);") : "", `
}`), r)
        } else
            zh(r);
        return function() {
            zh(r)
        }
    }, [t, r])
}
var I3 = !1;
function l_(e) {
    return typeof e == "boolean" && (I3 = e),
    I3
}
var B3 = function(t) {
    return t === !1 ? !1 : !Tn() || !t ? null : typeof t == "string" ? document.querySelector(t) : typeof t == "function" ? t() : t
}
  , VS = M.forwardRef(function(e, t) {
    var n = e.open
      , i = e.autoLock
      , r = e.getContainer;
    e.debug;
    var s = e.autoDestroy
      , o = s === void 0 ? !0 : s
      , a = e.children
      , l = M.useState(n)
      , c = Me(l, 2)
      , u = c[0]
      , h = c[1]
      , d = u || n;
    M.useEffect(function() {
        (o || n) && h(n)
    }, [n, o]);
    var m = M.useState(function() {
        return B3(r)
    })
      , f = Me(m, 2)
      , x = f[0]
      , S = f[1];
    M.useEffect(function() {
        var T = B3(r);
        S(T ?? null)
    });
    var v = n_(d && !x)
      , p = Me(v, 2)
      , g = p[0]
      , C = p[1]
      , E = x ?? g;
    a_(i && n && Tn() && (E === g || E === document.body));
    var O = null;
    if (a && mc(a) && t) {
        var R = a;
        O = R.ref
    }
    var F = h2(O, t);
    if (!d || !Tn() || x === void 0)
        return null;
    var P = E === !1 || l_()
      , _ = a;
    return t && (_ = M.cloneElement(a, {
        ref: F
    })),
    M.createElement(zS.Provider, {
        value: C
    }, P ? _ : Td.createPortal(_, E))
});
function c_() {
    var e = be({}, uc);
    return e.useId
}
var z3 = 0
  , V3 = c_();
const u_ = V3 ? function(t) {
    var n = V3();
    return t || n
}
: function(t) {
    var n = M.useState("ssr-id")
      , i = Me(n, 2)
      , r = i[0]
      , s = i[1];
    return M.useEffect(function() {
        var o = z3;
        z3 += 1,
        s("rc_unique_".concat(o))
    }, []),
    t || r
}
;
var _s = "RC_FORM_INTERNAL_HOOKS"
  , tt = function() {
    ii(!1, "Can not find FormContext. Please make sure you wrap Field under Form.")
}
  , fa = M.createContext({
    getFieldValue: tt,
    getFieldsValue: tt,
    getFieldError: tt,
    getFieldWarning: tt,
    getFieldsError: tt,
    isFieldsTouched: tt,
    isFieldTouched: tt,
    isFieldValidating: tt,
    isFieldsValidating: tt,
    resetFields: tt,
    setFields: tt,
    setFieldValue: tt,
    setFieldsValue: tt,
    validateFields: tt,
    submit: tt,
    getInternalHooks: function() {
        return tt(),
        {
            dispatch: tt,
            initEntityValue: tt,
            registerField: tt,
            useSubscribe: tt,
            setInitialValues: tt,
            destroyForm: tt,
            setCallbacks: tt,
            registerWatch: tt,
            getFields: tt,
            setValidateMessages: tt,
            setPreserve: tt,
            getInitialValue: tt
        }
    }
})
  , Uh = M.createContext(null);
function jp(e) {
    return e == null ? [] : Array.isArray(e) ? e : [e]
}
function h_(e) {
    return e && !!e._init
}
function Ds() {
    return Ds = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Ds.apply(this, arguments)
}
function d_(e, t) {
    e.prototype = Object.create(t.prototype),
    e.prototype.constructor = e,
    Xl(e, t)
}
function Op(e) {
    return Op = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }
    ,
    Op(e)
}
function Xl(e, t) {
    return Xl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, r) {
        return i.__proto__ = r,
        i
    }
    ,
    Xl(e, t)
}
function f_() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
        !0
    } catch {
        return !1
    }
}
function eh(e, t, n) {
    return f_() ? eh = Reflect.construct.bind() : eh = function(r, s, o) {
        var a = [null];
        a.push.apply(a, s);
        var l = Function.bind.apply(r, a)
          , c = new l;
        return o && Xl(c, o.prototype),
        c
    }
    ,
    eh.apply(null, arguments)
}
function p_(e) {
    return Function.toString.call(e).indexOf("[native code]") !== -1
}
function Lp(e) {
    var t = typeof Map == "function" ? new Map : void 0;
    return Lp = function(i) {
        if (i === null || !p_(i))
            return i;
        if (typeof i != "function")
            throw new TypeError("Super expression must either be null or a function");
        if (typeof t < "u") {
            if (t.has(i))
                return t.get(i);
            t.set(i, r)
        }
        function r() {
            return eh(i, arguments, Op(this).constructor)
        }
        return r.prototype = Object.create(i.prototype, {
            constructor: {
                value: r,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        Xl(r, i)
    }
    ,
    Lp(e)
}
var g_ = /%[sdj%]/g
  , m_ = function() {};
function Rp(e) {
    if (!e || !e.length)
        return null;
    var t = {};
    return e.forEach(function(n) {
        var i = n.field;
        t[i] = t[i] || [],
        t[i].push(n)
    }),
    t
}
function In(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
        n[i - 1] = arguments[i];
    var r = 0
      , s = n.length;
    if (typeof e == "function")
        return e.apply(null, n);
    if (typeof e == "string") {
        var o = e.replace(g_, function(a) {
            if (a === "%%")
                return "%";
            if (r >= s)
                return a;
            switch (a) {
            case "%s":
                return String(n[r++]);
            case "%d":
                return Number(n[r++]);
            case "%j":
                try {
                    return JSON.stringify(n[r++])
                } catch {
                    return "[Circular]"
                }
                break;
            default:
                return a
            }
        });
        return o
    }
    return e
}
function v_(e) {
    return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern"
}
function Ut(e, t) {
    return !!(e == null || t === "array" && Array.isArray(e) && !e.length || v_(t) && typeof e == "string" && !e)
}
function y_(e, t, n) {
    var i = []
      , r = 0
      , s = e.length;
    function o(a) {
        i.push.apply(i, a || []),
        r++,
        r === s && n(i)
    }
    e.forEach(function(a) {
        t(a, o)
    })
}
function W3(e, t, n) {
    var i = 0
      , r = e.length;
    function s(o) {
        if (o && o.length) {
            n(o);
            return
        }
        var a = i;
        i = i + 1,
        a < r ? t(e[a], s) : n([])
    }
    s([])
}
function x_(e) {
    var t = [];
    return Object.keys(e).forEach(function(n) {
        t.push.apply(t, e[n] || [])
    }),
    t
}
var H3 = function(e) {
    d_(t, e);
    function t(n, i) {
        var r;
        return r = e.call(this, "Async Validation Error") || this,
        r.errors = n,
        r.fields = i,
        r
    }
    return t
}(Lp(Error));
function b_(e, t, n, i, r) {
    if (t.first) {
        var s = new Promise(function(d, m) {
            var f = function(v) {
                return i(v),
                v.length ? m(new H3(v,Rp(v))) : d(r)
            }
              , x = x_(e);
            W3(x, n, f)
        }
        );
        return s.catch(function(d) {
            return d
        }),
        s
    }
    var o = t.firstFields === !0 ? Object.keys(e) : t.firstFields || []
      , a = Object.keys(e)
      , l = a.length
      , c = 0
      , u = []
      , h = new Promise(function(d, m) {
        var f = function(S) {
            if (u.push.apply(u, S),
            c++,
            c === l)
                return i(u),
                u.length ? m(new H3(u,Rp(u))) : d(r)
        };
        a.length || (i(u),
        d(r)),
        a.forEach(function(x) {
            var S = e[x];
            o.indexOf(x) !== -1 ? W3(S, n, f) : y_(S, n, f)
        })
    }
    );
    return h.catch(function(d) {
        return d
    }),
    h
}
function w_(e) {
    return !!(e && e.message !== void 0)
}
function S_(e, t) {
    for (var n = e, i = 0; i < t.length; i++) {
        if (n == null)
            return n;
        n = n[t[i]]
    }
    return n
}
function U3(e, t) {
    return function(n) {
        var i;
        return e.fullFields ? i = S_(t, e.fullFields) : i = t[n.field || e.fullField],
        w_(n) ? (n.field = n.field || e.fullField,
        n.fieldValue = i,
        n) : {
            message: typeof n == "function" ? n() : n,
            fieldValue: i,
            field: n.field || e.fullField
        }
    }
}
function G3(e, t) {
    if (t) {
        for (var n in t)
            if (t.hasOwnProperty(n)) {
                var i = t[n];
                typeof i == "object" && typeof e[n] == "object" ? e[n] = Ds({}, e[n], i) : e[n] = i
            }
    }
    return e
}
var WS = function(t, n, i, r, s, o) {
    t.required && (!i.hasOwnProperty(t.field) || Ut(n, o || t.type)) && r.push(In(s.messages.required, t.fullField))
}, C_ = function(t, n, i, r, s) {
    (/^\s+$/.test(n) || n === "") && r.push(In(s.messages.whitespace, t.fullField))
}, hu, k_ = function() {
    if (hu)
        return hu;
    var e = "[a-fA-F\\d:]"
      , t = function(C) {
        return C && C.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : ""
    }
      , n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}"
      , i = "[a-fA-F\\d]{1,4}"
      , r = (`
(?:
(?:` + i + ":){7}(?:" + i + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + i + ":){6}(?:" + n + "|:" + i + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + i + ":){5}(?::" + n + "|(?::" + i + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + i + ":){4}(?:(?::" + i + "){0,1}:" + n + "|(?::" + i + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + i + ":){3}(?:(?::" + i + "){0,2}:" + n + "|(?::" + i + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + i + ":){2}(?:(?::" + i + "){0,3}:" + n + "|(?::" + i + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + i + ":){1}(?:(?::" + i + "){0,4}:" + n + "|(?::" + i + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + i + "){0,5}:" + n + "|(?::" + i + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim()
      , s = new RegExp("(?:^" + n + "$)|(?:^" + r + "$)")
      , o = new RegExp("^" + n + "$")
      , a = new RegExp("^" + r + "$")
      , l = function(C) {
        return C && C.exact ? s : new RegExp("(?:" + t(C) + n + t(C) + ")|(?:" + t(C) + r + t(C) + ")","g")
    };
    l.v4 = function(g) {
        return g && g.exact ? o : new RegExp("" + t(g) + n + t(g),"g")
    }
    ,
    l.v6 = function(g) {
        return g && g.exact ? a : new RegExp("" + t(g) + r + t(g),"g")
    }
    ;
    var c = "(?:(?:[a-z]+:)?//)"
      , u = "(?:\\S+(?::\\S*)?@)?"
      , h = l.v4().source
      , d = l.v6().source
      , m = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)"
      , f = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*"
      , x = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))"
      , S = "(?::\\d{2,5})?"
      , v = '(?:[/?#][^\\s"]*)?'
      , p = "(?:" + c + "|www\\.)" + u + "(?:localhost|" + h + "|" + d + "|" + m + f + x + ")" + S + v;
    return hu = new RegExp("(?:^" + p + "$)","i"),
    hu
}, X3 = {
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, Qa = {
    integer: function(t) {
        return Qa.number(t) && parseInt(t, 10) === t
    },
    float: function(t) {
        return Qa.number(t) && !Qa.integer(t)
    },
    array: function(t) {
        return Array.isArray(t)
    },
    regexp: function(t) {
        if (t instanceof RegExp)
            return !0;
        try {
            return !!new RegExp(t)
        } catch {
            return !1
        }
    },
    date: function(t) {
        return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime())
    },
    number: function(t) {
        return isNaN(t) ? !1 : typeof t == "number"
    },
    object: function(t) {
        return typeof t == "object" && !Qa.array(t)
    },
    method: function(t) {
        return typeof t == "function"
    },
    email: function(t) {
        return typeof t == "string" && t.length <= 320 && !!t.match(X3.email)
    },
    url: function(t) {
        return typeof t == "string" && t.length <= 2048 && !!t.match(k_())
    },
    hex: function(t) {
        return typeof t == "string" && !!t.match(X3.hex)
    }
}, A_ = function(t, n, i, r, s) {
    if (t.required && n === void 0) {
        WS(t, n, i, r, s);
        return
    }
    var o = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"]
      , a = t.type;
    o.indexOf(a) > -1 ? Qa[a](n) || r.push(In(s.messages.types[a], t.fullField, t.type)) : a && typeof n !== t.type && r.push(In(s.messages.types[a], t.fullField, t.type))
}, M_ = function(t, n, i, r, s) {
    var o = typeof t.len == "number"
      , a = typeof t.min == "number"
      , l = typeof t.max == "number"
      , c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g
      , u = n
      , h = null
      , d = typeof n == "number"
      , m = typeof n == "string"
      , f = Array.isArray(n);
    if (d ? h = "number" : m ? h = "string" : f && (h = "array"),
    !h)
        return !1;
    f && (u = n.length),
    m && (u = n.replace(c, "_").length),
    o ? u !== t.len && r.push(In(s.messages[h].len, t.fullField, t.len)) : a && !l && u < t.min ? r.push(In(s.messages[h].min, t.fullField, t.min)) : l && !a && u > t.max ? r.push(In(s.messages[h].max, t.fullField, t.max)) : a && l && (u < t.min || u > t.max) && r.push(In(s.messages[h].range, t.fullField, t.min, t.max))
}, vo = "enum", E_ = function(t, n, i, r, s) {
    t[vo] = Array.isArray(t[vo]) ? t[vo] : [],
    t[vo].indexOf(n) === -1 && r.push(In(s.messages[vo], t.fullField, t[vo].join(", ")))
}, P_ = function(t, n, i, r, s) {
    if (t.pattern) {
        if (t.pattern instanceof RegExp)
            t.pattern.lastIndex = 0,
            t.pattern.test(n) || r.push(In(s.messages.pattern.mismatch, t.fullField, n, t.pattern));
        else if (typeof t.pattern == "string") {
            var o = new RegExp(t.pattern);
            o.test(n) || r.push(In(s.messages.pattern.mismatch, t.fullField, n, t.pattern))
        }
    }
}, Ue = {
    required: WS,
    whitespace: C_,
    type: A_,
    range: M_,
    enum: E_,
    pattern: P_
}, T_ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (Ut(n, "string") && !t.required)
            return i();
        Ue.required(t, n, r, o, s, "string"),
        Ut(n, "string") || (Ue.type(t, n, r, o, s),
        Ue.range(t, n, r, o, s),
        Ue.pattern(t, n, r, o, s),
        t.whitespace === !0 && Ue.whitespace(t, n, r, o, s))
    }
    i(o)
}, j_ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (Ut(n) && !t.required)
            return i();
        Ue.required(t, n, r, o, s),
        n !== void 0 && Ue.type(t, n, r, o, s)
    }
    i(o)
}, O_ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (n === "" && (n = void 0),
        Ut(n) && !t.required)
            return i();
        Ue.required(t, n, r, o, s),
        n !== void 0 && (Ue.type(t, n, r, o, s),
        Ue.range(t, n, r, o, s))
    }
    i(o)
}, L_ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (Ut(n) && !t.required)
            return i();
        Ue.required(t, n, r, o, s),
        n !== void 0 && Ue.type(t, n, r, o, s)
    }
    i(o)
}, R_ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (Ut(n) && !t.required)
            return i();
        Ue.required(t, n, r, o, s),
        Ut(n) || Ue.type(t, n, r, o, s)
    }
    i(o)
}, __ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (Ut(n) && !t.required)
            return i();
        Ue.required(t, n, r, o, s),
        n !== void 0 && (Ue.type(t, n, r, o, s),
        Ue.range(t, n, r, o, s))
    }
    i(o)
}, D_ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (Ut(n) && !t.required)
            return i();
        Ue.required(t, n, r, o, s),
        n !== void 0 && (Ue.type(t, n, r, o, s),
        Ue.range(t, n, r, o, s))
    }
    i(o)
}, N_ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (n == null && !t.required)
            return i();
        Ue.required(t, n, r, o, s, "array"),
        n != null && (Ue.type(t, n, r, o, s),
        Ue.range(t, n, r, o, s))
    }
    i(o)
}, F_ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (Ut(n) && !t.required)
            return i();
        Ue.required(t, n, r, o, s),
        n !== void 0 && Ue.type(t, n, r, o, s)
    }
    i(o)
}, I_ = "enum", B_ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (Ut(n) && !t.required)
            return i();
        Ue.required(t, n, r, o, s),
        n !== void 0 && Ue[I_](t, n, r, o, s)
    }
    i(o)
}, z_ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (Ut(n, "string") && !t.required)
            return i();
        Ue.required(t, n, r, o, s),
        Ut(n, "string") || Ue.pattern(t, n, r, o, s)
    }
    i(o)
}, V_ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (Ut(n, "date") && !t.required)
            return i();
        if (Ue.required(t, n, r, o, s),
        !Ut(n, "date")) {
            var l;
            n instanceof Date ? l = n : l = new Date(n),
            Ue.type(t, l, r, o, s),
            l && Ue.range(t, l.getTime(), r, o, s)
        }
    }
    i(o)
}, W_ = function(t, n, i, r, s) {
    var o = []
      , a = Array.isArray(n) ? "array" : typeof n;
    Ue.required(t, n, r, o, s, a),
    i(o)
}, m0 = function(t, n, i, r, s) {
    var o = t.type
      , a = []
      , l = t.required || !t.required && r.hasOwnProperty(t.field);
    if (l) {
        if (Ut(n, o) && !t.required)
            return i();
        Ue.required(t, n, r, a, s, o),
        Ut(n, o) || Ue.type(t, n, r, a, s)
    }
    i(a)
}, H_ = function(t, n, i, r, s) {
    var o = []
      , a = t.required || !t.required && r.hasOwnProperty(t.field);
    if (a) {
        if (Ut(n) && !t.required)
            return i();
        Ue.required(t, n, r, o, s)
    }
    i(o)
}, pl = {
    string: T_,
    method: j_,
    number: O_,
    boolean: L_,
    regexp: R_,
    integer: __,
    float: D_,
    array: N_,
    object: F_,
    enum: B_,
    pattern: z_,
    date: V_,
    url: m0,
    hex: m0,
    email: m0,
    required: W_,
    any: H_
};
function _p() {
    return {
        default: "Validation error on field %s",
        required: "%s is required",
        enum: "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
        },
        types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            boolean: "%s is not a %s",
            integer: "%s is not an %s",
            float: "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
        },
        string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
        },
        number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
        },
        array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
        },
        pattern: {
            mismatch: "%s value %s does not match pattern %s"
        },
        clone: function() {
            var t = JSON.parse(JSON.stringify(this));
            return t.clone = this.clone,
            t
        }
    }
}
var Dp = _p()
  , yc = function() {
    function e(n) {
        this.rules = null,
        this._messages = Dp,
        this.define(n)
    }
    var t = e.prototype;
    return t.define = function(i) {
        var r = this;
        if (!i)
            throw new Error("Cannot configure a schema with no rules");
        if (typeof i != "object" || Array.isArray(i))
            throw new Error("Rules must be an object");
        this.rules = {},
        Object.keys(i).forEach(function(s) {
            var o = i[s];
            r.rules[s] = Array.isArray(o) ? o : [o]
        })
    }
    ,
    t.messages = function(i) {
        return i && (this._messages = G3(_p(), i)),
        this._messages
    }
    ,
    t.validate = function(i, r, s) {
        var o = this;
        r === void 0 && (r = {}),
        s === void 0 && (s = function() {}
        );
        var a = i
          , l = r
          , c = s;
        if (typeof l == "function" && (c = l,
        l = {}),
        !this.rules || Object.keys(this.rules).length === 0)
            return c && c(null, a),
            Promise.resolve(a);
        function u(x) {
            var S = []
              , v = {};
            function p(C) {
                if (Array.isArray(C)) {
                    var E;
                    S = (E = S).concat.apply(E, C)
                } else
                    S.push(C)
            }
            for (var g = 0; g < x.length; g++)
                p(x[g]);
            S.length ? (v = Rp(S),
            c(S, v)) : c(null, a)
        }
        if (l.messages) {
            var h = this.messages();
            h === Dp && (h = _p()),
            G3(h, l.messages),
            l.messages = h
        } else
            l.messages = this.messages();
        var d = {}
          , m = l.keys || Object.keys(this.rules);
        m.forEach(function(x) {
            var S = o.rules[x]
              , v = a[x];
            S.forEach(function(p) {
                var g = p;
                typeof g.transform == "function" && (a === i && (a = Ds({}, a)),
                v = a[x] = g.transform(v)),
                typeof g == "function" ? g = {
                    validator: g
                } : g = Ds({}, g),
                g.validator = o.getValidationMethod(g),
                g.validator && (g.field = x,
                g.fullField = g.fullField || x,
                g.type = o.getType(g),
                d[x] = d[x] || [],
                d[x].push({
                    rule: g,
                    value: v,
                    source: a,
                    field: x
                }))
            })
        });
        var f = {};
        return b_(d, l, function(x, S) {
            var v = x.rule
              , p = (v.type === "object" || v.type === "array") && (typeof v.fields == "object" || typeof v.defaultField == "object");
            p = p && (v.required || !v.required && x.value),
            v.field = x.field;
            function g(O, R) {
                return Ds({}, R, {
                    fullField: v.fullField + "." + O,
                    fullFields: v.fullFields ? [].concat(v.fullFields, [O]) : [O]
                })
            }
            function C(O) {
                O === void 0 && (O = []);
                var R = Array.isArray(O) ? O : [O];
                !l.suppressWarning && R.length && e.warning("async-validator:", R),
                R.length && v.message !== void 0 && (R = [].concat(v.message));
                var F = R.map(U3(v, a));
                if (l.first && F.length)
                    return f[v.field] = 1,
                    S(F);
                if (!p)
                    S(F);
                else {
                    if (v.required && !x.value)
                        return v.message !== void 0 ? F = [].concat(v.message).map(U3(v, a)) : l.error && (F = [l.error(v, In(l.messages.required, v.field))]),
                        S(F);
                    var P = {};
                    v.defaultField && Object.keys(x.value).map(function(L) {
                        P[L] = v.defaultField
                    }),
                    P = Ds({}, P, x.rule.fields);
                    var _ = {};
                    Object.keys(P).forEach(function(L) {
                        var I = P[L]
                          , k = Array.isArray(I) ? I : [I];
                        _[L] = k.map(g.bind(null, L))
                    });
                    var T = new e(_);
                    T.messages(l.messages),
                    x.rule.options && (x.rule.options.messages = l.messages,
                    x.rule.options.error = l.error),
                    T.validate(x.value, x.rule.options || l, function(L) {
                        var I = [];
                        F && F.length && I.push.apply(I, F),
                        L && L.length && I.push.apply(I, L),
                        S(I.length ? I : null)
                    })
                }
            }
            var E;
            if (v.asyncValidator)
                E = v.asyncValidator(v, x.value, C, x.source, l);
            else if (v.validator) {
                try {
                    E = v.validator(v, x.value, C, x.source, l)
                } catch (O) {
                    console.error == null || console.error(O),
                    l.suppressValidatorError || setTimeout(function() {
                        throw O
                    }, 0),
                    C(O.message)
                }
                E === !0 ? C() : E === !1 ? C(typeof v.message == "function" ? v.message(v.fullField || v.field) : v.message || (v.fullField || v.field) + " fails") : E instanceof Array ? C(E) : E instanceof Error && C(E.message)
            }
            E && E.then && E.then(function() {
                return C()
            }, function(O) {
                return C(O)
            })
        }, function(x) {
            u(x)
        }, a)
    }
    ,
    t.getType = function(i) {
        if (i.type === void 0 && i.pattern instanceof RegExp && (i.type = "pattern"),
        typeof i.validator != "function" && i.type && !pl.hasOwnProperty(i.type))
            throw new Error(In("Unknown rule type %s", i.type));
        return i.type || "string"
    }
    ,
    t.getValidationMethod = function(i) {
        if (typeof i.validator == "function")
            return i.validator;
        var r = Object.keys(i)
          , s = r.indexOf("message");
        return s !== -1 && r.splice(s, 1),
        r.length === 1 && r[0] === "required" ? pl.required : pl[this.getType(i)] || void 0
    }
    ,
    e
}();
yc.register = function(t, n) {
    if (typeof n != "function")
        throw new Error("Cannot register a validator by type, validator is not a function");
    pl[t] = n
}
;
yc.warning = m_;
yc.messages = Dp;
yc.validators = pl;
var Ln = "'${name}' is not a valid ${type}"
  , HS = {
    default: "Validation error on field '${name}'",
    required: "'${name}' is required",
    enum: "'${name}' must be one of [${enum}]",
    whitespace: "'${name}' cannot be empty",
    date: {
        format: "'${name}' is invalid for format date",
        parse: "'${name}' could not be parsed as date",
        invalid: "'${name}' is invalid date"
    },
    types: {
        string: Ln,
        method: Ln,
        array: Ln,
        object: Ln,
        number: Ln,
        date: Ln,
        boolean: Ln,
        integer: Ln,
        float: Ln,
        regexp: Ln,
        email: Ln,
        url: Ln,
        hex: Ln
    },
    string: {
        len: "'${name}' must be exactly ${len} characters",
        min: "'${name}' must be at least ${min} characters",
        max: "'${name}' cannot be longer than ${max} characters",
        range: "'${name}' must be between ${min} and ${max} characters"
    },
    number: {
        len: "'${name}' must equal ${len}",
        min: "'${name}' cannot be less than ${min}",
        max: "'${name}' cannot be greater than ${max}",
        range: "'${name}' must be between ${min} and ${max}"
    },
    array: {
        len: "'${name}' must be exactly ${len} in length",
        min: "'${name}' cannot be less than ${min} in length",
        max: "'${name}' cannot be greater than ${max} in length",
        range: "'${name}' must be between ${min} and ${max} in length"
    },
    pattern: {
        mismatch: "'${name}' does not match pattern ${pattern}"
    }
}
  , Y3 = yc;
function U_(e, t) {
    return e.replace(/\$\{\w+\}/g, function(n) {
        var i = n.slice(2, -1);
        return t[i]
    })
}
var $3 = "CODE_LOGIC_ERROR";
function Np(e, t, n, i, r) {
    return Fp.apply(this, arguments)
}
function Fp() {
    return Fp = io(vn().mark(function e(t, n, i, r, s) {
        var o, a, l, c, u, h, d, m, f;
        return vn().wrap(function(S) {
            for (; ; )
                switch (S.prev = S.next) {
                case 0:
                    return o = be({}, i),
                    delete o.ruleIndex,
                    Y3.warning = function() {}
                    ,
                    o.validator && (a = o.validator,
                    o.validator = function() {
                        try {
                            return a.apply(void 0, arguments)
                        } catch (v) {
                            return console.error(v),
                            Promise.reject($3)
                        }
                    }
                    ),
                    l = null,
                    o && o.type === "array" && o.defaultField && (l = o.defaultField,
                    delete o.defaultField),
                    c = new Y3(me({}, t, [o])),
                    u = Io(HS, r.validateMessages),
                    c.messages(u),
                    h = [],
                    S.prev = 10,
                    S.next = 13,
                    Promise.resolve(c.validate(me({}, t, n), be({}, r)));
                case 13:
                    S.next = 18;
                    break;
                case 15:
                    S.prev = 15,
                    S.t0 = S.catch(10),
                    S.t0.errors && (h = S.t0.errors.map(function(v, p) {
                        var g = v.message
                          , C = g === $3 ? u.default : g;
                        return M.isValidElement(C) ? M.cloneElement(C, {
                            key: "error_".concat(p)
                        }) : C
                    }));
                case 18:
                    if (!(!h.length && l)) {
                        S.next = 23;
                        break
                    }
                    return S.next = 21,
                    Promise.all(n.map(function(v, p) {
                        return Np("".concat(t, ".").concat(p), v, l, r, s)
                    }));
                case 21:
                    return d = S.sent,
                    S.abrupt("return", d.reduce(function(v, p) {
                        return [].concat(Re(v), Re(p))
                    }, []));
                case 23:
                    return m = be(be({}, i), {}, {
                        name: t,
                        enum: (i.enum || []).join(", ")
                    }, s),
                    f = h.map(function(v) {
                        return typeof v == "string" ? U_(v, m) : v
                    }),
                    S.abrupt("return", f);
                case 26:
                case "end":
                    return S.stop()
                }
        }, e, null, [[10, 15]])
    })),
    Fp.apply(this, arguments)
}
function G_(e, t, n, i, r, s) {
    var o = e.join("."), a = n.map(function(u, h) {
        var d = u.validator
          , m = be(be({}, u), {}, {
            ruleIndex: h
        });
        return d && (m.validator = function(f, x, S) {
            var v = !1
              , p = function() {
                for (var E = arguments.length, O = new Array(E), R = 0; R < E; R++)
                    O[R] = arguments[R];
                Promise.resolve().then(function() {
                    ii(!v, "Your validator function has already return a promise. `callback` will be ignored."),
                    v || S.apply(void 0, O)
                })
            }
              , g = d(f, x, p);
            v = g && typeof g.then == "function" && typeof g.catch == "function",
            ii(v, "`callback` is deprecated. Please return a promise instead."),
            v && g.then(function() {
                S()
            }).catch(function(C) {
                S(C || " ")
            })
        }
        ),
        m
    }).sort(function(u, h) {
        var d = u.warningOnly
          , m = u.ruleIndex
          , f = h.warningOnly
          , x = h.ruleIndex;
        return !!d == !!f ? m - x : d ? 1 : -1
    }), l;
    if (r === !0)
        l = new Promise(function() {
            var u = io(vn().mark(function h(d, m) {
                var f, x, S;
                return vn().wrap(function(p) {
                    for (; ; )
                        switch (p.prev = p.next) {
                        case 0:
                            f = 0;
                        case 1:
                            if (!(f < a.length)) {
                                p.next = 12;
                                break
                            }
                            return x = a[f],
                            p.next = 5,
                            Np(o, t, x, i, s);
                        case 5:
                            if (S = p.sent,
                            !S.length) {
                                p.next = 9;
                                break
                            }
                            return m([{
                                errors: S,
                                rule: x
                            }]),
                            p.abrupt("return");
                        case 9:
                            f += 1,
                            p.next = 1;
                            break;
                        case 12:
                            d([]);
                        case 13:
                        case "end":
                            return p.stop()
                        }
                }, h)
            }));
            return function(h, d) {
                return u.apply(this, arguments)
            }
        }());
    else {
        var c = a.map(function(u) {
            return Np(o, t, u, i, s).then(function(h) {
                return {
                    errors: h,
                    rule: u
                }
            })
        });
        l = (r ? Y_(c) : X_(c)).then(function(u) {
            return Promise.reject(u)
        })
    }
    return l.catch(function(u) {
        return u
    }),
    l
}
function X_(e) {
    return Ip.apply(this, arguments)
}
function Ip() {
    return Ip = io(vn().mark(function e(t) {
        return vn().wrap(function(i) {
            for (; ; )
                switch (i.prev = i.next) {
                case 0:
                    return i.abrupt("return", Promise.all(t).then(function(r) {
                        var s, o = (s = []).concat.apply(s, Re(r));
                        return o
                    }));
                case 1:
                case "end":
                    return i.stop()
                }
        }, e)
    })),
    Ip.apply(this, arguments)
}
function Y_(e) {
    return Bp.apply(this, arguments)
}
function Bp() {
    return Bp = io(vn().mark(function e(t) {
        var n;
        return vn().wrap(function(r) {
            for (; ; )
                switch (r.prev = r.next) {
                case 0:
                    return n = 0,
                    r.abrupt("return", new Promise(function(s) {
                        t.forEach(function(o) {
                            o.then(function(a) {
                                a.errors.length && s([a]),
                                n += 1,
                                n === t.length && s([])
                            })
                        })
                    }
                    ));
                case 2:
                case "end":
                    return r.stop()
                }
        }, e)
    })),
    Bp.apply(this, arguments)
}
function jt(e) {
    return jp(e)
}
function K3(e, t) {
    var n = {};
    return t.forEach(function(i) {
        var r = yi(e, i);
        n = gi(n, i, r)
    }),
    n
}
function Jo(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    return e && e.some(function(i) {
        return US(t, i, n)
    })
}
function US(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    return !e || !t || !n && e.length !== t.length ? !1 : t.every(function(i, r) {
        return e[r] === i
    })
}
function $_(e, t) {
    if (e === t)
        return !0;
    if (!e && t || e && !t || !e || !t || it(e) !== "object" || it(t) !== "object")
        return !1;
    var n = Object.keys(e)
      , i = Object.keys(t)
      , r = new Set([].concat(n, i));
    return Re(r).every(function(s) {
        var o = e[s]
          , a = t[s];
        return typeof o == "function" && typeof a == "function" ? !0 : o === a
    })
}
function K_(e) {
    var t = arguments.length <= 1 ? void 0 : arguments[1];
    return t && t.target && it(t.target) === "object" && e in t.target ? t.target[e] : t
}
function Q3(e, t, n) {
    var i = e.length;
    if (t < 0 || t >= i || n < 0 || n >= i)
        return e;
    var r = e[t]
      , s = t - n;
    return s > 0 ? [].concat(Re(e.slice(0, n)), [r], Re(e.slice(n, t)), Re(e.slice(t + 1, i))) : s < 0 ? [].concat(Re(e.slice(0, t)), Re(e.slice(t + 1, n + 1)), [r], Re(e.slice(n + 1, i))) : e
}
var Q_ = ["name"]
  , $n = [];
function q3(e, t, n, i, r, s) {
    return typeof e == "function" ? e(t, n, "source"in s ? {
        source: s.source
    } : {}) : i !== r
}
var E2 = function(e) {
    Hd(n, e);
    var t = Ud(n);
    function n(i) {
        var r;
        if (zi(this, n),
        r = t.call(this, i),
        me(Ye(r), "state", {
            resetCount: 0
        }),
        me(Ye(r), "cancelRegisterFunc", null),
        me(Ye(r), "mounted", !1),
        me(Ye(r), "touched", !1),
        me(Ye(r), "dirty", !1),
        me(Ye(r), "validatePromise", void 0),
        me(Ye(r), "prevValidating", void 0),
        me(Ye(r), "errors", $n),
        me(Ye(r), "warnings", $n),
        me(Ye(r), "cancelRegister", function() {
            var l = r.props
              , c = l.preserve
              , u = l.isListField
              , h = l.name;
            r.cancelRegisterFunc && r.cancelRegisterFunc(u, c, jt(h)),
            r.cancelRegisterFunc = null
        }),
        me(Ye(r), "getNamePath", function() {
            var l = r.props
              , c = l.name
              , u = l.fieldContext
              , h = u.prefixName
              , d = h === void 0 ? [] : h;
            return c !== void 0 ? [].concat(Re(d), Re(c)) : []
        }),
        me(Ye(r), "getRules", function() {
            var l = r.props
              , c = l.rules
              , u = c === void 0 ? [] : c
              , h = l.fieldContext;
            return u.map(function(d) {
                return typeof d == "function" ? d(h) : d
            })
        }),
        me(Ye(r), "refresh", function() {
            r.mounted && r.setState(function(l) {
                var c = l.resetCount;
                return {
                    resetCount: c + 1
                }
            })
        }),
        me(Ye(r), "metaCache", null),
        me(Ye(r), "triggerMetaEvent", function(l) {
            var c = r.props.onMetaChange;
            if (c) {
                var u = be(be({}, r.getMeta()), {}, {
                    destroy: l
                });
                m2(r.metaCache, u) || c(u),
                r.metaCache = u
            } else
                r.metaCache = null
        }),
        me(Ye(r), "onStoreChange", function(l, c, u) {
            var h = r.props
              , d = h.shouldUpdate
              , m = h.dependencies
              , f = m === void 0 ? [] : m
              , x = h.onReset
              , S = u.store
              , v = r.getNamePath()
              , p = r.getValue(l)
              , g = r.getValue(S)
              , C = c && Jo(c, v);
            switch (u.type === "valueUpdate" && u.source === "external" && p !== g && (r.touched = !0,
            r.dirty = !0,
            r.validatePromise = null,
            r.errors = $n,
            r.warnings = $n,
            r.triggerMetaEvent()),
            u.type) {
            case "reset":
                if (!c || C) {
                    r.touched = !1,
                    r.dirty = !1,
                    r.validatePromise = void 0,
                    r.errors = $n,
                    r.warnings = $n,
                    r.triggerMetaEvent(),
                    x == null || x(),
                    r.refresh();
                    return
                }
                break;
            case "remove":
                {
                    if (d) {
                        r.reRender();
                        return
                    }
                    break
                }
            case "setField":
                {
                    var E = u.data;
                    if (C) {
                        "touched"in E && (r.touched = E.touched),
                        "validating"in E && !("originRCField"in E) && (r.validatePromise = E.validating ? Promise.resolve([]) : null),
                        "errors"in E && (r.errors = E.errors || $n),
                        "warnings"in E && (r.warnings = E.warnings || $n),
                        r.dirty = !0,
                        r.triggerMetaEvent(),
                        r.reRender();
                        return
                    } else if ("value"in E && Jo(c, v, !0)) {
                        r.reRender();
                        return
                    }
                    if (d && !v.length && q3(d, l, S, p, g, u)) {
                        r.reRender();
                        return
                    }
                    break
                }
            case "dependenciesUpdate":
                {
                    var O = f.map(jt);
                    if (O.some(function(R) {
                        return Jo(u.relatedFields, R)
                    })) {
                        r.reRender();
                        return
                    }
                    break
                }
            default:
                if (C || (!f.length || v.length || d) && q3(d, l, S, p, g, u)) {
                    r.reRender();
                    return
                }
                break
            }
            d === !0 && r.reRender()
        }),
        me(Ye(r), "validateRules", function(l) {
            var c = r.getNamePath()
              , u = r.getValue()
              , h = l || {}
              , d = h.triggerName
              , m = h.validateOnly
              , f = m === void 0 ? !1 : m
              , x = Promise.resolve().then(io(vn().mark(function S() {
                var v, p, g, C, E, O, R;
                return vn().wrap(function(P) {
                    for (; ; )
                        switch (P.prev = P.next) {
                        case 0:
                            if (r.mounted) {
                                P.next = 2;
                                break
                            }
                            return P.abrupt("return", []);
                        case 2:
                            if (v = r.props,
                            p = v.validateFirst,
                            g = p === void 0 ? !1 : p,
                            C = v.messageVariables,
                            E = v.validateDebounce,
                            O = r.getRules(),
                            d && (O = O.filter(function(_) {
                                return _
                            }).filter(function(_) {
                                var T = _.validateTrigger;
                                if (!T)
                                    return !0;
                                var L = jp(T);
                                return L.includes(d)
                            })),
                            !(E && d)) {
                                P.next = 10;
                                break
                            }
                            return P.next = 8,
                            new Promise(function(_) {
                                setTimeout(_, E)
                            }
                            );
                        case 8:
                            if (r.validatePromise === x) {
                                P.next = 10;
                                break
                            }
                            return P.abrupt("return", []);
                        case 10:
                            return R = G_(c, u, O, l, g, C),
                            R.catch(function(_) {
                                return _
                            }).then(function() {
                                var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : $n;
                                if (r.validatePromise === x) {
                                    var T;
                                    r.validatePromise = null;
                                    var L = []
                                      , I = [];
                                    (T = _.forEach) === null || T === void 0 || T.call(_, function(k) {
                                        var w = k.rule.warningOnly
                                          , b = k.errors
                                          , A = b === void 0 ? $n : b;
                                        w ? I.push.apply(I, Re(A)) : L.push.apply(L, Re(A))
                                    }),
                                    r.errors = L,
                                    r.warnings = I,
                                    r.triggerMetaEvent(),
                                    r.reRender()
                                }
                            }),
                            P.abrupt("return", R);
                        case 13:
                        case "end":
                            return P.stop()
                        }
                }, S)
            })));
            return f || (r.validatePromise = x,
            r.dirty = !0,
            r.errors = $n,
            r.warnings = $n,
            r.triggerMetaEvent(),
            r.reRender()),
            x
        }),
        me(Ye(r), "isFieldValidating", function() {
            return !!r.validatePromise
        }),
        me(Ye(r), "isFieldTouched", function() {
            return r.touched
        }),
        me(Ye(r), "isFieldDirty", function() {
            if (r.dirty || r.props.initialValue !== void 0)
                return !0;
            var l = r.props.fieldContext
              , c = l.getInternalHooks(_s)
              , u = c.getInitialValue;
            return u(r.getNamePath()) !== void 0
        }),
        me(Ye(r), "getErrors", function() {
            return r.errors
        }),
        me(Ye(r), "getWarnings", function() {
            return r.warnings
        }),
        me(Ye(r), "isListField", function() {
            return r.props.isListField
        }),
        me(Ye(r), "isList", function() {
            return r.props.isList
        }),
        me(Ye(r), "isPreserve", function() {
            return r.props.preserve
        }),
        me(Ye(r), "getMeta", function() {
            r.prevValidating = r.isFieldValidating();
            var l = {
                touched: r.isFieldTouched(),
                validating: r.prevValidating,
                errors: r.errors,
                warnings: r.warnings,
                name: r.getNamePath(),
                validated: r.validatePromise === null
            };
            return l
        }),
        me(Ye(r), "getOnlyChild", function(l) {
            if (typeof l == "function") {
                var c = r.getMeta();
                return be(be({}, r.getOnlyChild(l(r.getControlled(), c, r.props.fieldContext))), {}, {
                    isFunction: !0
                })
            }
            var u = Dh(l);
            return u.length !== 1 || !M.isValidElement(u[0]) ? {
                child: u,
                isFunction: !1
            } : {
                child: u[0],
                isFunction: !1
            }
        }),
        me(Ye(r), "getValue", function(l) {
            var c = r.props.fieldContext.getFieldsValue
              , u = r.getNamePath();
            return yi(l || c(!0), u)
        }),
        me(Ye(r), "getControlled", function() {
            var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
              , c = r.props
              , u = c.trigger
              , h = c.validateTrigger
              , d = c.getValueFromEvent
              , m = c.normalize
              , f = c.valuePropName
              , x = c.getValueProps
              , S = c.fieldContext
              , v = h !== void 0 ? h : S.validateTrigger
              , p = r.getNamePath()
              , g = S.getInternalHooks
              , C = S.getFieldsValue
              , E = g(_s)
              , O = E.dispatch
              , R = r.getValue()
              , F = x || function(L) {
                return me({}, f, L)
            }
              , P = l[u]
              , _ = be(be({}, l), F(R));
            _[u] = function() {
                r.touched = !0,
                r.dirty = !0,
                r.triggerMetaEvent();
                for (var L, I = arguments.length, k = new Array(I), w = 0; w < I; w++)
                    k[w] = arguments[w];
                d ? L = d.apply(void 0, k) : L = K_.apply(void 0, [f].concat(k)),
                m && (L = m(L, R, C(!0))),
                O({
                    type: "updateValue",
                    namePath: p,
                    value: L
                }),
                P && P.apply(void 0, k)
            }
            ;
            var T = jp(v || []);
            return T.forEach(function(L) {
                var I = _[L];
                _[L] = function() {
                    I && I.apply(void 0, arguments);
                    var k = r.props.rules;
                    k && k.length && O({
                        type: "validateField",
                        namePath: p,
                        triggerName: L
                    })
                }
            }),
            _
        }),
        i.fieldContext) {
            var s = i.fieldContext.getInternalHooks
              , o = s(_s)
              , a = o.initEntityValue;
            a(Ye(r))
        }
        return r
    }
    return Vi(n, [{
        key: "componentDidMount",
        value: function() {
            var r = this.props
              , s = r.shouldUpdate
              , o = r.fieldContext;
            if (this.mounted = !0,
            o) {
                var a = o.getInternalHooks
                  , l = a(_s)
                  , c = l.registerField;
                this.cancelRegisterFunc = c(this)
            }
            s === !0 && this.reRender()
        }
    }, {
        key: "componentWillUnmount",
        value: function() {
            this.cancelRegister(),
            this.triggerMetaEvent(!0),
            this.mounted = !1
        }
    }, {
        key: "reRender",
        value: function() {
            this.mounted && this.forceUpdate()
        }
    }, {
        key: "render",
        value: function() {
            var r = this.state.resetCount, s = this.props.children, o = this.getOnlyChild(s), a = o.child, l = o.isFunction, c;
            return l ? c = a : M.isValidElement(a) ? c = M.cloneElement(a, this.getControlled(a.props)) : (ii(!a, "`children` of Field is not validate ReactElement."),
            c = a),
            M.createElement(M.Fragment, {
                key: r
            }, c)
        }
    }]),
    n
}(M.Component);
me(E2, "contextType", fa);
me(E2, "defaultProps", {
    trigger: "onChange",
    valuePropName: "value"
});
function GS(e) {
    var t = e.name
      , n = ki(e, Q_)
      , i = M.useContext(fa)
      , r = M.useContext(Uh)
      , s = t !== void 0 ? jt(t) : void 0
      , o = "keep";
    return n.isListField || (o = "_".concat((s || []).join("_"))),
    M.createElement(E2, Wn({
        key: o,
        name: s,
        isListField: !!r
    }, n, {
        fieldContext: i
    }))
}
function q_(e) {
    var t = e.name
      , n = e.initialValue
      , i = e.children
      , r = e.rules
      , s = e.validateTrigger
      , o = e.isListField
      , a = M.useContext(fa)
      , l = M.useContext(Uh)
      , c = M.useRef({
        keys: [],
        id: 0
    })
      , u = c.current
      , h = M.useMemo(function() {
        var x = jt(a.prefixName) || [];
        return [].concat(Re(x), Re(jt(t)))
    }, [a.prefixName, t])
      , d = M.useMemo(function() {
        return be(be({}, a), {}, {
            prefixName: h
        })
    }, [a, h])
      , m = M.useMemo(function() {
        return {
            getKey: function(S) {
                var v = h.length
                  , p = S[v];
                return [u.keys[p], S.slice(v + 1)]
            }
        }
    }, [h]);
    if (typeof i != "function")
        return ii(!1, "Form.List only accepts function as children."),
        null;
    var f = function(S, v, p) {
        var g = p.source;
        return g === "internal" ? !1 : S !== v
    };
    return M.createElement(Uh.Provider, {
        value: m
    }, M.createElement(fa.Provider, {
        value: d
    }, M.createElement(GS, {
        name: [],
        shouldUpdate: f,
        rules: r,
        validateTrigger: s,
        initialValue: n,
        isList: !0,
        isListField: o ?? !!l
    }, function(x, S) {
        var v = x.value
          , p = v === void 0 ? [] : v
          , g = x.onChange
          , C = a.getFieldValue
          , E = function() {
            var P = C(h || []);
            return P || []
        }
          , O = {
            add: function(P, _) {
                var T = E();
                _ >= 0 && _ <= T.length ? (u.keys = [].concat(Re(u.keys.slice(0, _)), [u.id], Re(u.keys.slice(_))),
                g([].concat(Re(T.slice(0, _)), [P], Re(T.slice(_))))) : (u.keys = [].concat(Re(u.keys), [u.id]),
                g([].concat(Re(T), [P]))),
                u.id += 1
            },
            remove: function(P) {
                var _ = E()
                  , T = new Set(Array.isArray(P) ? P : [P]);
                T.size <= 0 || (u.keys = u.keys.filter(function(L, I) {
                    return !T.has(I)
                }),
                g(_.filter(function(L, I) {
                    return !T.has(I)
                })))
            },
            move: function(P, _) {
                if (P !== _) {
                    var T = E();
                    P < 0 || P >= T.length || _ < 0 || _ >= T.length || (u.keys = Q3(u.keys, P, _),
                    g(Q3(T, P, _)))
                }
            }
        }
          , R = p || [];
        return Array.isArray(R) || (R = []),
        i(R.map(function(F, P) {
            var _ = u.keys[P];
            return _ === void 0 && (u.keys[P] = u.id,
            _ = u.keys[P],
            u.id += 1),
            {
                name: P,
                key: _,
                isListField: !0
            }
        }), O, S)
    })))
}
function Z_(e) {
    var t = !1
      , n = e.length
      , i = [];
    return e.length ? new Promise(function(r, s) {
        e.forEach(function(o, a) {
            o.catch(function(l) {
                return t = !0,
                l
            }).then(function(l) {
                n -= 1,
                i[a] = l,
                !(n > 0) && (t && s(i),
                r(i))
            })
        })
    }
    ) : Promise.resolve([])
}
var XS = "__@field_split__";
function v0(e) {
    return e.map(function(t) {
        return "".concat(it(t), ":").concat(t)
    }).join(XS)
}
var yo = function() {
    function e() {
        zi(this, e),
        me(this, "kvs", new Map)
    }
    return Vi(e, [{
        key: "set",
        value: function(n, i) {
            this.kvs.set(v0(n), i)
        }
    }, {
        key: "get",
        value: function(n) {
            return this.kvs.get(v0(n))
        }
    }, {
        key: "update",
        value: function(n, i) {
            var r = this.get(n)
              , s = i(r);
            s ? this.set(n, s) : this.delete(n)
        }
    }, {
        key: "delete",
        value: function(n) {
            this.kvs.delete(v0(n))
        }
    }, {
        key: "map",
        value: function(n) {
            return Re(this.kvs.entries()).map(function(i) {
                var r = Me(i, 2)
                  , s = r[0]
                  , o = r[1]
                  , a = s.split(XS);
                return n({
                    key: a.map(function(l) {
                        var c = l.match(/^([^:]*):(.*)$/)
                          , u = Me(c, 3)
                          , h = u[1]
                          , d = u[2];
                        return h === "number" ? Number(d) : d
                    }),
                    value: o
                })
            })
        }
    }, {
        key: "toJSON",
        value: function() {
            var n = {};
            return this.map(function(i) {
                var r = i.key
                  , s = i.value;
                return n[r.join(".")] = s,
                null
            }),
            n
        }
    }]),
    e
}()
  , J_ = ["name"]
  , eD = Vi(function e(t) {
    var n = this;
    zi(this, e),
    me(this, "formHooked", !1),
    me(this, "forceRootUpdate", void 0),
    me(this, "subscribable", !0),
    me(this, "store", {}),
    me(this, "fieldEntities", []),
    me(this, "initialValues", {}),
    me(this, "callbacks", {}),
    me(this, "validateMessages", null),
    me(this, "preserve", null),
    me(this, "lastValidatePromise", null),
    me(this, "getForm", function() {
        return {
            getFieldValue: n.getFieldValue,
            getFieldsValue: n.getFieldsValue,
            getFieldError: n.getFieldError,
            getFieldWarning: n.getFieldWarning,
            getFieldsError: n.getFieldsError,
            isFieldsTouched: n.isFieldsTouched,
            isFieldTouched: n.isFieldTouched,
            isFieldValidating: n.isFieldValidating,
            isFieldsValidating: n.isFieldsValidating,
            resetFields: n.resetFields,
            setFields: n.setFields,
            setFieldValue: n.setFieldValue,
            setFieldsValue: n.setFieldsValue,
            validateFields: n.validateFields,
            submit: n.submit,
            _init: !0,
            getInternalHooks: n.getInternalHooks
        }
    }),
    me(this, "getInternalHooks", function(i) {
        return i === _s ? (n.formHooked = !0,
        {
            dispatch: n.dispatch,
            initEntityValue: n.initEntityValue,
            registerField: n.registerField,
            useSubscribe: n.useSubscribe,
            setInitialValues: n.setInitialValues,
            destroyForm: n.destroyForm,
            setCallbacks: n.setCallbacks,
            setValidateMessages: n.setValidateMessages,
            getFields: n.getFields,
            setPreserve: n.setPreserve,
            getInitialValue: n.getInitialValue,
            registerWatch: n.registerWatch
        }) : (ii(!1, "`getInternalHooks` is internal usage. Should not call directly."),
        null)
    }),
    me(this, "useSubscribe", function(i) {
        n.subscribable = i
    }),
    me(this, "prevWithoutPreserves", null),
    me(this, "setInitialValues", function(i, r) {
        if (n.initialValues = i || {},
        r) {
            var s, o = Io(i, n.store);
            (s = n.prevWithoutPreserves) === null || s === void 0 || s.map(function(a) {
                var l = a.key;
                o = gi(o, l, yi(i, l))
            }),
            n.prevWithoutPreserves = null,
            n.updateStore(o)
        }
    }),
    me(this, "destroyForm", function() {
        var i = new yo;
        n.getFieldEntities(!0).forEach(function(r) {
            n.isMergedPreserve(r.isPreserve()) || i.set(r.getNamePath(), !0)
        }),
        n.prevWithoutPreserves = i
    }),
    me(this, "getInitialValue", function(i) {
        var r = yi(n.initialValues, i);
        return i.length ? Io(r) : r
    }),
    me(this, "setCallbacks", function(i) {
        n.callbacks = i
    }),
    me(this, "setValidateMessages", function(i) {
        n.validateMessages = i
    }),
    me(this, "setPreserve", function(i) {
        n.preserve = i
    }),
    me(this, "watchList", []),
    me(this, "registerWatch", function(i) {
        return n.watchList.push(i),
        function() {
            n.watchList = n.watchList.filter(function(r) {
                return r !== i
            })
        }
    }),
    me(this, "notifyWatch", function() {
        var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (n.watchList.length) {
            var r = n.getFieldsValue()
              , s = n.getFieldsValue(!0);
            n.watchList.forEach(function(o) {
                o(r, s, i)
            })
        }
    }),
    me(this, "timeoutId", null),
    me(this, "warningUnhooked", function() {}),
    me(this, "updateStore", function(i) {
        n.store = i
    }),
    me(this, "getFieldEntities", function() {
        var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
        return i ? n.fieldEntities.filter(function(r) {
            return r.getNamePath().length
        }) : n.fieldEntities
    }),
    me(this, "getFieldsMap", function() {
        var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1
          , r = new yo;
        return n.getFieldEntities(i).forEach(function(s) {
            var o = s.getNamePath();
            r.set(o, s)
        }),
        r
    }),
    me(this, "getFieldEntitiesForNamePathList", function(i) {
        if (!i)
            return n.getFieldEntities(!0);
        var r = n.getFieldsMap(!0);
        return i.map(function(s) {
            var o = jt(s);
            return r.get(o) || {
                INVALIDATE_NAME_PATH: jt(s)
            }
        })
    }),
    me(this, "getFieldsValue", function(i, r) {
        n.warningUnhooked();
        var s, o, a;
        if (i === !0 || Array.isArray(i) ? (s = i,
        o = r) : i && it(i) === "object" && (a = i.strict,
        o = i.filter),
        s === !0 && !o)
            return n.store;
        var l = n.getFieldEntitiesForNamePathList(Array.isArray(s) ? s : null)
          , c = [];
        return l.forEach(function(u) {
            var h, d, m = "INVALIDATE_NAME_PATH"in u ? u.INVALIDATE_NAME_PATH : u.getNamePath();
            if (a) {
                var f, x;
                if ((f = (x = u).isList) !== null && f !== void 0 && f.call(x))
                    return
            } else if (!s && (h = (d = u).isListField) !== null && h !== void 0 && h.call(d))
                return;
            if (!o)
                c.push(m);
            else {
                var S = "getMeta"in u ? u.getMeta() : null;
                o(S) && c.push(m)
            }
        }),
        K3(n.store, c.map(jt))
    }),
    me(this, "getFieldValue", function(i) {
        n.warningUnhooked();
        var r = jt(i);
        return yi(n.store, r)
    }),
    me(this, "getFieldsError", function(i) {
        n.warningUnhooked();
        var r = n.getFieldEntitiesForNamePathList(i);
        return r.map(function(s, o) {
            return s && !("INVALIDATE_NAME_PATH"in s) ? {
                name: s.getNamePath(),
                errors: s.getErrors(),
                warnings: s.getWarnings()
            } : {
                name: jt(i[o]),
                errors: [],
                warnings: []
            }
        })
    }),
    me(this, "getFieldError", function(i) {
        n.warningUnhooked();
        var r = jt(i)
          , s = n.getFieldsError([r])[0];
        return s.errors
    }),
    me(this, "getFieldWarning", function(i) {
        n.warningUnhooked();
        var r = jt(i)
          , s = n.getFieldsError([r])[0];
        return s.warnings
    }),
    me(this, "isFieldsTouched", function() {
        n.warningUnhooked();
        for (var i = arguments.length, r = new Array(i), s = 0; s < i; s++)
            r[s] = arguments[s];
        var o = r[0], a = r[1], l, c = !1;
        r.length === 0 ? l = null : r.length === 1 ? Array.isArray(o) ? (l = o.map(jt),
        c = !1) : (l = null,
        c = o) : (l = o.map(jt),
        c = a);
        var u = n.getFieldEntities(!0)
          , h = function(S) {
            return S.isFieldTouched()
        };
        if (!l)
            return c ? u.every(h) : u.some(h);
        var d = new yo;
        l.forEach(function(x) {
            d.set(x, [])
        }),
        u.forEach(function(x) {
            var S = x.getNamePath();
            l.forEach(function(v) {
                v.every(function(p, g) {
                    return S[g] === p
                }) && d.update(v, function(p) {
                    return [].concat(Re(p), [x])
                })
            })
        });
        var m = function(S) {
            return S.some(h)
        }
          , f = d.map(function(x) {
            var S = x.value;
            return S
        });
        return c ? f.every(m) : f.some(m)
    }),
    me(this, "isFieldTouched", function(i) {
        return n.warningUnhooked(),
        n.isFieldsTouched([i])
    }),
    me(this, "isFieldsValidating", function(i) {
        n.warningUnhooked();
        var r = n.getFieldEntities();
        if (!i)
            return r.some(function(o) {
                return o.isFieldValidating()
            });
        var s = i.map(jt);
        return r.some(function(o) {
            var a = o.getNamePath();
            return Jo(s, a) && o.isFieldValidating()
        })
    }),
    me(this, "isFieldValidating", function(i) {
        return n.warningUnhooked(),
        n.isFieldsValidating([i])
    }),
    me(this, "resetWithFieldInitialValue", function() {
        var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , r = new yo
          , s = n.getFieldEntities(!0);
        s.forEach(function(l) {
            var c = l.props.initialValue
              , u = l.getNamePath();
            if (c !== void 0) {
                var h = r.get(u) || new Set;
                h.add({
                    entity: l,
                    value: c
                }),
                r.set(u, h)
            }
        });
        var o = function(c) {
            c.forEach(function(u) {
                var h = u.props.initialValue;
                if (h !== void 0) {
                    var d = u.getNamePath()
                      , m = n.getInitialValue(d);
                    if (m !== void 0)
                        ii(!1, "Form already set 'initialValues' with path '".concat(d.join("."), "'. Field can not overwrite it."));
                    else {
                        var f = r.get(d);
                        if (f && f.size > 1)
                            ii(!1, "Multiple Field with path '".concat(d.join("."), "' set 'initialValue'. Can not decide which one to pick."));
                        else if (f) {
                            var x = n.getFieldValue(d)
                              , S = u.isListField();
                            !S && (!i.skipExist || x === void 0) && n.updateStore(gi(n.store, d, Re(f)[0].value))
                        }
                    }
                }
            })
        }, a;
        i.entities ? a = i.entities : i.namePathList ? (a = [],
        i.namePathList.forEach(function(l) {
            var c = r.get(l);
            if (c) {
                var u;
                (u = a).push.apply(u, Re(Re(c).map(function(h) {
                    return h.entity
                })))
            }
        })) : a = s,
        o(a)
    }),
    me(this, "resetFields", function(i) {
        n.warningUnhooked();
        var r = n.store;
        if (!i) {
            n.updateStore(Io(n.initialValues)),
            n.resetWithFieldInitialValue(),
            n.notifyObservers(r, null, {
                type: "reset"
            }),
            n.notifyWatch();
            return
        }
        var s = i.map(jt);
        s.forEach(function(o) {
            var a = n.getInitialValue(o);
            n.updateStore(gi(n.store, o, a))
        }),
        n.resetWithFieldInitialValue({
            namePathList: s
        }),
        n.notifyObservers(r, s, {
            type: "reset"
        }),
        n.notifyWatch(s)
    }),
    me(this, "setFields", function(i) {
        n.warningUnhooked();
        var r = n.store
          , s = [];
        i.forEach(function(o) {
            var a = o.name
              , l = ki(o, J_)
              , c = jt(a);
            s.push(c),
            "value"in l && n.updateStore(gi(n.store, c, l.value)),
            n.notifyObservers(r, [c], {
                type: "setField",
                data: o
            })
        }),
        n.notifyWatch(s)
    }),
    me(this, "getFields", function() {
        var i = n.getFieldEntities(!0)
          , r = i.map(function(s) {
            var o = s.getNamePath()
              , a = s.getMeta()
              , l = be(be({}, a), {}, {
                name: o,
                value: n.getFieldValue(o)
            });
            return Object.defineProperty(l, "originRCField", {
                value: !0
            }),
            l
        });
        return r
    }),
    me(this, "initEntityValue", function(i) {
        var r = i.props.initialValue;
        if (r !== void 0) {
            var s = i.getNamePath()
              , o = yi(n.store, s);
            o === void 0 && n.updateStore(gi(n.store, s, r))
        }
    }),
    me(this, "isMergedPreserve", function(i) {
        var r = i !== void 0 ? i : n.preserve;
        return r ?? !0
    }),
    me(this, "registerField", function(i) {
        n.fieldEntities.push(i);
        var r = i.getNamePath();
        if (n.notifyWatch([r]),
        i.props.initialValue !== void 0) {
            var s = n.store;
            n.resetWithFieldInitialValue({
                entities: [i],
                skipExist: !0
            }),
            n.notifyObservers(s, [i.getNamePath()], {
                type: "valueUpdate",
                source: "internal"
            })
        }
        return function(o, a) {
            var l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
            if (n.fieldEntities = n.fieldEntities.filter(function(h) {
                return h !== i
            }),
            !n.isMergedPreserve(a) && (!o || l.length > 1)) {
                var c = o ? void 0 : n.getInitialValue(r);
                if (r.length && n.getFieldValue(r) !== c && n.fieldEntities.every(function(h) {
                    return !US(h.getNamePath(), r)
                })) {
                    var u = n.store;
                    n.updateStore(gi(u, r, c, !0)),
                    n.notifyObservers(u, [r], {
                        type: "remove"
                    }),
                    n.triggerDependenciesUpdate(u, r)
                }
            }
            n.notifyWatch([r])
        }
    }),
    me(this, "dispatch", function(i) {
        switch (i.type) {
        case "updateValue":
            {
                var r = i.namePath
                  , s = i.value;
                n.updateValue(r, s);
                break
            }
        case "validateField":
            {
                var o = i.namePath
                  , a = i.triggerName;
                n.validateFields([o], {
                    triggerName: a
                });
                break
            }
        }
    }),
    me(this, "notifyObservers", function(i, r, s) {
        if (n.subscribable) {
            var o = be(be({}, s), {}, {
                store: n.getFieldsValue(!0)
            });
            n.getFieldEntities().forEach(function(a) {
                var l = a.onStoreChange;
                l(i, r, o)
            })
        } else
            n.forceRootUpdate()
    }),
    me(this, "triggerDependenciesUpdate", function(i, r) {
        var s = n.getDependencyChildrenFields(r);
        return s.length && n.validateFields(s),
        n.notifyObservers(i, s, {
            type: "dependenciesUpdate",
            relatedFields: [r].concat(Re(s))
        }),
        s
    }),
    me(this, "updateValue", function(i, r) {
        var s = jt(i)
          , o = n.store;
        n.updateStore(gi(n.store, s, r)),
        n.notifyObservers(o, [s], {
            type: "valueUpdate",
            source: "internal"
        }),
        n.notifyWatch([s]);
        var a = n.triggerDependenciesUpdate(o, s)
          , l = n.callbacks.onValuesChange;
        if (l) {
            var c = K3(n.store, [s]);
            l(c, n.getFieldsValue())
        }
        n.triggerOnFieldsChange([s].concat(Re(a)))
    }),
    me(this, "setFieldsValue", function(i) {
        n.warningUnhooked();
        var r = n.store;
        if (i) {
            var s = Io(n.store, i);
            n.updateStore(s)
        }
        n.notifyObservers(r, null, {
            type: "valueUpdate",
            source: "external"
        }),
        n.notifyWatch()
    }),
    me(this, "setFieldValue", function(i, r) {
        n.setFields([{
            name: i,
            value: r
        }])
    }),
    me(this, "getDependencyChildrenFields", function(i) {
        var r = new Set
          , s = []
          , o = new yo;
        n.getFieldEntities().forEach(function(l) {
            var c = l.props.dependencies;
            (c || []).forEach(function(u) {
                var h = jt(u);
                o.update(h, function() {
                    var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Set;
                    return d.add(l),
                    d
                })
            })
        });
        var a = function l(c) {
            var u = o.get(c) || new Set;
            u.forEach(function(h) {
                if (!r.has(h)) {
                    r.add(h);
                    var d = h.getNamePath();
                    h.isFieldDirty() && d.length && (s.push(d),
                    l(d))
                }
            })
        };
        return a(i),
        s
    }),
    me(this, "triggerOnFieldsChange", function(i, r) {
        var s = n.callbacks.onFieldsChange;
        if (s) {
            var o = n.getFields();
            if (r) {
                var a = new yo;
                r.forEach(function(c) {
                    var u = c.name
                      , h = c.errors;
                    a.set(u, h)
                }),
                o.forEach(function(c) {
                    c.errors = a.get(c.name) || c.errors
                })
            }
            var l = o.filter(function(c) {
                var u = c.name;
                return Jo(i, u)
            });
            l.length && s(l, o)
        }
    }),
    me(this, "validateFields", function(i, r) {
        n.warningUnhooked();
        var s, o;
        Array.isArray(i) || typeof i == "string" || typeof r == "string" ? (s = i,
        o = r) : o = i;
        var a = !!s
          , l = a ? s.map(jt) : []
          , c = []
          , u = String(Date.now())
          , h = new Set
          , d = o || {}
          , m = d.recursive
          , f = d.dirty;
        n.getFieldEntities(!0).forEach(function(p) {
            if (a || l.push(p.getNamePath()),
            !(!p.props.rules || !p.props.rules.length) && !(f && !p.isFieldDirty())) {
                var g = p.getNamePath();
                if (h.add(g.join(u)),
                !a || Jo(l, g, m)) {
                    var C = p.validateRules(be({
                        validateMessages: be(be({}, HS), n.validateMessages)
                    }, o));
                    c.push(C.then(function() {
                        return {
                            name: g,
                            errors: [],
                            warnings: []
                        }
                    }).catch(function(E) {
                        var O, R = [], F = [];
                        return (O = E.forEach) === null || O === void 0 || O.call(E, function(P) {
                            var _ = P.rule.warningOnly
                              , T = P.errors;
                            _ ? F.push.apply(F, Re(T)) : R.push.apply(R, Re(T))
                        }),
                        R.length ? Promise.reject({
                            name: g,
                            errors: R,
                            warnings: F
                        }) : {
                            name: g,
                            errors: R,
                            warnings: F
                        }
                    }))
                }
            }
        });
        var x = Z_(c);
        n.lastValidatePromise = x,
        x.catch(function(p) {
            return p
        }).then(function(p) {
            var g = p.map(function(C) {
                var E = C.name;
                return E
            });
            n.notifyObservers(n.store, g, {
                type: "validateFinish"
            }),
            n.triggerOnFieldsChange(g, p)
        });
        var S = x.then(function() {
            return n.lastValidatePromise === x ? Promise.resolve(n.getFieldsValue(l)) : Promise.reject([])
        }).catch(function(p) {
            var g = p.filter(function(C) {
                return C && C.errors.length
            });
            return Promise.reject({
                values: n.getFieldsValue(l),
                errorFields: g,
                outOfDate: n.lastValidatePromise !== x
            })
        });
        S.catch(function(p) {
            return p
        });
        var v = l.filter(function(p) {
            return h.has(p.join(u))
        });
        return n.triggerOnFieldsChange(v),
        S
    }),
    me(this, "submit", function() {
        n.warningUnhooked(),
        n.validateFields().then(function(i) {
            var r = n.callbacks.onFinish;
            if (r)
                try {
                    r(i)
                } catch (s) {
                    console.error(s)
                }
        }).catch(function(i) {
            var r = n.callbacks.onFinishFailed;
            r && r(i)
        })
    }),
    this.forceRootUpdate = t
});
function YS(e) {
    var t = M.useRef()
      , n = M.useState({})
      , i = Me(n, 2)
      , r = i[1];
    if (!t.current)
        if (e)
            t.current = e;
        else {
            var s = function() {
                r({})
            }
              , o = new eD(s);
            t.current = o.getForm()
        }
    return [t.current]
}
var zp = M.createContext({
    triggerFormChange: function() {},
    triggerFormFinish: function() {},
    registerForm: function() {},
    unregisterForm: function() {}
})
  , tD = function(t) {
    var n = t.validateMessages
      , i = t.onFormChange
      , r = t.onFormFinish
      , s = t.children
      , o = M.useContext(zp)
      , a = M.useRef({});
    return M.createElement(zp.Provider, {
        value: be(be({}, o), {}, {
            validateMessages: be(be({}, o.validateMessages), n),
            triggerFormChange: function(c, u) {
                i && i(c, {
                    changedFields: u,
                    forms: a.current
                }),
                o.triggerFormChange(c, u)
            },
            triggerFormFinish: function(c, u) {
                r && r(c, {
                    values: u,
                    forms: a.current
                }),
                o.triggerFormFinish(c, u)
            },
            registerForm: function(c, u) {
                c && (a.current = be(be({}, a.current), {}, me({}, c, u))),
                o.registerForm(c, u)
            },
            unregisterForm: function(c) {
                var u = be({}, a.current);
                delete u[c],
                a.current = u,
                o.unregisterForm(c)
            }
        })
    }, s)
}
  , nD = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"]
  , iD = function(t, n) {
    var i = t.name
      , r = t.initialValues
      , s = t.fields
      , o = t.form
      , a = t.preserve
      , l = t.children
      , c = t.component
      , u = c === void 0 ? "form" : c
      , h = t.validateMessages
      , d = t.validateTrigger
      , m = d === void 0 ? "onChange" : d
      , f = t.onValuesChange
      , x = t.onFieldsChange
      , S = t.onFinish
      , v = t.onFinishFailed
      , p = ki(t, nD)
      , g = M.useContext(zp)
      , C = YS(o)
      , E = Me(C, 1)
      , O = E[0]
      , R = O.getInternalHooks(_s)
      , F = R.useSubscribe
      , P = R.setInitialValues
      , _ = R.setCallbacks
      , T = R.setValidateMessages
      , L = R.setPreserve
      , I = R.destroyForm;
    M.useImperativeHandle(n, function() {
        return O
    }),
    M.useEffect(function() {
        return g.registerForm(i, O),
        function() {
            g.unregisterForm(i)
        }
    }, [g, O, i]),
    T(be(be({}, g.validateMessages), h)),
    _({
        onValuesChange: f,
        onFieldsChange: function(H) {
            if (g.triggerFormChange(i, H),
            x) {
                for (var X = arguments.length, ie = new Array(X > 1 ? X - 1 : 0), K = 1; K < X; K++)
                    ie[K - 1] = arguments[K];
                x.apply(void 0, [H].concat(ie))
            }
        },
        onFinish: function(H) {
            g.triggerFormFinish(i, H),
            S && S(H)
        },
        onFinishFailed: v
    }),
    L(a);
    var k = M.useRef(null);
    P(r, !k.current),
    k.current || (k.current = !0),
    M.useEffect(function() {
        return I
    }, []);
    var w, b = typeof l == "function";
    if (b) {
        var A = O.getFieldsValue(!0);
        w = l(A, O)
    } else
        w = l;
    F(!b);
    var j = M.useRef();
    M.useEffect(function() {
        $_(j.current || [], s || []) || O.setFields(s || []),
        j.current = s
    }, [s, O]);
    var B = M.useMemo(function() {
        return be(be({}, O), {}, {
            validateTrigger: m
        })
    }, [O, m])
      , W = M.createElement(Uh.Provider, {
        value: null
    }, M.createElement(fa.Provider, {
        value: B
    }, w));
    return u === !1 ? W : M.createElement(u, Wn({}, p, {
        onSubmit: function(H) {
            H.preventDefault(),
            H.stopPropagation(),
            O.submit()
        },
        onReset: function(H) {
            var X;
            H.preventDefault(),
            O.resetFields(),
            (X = p.onReset) === null || X === void 0 || X.call(p, H)
        }
    }), W)
};
function Z3(e) {
    try {
        return JSON.stringify(e)
    } catch {
        return Math.random()
    }
}
function rD() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    var i = t[0]
      , r = i === void 0 ? [] : i
      , s = t[1]
      , o = s === void 0 ? {} : s
      , a = h_(o) ? {
        form: o
    } : o
      , l = a.form
      , c = M.useState()
      , u = Me(c, 2)
      , h = u[0]
      , d = u[1]
      , m = M.useMemo(function() {
        return Z3(h)
    }, [h])
      , f = M.useRef(m);
    f.current = m;
    var x = M.useContext(fa)
      , S = l || x
      , v = S && S._init
      , p = jt(r)
      , g = M.useRef(p);
    return g.current = p,
    M.useEffect(function() {
        if (v) {
            var C = S.getFieldsValue
              , E = S.getInternalHooks
              , O = E(_s)
              , R = O.registerWatch
              , F = R(function(_, T) {
                var L = yi(a.preserve ? T : _, g.current)
                  , I = Z3(L);
                f.current !== I && (f.current = I,
                d(L))
            })
              , P = yi(a.preserve ? C(!0) : C(), g.current);
            return h !== P && d(P),
            F
        }
    }, [v]),
    h
}
var sD = M.forwardRef(iD)
  , xc = sD;
xc.FormProvider = tD;
xc.Field = GS;
xc.List = q_;
xc.useForm = YS;
xc.useWatch = rD;
const oD = M.createContext({})
  , aD = e=>({
    animationDuration: e,
    animationFillMode: "both"
})
  , lD = e=>({
    animationDuration: e,
    animationFillMode: "both"
})
  , cD = function(e, t, n, i) {
    const s = (arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1) ? "&" : "";
    return {
        [`
      ${s}${e}-enter,
      ${s}${e}-appear
    `]: Object.assign(Object.assign({}, aD(i)), {
            animationPlayState: "paused"
        }),
        [`${s}${e}-leave`]: Object.assign(Object.assign({}, lD(i)), {
            animationPlayState: "paused"
        }),
        [`
      ${s}${e}-enter${e}-enter-active,
      ${s}${e}-appear${e}-appear-active
    `]: {
            animationName: t,
            animationPlayState: "running"
        },
        [`${s}${e}-leave${e}-leave-active`]: {
            animationName: n,
            animationPlayState: "running",
            pointerEvents: "none"
        }
    }
}
  , uD = new li("antZoomIn",{
    "0%": {
        transform: "scale(0.2)",
        opacity: 0
    },
    "100%": {
        transform: "scale(1)",
        opacity: 1
    }
})
  , hD = new li("antZoomOut",{
    "0%": {
        transform: "scale(1)"
    },
    "100%": {
        transform: "scale(0.2)",
        opacity: 0
    }
})
  , J3 = new li("antZoomBigIn",{
    "0%": {
        transform: "scale(0.8)",
        opacity: 0
    },
    "100%": {
        transform: "scale(1)",
        opacity: 1
    }
})
  , ex = new li("antZoomBigOut",{
    "0%": {
        transform: "scale(1)"
    },
    "100%": {
        transform: "scale(0.8)",
        opacity: 0
    }
})
  , dD = new li("antZoomUpIn",{
    "0%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 0%",
        opacity: 0
    },
    "100%": {
        transform: "scale(1)",
        transformOrigin: "50% 0%"
    }
})
  , fD = new li("antZoomUpOut",{
    "0%": {
        transform: "scale(1)",
        transformOrigin: "50% 0%"
    },
    "100%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 0%",
        opacity: 0
    }
})
  , pD = new li("antZoomLeftIn",{
    "0%": {
        transform: "scale(0.8)",
        transformOrigin: "0% 50%",
        opacity: 0
    },
    "100%": {
        transform: "scale(1)",
        transformOrigin: "0% 50%"
    }
})
  , gD = new li("antZoomLeftOut",{
    "0%": {
        transform: "scale(1)",
        transformOrigin: "0% 50%"
    },
    "100%": {
        transform: "scale(0.8)",
        transformOrigin: "0% 50%",
        opacity: 0
    }
})
  , mD = new li("antZoomRightIn",{
    "0%": {
        transform: "scale(0.8)",
        transformOrigin: "100% 50%",
        opacity: 0
    },
    "100%": {
        transform: "scale(1)",
        transformOrigin: "100% 50%"
    }
})
  , vD = new li("antZoomRightOut",{
    "0%": {
        transform: "scale(1)",
        transformOrigin: "100% 50%"
    },
    "100%": {
        transform: "scale(0.8)",
        transformOrigin: "100% 50%",
        opacity: 0
    }
})
  , yD = new li("antZoomDownIn",{
    "0%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 100%",
        opacity: 0
    },
    "100%": {
        transform: "scale(1)",
        transformOrigin: "50% 100%"
    }
})
  , xD = new li("antZoomDownOut",{
    "0%": {
        transform: "scale(1)",
        transformOrigin: "50% 100%"
    },
    "100%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 100%",
        opacity: 0
    }
})
  , bD = {
    zoom: {
        inKeyframes: uD,
        outKeyframes: hD
    },
    "zoom-big": {
        inKeyframes: J3,
        outKeyframes: ex
    },
    "zoom-big-fast": {
        inKeyframes: J3,
        outKeyframes: ex
    },
    "zoom-left": {
        inKeyframes: pD,
        outKeyframes: gD
    },
    "zoom-right": {
        inKeyframes: mD,
        outKeyframes: vD
    },
    "zoom-up": {
        inKeyframes: dD,
        outKeyframes: fD
    },
    "zoom-down": {
        inKeyframes: yD,
        outKeyframes: xD
    }
}
  , wD = (e,t)=>{
    const {antCls: n} = e
      , i = `${n}-${t}`
      , {inKeyframes: r, outKeyframes: s} = bD[t];
    return [cD(i, r, s, t === "zoom-big-fast" ? e.motionDurationFast : e.motionDurationMid), {
        [`
        ${i}-enter,
        ${i}-appear
      `]: {
            transform: "scale(0)",
            opacity: 0,
            animationTimingFunction: e.motionEaseOutCirc,
            "&-prepare": {
                transform: "none"
            }
        },
        [`${i}-leave`]: {
            animationTimingFunction: e.motionEaseInOutCirc
        }
    }]
}
  , SD = function() {
    if (typeof navigator > "u" || typeof window > "u")
        return !1;
    var e = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e == null ? void 0 : e.substr(0, 4))
};
function CD(e) {
    var t = e.prefixCls
      , n = e.align
      , i = e.arrow
      , r = e.arrowPos
      , s = i || {}
      , o = s.className
      , a = s.content
      , l = r.x
      , c = l === void 0 ? 0 : l
      , u = r.y
      , h = u === void 0 ? 0 : u
      , d = M.useRef();
    if (!n || !n.points)
        return null;
    var m = {
        position: "absolute"
    };
    if (n.autoArrow !== !1) {
        var f = n.points[0]
          , x = n.points[1]
          , S = f[0]
          , v = f[1]
          , p = x[0]
          , g = x[1];
        S === p || !["t", "b"].includes(S) ? m.top = h : S === "t" ? m.top = 0 : m.bottom = 0,
        v === g || !["l", "r"].includes(v) ? m.left = c : v === "l" ? m.left = 0 : m.right = 0
    }
    return M.createElement("div", {
        ref: d,
        className: nt("".concat(t, "-arrow"), o),
        style: m
    }, a)
}
function kD(e) {
    var t = e.prefixCls
      , n = e.open
      , i = e.zIndex
      , r = e.mask
      , s = e.motion;
    return r ? M.createElement(Kd, Wn({}, s, {
        motionAppear: !0,
        visible: n,
        removeOnLeave: !0
    }), function(o) {
        var a = o.className;
        return M.createElement("div", {
            style: {
                zIndex: i
            },
            className: nt("".concat(t, "-mask"), a)
        })
    }) : null
}
var AD = M.memo(function(e) {
    var t = e.children;
    return t
}, function(e, t) {
    return t.cache
})
  , MD = M.forwardRef(function(e, t) {
    var n = e.popup
      , i = e.className
      , r = e.prefixCls
      , s = e.style
      , o = e.target
      , a = e.onVisibleChanged
      , l = e.open
      , c = e.keepDom
      , u = e.fresh
      , h = e.onClick
      , d = e.mask
      , m = e.arrow
      , f = e.arrowPos
      , x = e.align
      , S = e.motion
      , v = e.maskMotion
      , p = e.forceRender
      , g = e.getPopupContainer
      , C = e.autoDestroy
      , E = e.portal
      , O = e.zIndex
      , R = e.onMouseEnter
      , F = e.onMouseLeave
      , P = e.onPointerEnter
      , _ = e.ready
      , T = e.offsetX
      , L = e.offsetY
      , I = e.offsetR
      , k = e.offsetB
      , w = e.onAlign
      , b = e.onPrepare
      , A = e.stretch
      , j = e.targetWidth
      , B = e.targetHeight
      , W = typeof n == "function" ? n() : n
      , N = l || c
      , H = (g == null ? void 0 : g.length) > 0
      , X = M.useState(!g || !H)
      , ie = Me(X, 2)
      , K = ie[0]
      , D = ie[1];
    if (pn(function() {
        !K && H && o && D(!0)
    }, [K, H, o]),
    !K)
        return null;
    var V = "auto"
      , G = {
        left: "-1000vw",
        top: "-1000vh",
        right: V,
        bottom: V
    };
    if (_ || !l) {
        var ee, J = x.points, te = x.dynamicInset || ((ee = x._experimental) === null || ee === void 0 ? void 0 : ee.dynamicInset), z = te && J[0][1] === "r", Y = te && J[0][0] === "b";
        z ? (G.right = I,
        G.left = V) : (G.left = T,
        G.right = V),
        Y ? (G.bottom = k,
        G.top = V) : (G.top = L,
        G.bottom = V)
    }
    var U = {};
    return A && (A.includes("height") && B ? U.height = B : A.includes("minHeight") && B && (U.minHeight = B),
    A.includes("width") && j ? U.width = j : A.includes("minWidth") && j && (U.minWidth = j)),
    l || (U.pointerEvents = "none"),
    M.createElement(E, {
        open: p || N,
        getContainer: g && function() {
            return g(o)
        }
        ,
        autoDestroy: C
    }, M.createElement(kD, {
        prefixCls: r,
        open: l,
        zIndex: O,
        mask: d,
        motion: v
    }), M.createElement(d2, {
        onResize: w,
        disabled: !l
    }, function(Z) {
        return M.createElement(Kd, Wn({
            motionAppear: !0,
            motionEnter: !0,
            motionLeave: !0,
            removeOnLeave: !1,
            forceRender: p,
            leavedClassName: "".concat(r, "-hidden")
        }, S, {
            onAppearPrepare: b,
            onEnterPrepare: b,
            visible: l,
            onVisibleChanged: function(ne) {
                var oe;
                S == null || (oe = S.onVisibleChanged) === null || oe === void 0 || oe.call(S, ne),
                a(ne)
            }
        }), function($, ne) {
            var oe = $.className
              , se = $.style
              , le = nt(r, oe, i);
            return M.createElement("div", {
                ref: Vd(Z, t, ne),
                className: le,
                style: be(be(be(be({
                    "--arrow-x": "".concat(f.x || 0, "px"),
                    "--arrow-y": "".concat(f.y || 0, "px")
                }, G), U), se), {}, {
                    boxSizing: "border-box",
                    zIndex: O
                }, s),
                onMouseEnter: R,
                onMouseLeave: F,
                onPointerEnter: P,
                onClick: h
            }, m && M.createElement(CD, {
                prefixCls: r,
                arrow: m,
                arrowPos: f,
                align: x
            }), M.createElement(AD, {
                cache: !l && !u
            }, W))
        })
    }))
})
  , ED = M.forwardRef(function(e, t) {
    var n = e.children
      , i = e.getTriggerDOMNode
      , r = mc(n)
      , s = M.useCallback(function(a) {
        u2(t, i ? i(a) : a)
    }, [i])
      , o = h2(s, n.ref);
    return r ? M.cloneElement(n, {
        ref: o
    }) : n
})
  , tx = M.createContext(null);
function nx(e) {
    return e ? Array.isArray(e) ? e : [e] : []
}
function PD(e, t, n, i) {
    return M.useMemo(function() {
        var r = nx(n ?? t)
          , s = nx(i ?? t)
          , o = new Set(r)
          , a = new Set(s);
        return e && (o.has("hover") && (o.delete("hover"),
        o.add("click")),
        a.has("hover") && (a.delete("hover"),
        a.add("click"))),
        [o, a]
    }, [e, t, n, i])
}
function TD() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []
      , t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []
      , n = arguments.length > 2 ? arguments[2] : void 0;
    return n ? e[0] === t[0] : e[0] === t[0] && e[1] === t[1]
}
function jD(e, t, n, i) {
    for (var r = n.points, s = Object.keys(e), o = 0; o < s.length; o += 1) {
        var a, l = s[o];
        if (TD((a = e[l]) === null || a === void 0 ? void 0 : a.points, r, i))
            return "".concat(t, "-placement-").concat(l)
    }
    return ""
}
function ix(e, t, n, i) {
    return t || (n ? {
        motionName: "".concat(e, "-").concat(n)
    } : i ? {
        motionName: i
    } : null)
}
function bc(e) {
    return e.ownerDocument.defaultView
}
function Vp(e) {
    for (var t = [], n = e == null ? void 0 : e.parentElement, i = ["hidden", "scroll", "clip", "auto"]; n; ) {
        var r = bc(n).getComputedStyle(n)
          , s = r.overflowX
          , o = r.overflowY
          , a = r.overflow;
        [s, o, a].some(function(l) {
            return i.includes(l)
        }) && t.push(n),
        n = n.parentElement
    }
    return t
}
function Yl(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return Number.isNaN(e) ? t : e
}
function Ia(e) {
    return Yl(parseFloat(e), 0)
}
function rx(e, t) {
    var n = be({}, e);
    return (t || []).forEach(function(i) {
        if (!(i instanceof HTMLBodyElement || i instanceof HTMLHtmlElement)) {
            var r = bc(i).getComputedStyle(i)
              , s = r.overflow
              , o = r.overflowClipMargin
              , a = r.borderTopWidth
              , l = r.borderBottomWidth
              , c = r.borderLeftWidth
              , u = r.borderRightWidth
              , h = i.getBoundingClientRect()
              , d = i.offsetHeight
              , m = i.clientHeight
              , f = i.offsetWidth
              , x = i.clientWidth
              , S = Ia(a)
              , v = Ia(l)
              , p = Ia(c)
              , g = Ia(u)
              , C = Yl(Math.round(h.width / f * 1e3) / 1e3)
              , E = Yl(Math.round(h.height / d * 1e3) / 1e3)
              , O = (f - x - p - g) * C
              , R = (d - m - S - v) * E
              , F = S * E
              , P = v * E
              , _ = p * C
              , T = g * C
              , L = 0
              , I = 0;
            if (s === "clip") {
                var k = Ia(o);
                L = k * C,
                I = k * E
            }
            var w = h.x + _ - L
              , b = h.y + F - I
              , A = w + h.width + 2 * L - _ - T - O
              , j = b + h.height + 2 * I - F - P - R;
            n.left = Math.max(n.left, w),
            n.top = Math.max(n.top, b),
            n.right = Math.min(n.right, A),
            n.bottom = Math.min(n.bottom, j)
        }
    }),
    n
}
function sx(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
      , n = "".concat(t)
      , i = n.match(/^(.*)\%$/);
    return i ? e * (parseFloat(i[1]) / 100) : parseFloat(n)
}
function ox(e, t) {
    var n = t || []
      , i = Me(n, 2)
      , r = i[0]
      , s = i[1];
    return [sx(e.width, r), sx(e.height, s)]
}
function ax() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return [e[0], e[1]]
}
function xo(e, t) {
    var n = t[0], i = t[1], r, s;
    return n === "t" ? s = e.y : n === "b" ? s = e.y + e.height : s = e.y + e.height / 2,
    i === "l" ? r = e.x : i === "r" ? r = e.x + e.width : r = e.x + e.width / 2,
    {
        x: r,
        y: s
    }
}
function vr(e, t) {
    var n = {
        t: "b",
        b: "t",
        l: "r",
        r: "l"
    };
    return e.map(function(i, r) {
        return r === t ? n[i] || "c" : i
    }).join("")
}
function OD(e, t, n, i, r, s, o) {
    var a = M.useState({
        ready: !1,
        offsetX: 0,
        offsetY: 0,
        offsetR: 0,
        offsetB: 0,
        arrowX: 0,
        arrowY: 0,
        scaleX: 1,
        scaleY: 1,
        align: r[i] || {}
    })
      , l = Me(a, 2)
      , c = l[0]
      , u = l[1]
      , h = M.useRef(0)
      , d = M.useMemo(function() {
        return t ? Vp(t) : []
    }, [t])
      , m = M.useRef({})
      , f = function() {
        m.current = {}
    };
    e || f();
    var x = Ri(function() {
        if (t && n && e) {
            let Xt = function(Dc, Ui) {
                var ps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : le
                  , po = W.x + Dc
                  , Pa = W.y + Ui
                  , Sf = po + ee
                  , Cf = Pa + G
                  , kf = Math.max(po, ps.left)
                  , Af = Math.max(Pa, ps.top)
                  , Pe = Math.min(Sf, ps.right)
                  , Be = Math.min(Cf, ps.bottom);
                return Math.max(0, (Pe - kf) * (Be - Af))
            }
              , Ea = function() {
                Ai = W.y + Te,
                qe = Ai + G,
                We = W.x + Ne,
                Ie = We + ee
            };
            var gv = Xt, mv = Ea, p, g, C = t, E = C.ownerDocument, O = bc(C), R = O.getComputedStyle(C), F = R.width, P = R.height, _ = R.position, T = C.style.left, L = C.style.top, I = C.style.right, k = C.style.bottom, w = C.style.overflow, b = be(be({}, r[i]), s), A = E.createElement("div");
            (p = C.parentElement) === null || p === void 0 || p.appendChild(A),
            A.style.left = "".concat(C.offsetLeft, "px"),
            A.style.top = "".concat(C.offsetTop, "px"),
            A.style.position = _,
            A.style.height = "".concat(C.offsetHeight, "px"),
            A.style.width = "".concat(C.offsetWidth, "px"),
            C.style.left = "0",
            C.style.top = "0",
            C.style.right = "auto",
            C.style.bottom = "auto",
            C.style.overflow = "hidden";
            var j;
            if (Array.isArray(n))
                j = {
                    x: n[0],
                    y: n[1],
                    width: 0,
                    height: 0
                };
            else {
                var B = n.getBoundingClientRect();
                j = {
                    x: B.x,
                    y: B.y,
                    width: B.width,
                    height: B.height
                }
            }
            var W = C.getBoundingClientRect()
              , N = E.documentElement
              , H = N.clientWidth
              , X = N.clientHeight
              , ie = N.scrollWidth
              , K = N.scrollHeight
              , D = N.scrollTop
              , V = N.scrollLeft
              , G = W.height
              , ee = W.width
              , J = j.height
              , te = j.width
              , z = {
                left: 0,
                top: 0,
                right: H,
                bottom: X
            }
              , Y = {
                left: -V,
                top: -D,
                right: ie - V,
                bottom: K - D
            }
              , U = b.htmlRegion
              , Z = "visible"
              , $ = "visibleFirst";
            U !== "scroll" && U !== $ && (U = Z);
            var ne = U === $
              , oe = rx(Y, d)
              , se = rx(z, d)
              , le = U === Z ? se : oe
              , he = ne ? se : le;
            C.style.left = "auto",
            C.style.top = "auto",
            C.style.right = "0",
            C.style.bottom = "0";
            var Q = C.getBoundingClientRect();
            C.style.left = T,
            C.style.top = L,
            C.style.right = I,
            C.style.bottom = k,
            C.style.overflow = w,
            (g = C.parentElement) === null || g === void 0 || g.removeChild(A);
            var q = Yl(Math.round(ee / parseFloat(F) * 1e3) / 1e3)
              , ae = Yl(Math.round(G / parseFloat(P) * 1e3) / 1e3);
            if (q === 0 || ae === 0 || Nh(n) && !BS(n))
                return;
            var re = b.offset
              , ce = b.targetOffset
              , ue = ox(W, re)
              , fe = Me(ue, 2)
              , de = fe[0]
              , ge = fe[1]
              , ye = ox(j, ce)
              , pe = Me(ye, 2)
              , xe = pe[0]
              , ke = pe[1];
            j.x -= xe,
            j.y -= ke;
            var Ee = b.points || [], we = Me(Ee, 2), ve = we[0], _e = we[1], Oe = ax(_e), ze = ax(ve), Qe = xo(j, Oe), Fe = xo(W, ze), rt = be({}, b), Ne = Qe.x - Fe.x + de, Te = Qe.y - Fe.y + ge, Ve = Xt(Ne, Te), Ke = Xt(Ne, Te, se), st = xo(j, ["t", "l"]), Qt = xo(W, ["t", "l"]), un = xo(j, ["b", "r"]), bn = xo(W, ["b", "r"]), ct = b.overflow || {}, Yn = ct.adjustX, pr = ct.adjustY, ci = ct.shiftX, Gt = ct.shiftY, ls = function(Ui) {
                return typeof Ui == "boolean" ? Ui : Ui >= 0
            }, Ai, qe, We, Ie;
            Ea();
            var ut = ls(pr)
              , ht = ze[0] === Oe[0];
            if (ut && ze[0] === "t" && (qe > he.bottom || m.current.bt)) {
                var It = Te;
                ht ? It -= G - J : It = st.y - bn.y - ge;
                var hn = Xt(Ne, It)
                  , ui = Xt(Ne, It, se);
                hn > Ve || hn === Ve && (!ne || ui >= Ke) ? (m.current.bt = !0,
                Te = It,
                ge = -ge,
                rt.points = [vr(ze, 0), vr(Oe, 0)]) : m.current.bt = !1
            }
            if (ut && ze[0] === "b" && (Ai < he.top || m.current.tb)) {
                var ot = Te;
                ht ? ot += G - J : ot = un.y - Qt.y - ge;
                var cs = Xt(Ne, ot)
                  , lo = Xt(Ne, ot, se);
                cs > Ve || cs === Ve && (!ne || lo >= Ke) ? (m.current.tb = !0,
                Te = ot,
                ge = -ge,
                rt.points = [vr(ze, 0), vr(Oe, 0)]) : m.current.tb = !1
            }
            var Mi = ls(Yn)
              , co = ze[1] === Oe[1];
            if (Mi && ze[1] === "l" && (Ie > he.right || m.current.rl)) {
                var us = Ne;
                co ? us -= ee - te : us = st.x - bn.x - de;
                var Pc = Xt(us, Te)
                  , ff = Xt(us, Te, se);
                Pc > Ve || Pc === Ve && (!ne || ff >= Ke) ? (m.current.rl = !0,
                Ne = us,
                de = -de,
                rt.points = [vr(ze, 1), vr(Oe, 1)]) : m.current.rl = !1
            }
            if (Mi && ze[1] === "r" && (We < he.left || m.current.lr)) {
                var hs = Ne;
                co ? hs += ee - te : hs = un.x - Qt.x - de;
                var Tc = Xt(hs, Te)
                  , uo = Xt(hs, Te, se);
                Tc > Ve || Tc === Ve && (!ne || uo >= Ke) ? (m.current.lr = !0,
                Ne = hs,
                de = -de,
                rt.points = [vr(ze, 1), vr(Oe, 1)]) : m.current.lr = !1
            }
            Ea();
            var Wi = ci === !0 ? 0 : ci;
            typeof Wi == "number" && (We < se.left && (Ne -= We - se.left - de,
            j.x + te < se.left + Wi && (Ne += j.x - se.left + te - Wi)),
            Ie > se.right && (Ne -= Ie - se.right - de,
            j.x > se.right - Wi && (Ne += j.x - se.right + Wi)));
            var ds = Gt === !0 ? 0 : Gt;
            typeof ds == "number" && (Ai < se.top && (Te -= Ai - se.top - ge,
            j.y + J < se.top + ds && (Te += j.y - se.top + J - ds)),
            qe > se.bottom && (Te -= qe - se.bottom - ge,
            j.y > se.bottom - ds && (Te += j.y - se.bottom + ds)));
            var ho = W.x + Ne
              , fo = ho + ee
              , Hi = W.y + Te
              , jc = Hi + G
              , fs = j.x
              , gr = fs + te
              , Oc = j.y
              , pf = Oc + J
              , gf = Math.max(ho, fs)
              , Lc = Math.min(fo, gr)
              , mf = (gf + Lc) / 2
              , vf = mf - ho
              , yf = Math.max(Hi, Oc)
              , Rc = Math.min(jc, pf)
              , xf = (yf + Rc) / 2
              , bf = xf - Hi;
            o == null || o(t, rt);
            var _c = Q.right - W.x - (Ne + W.width)
              , wf = Q.bottom - W.y - (Te + W.height);
            u({
                ready: !0,
                offsetX: Ne / q,
                offsetY: Te / ae,
                offsetR: _c / q,
                offsetB: wf / ae,
                arrowX: vf / q,
                arrowY: bf / ae,
                scaleX: q,
                scaleY: ae,
                align: rt
            })
        }
    })
      , S = function() {
        h.current += 1;
        var g = h.current;
        Promise.resolve().then(function() {
            h.current === g && x()
        })
    }
      , v = function() {
        u(function(g) {
            return be(be({}, g), {}, {
                ready: !1
            })
        })
    };
    return pn(v, [i]),
    pn(function() {
        e || v()
    }, [e]),
    [c.ready, c.offsetX, c.offsetY, c.offsetR, c.offsetB, c.arrowX, c.arrowY, c.scaleX, c.scaleY, c.align, S]
}
function LD(e, t, n, i, r) {
    pn(function() {
        if (e && t && n) {
            let d = function() {
                i(),
                r()
            };
            var h = d
              , s = t
              , o = n
              , a = Vp(s)
              , l = Vp(o)
              , c = bc(o)
              , u = new Set([c].concat(Re(a), Re(l)));
            return u.forEach(function(m) {
                m.addEventListener("scroll", d, {
                    passive: !0
                })
            }),
            c.addEventListener("resize", d, {
                passive: !0
            }),
            i(),
            function() {
                u.forEach(function(m) {
                    m.removeEventListener("scroll", d),
                    c.removeEventListener("resize", d)
                })
            }
        }
    }, [e, t, n])
}
function RD(e, t, n, i, r, s, o, a) {
    var l = M.useRef(e)
      , c = M.useRef(!1);
    l.current !== e && (c.current = !0,
    l.current = e),
    M.useEffect(function() {
        var u = Ci(function() {
            c.current = !1
        });
        return function() {
            Ci.cancel(u)
        }
    }, [e]),
    M.useEffect(function() {
        if (t && i && (!r || s)) {
            var u = function() {
                var O = !1
                  , R = function(_) {
                    var T = _.target;
                    O = o(T)
                }
                  , F = function(_) {
                    var T = _.target;
                    !c.current && l.current && !O && !o(T) && a(!1)
                };
                return [R, F]
            }
              , h = u()
              , d = Me(h, 2)
              , m = d[0]
              , f = d[1]
              , x = u()
              , S = Me(x, 2)
              , v = S[0]
              , p = S[1]
              , g = bc(i);
            g.addEventListener("mousedown", m, !0),
            g.addEventListener("click", f, !0),
            g.addEventListener("contextmenu", f, !0);
            var C = Ep(n);
            return C && (C.addEventListener("mousedown", v, !0),
            C.addEventListener("click", p, !0),
            C.addEventListener("contextmenu", p, !0)),
            function() {
                g.removeEventListener("mousedown", m, !0),
                g.removeEventListener("click", f, !0),
                g.removeEventListener("contextmenu", f, !0),
                C && (C.removeEventListener("mousedown", v, !0),
                C.removeEventListener("click", p, !0),
                C.removeEventListener("contextmenu", p, !0))
            }
        }
    }, [t, n, i, r, s])
}
var _D = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
function DD() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : VS
      , t = M.forwardRef(function(n, i) {
        var r = n.prefixCls
          , s = r === void 0 ? "rc-trigger-popup" : r
          , o = n.children
          , a = n.action
          , l = a === void 0 ? "hover" : a
          , c = n.showAction
          , u = n.hideAction
          , h = n.popupVisible
          , d = n.defaultPopupVisible
          , m = n.onPopupVisibleChange
          , f = n.afterPopupVisibleChange
          , x = n.mouseEnterDelay
          , S = n.mouseLeaveDelay
          , v = S === void 0 ? .1 : S
          , p = n.focusDelay
          , g = n.blurDelay
          , C = n.mask
          , E = n.maskClosable
          , O = E === void 0 ? !0 : E
          , R = n.getPopupContainer
          , F = n.forceRender
          , P = n.autoDestroy
          , _ = n.destroyPopupOnHide
          , T = n.popup
          , L = n.popupClassName
          , I = n.popupStyle
          , k = n.popupPlacement
          , w = n.builtinPlacements
          , b = w === void 0 ? {} : w
          , A = n.popupAlign
          , j = n.zIndex
          , B = n.stretch
          , W = n.getPopupClassNameFromAlign
          , N = n.fresh
          , H = n.alignPoint
          , X = n.onPopupClick
          , ie = n.onPopupAlign
          , K = n.arrow
          , D = n.popupMotion
          , V = n.maskMotion
          , G = n.popupTransitionName
          , ee = n.popupAnimation
          , J = n.maskTransitionName
          , te = n.maskAnimation
          , z = n.className
          , Y = n.getTriggerDOMNode
          , U = ki(n, _D)
          , Z = P || _ || !1
          , $ = M.useState(!1)
          , ne = Me($, 2)
          , oe = ne[0]
          , se = ne[1];
        pn(function() {
            se(SD())
        }, []);
        var le = M.useRef({})
          , he = M.useContext(tx)
          , Q = M.useMemo(function() {
            return {
                registerSubPopup: function(Be, kt) {
                    le.current[Be] = kt,
                    he == null || he.registerSubPopup(Be, kt)
                }
            }
        }, [he])
          , q = u_()
          , ae = M.useState(null)
          , re = Me(ae, 2)
          , ce = re[0]
          , ue = re[1]
          , fe = Ri(function(Pe) {
            Nh(Pe) && ce !== Pe && ue(Pe),
            he == null || he.registerSubPopup(q, Pe)
        })
          , de = M.useState(null)
          , ge = Me(de, 2)
          , ye = ge[0]
          , pe = ge[1]
          , xe = M.useRef(null)
          , ke = Ri(function(Pe) {
            Nh(Pe) && ye !== Pe && (pe(Pe),
            xe.current = Pe)
        })
          , Ee = M.Children.only(o)
          , we = (Ee == null ? void 0 : Ee.props) || {}
          , ve = {}
          , _e = Ri(function(Pe) {
            var Be, kt, Bt = ye;
            return (Bt == null ? void 0 : Bt.contains(Pe)) || ((Be = Ep(Bt)) === null || Be === void 0 ? void 0 : Be.host) === Pe || Pe === Bt || (ce == null ? void 0 : ce.contains(Pe)) || ((kt = Ep(ce)) === null || kt === void 0 ? void 0 : kt.host) === Pe || Pe === ce || Object.values(le.current).some(function(At) {
                return (At == null ? void 0 : At.contains(Pe)) || Pe === At
            })
        })
          , Oe = ix(s, D, ee, G)
          , ze = ix(s, V, te, J)
          , Qe = M.useState(d || !1)
          , Fe = Me(Qe, 2)
          , rt = Fe[0]
          , Ne = Fe[1]
          , Te = h ?? rt
          , Ve = Ri(function(Pe) {
            h === void 0 && Ne(Pe)
        });
        pn(function() {
            Ne(h || !1)
        }, [h]);
        var Ke = M.useRef(Te);
        Ke.current = Te;
        var st = M.useRef([]);
        st.current = [];
        var Qt = Ri(function(Pe) {
            var Be;
            Ve(Pe),
            ((Be = st.current[st.current.length - 1]) !== null && Be !== void 0 ? Be : Te) !== Pe && (st.current.push(Pe),
            m == null || m(Pe))
        })
          , un = M.useRef()
          , bn = function() {
            clearTimeout(un.current)
        }
          , ct = function(Be) {
            var kt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            bn(),
            kt === 0 ? Qt(Be) : un.current = setTimeout(function() {
                Qt(Be)
            }, kt * 1e3)
        };
        M.useEffect(function() {
            return bn
        }, []);
        var Yn = M.useState(!1)
          , pr = Me(Yn, 2)
          , ci = pr[0]
          , Gt = pr[1];
        pn(function(Pe) {
            (!Pe || Te) && Gt(!0)
        }, [Te]);
        var ls = M.useState(null)
          , Ai = Me(ls, 2)
          , qe = Ai[0]
          , We = Ai[1]
          , Ie = M.useState([0, 0])
          , ut = Me(Ie, 2)
          , ht = ut[0]
          , It = ut[1]
          , hn = function(Be) {
            It([Be.clientX, Be.clientY])
        }
          , ui = OD(Te, ce, H ? ht : ye, k, b, A, ie)
          , ot = Me(ui, 11)
          , cs = ot[0]
          , lo = ot[1]
          , Mi = ot[2]
          , co = ot[3]
          , us = ot[4]
          , Pc = ot[5]
          , ff = ot[6]
          , hs = ot[7]
          , Tc = ot[8]
          , uo = ot[9]
          , Wi = ot[10]
          , ds = PD(oe, l, c, u)
          , ho = Me(ds, 2)
          , fo = ho[0]
          , Hi = ho[1]
          , jc = fo.has("click")
          , fs = Hi.has("click") || Hi.has("contextMenu")
          , gr = Ri(function() {
            ci || Wi()
        })
          , Oc = function() {
            Ke.current && H && fs && ct(!1)
        };
        LD(Te, ye, ce, gr, Oc),
        pn(function() {
            gr()
        }, [ht, k]),
        pn(function() {
            Te && !(b != null && b[k]) && gr()
        }, [JSON.stringify(A)]);
        var pf = M.useMemo(function() {
            var Pe = jD(b, s, uo, H);
            return nt(Pe, W == null ? void 0 : W(uo))
        }, [uo, W, b, s, H]);
        M.useImperativeHandle(i, function() {
            return {
                nativeElement: xe.current,
                forceAlign: gr
            }
        });
        var gf = M.useState(0)
          , Lc = Me(gf, 2)
          , mf = Lc[0]
          , vf = Lc[1]
          , yf = M.useState(0)
          , Rc = Me(yf, 2)
          , xf = Rc[0]
          , bf = Rc[1]
          , _c = function() {
            if (B && ye) {
                var Be = ye.getBoundingClientRect();
                vf(Be.width),
                bf(Be.height)
            }
        }
          , wf = function() {
            _c(),
            gr()
        }
          , gv = function(Be) {
            Gt(!1),
            Wi(),
            f == null || f(Be)
        }
          , mv = function() {
            return new Promise(function(Be) {
                _c(),
                We(function() {
                    return Be
                })
            }
            )
        };
        pn(function() {
            qe && (Wi(),
            qe(),
            We(null))
        }, [qe]);
        function Xt(Pe, Be, kt, Bt) {
            ve[Pe] = function(At) {
                var Nc;
                Bt == null || Bt(At),
                ct(Be, kt);
                for (var Mf = arguments.length, vv = new Array(Mf > 1 ? Mf - 1 : 0), Fc = 1; Fc < Mf; Fc++)
                    vv[Fc - 1] = arguments[Fc];
                (Nc = we[Pe]) === null || Nc === void 0 || Nc.call.apply(Nc, [we, At].concat(vv))
            }
        }
        (jc || fs) && (ve.onClick = function(Pe) {
            var Be;
            Ke.current && fs ? ct(!1) : !Ke.current && jc && (hn(Pe),
            ct(!0));
            for (var kt = arguments.length, Bt = new Array(kt > 1 ? kt - 1 : 0), At = 1; At < kt; At++)
                Bt[At - 1] = arguments[At];
            (Be = we.onClick) === null || Be === void 0 || Be.call.apply(Be, [we, Pe].concat(Bt))
        }
        ),
        RD(Te, fs, ye, ce, C, O, _e, ct);
        var Ea = fo.has("hover"), Dc = Hi.has("hover"), Ui, ps;
        Ea && (Xt("onMouseEnter", !0, x, function(Pe) {
            hn(Pe)
        }),
        Xt("onPointerEnter", !0, x, function(Pe) {
            hn(Pe)
        }),
        Ui = function() {
            (Te || ci) && ct(!0, x)
        }
        ,
        H && (ve.onMouseMove = function(Pe) {
            var Be;
            (Be = we.onMouseMove) === null || Be === void 0 || Be.call(we, Pe)
        }
        )),
        Dc && (Xt("onMouseLeave", !1, v),
        Xt("onPointerLeave", !1, v),
        ps = function() {
            ct(!1, v)
        }
        ),
        fo.has("focus") && Xt("onFocus", !0, p),
        Hi.has("focus") && Xt("onBlur", !1, g),
        fo.has("contextMenu") && (ve.onContextMenu = function(Pe) {
            var Be;
            Ke.current && Hi.has("contextMenu") ? ct(!1) : (hn(Pe),
            ct(!0)),
            Pe.preventDefault();
            for (var kt = arguments.length, Bt = new Array(kt > 1 ? kt - 1 : 0), At = 1; At < kt; At++)
                Bt[At - 1] = arguments[At];
            (Be = we.onContextMenu) === null || Be === void 0 || Be.call.apply(Be, [we, Pe].concat(Bt))
        }
        ),
        z && (ve.className = nt(we.className, z));
        var po = be(be({}, we), ve)
          , Pa = {}
          , Sf = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
        Sf.forEach(function(Pe) {
            U[Pe] && (Pa[Pe] = function() {
                for (var Be, kt = arguments.length, Bt = new Array(kt), At = 0; At < kt; At++)
                    Bt[At] = arguments[At];
                (Be = po[Pe]) === null || Be === void 0 || Be.call.apply(Be, [po].concat(Bt)),
                U[Pe].apply(U, Bt)
            }
            )
        });
        var Cf = M.cloneElement(Ee, be(be({}, po), Pa))
          , kf = {
            x: Pc,
            y: ff
        }
          , Af = K ? be({}, K !== !0 ? K : {}) : null;
        return M.createElement(M.Fragment, null, M.createElement(d2, {
            disabled: !Te,
            ref: ke,
            onResize: wf
        }, M.createElement(ED, {
            getTriggerDOMNode: Y
        }, Cf)), M.createElement(tx.Provider, {
            value: Q
        }, M.createElement(MD, {
            portal: e,
            ref: fe,
            prefixCls: s,
            popup: T,
            className: nt(L, pf),
            style: I,
            target: ye,
            onMouseEnter: Ui,
            onMouseLeave: ps,
            onPointerEnter: Ui,
            zIndex: j,
            open: Te,
            keepDom: ci,
            fresh: N,
            onClick: X,
            mask: C,
            motion: Oe,
            maskMotion: ze,
            onVisibleChanged: gv,
            onPrepare: mv,
            forceRender: F,
            autoDestroy: Z,
            getPopupContainer: R,
            align: uo,
            arrow: Af,
            arrowPos: kf,
            ready: cs,
            offsetX: lo,
            offsetY: Mi,
            offsetR: co,
            offsetB: us,
            onAlign: gr,
            stretch: B,
            targetWidth: mf / hs,
            targetHeight: xf / Tc
        })))
    });
    return t
}
const ND = DD(VS)
  , $l = ["xxl", "xl", "lg", "md", "sm", "xs"]
  , FD = e=>({
    xs: `(max-width: ${e.screenXSMax}px)`,
    sm: `(min-width: ${e.screenSM}px)`,
    md: `(min-width: ${e.screenMD}px)`,
    lg: `(min-width: ${e.screenLG}px)`,
    xl: `(min-width: ${e.screenXL}px)`,
    xxl: `(min-width: ${e.screenXXL}px)`
})
  , ID = e=>{
    const t = e
      , n = [].concat($l).reverse();
    return n.forEach((i,r)=>{
        const s = i.toUpperCase()
          , o = `screen${s}Min`
          , a = `screen${s}`;
        if (!(t[o] <= t[a]))
            throw new Error(`${o}<=${a} fails : !(${t[o]}<=${t[a]})`);
        if (r < n.length - 1) {
            const l = `screen${s}Max`;
            if (!(t[a] <= t[l]))
                throw new Error(`${a}<=${l} fails : !(${t[a]}<=${t[l]})`);
            const u = `screen${n[r + 1].toUpperCase()}Min`;
            if (!(t[l] <= t[u]))
                throw new Error(`${l}<=${u} fails : !(${t[l]}<=${t[u]})`)
        }
    }
    ),
    e
}
;
function BD() {
    const [,e] = no()
      , t = FD(ID(e));
    return Ce.useMemo(()=>{
        const n = new Map;
        let i = -1
          , r = {};
        return {
            matchHandlers: {},
            dispatch(s) {
                return r = s,
                n.forEach(o=>o(r)),
                n.size >= 1
            },
            subscribe(s) {
                return n.size || this.register(),
                i += 1,
                n.set(i, s),
                s(r),
                i
            },
            unsubscribe(s) {
                n.delete(s),
                n.size || this.unregister()
            },
            unregister() {
                Object.keys(t).forEach(s=>{
                    const o = t[s]
                      , a = this.matchHandlers[o];
                    a == null || a.mql.removeListener(a == null ? void 0 : a.listener)
                }
                ),
                n.clear()
            },
            register() {
                Object.keys(t).forEach(s=>{
                    const o = t[s]
                      , a = c=>{
                        let {matches: u} = c;
                        this.dispatch(Object.assign(Object.assign({}, r), {
                            [s]: u
                        }))
                    }
                      , l = window.matchMedia(o);
                    l.addListener(a),
                    this.matchHandlers[o] = {
                        mql: l,
                        listener: a
                    },
                    a(l)
                }
                )
            },
            responsiveMap: t
        }
    }
    , [e])
}
function $S(e) {
    var t = e.children
      , n = e.prefixCls
      , i = e.id
      , r = e.overlayInnerStyle
      , s = e.className
      , o = e.style;
    return M.createElement("div", {
        className: nt("".concat(n, "-content"), s),
        style: o
    }, M.createElement("div", {
        className: "".concat(n, "-inner"),
        id: i,
        role: "tooltip",
        style: r
    }, typeof t == "function" ? t() : t))
}
var bo = {
    shiftX: 64,
    adjustY: 1
}
  , wo = {
    adjustX: 1,
    shiftY: !0
}
  , Kn = [0, 0]
  , zD = {
    left: {
        points: ["cr", "cl"],
        overflow: wo,
        offset: [-4, 0],
        targetOffset: Kn
    },
    right: {
        points: ["cl", "cr"],
        overflow: wo,
        offset: [4, 0],
        targetOffset: Kn
    },
    top: {
        points: ["bc", "tc"],
        overflow: bo,
        offset: [0, -4],
        targetOffset: Kn
    },
    bottom: {
        points: ["tc", "bc"],
        overflow: bo,
        offset: [0, 4],
        targetOffset: Kn
    },
    topLeft: {
        points: ["bl", "tl"],
        overflow: bo,
        offset: [0, -4],
        targetOffset: Kn
    },
    leftTop: {
        points: ["tr", "tl"],
        overflow: wo,
        offset: [-4, 0],
        targetOffset: Kn
    },
    topRight: {
        points: ["br", "tr"],
        overflow: bo,
        offset: [0, -4],
        targetOffset: Kn
    },
    rightTop: {
        points: ["tl", "tr"],
        overflow: wo,
        offset: [4, 0],
        targetOffset: Kn
    },
    bottomRight: {
        points: ["tr", "br"],
        overflow: bo,
        offset: [0, 4],
        targetOffset: Kn
    },
    rightBottom: {
        points: ["bl", "br"],
        overflow: wo,
        offset: [4, 0],
        targetOffset: Kn
    },
    bottomLeft: {
        points: ["tl", "bl"],
        overflow: bo,
        offset: [0, 4],
        targetOffset: Kn
    },
    leftBottom: {
        points: ["br", "bl"],
        overflow: wo,
        offset: [-4, 0],
        targetOffset: Kn
    }
}
  , VD = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"]
  , WD = function(t, n) {
    var i = t.overlayClassName
      , r = t.trigger
      , s = r === void 0 ? ["hover"] : r
      , o = t.mouseEnterDelay
      , a = o === void 0 ? 0 : o
      , l = t.mouseLeaveDelay
      , c = l === void 0 ? .1 : l
      , u = t.overlayStyle
      , h = t.prefixCls
      , d = h === void 0 ? "rc-tooltip" : h
      , m = t.children
      , f = t.onVisibleChange
      , x = t.afterVisibleChange
      , S = t.transitionName
      , v = t.animation
      , p = t.motion
      , g = t.placement
      , C = g === void 0 ? "right" : g
      , E = t.align
      , O = E === void 0 ? {} : E
      , R = t.destroyTooltipOnHide
      , F = R === void 0 ? !1 : R
      , P = t.defaultVisible
      , _ = t.getTooltipContainer
      , T = t.overlayInnerStyle;
    t.arrowContent;
    var L = t.overlay
      , I = t.id
      , k = t.showArrow
      , w = k === void 0 ? !0 : k
      , b = ki(t, VD)
      , A = M.useRef(null);
    M.useImperativeHandle(n, function() {
        return A.current
    });
    var j = be({}, b);
    "visible"in t && (j.popupVisible = t.visible);
    var B = function() {
        return M.createElement($S, {
            key: "content",
            prefixCls: d,
            id: I,
            overlayInnerStyle: T
        }, L)
    };
    return M.createElement(ND, Wn({
        popupClassName: i,
        prefixCls: d,
        popup: B,
        action: s,
        builtinPlacements: zD,
        popupPlacement: C,
        ref: A,
        popupAlign: O,
        getPopupContainer: _,
        onPopupVisibleChange: f,
        afterPopupVisibleChange: x,
        popupTransitionName: S,
        popupAnimation: v,
        popupMotion: p,
        defaultPopupVisible: P,
        autoDestroy: F,
        mouseLeaveDelay: c,
        popupStyle: u,
        mouseEnterDelay: a,
        arrow: w
    }, j), m)
};
const HD = M.forwardRef(WD)
  , KS = 8;
function QS(e) {
    const t = KS
      , {contentRadius: n, limitVerticalRadius: i} = e
      , r = n > 12 ? n + 2 : 12;
    return {
        dropdownArrowOffset: r,
        dropdownArrowOffsetVertical: i ? t : r
    }
}
function du(e, t) {
    return e ? t : {}
}
function UD(e, t) {
    const {componentCls: n, sizePopupArrow: i, borderRadiusXS: r, borderRadiusOuter: s, boxShadowPopoverArrow: o} = e
      , {colorBg: a, contentRadius: l=e.borderRadiusLG, limitVerticalRadius: c, arrowDistance: u=0, arrowPlacement: h={
        left: !0,
        right: !0,
        top: !0,
        bottom: !0
    }} = t
      , {dropdownArrowOffsetVertical: d, dropdownArrowOffset: m} = QS({
        contentRadius: l,
        limitVerticalRadius: c
    });
    return {
        [n]: Object.assign(Object.assign(Object.assign(Object.assign({
            [`${n}-arrow`]: [Object.assign(Object.assign({
                position: "absolute",
                zIndex: 1,
                display: "block"
            }, BL(i, r, s, a, o)), {
                "&:before": {
                    background: a
                }
            })]
        }, du(!!h.top, {
            [[`&-placement-top ${n}-arrow`, `&-placement-topLeft ${n}-arrow`, `&-placement-topRight ${n}-arrow`].join(",")]: {
                bottom: u,
                transform: "translateY(100%) rotate(180deg)"
            },
            [`&-placement-top ${n}-arrow`]: {
                left: {
                    _skip_check_: !0,
                    value: "50%"
                },
                transform: "translateX(-50%) translateY(100%) rotate(180deg)"
            },
            [`&-placement-topLeft ${n}-arrow`]: {
                left: {
                    _skip_check_: !0,
                    value: m
                }
            },
            [`&-placement-topRight ${n}-arrow`]: {
                right: {
                    _skip_check_: !0,
                    value: m
                }
            }
        })), du(!!h.bottom, {
            [[`&-placement-bottom ${n}-arrow`, `&-placement-bottomLeft ${n}-arrow`, `&-placement-bottomRight ${n}-arrow`].join(",")]: {
                top: u,
                transform: "translateY(-100%)"
            },
            [`&-placement-bottom ${n}-arrow`]: {
                left: {
                    _skip_check_: !0,
                    value: "50%"
                },
                transform: "translateX(-50%) translateY(-100%)"
            },
            [`&-placement-bottomLeft ${n}-arrow`]: {
                left: {
                    _skip_check_: !0,
                    value: m
                }
            },
            [`&-placement-bottomRight ${n}-arrow`]: {
                right: {
                    _skip_check_: !0,
                    value: m
                }
            }
        })), du(!!h.left, {
            [[`&-placement-left ${n}-arrow`, `&-placement-leftTop ${n}-arrow`, `&-placement-leftBottom ${n}-arrow`].join(",")]: {
                right: {
                    _skip_check_: !0,
                    value: u
                },
                transform: "translateX(100%) rotate(90deg)"
            },
            [`&-placement-left ${n}-arrow`]: {
                top: {
                    _skip_check_: !0,
                    value: "50%"
                },
                transform: "translateY(-50%) translateX(100%) rotate(90deg)"
            },
            [`&-placement-leftTop ${n}-arrow`]: {
                top: d
            },
            [`&-placement-leftBottom ${n}-arrow`]: {
                bottom: d
            }
        })), du(!!h.right, {
            [[`&-placement-right ${n}-arrow`, `&-placement-rightTop ${n}-arrow`, `&-placement-rightBottom ${n}-arrow`].join(",")]: {
                left: {
                    _skip_check_: !0,
                    value: u
                },
                transform: "translateX(-100%) rotate(-90deg)"
            },
            [`&-placement-right ${n}-arrow`]: {
                top: {
                    _skip_check_: !0,
                    value: "50%"
                },
                transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
            },
            [`&-placement-rightTop ${n}-arrow`]: {
                top: d
            },
            [`&-placement-rightBottom ${n}-arrow`]: {
                bottom: d
            }
        }))
    }
}
function GD(e, t, n, i) {
    if (i === !1)
        return {
            adjustX: !1,
            adjustY: !1
        };
    const r = i && typeof i == "object" ? i : {}
      , s = {};
    switch (e) {
    case "top":
    case "bottom":
        s.shiftX = t.dropdownArrowOffset * 2 + n,
        s.shiftY = !0,
        s.adjustY = !0;
        break;
    case "left":
    case "right":
        s.shiftY = t.dropdownArrowOffsetVertical * 2 + n,
        s.shiftX = !0,
        s.adjustX = !0;
        break
    }
    const o = Object.assign(Object.assign({}, s), r);
    return o.shiftX || (o.adjustX = !0),
    o.shiftY || (o.adjustY = !0),
    o
}
const lx = {
    left: {
        points: ["cr", "cl"]
    },
    right: {
        points: ["cl", "cr"]
    },
    top: {
        points: ["bc", "tc"]
    },
    bottom: {
        points: ["tc", "bc"]
    },
    topLeft: {
        points: ["bl", "tl"]
    },
    leftTop: {
        points: ["tr", "tl"]
    },
    topRight: {
        points: ["br", "tr"]
    },
    rightTop: {
        points: ["tl", "tr"]
    },
    bottomRight: {
        points: ["tr", "br"]
    },
    rightBottom: {
        points: ["bl", "br"]
    },
    bottomLeft: {
        points: ["tl", "bl"]
    },
    leftBottom: {
        points: ["br", "bl"]
    }
}
  , XD = {
    topLeft: {
        points: ["bl", "tc"]
    },
    leftTop: {
        points: ["tr", "cl"]
    },
    topRight: {
        points: ["br", "tc"]
    },
    rightTop: {
        points: ["tl", "cr"]
    },
    bottomRight: {
        points: ["tr", "bc"]
    },
    rightBottom: {
        points: ["bl", "cr"]
    },
    bottomLeft: {
        points: ["tl", "bc"]
    },
    leftBottom: {
        points: ["br", "cl"]
    }
}
  , YD = new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
function $D(e) {
    const {arrowWidth: t, autoAdjustOverflow: n, arrowPointAtCenter: i, offset: r, borderRadius: s, visibleFirst: o} = e
      , a = t / 2
      , l = {};
    return Object.keys(lx).forEach(c=>{
        const u = i && XD[c] || lx[c]
          , h = Object.assign(Object.assign({}, u), {
            offset: [0, 0],
            dynamicInset: !0
        });
        switch (l[c] = h,
        YD.has(c) && (h.autoArrow = !1),
        c) {
        case "top":
        case "topLeft":
        case "topRight":
            h.offset[1] = -a - r;
            break;
        case "bottom":
        case "bottomLeft":
        case "bottomRight":
            h.offset[1] = a + r;
            break;
        case "left":
        case "leftTop":
        case "leftBottom":
            h.offset[0] = -a - r;
            break;
        case "right":
        case "rightTop":
        case "rightBottom":
            h.offset[0] = a + r;
            break
        }
        const d = QS({
            contentRadius: s,
            limitVerticalRadius: !0
        });
        if (i)
            switch (c) {
            case "topLeft":
            case "bottomLeft":
                h.offset[0] = -d.dropdownArrowOffset - a;
                break;
            case "topRight":
            case "bottomRight":
                h.offset[0] = d.dropdownArrowOffset + a;
                break;
            case "leftTop":
            case "rightTop":
                h.offset[1] = -d.dropdownArrowOffset - a;
                break;
            case "leftBottom":
            case "rightBottom":
                h.offset[1] = d.dropdownArrowOffset + a;
                break
            }
        h.overflow = GD(c, d, t, n),
        o && (h.htmlRegion = "visibleFirst")
    }
    ),
    l
}
const KD = e=>{
    const {componentCls: t, tooltipMaxWidth: n, tooltipColor: i, tooltipBg: r, tooltipBorderRadius: s, zIndexPopup: o, controlHeight: a, boxShadowSecondary: l, paddingSM: c, paddingXS: u, tooltipRadiusOuter: h} = e;
    return [{
        [t]: Object.assign(Object.assign(Object.assign(Object.assign({}, fl(e)), {
            position: "absolute",
            zIndex: o,
            display: "block",
            width: "max-content",
            maxWidth: n,
            visibility: "visible",
            transformOrigin: "var(--arrow-x, 50%) var(--arrow-y, 50%)",
            "&-hidden": {
                display: "none"
            },
            "--antd-arrow-background-color": r,
            [`${t}-inner`]: {
                minWidth: a,
                minHeight: a,
                padding: `${c / 2}px ${u}px`,
                color: i,
                textAlign: "start",
                textDecoration: "none",
                wordWrap: "break-word",
                backgroundColor: r,
                borderRadius: s,
                boxShadow: l,
                boxSizing: "border-box"
            },
            [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
                [`${t}-inner`]: {
                    borderRadius: Math.min(s, KS)
                }
            },
            [`${t}-content`]: {
                position: "relative"
            }
        }), YL(e, (d,m)=>{
            let {darkColor: f} = m;
            return {
                [`&${t}-${d}`]: {
                    [`${t}-inner`]: {
                        backgroundColor: f
                    },
                    [`${t}-arrow`]: {
                        "--antd-arrow-background-color": f
                    }
                }
            }
        }
        )), {
            "&-rtl": {
                direction: "rtl"
            }
        })
    }, UD(qs(e, {
        borderRadiusOuter: h
    }), {
        colorBg: "var(--antd-arrow-background-color)",
        contentRadius: s,
        limitVerticalRadius: !0
    }), {
        [`${t}-pure`]: {
            position: "relative",
            maxWidth: "none",
            margin: e.sizePopupArrow
        }
    }]
}
  , qS = (e,t)=>Aa("Tooltip", i=>{
    if (t === !1)
        return [];
    const {borderRadius: r, colorTextLightSolid: s, colorBgDefault: o, borderRadiusOuter: a} = i
      , l = qs(i, {
        tooltipMaxWidth: 250,
        tooltipColor: s,
        tooltipBorderRadius: r,
        tooltipBg: o,
        tooltipRadiusOuter: a > 4 ? 4 : a
    });
    return [KD(l), wD(i, "zoom-big-fast")]
}
, i=>{
    let {zIndexPopupBase: r, colorBgSpotlight: s} = i;
    return {
        zIndexPopup: r + 70,
        colorBgDefault: s
    }
}
, {
    resetStyle: !1
})(e)
  , QD = Wh.map(e=>`${e}-inverse`);
function qD(e) {
    return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? [].concat(Re(QD), Re(Wh)).includes(e) : Wh.includes(e)
}
function ZS(e, t) {
    const n = qD(t)
      , i = nt({
        [`${e}-${t}`]: t && n
    })
      , r = {}
      , s = {};
    return t && !n && (r.background = t,
    s["--antd-arrow-background-color"] = t),
    {
        className: i,
        overlayStyle: r,
        arrowStyle: s
    }
}
const ZD = e=>{
    const {prefixCls: t, className: n, placement: i="top", title: r, color: s, overlayInnerStyle: o} = e
      , {getPrefixCls: a} = M.useContext(Xn)
      , l = a("tooltip", t)
      , [c,u] = qS(l, !0)
      , h = ZS(l, s)
      , d = h.arrowStyle
      , m = Object.assign(Object.assign({}, o), h.overlayStyle)
      , f = nt(u, l, `${l}-pure`, `${l}-placement-${i}`, n, h.className);
    return c(M.createElement("div", {
        className: f,
        style: d
    }, M.createElement("div", {
        className: `${l}-arrow`
    }), M.createElement($S, Object.assign({}, e, {
        className: u,
        prefixCls: l,
        overlayInnerStyle: m
    }), r)))
}
  , JD = ZD;
var eN = function(e, t) {
    var n = {};
    for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++)
            t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
    return n
};
const JS = M.forwardRef((e,t)=>{
    var n, i;
    const {prefixCls: r, openClassName: s, getTooltipContainer: o, overlayClassName: a, color: l, overlayInnerStyle: c, children: u, afterOpenChange: h, afterVisibleChange: d, destroyTooltipOnHide: m, arrow: f=!0, title: x, overlay: S, builtinPlacements: v, arrowPointAtCenter: p=!1, autoAdjustOverflow: g=!0} = e
      , C = !!f
      , [,E] = no()
      , {getPopupContainer: O, getPrefixCls: R, direction: F} = M.useContext(Xn)
      , P = WO()
      , _ = M.useRef(null)
      , T = ()=>{
        var Q;
        (Q = _.current) === null || Q === void 0 || Q.forceAlign()
    }
    ;
    M.useImperativeHandle(t, ()=>({
        forceAlign: T,
        forcePopupAlign: ()=>{
            P.deprecated(!1, "forcePopupAlign", "forceAlign"),
            T()
        }
    }));
    const [L,I] = C2(!1, {
        value: (n = e.open) !== null && n !== void 0 ? n : e.visible,
        defaultValue: (i = e.defaultOpen) !== null && i !== void 0 ? i : e.defaultVisible
    })
      , k = !x && !S && x !== 0
      , w = Q=>{
        var q, ae;
        I(k ? !1 : Q),
        k || ((q = e.onOpenChange) === null || q === void 0 || q.call(e, Q),
        (ae = e.onVisibleChange) === null || ae === void 0 || ae.call(e, Q))
    }
      , b = M.useMemo(()=>{
        var Q, q;
        let ae = p;
        return typeof f == "object" && (ae = (q = (Q = f.pointAtCenter) !== null && Q !== void 0 ? Q : f.arrowPointAtCenter) !== null && q !== void 0 ? q : p),
        v || $D({
            arrowPointAtCenter: ae,
            autoAdjustOverflow: g,
            arrowWidth: C ? E.sizePopupArrow : 0,
            borderRadius: E.borderRadius,
            offset: E.marginXXS,
            visibleFirst: !0
        })
    }
    , [p, f, v, E])
      , A = M.useMemo(()=>x === 0 ? x : S || x || "", [S, x])
      , j = M.createElement(t_, null, typeof A == "function" ? A() : A)
      , {getPopupContainer: B, placement: W="top", mouseEnterDelay: N=.1, mouseLeaveDelay: H=.1, overlayStyle: X, rootClassName: ie} = e
      , K = eN(e, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"])
      , D = R("tooltip", r)
      , V = R()
      , G = e["data-popover-inject"];
    let ee = L;
    !("open"in e) && !("visible"in e) && k && (ee = !1);
    const J = A2(u) && !AR(u) ? u : M.createElement("span", null, u)
      , te = J.props
      , z = !te.className || typeof te.className == "string" ? nt(te.className, s || `${D}-open`) : te.className
      , [Y,U] = qS(D, !G)
      , Z = ZS(D, l)
      , $ = Z.arrowStyle
      , ne = Object.assign(Object.assign({}, c), Z.overlayStyle)
      , oe = nt(a, {
        [`${D}-rtl`]: F === "rtl"
    }, Z.className, ie, U)
      , [se,le] = LR("Tooltip", K.zIndex)
      , he = M.createElement(HD, Object.assign({}, K, {
        zIndex: se,
        showArrow: C,
        placement: W,
        mouseEnterDelay: N,
        mouseLeaveDelay: H,
        prefixCls: D,
        overlayClassName: oe,
        overlayStyle: Object.assign(Object.assign({}, $), X),
        getTooltipContainer: B || o || O,
        ref: _,
        builtinPlacements: b,
        overlay: j,
        visible: ee,
        onVisibleChange: w,
        afterVisibleChange: h ?? d,
        overlayInnerStyle: ne,
        arrowContent: M.createElement("span", {
            className: `${D}-arrow-content`
        }),
        motion: {
            motionName: HR(V, "zoom-big-fast", e.transitionName),
            motionDeadline: 1e3
        },
        destroyTooltipOnHide: !!m
    }), ee ? NS(J, {
        className: z
    }) : J);
    return Y(M.createElement(FS.Provider, {
        value: le
    }, he))
}
);
JS._InternalPanelDoNotUseOrYouWillBeFired = JD;
const tN = JS;
var nN = ["prefixCls", "className", "style", "checked", "disabled", "defaultChecked", "type", "title", "onChange"]
  , iN = M.forwardRef(function(e, t) {
    var n, i = e.prefixCls, r = i === void 0 ? "rc-checkbox" : i, s = e.className, o = e.style, a = e.checked, l = e.disabled, c = e.defaultChecked, u = c === void 0 ? !1 : c, h = e.type, d = h === void 0 ? "checkbox" : h, m = e.title, f = e.onChange, x = ki(e, nN), S = M.useRef(null), v = C2(u, {
        value: a
    }), p = Me(v, 2), g = p[0], C = p[1];
    M.useImperativeHandle(t, function() {
        return {
            focus: function() {
                var F;
                (F = S.current) === null || F === void 0 || F.focus()
            },
            blur: function() {
                var F;
                (F = S.current) === null || F === void 0 || F.blur()
            },
            input: S.current
        }
    });
    var E = nt(r, s, (n = {},
    me(n, "".concat(r, "-checked"), g),
    me(n, "".concat(r, "-disabled"), l),
    n))
      , O = function(F) {
        l || ("checked"in e || C(F.target.checked),
        f == null || f({
            target: be(be({}, e), {}, {
                type: d,
                checked: F.target.checked
            }),
            stopPropagation: function() {
                F.stopPropagation()
            },
            preventDefault: function() {
                F.preventDefault()
            },
            nativeEvent: F.nativeEvent
        }))
    };
    return M.createElement("span", {
        className: E,
        title: m,
        style: o
    }, M.createElement("input", Wn({}, x, {
        className: "".concat(r, "-input"),
        ref: S,
        onChange: O,
        disabled: l,
        checked: !!g,
        type: d
    })), M.createElement("span", {
        className: "".concat(r, "-inner")
    }))
});
const rN = e=>{
    const {checkboxCls: t} = e
      , n = `${t}-wrapper`;
    return [{
        [`${t}-group`]: Object.assign(Object.assign({}, fl(e)), {
            display: "inline-flex",
            flexWrap: "wrap",
            columnGap: e.marginXS,
            [`> ${e.antCls}-row`]: {
                flex: 1
            }
        }),
        [n]: Object.assign(Object.assign({}, fl(e)), {
            display: "inline-flex",
            alignItems: "baseline",
            cursor: "pointer",
            "&:after": {
                display: "inline-block",
                width: 0,
                overflow: "hidden",
                content: "'\\a0'"
            },
            [`& + ${n}`]: {
                marginInlineStart: 0
            },
            [`&${n}-in-form-item`]: {
                'input[type="checkbox"]': {
                    width: 14,
                    height: 14
                }
            }
        }),
        [t]: Object.assign(Object.assign({}, fl(e)), {
            position: "relative",
            whiteSpace: "nowrap",
            lineHeight: 1,
            cursor: "pointer",
            borderRadius: e.borderRadiusSM,
            alignSelf: "center",
            [`${t}-input`]: {
                position: "absolute",
                inset: 0,
                zIndex: 1,
                cursor: "pointer",
                opacity: 0,
                margin: 0,
                [`&:focus-visible + ${t}-inner`]: Object.assign({}, HL(e))
            },
            [`${t}-inner`]: {
                boxSizing: "border-box",
                position: "relative",
                top: 0,
                insetInlineStart: 0,
                display: "block",
                width: e.checkboxSize,
                height: e.checkboxSize,
                direction: "ltr",
                backgroundColor: e.colorBgContainer,
                border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
                borderRadius: e.borderRadiusSM,
                borderCollapse: "separate",
                transition: `all ${e.motionDurationSlow}`,
                "&:after": {
                    boxSizing: "border-box",
                    position: "absolute",
                    top: "50%",
                    insetInlineStart: "21.5%",
                    display: "table",
                    width: e.checkboxSize / 14 * 5,
                    height: e.checkboxSize / 14 * 8,
                    border: `${e.lineWidthBold}px solid ${e.colorWhite}`,
                    borderTop: 0,
                    borderInlineStart: 0,
                    transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
                    opacity: 0,
                    content: '""',
                    transition: `all ${e.motionDurationFast} ${e.motionEaseInBack}, opacity ${e.motionDurationFast}`
                }
            },
            "& + span": {
                paddingInlineStart: e.paddingXS,
                paddingInlineEnd: e.paddingXS
            }
        })
    }, {
        [`
        ${n}:not(${n}-disabled),
        ${t}:not(${t}-disabled)
      `]: {
            [`&:hover ${t}-inner`]: {
                borderColor: e.colorPrimary
            }
        },
        [`${n}:not(${n}-disabled)`]: {
            [`&:hover ${t}-checked:not(${t}-disabled) ${t}-inner`]: {
                backgroundColor: e.colorPrimaryHover,
                borderColor: "transparent"
            },
            [`&:hover ${t}-checked:not(${t}-disabled):after`]: {
                borderColor: e.colorPrimaryHover
            }
        }
    }, {
        [`${t}-checked`]: {
            [`${t}-inner`]: {
                backgroundColor: e.colorPrimary,
                borderColor: e.colorPrimary,
                "&:after": {
                    opacity: 1,
                    transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
                    transition: `all ${e.motionDurationMid} ${e.motionEaseOutBack} ${e.motionDurationFast}`
                }
            }
        },
        [`
        ${n}-checked:not(${n}-disabled),
        ${t}-checked:not(${t}-disabled)
      `]: {
            [`&:hover ${t}-inner`]: {
                backgroundColor: e.colorPrimaryHover,
                borderColor: "transparent"
            }
        }
    }, {
        [t]: {
            "&-indeterminate": {
                [`${t}-inner`]: {
                    backgroundColor: e.colorBgContainer,
                    borderColor: e.colorBorder,
                    "&:after": {
                        top: "50%",
                        insetInlineStart: "50%",
                        width: e.fontSizeLG / 2,
                        height: e.fontSizeLG / 2,
                        backgroundColor: e.colorPrimary,
                        border: 0,
                        transform: "translate(-50%, -50%) scale(1)",
                        opacity: 1,
                        content: '""'
                    }
                }
            }
        }
    }, {
        [`${n}-disabled`]: {
            cursor: "not-allowed"
        },
        [`${t}-disabled`]: {
            [`&, ${t}-input`]: {
                cursor: "not-allowed",
                pointerEvents: "none"
            },
            [`${t}-inner`]: {
                background: e.colorBgContainerDisabled,
                borderColor: e.colorBorder,
                "&:after": {
                    borderColor: e.colorTextDisabled
                }
            },
            "&:after": {
                display: "none"
            },
            "& + span": {
                color: e.colorTextDisabled
            },
            [`&${t}-indeterminate ${t}-inner::after`]: {
                background: e.colorTextDisabled
            }
        }
    }]
}
;
function sN(e, t) {
    const n = qs(t, {
        checkboxCls: `.${e}`,
        checkboxSize: t.controlInteractiveSize
    });
    return [rN(n)]
}
const eC = Aa("Checkbox", (e,t)=>{
    let {prefixCls: n} = t;
    return [sN(n, e)]
}
)
  , oN = Ce.createContext(null)
  , tC = oN;
var aN = function(e, t) {
    var n = {};
    for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++)
            t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
    return n
};
const lN = (e,t)=>{
    var n;
    const {prefixCls: i, className: r, rootClassName: s, children: o, indeterminate: a=!1, style: l, onMouseEnter: c, onMouseLeave: u, skipGroup: h=!1, disabled: d} = e
      , m = aN(e, ["prefixCls", "className", "rootClassName", "children", "indeterminate", "style", "onMouseEnter", "onMouseLeave", "skipGroup", "disabled"])
      , {getPrefixCls: f, direction: x, checkbox: S} = M.useContext(Xn)
      , v = M.useContext(tC)
      , {isFormItemInput: p} = M.useContext(oD)
      , g = M.useContext(w2)
      , C = (n = (v == null ? void 0 : v.disabled) || d) !== null && n !== void 0 ? n : g
      , E = M.useRef(m.value);
    M.useEffect(()=>{
        v == null || v.registerValue(m.value)
    }
    , []),
    M.useEffect(()=>{
        if (!h)
            return m.value !== E.current && (v == null || v.cancelValue(E.current),
            v == null || v.registerValue(m.value),
            E.current = m.value),
            ()=>v == null ? void 0 : v.cancelValue(m.value)
    }
    , [m.value]);
    const O = f("checkbox", i)
      , [R,F] = eC(O)
      , P = Object.assign({}, m);
    v && !h && (P.onChange = function() {
        m.onChange && m.onChange.apply(m, arguments),
        v.toggleOption && v.toggleOption({
            label: o,
            value: m.value
        })
    }
    ,
    P.name = v.name,
    P.checked = v.value.includes(m.value));
    const _ = nt(`${O}-wrapper`, {
        [`${O}-rtl`]: x === "rtl",
        [`${O}-wrapper-checked`]: P.checked,
        [`${O}-wrapper-disabled`]: C,
        [`${O}-wrapper-in-form-item`]: p
    }, S == null ? void 0 : S.className, r, s, F)
      , T = nt({
        [`${O}-indeterminate`]: a
    }, M2, F)
      , L = a ? "mixed" : void 0;
    return R(M.createElement(JR, {
        component: "Checkbox",
        disabled: C
    }, M.createElement("label", {
        className: _,
        style: Object.assign(Object.assign({}, S == null ? void 0 : S.style), l),
        onMouseEnter: c,
        onMouseLeave: u
    }, M.createElement(iN, Object.assign({
        "aria-checked": L
    }, P, {
        prefixCls: O,
        className: T,
        disabled: C,
        ref: t
    })), o !== void 0 && M.createElement("span", null, o))))
}
  , cN = M.forwardRef(lN)
  , nC = cN;
var uN = function(e, t) {
    var n = {};
    for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++)
            t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
    return n
};
const hN = (e,t)=>{
    const {defaultValue: n, children: i, options: r=[], prefixCls: s, className: o, rootClassName: a, style: l, onChange: c} = e
      , u = uN(e, ["defaultValue", "children", "options", "prefixCls", "className", "rootClassName", "style", "onChange"])
      , {getPrefixCls: h, direction: d} = M.useContext(Xn)
      , [m,f] = M.useState(u.value || n || [])
      , [x,S] = M.useState([]);
    M.useEffect(()=>{
        "value"in u && f(u.value || [])
    }
    , [u.value]);
    const v = M.useMemo(()=>r.map(I=>typeof I == "string" || typeof I == "number" ? {
        label: I,
        value: I
    } : I), [r])
      , p = I=>{
        S(k=>k.filter(w=>w !== I))
    }
      , g = I=>{
        S(k=>[].concat(Re(k), [I]))
    }
      , C = I=>{
        const k = m.indexOf(I.value)
          , w = Re(m);
        k === -1 ? w.push(I.value) : w.splice(k, 1),
        "value"in u || f(w),
        c == null || c(w.filter(b=>x.includes(b)).sort((b,A)=>{
            const j = v.findIndex(W=>W.value === b)
              , B = v.findIndex(W=>W.value === A);
            return j - B
        }
        ))
    }
      , E = h("checkbox", s)
      , O = `${E}-group`
      , [R,F] = eC(E)
      , P = Mj(u, ["value", "disabled"])
      , _ = r.length ? v.map(I=>M.createElement(nC, {
        prefixCls: E,
        key: I.value.toString(),
        disabled: "disabled"in I ? I.disabled : u.disabled,
        value: I.value,
        checked: m.includes(I.value),
        onChange: I.onChange,
        className: `${O}-item`,
        style: I.style,
        title: I.title,
        id: I.id,
        required: I.required
    }, I.label)) : i
      , T = {
        toggleOption: C,
        value: m,
        disabled: u.disabled,
        name: u.name,
        registerValue: g,
        cancelValue: p
    }
      , L = nt(O, {
        [`${O}-rtl`]: d === "rtl"
    }, o, a, F);
    return R(M.createElement("div", Object.assign({
        className: L,
        style: l
    }, P, {
        ref: t
    }), M.createElement(tC.Provider, {
        value: T
    }, _)))
}
  , dN = M.forwardRef(hN)
  , fN = M.memo(dN)
  , P2 = nC;
P2.Group = fN;
P2.__ANT_CHECKBOX = !0;
const pN = P2
  , gN = M.createContext({})
  , iC = gN
  , mN = e=>{
    const {componentCls: t} = e;
    return {
        [t]: {
            display: "flex",
            flexFlow: "row wrap",
            minWidth: 0,
            "&::before, &::after": {
                display: "flex"
            },
            "&-no-wrap": {
                flexWrap: "nowrap"
            },
            "&-start": {
                justifyContent: "flex-start"
            },
            "&-center": {
                justifyContent: "center"
            },
            "&-end": {
                justifyContent: "flex-end"
            },
            "&-space-between": {
                justifyContent: "space-between"
            },
            "&-space-around": {
                justifyContent: "space-around"
            },
            "&-space-evenly": {
                justifyContent: "space-evenly"
            },
            "&-top": {
                alignItems: "flex-start"
            },
            "&-middle": {
                alignItems: "center"
            },
            "&-bottom": {
                alignItems: "flex-end"
            }
        }
    }
}
  , vN = e=>{
    const {componentCls: t} = e;
    return {
        [t]: {
            position: "relative",
            maxWidth: "100%",
            minHeight: 1
        }
    }
}
  , yN = (e,t)=>{
    const {componentCls: n, gridColumns: i} = e
      , r = {};
    for (let s = i; s >= 0; s--)
        s === 0 ? (r[`${n}${t}-${s}`] = {
            display: "none"
        },
        r[`${n}-push-${s}`] = {
            insetInlineStart: "auto"
        },
        r[`${n}-pull-${s}`] = {
            insetInlineEnd: "auto"
        },
        r[`${n}${t}-push-${s}`] = {
            insetInlineStart: "auto"
        },
        r[`${n}${t}-pull-${s}`] = {
            insetInlineEnd: "auto"
        },
        r[`${n}${t}-offset-${s}`] = {
            marginInlineStart: 0
        },
        r[`${n}${t}-order-${s}`] = {
            order: 0
        }) : (r[`${n}${t}-${s}`] = [{
            "--ant-display": "block",
            display: "block"
        }, {
            display: "var(--ant-display)",
            flex: `0 0 ${s / i * 100}%`,
            maxWidth: `${s / i * 100}%`
        }],
        r[`${n}${t}-push-${s}`] = {
            insetInlineStart: `${s / i * 100}%`
        },
        r[`${n}${t}-pull-${s}`] = {
            insetInlineEnd: `${s / i * 100}%`
        },
        r[`${n}${t}-offset-${s}`] = {
            marginInlineStart: `${s / i * 100}%`
        },
        r[`${n}${t}-order-${s}`] = {
            order: s
        });
    return r
}
  , Wp = (e,t)=>yN(e, t)
  , xN = (e,t,n)=>({
    [`@media (min-width: ${t}px)`]: Object.assign({}, Wp(e, n))
})
  , bN = Aa("Grid", e=>[mN(e)])
  , wN = Aa("Grid", e=>{
    const t = qs(e, {
        gridColumns: 24
    })
      , n = {
        "-sm": t.screenSMMin,
        "-md": t.screenMDMin,
        "-lg": t.screenLGMin,
        "-xl": t.screenXLMin,
        "-xxl": t.screenXXLMin
    };
    return [vN(t), Wp(t, ""), Wp(t, "-xs"), Object.keys(n).map(i=>xN(t, n[i], i)).reduce((i,r)=>Object.assign(Object.assign({}, i), r), {})]
}
);
var SN = function(e, t) {
    var n = {};
    for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++)
            t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
    return n
};
function CN(e) {
    return typeof e == "number" ? `${e} ${e} auto` : /^\d+(\.\d+)?(px|em|rem|%)$/.test(e) ? `0 0 ${e}` : e
}
const kN = ["xs", "sm", "md", "lg", "xl", "xxl"]
  , AN = M.forwardRef((e,t)=>{
    const {getPrefixCls: n, direction: i} = M.useContext(Xn)
      , {gutter: r, wrap: s} = M.useContext(iC)
      , {prefixCls: o, span: a, order: l, offset: c, push: u, pull: h, className: d, children: m, flex: f, style: x} = e
      , S = SN(e, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"])
      , v = n("col", o)
      , [p,g] = wN(v);
    let C = {};
    kN.forEach(R=>{
        let F = {};
        const P = e[R];
        typeof P == "number" ? F.span = P : typeof P == "object" && (F = P || {}),
        delete S[R],
        C = Object.assign(Object.assign({}, C), {
            [`${v}-${R}-${F.span}`]: F.span !== void 0,
            [`${v}-${R}-order-${F.order}`]: F.order || F.order === 0,
            [`${v}-${R}-offset-${F.offset}`]: F.offset || F.offset === 0,
            [`${v}-${R}-push-${F.push}`]: F.push || F.push === 0,
            [`${v}-${R}-pull-${F.pull}`]: F.pull || F.pull === 0,
            [`${v}-${R}-flex-${F.flex}`]: F.flex || F.flex === "auto",
            [`${v}-rtl`]: i === "rtl"
        })
    }
    );
    const E = nt(v, {
        [`${v}-${a}`]: a !== void 0,
        [`${v}-order-${l}`]: l,
        [`${v}-offset-${c}`]: c,
        [`${v}-push-${u}`]: u,
        [`${v}-pull-${h}`]: h
    }, d, C, g)
      , O = {};
    if (r && r[0] > 0) {
        const R = r[0] / 2;
        O.paddingLeft = R,
        O.paddingRight = R
    }
    return f && (O.flex = CN(f),
    s === !1 && !O.minWidth && (O.minWidth = 0)),
    p(M.createElement("div", Object.assign({}, S, {
        style: Object.assign(Object.assign({}, O), x),
        className: E,
        ref: t
    }), m))
}
)
  , Ot = AN;
var MN = function(e, t) {
    var n = {};
    for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++)
            t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
    return n
};
function cx(e, t) {
    const [n,i] = M.useState(typeof e == "string" ? e : "")
      , r = ()=>{
        if (typeof e == "string" && i(e),
        typeof e == "object")
            for (let s = 0; s < $l.length; s++) {
                const o = $l[s];
                if (!t[o])
                    continue;
                const a = e[o];
                if (a !== void 0) {
                    i(a);
                    return
                }
            }
    }
    ;
    return M.useEffect(()=>{
        r()
    }
    , [JSON.stringify(e), t]),
    n
}
const EN = M.forwardRef((e,t)=>{
    const {prefixCls: n, justify: i, align: r, className: s, style: o, children: a, gutter: l=0, wrap: c} = e
      , u = MN(e, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"])
      , {getPrefixCls: h, direction: d} = M.useContext(Xn)
      , [m,f] = M.useState({
        xs: !0,
        sm: !0,
        md: !0,
        lg: !0,
        xl: !0,
        xxl: !0
    })
      , [x,S] = M.useState({
        xs: !1,
        sm: !1,
        md: !1,
        lg: !1,
        xl: !1,
        xxl: !1
    })
      , v = cx(r, x)
      , p = cx(i, x)
      , g = M.useRef(l)
      , C = BD();
    M.useEffect(()=>{
        const b = C.subscribe(A=>{
            S(A);
            const j = g.current || 0;
            (!Array.isArray(j) && typeof j == "object" || Array.isArray(j) && (typeof j[0] == "object" || typeof j[1] == "object")) && f(A)
        }
        );
        return ()=>C.unsubscribe(b)
    }
    , []);
    const E = ()=>{
        const b = [void 0, void 0];
        return (Array.isArray(l) ? l : [l, void 0]).forEach((j,B)=>{
            if (typeof j == "object")
                for (let W = 0; W < $l.length; W++) {
                    const N = $l[W];
                    if (m[N] && j[N] !== void 0) {
                        b[B] = j[N];
                        break
                    }
                }
            else
                b[B] = j
        }
        ),
        b
    }
      , O = h("row", n)
      , [R,F] = bN(O)
      , P = E()
      , _ = nt(O, {
        [`${O}-no-wrap`]: c === !1,
        [`${O}-${p}`]: p,
        [`${O}-${v}`]: v,
        [`${O}-rtl`]: d === "rtl"
    }, s, F)
      , T = {}
      , L = P[0] != null && P[0] > 0 ? P[0] / -2 : void 0;
    L && (T.marginLeft = L,
    T.marginRight = L),
    [,T.rowGap] = P;
    const [I,k] = P
      , w = M.useMemo(()=>({
        gutter: [I, k],
        wrap: c
    }), [I, k, c]);
    return R(M.createElement(iC.Provider, {
        value: w
    }, M.createElement("div", Object.assign({}, u, {
        className: _,
        style: Object.assign(Object.assign({}, T), o),
        ref: t
    }), a)))
}
)
  , Hr = EN;
var ro = M.createContext({
    min: 0,
    max: 0,
    direction: "ltr",
    step: 1,
    includedStart: 0,
    includedEnd: 0,
    tabIndex: 0,
    keyboard: !0,
    styles: {},
    classNames: {}
});
function Hp(e, t, n) {
    return (e - t) / (n - t)
}
function T2(e, t, n, i) {
    var r = Hp(t, n, i)
      , s = {};
    switch (e) {
    case "rtl":
        s.right = "".concat(r * 100, "%"),
        s.transform = "translateX(50%)";
        break;
    case "btt":
        s.bottom = "".concat(r * 100, "%"),
        s.transform = "translateY(50%)";
        break;
    case "ttb":
        s.top = "".concat(r * 100, "%"),
        s.transform = "translateY(-50%)";
        break;
    default:
        s.left = "".concat(r * 100, "%"),
        s.transform = "translateX(-50%)";
        break
    }
    return s
}
function Vo(e, t) {
    return Array.isArray(e) ? e[t] : e
}
var PN = ["prefixCls", "value", "valueIndex", "onStartMove", "style", "render", "dragging", "onOffsetChange"]
  , TN = M.forwardRef(function(e, t) {
    var n, i, r = e.prefixCls, s = e.value, o = e.valueIndex, a = e.onStartMove, l = e.style, c = e.render, u = e.dragging, h = e.onOffsetChange, d = ki(e, PN), m = M.useContext(ro), f = m.min, x = m.max, S = m.direction, v = m.disabled, p = m.keyboard, g = m.range, C = m.tabIndex, E = m.ariaLabelForHandle, O = m.ariaLabelledByForHandle, R = m.ariaValueTextFormatterForHandle, F = m.styles, P = m.classNames, _ = "".concat(r, "-handle"), T = function(b) {
        v || a(b, o)
    }, L = function(b) {
        if (!v && p) {
            var A = null;
            switch (b.which || b.keyCode) {
            case Le.LEFT:
                A = S === "ltr" || S === "btt" ? -1 : 1;
                break;
            case Le.RIGHT:
                A = S === "ltr" || S === "btt" ? 1 : -1;
                break;
            case Le.UP:
                A = S !== "ttb" ? 1 : -1;
                break;
            case Le.DOWN:
                A = S !== "ttb" ? -1 : 1;
                break;
            case Le.HOME:
                A = "min";
                break;
            case Le.END:
                A = "max";
                break;
            case Le.PAGE_UP:
                A = 2;
                break;
            case Le.PAGE_DOWN:
                A = -2;
                break
            }
            A !== null && (b.preventDefault(),
            h(A, o))
        }
    }, I = T2(S, s, f, x), k = M.createElement("div", Wn({
        ref: t,
        className: nt(_, (n = {},
        me(n, "".concat(_, "-").concat(o + 1), g),
        me(n, "".concat(_, "-dragging"), u),
        n), P.handle),
        style: be(be(be({}, I), l), F.handle),
        onMouseDown: T,
        onTouchStart: T,
        onKeyDown: L,
        tabIndex: v ? null : Vo(C, o),
        role: "slider",
        "aria-valuemin": f,
        "aria-valuemax": x,
        "aria-valuenow": s,
        "aria-disabled": v,
        "aria-label": Vo(E, o),
        "aria-labelledby": Vo(O, o),
        "aria-valuetext": (i = Vo(R, o)) === null || i === void 0 ? void 0 : i(s),
        "aria-orientation": S === "ltr" || S === "rtl" ? "horizontal" : "vertical"
    }, d));
    return c && (k = c(k, {
        index: o,
        prefixCls: r,
        value: s,
        dragging: u
    })),
    k
})
  , jN = ["prefixCls", "style", "onStartMove", "onOffsetChange", "values", "handleRender", "draggingIndex"]
  , ON = M.forwardRef(function(e, t) {
    var n = e.prefixCls
      , i = e.style
      , r = e.onStartMove
      , s = e.onOffsetChange
      , o = e.values
      , a = e.handleRender
      , l = e.draggingIndex
      , c = ki(e, jN)
      , u = M.useRef({});
    return M.useImperativeHandle(t, function() {
        return {
            focus: function(d) {
                var m;
                (m = u.current[d]) === null || m === void 0 || m.focus()
            }
        }
    }),
    M.createElement(M.Fragment, null, o.map(function(h, d) {
        return M.createElement(TN, Wn({
            ref: function(f) {
                f ? u.current[d] = f : delete u.current[d]
            },
            dragging: l === d,
            prefixCls: n,
            style: Vo(i, d),
            key: d,
            value: h,
            valueIndex: d,
            onStartMove: r,
            onOffsetChange: s,
            render: a
        }, c))
    }))
});
function ux(e) {
    var t = "touches"in e ? e.touches[0] : e;
    return {
        pageX: t.pageX,
        pageY: t.pageY
    }
}
function LN(e, t, n, i, r, s, o, a, l) {
    var c = M.useState(null)
      , u = Me(c, 2)
      , h = u[0]
      , d = u[1]
      , m = M.useState(-1)
      , f = Me(m, 2)
      , x = f[0]
      , S = f[1]
      , v = M.useState(n)
      , p = Me(v, 2)
      , g = p[0]
      , C = p[1]
      , E = M.useState(n)
      , O = Me(E, 2)
      , R = O[0]
      , F = O[1]
      , P = M.useRef(null)
      , _ = M.useRef(null);
    M.useEffect(function() {
        x === -1 && C(n)
    }, [n, x]),
    M.useEffect(function() {
        return function() {
            document.removeEventListener("mousemove", P.current),
            document.removeEventListener("mouseup", _.current),
            document.removeEventListener("touchmove", P.current),
            document.removeEventListener("touchend", _.current)
        }
    }, []);
    var T = function(A, j) {
        g.some(function(B, W) {
            return B !== A[W]
        }) && (j !== void 0 && d(j),
        C(A),
        o(A))
    }
      , L = function(A, j) {
        if (A === -1) {
            var B = R[0]
              , W = R[R.length - 1]
              , N = i - B
              , H = r - W
              , X = j * (r - i);
            X = Math.max(X, N),
            X = Math.min(X, H);
            var ie = s(B + X);
            X = ie - B;
            var K = R.map(function(ee) {
                return ee + X
            });
            T(K)
        } else {
            var D = (r - i) * j
              , V = Re(g);
            V[A] = R[A];
            var G = l(V, D, A, "dist");
            T(G.values, G.value)
        }
    }
      , I = M.useRef(L);
    I.current = L;
    var k = function(A, j, B) {
        A.stopPropagation();
        var W = B || n
          , N = W[j];
        S(j),
        d(N),
        F(W);
        var H = ux(A)
          , X = H.pageX
          , ie = H.pageY
          , K = function(G) {
            G.preventDefault();
            var ee = ux(G), J = ee.pageX, te = ee.pageY, z = J - X, Y = te - ie, U = e.current.getBoundingClientRect(), Z = U.width, $ = U.height, ne;
            switch (t) {
            case "btt":
                ne = -Y / $;
                break;
            case "ttb":
                ne = Y / $;
                break;
            case "rtl":
                ne = -z / Z;
                break;
            default:
                ne = z / Z
            }
            I.current(j, ne)
        }
          , D = function V(G) {
            G.preventDefault(),
            document.removeEventListener("mouseup", V),
            document.removeEventListener("mousemove", K),
            document.removeEventListener("touchend", V),
            document.removeEventListener("touchmove", K),
            P.current = null,
            _.current = null,
            S(-1),
            a()
        };
        document.addEventListener("mouseup", D),
        document.addEventListener("mousemove", K),
        document.addEventListener("touchend", D),
        document.addEventListener("touchmove", K),
        P.current = K,
        _.current = D
    }
      , w = M.useMemo(function() {
        var b = Re(n).sort(function(j, B) {
            return j - B
        })
          , A = Re(g).sort(function(j, B) {
            return j - B
        });
        return b.every(function(j, B) {
            return j === A[B]
        }) ? g : n
    }, [n, g]);
    return [x, h, w, k]
}
function RN(e, t, n, i, r, s) {
    var o = M.useCallback(function(m) {
        var f = isFinite(m) ? m : e;
        return f = Math.min(t, m),
        f = Math.max(e, f),
        f
    }, [e, t])
      , a = M.useCallback(function(m) {
        if (n !== null) {
            var f = e + Math.round((o(m) - e) / n) * n
              , x = function(g) {
                return (String(g).split(".")[1] || "").length
            }
              , S = Math.max(x(n), x(t), x(e))
              , v = Number(f.toFixed(S));
            return e <= v && v <= t ? v : null
        }
        return null
    }, [n, e, t, o])
      , l = M.useCallback(function(m) {
        var f = o(m)
          , x = i.map(function(p) {
            return p.value
        });
        n !== null && x.push(a(m)),
        x.push(e, t);
        var S = x[0]
          , v = t - e;
        return x.forEach(function(p) {
            var g = Math.abs(f - p);
            g <= v && (S = p,
            v = g)
        }),
        S
    }, [e, t, i, n, o, a])
      , c = function m(f, x, S) {
        var v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "unit";
        if (typeof x == "number") {
            var p, g = f[S], C = g + x, E = [];
            i.forEach(function(_) {
                E.push(_.value)
            }),
            E.push(e, t),
            E.push(a(g));
            var O = x > 0 ? 1 : -1;
            v === "unit" ? E.push(a(g + O * n)) : E.push(a(C)),
            E = E.filter(function(_) {
                return _ !== null
            }).filter(function(_) {
                return x < 0 ? _ <= g : _ >= g
            }),
            v === "unit" && (E = E.filter(function(_) {
                return _ !== g
            }));
            var R = v === "unit" ? g : C;
            p = E[0];
            var F = Math.abs(p - R);
            if (E.forEach(function(_) {
                var T = Math.abs(_ - R);
                T < F && (p = _,
                F = T)
            }),
            p === void 0)
                return x < 0 ? e : t;
            if (v === "dist")
                return p;
            if (Math.abs(x) > 1) {
                var P = Re(f);
                return P[S] = p,
                m(P, x - O, S, v)
            }
            return p
        } else {
            if (x === "min")
                return e;
            if (x === "max")
                return t
        }
    }
      , u = function(f, x, S) {
        var v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "unit"
          , p = f[S]
          , g = c(f, x, S, v);
        return {
            value: g,
            changed: g !== p
        }
    }
      , h = function(f) {
        return s === null && f === 0 || typeof s == "number" && f < s
    }
      , d = function(f, x, S) {
        var v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "unit"
          , p = f.map(l)
          , g = p[S]
          , C = c(p, x, S, v);
        if (p[S] = C,
        r === !1) {
            var E = s || 0;
            S > 0 && p[S - 1] !== g && (p[S] = Math.max(p[S], p[S - 1] + E)),
            S < p.length - 1 && p[S + 1] !== g && (p[S] = Math.min(p[S], p[S + 1] - E))
        } else if (typeof s == "number" || s === null) {
            for (var O = S + 1; O < p.length; O += 1)
                for (var R = !0; h(p[O] - p[O - 1]) && R; ) {
                    var F = u(p, 1, O);
                    p[O] = F.value,
                    R = F.changed
                }
            for (var P = S; P > 0; P -= 1)
                for (var _ = !0; h(p[P] - p[P - 1]) && _; ) {
                    var T = u(p, -1, P - 1);
                    p[P - 1] = T.value,
                    _ = T.changed
                }
            for (var L = p.length - 1; L > 0; L -= 1)
                for (var I = !0; h(p[L] - p[L - 1]) && I; ) {
                    var k = u(p, -1, L - 1);
                    p[L - 1] = k.value,
                    I = k.changed
                }
            for (var w = 0; w < p.length - 1; w += 1)
                for (var b = !0; h(p[w + 1] - p[w]) && b; ) {
                    var A = u(p, 1, w + 1);
                    p[w + 1] = A.value,
                    b = A.changed
                }
        }
        return {
            value: p[S],
            values: p
        }
    };
    return [l, d]
}
function _N(e) {
    var t = e.prefixCls
      , n = e.style
      , i = e.children
      , r = e.value
      , s = e.onClick
      , o = M.useContext(ro)
      , a = o.min
      , l = o.max
      , c = o.direction
      , u = o.includedStart
      , h = o.includedEnd
      , d = o.included
      , m = "".concat(t, "-text")
      , f = T2(c, r, a, l);
    return M.createElement("span", {
        className: nt(m, me({}, "".concat(m, "-active"), d && u <= r && r <= h)),
        style: be(be({}, f), n),
        onMouseDown: function(S) {
            S.stopPropagation()
        },
        onClick: function() {
            s(r)
        }
    }, i)
}
function DN(e) {
    var t = e.prefixCls
      , n = e.marks
      , i = e.onClick
      , r = "".concat(t, "-mark");
    return n.length ? M.createElement("div", {
        className: r
    }, n.map(function(s) {
        var o = s.value
          , a = s.style
          , l = s.label;
        return M.createElement(_N, {
            key: o,
            prefixCls: r,
            style: a,
            value: o,
            onClick: i
        }, l)
    })) : null
}
function NN(e) {
    var t = e.prefixCls
      , n = e.value
      , i = e.style
      , r = e.activeStyle
      , s = M.useContext(ro)
      , o = s.min
      , a = s.max
      , l = s.direction
      , c = s.included
      , u = s.includedStart
      , h = s.includedEnd
      , d = "".concat(t, "-dot")
      , m = c && u <= n && n <= h
      , f = be(be({}, T2(l, n, o, a)), typeof i == "function" ? i(n) : i);
    return m && (f = be(be({}, f), typeof r == "function" ? r(n) : r)),
    M.createElement("span", {
        className: nt(d, me({}, "".concat(d, "-active"), m)),
        style: f
    })
}
function FN(e) {
    var t = e.prefixCls
      , n = e.marks
      , i = e.dots
      , r = e.style
      , s = e.activeStyle
      , o = M.useContext(ro)
      , a = o.min
      , l = o.max
      , c = o.step
      , u = M.useMemo(function() {
        var h = new Set;
        if (n.forEach(function(m) {
            h.add(m.value)
        }),
        i && c !== null)
            for (var d = a; d <= l; )
                h.add(d),
                d += c;
        return Array.from(h)
    }, [a, l, c, i, n]);
    return M.createElement("div", {
        className: "".concat(t, "-step")
    }, u.map(function(h) {
        return M.createElement(NN, {
            prefixCls: t,
            key: h,
            value: h,
            style: r,
            activeStyle: s
        })
    }))
}
function hx(e) {
    var t, n = e.prefixCls, i = e.style, r = e.start, s = e.end, o = e.index, a = e.onStartMove, l = e.replaceCls, c = M.useContext(ro), u = c.direction, h = c.min, d = c.max, m = c.disabled, f = c.range, x = c.classNames, S = "".concat(n, "-track"), v = Hp(r, h, d), p = Hp(s, h, d), g = function(R) {
        !m && a && a(R, -1)
    }, C = {};
    switch (u) {
    case "rtl":
        C.right = "".concat(v * 100, "%"),
        C.width = "".concat(p * 100 - v * 100, "%");
        break;
    case "btt":
        C.bottom = "".concat(v * 100, "%"),
        C.height = "".concat(p * 100 - v * 100, "%");
        break;
    case "ttb":
        C.top = "".concat(v * 100, "%"),
        C.height = "".concat(p * 100 - v * 100, "%");
        break;
    default:
        C.left = "".concat(v * 100, "%"),
        C.width = "".concat(p * 100 - v * 100, "%")
    }
    var E = l || nt(S, (t = {},
    me(t, "".concat(S, "-").concat(o + 1), o !== null && f),
    me(t, "".concat(n, "-track-draggable"), a),
    t), x.track);
    return M.createElement("div", {
        className: E,
        style: be(be({}, C), i),
        onMouseDown: g,
        onTouchStart: g
    })
}
function IN(e) {
    var t = e.prefixCls
      , n = e.style
      , i = e.values
      , r = e.startPoint
      , s = e.onStartMove
      , o = M.useContext(ro)
      , a = o.included
      , l = o.range
      , c = o.min
      , u = o.styles
      , h = o.classNames
      , d = M.useMemo(function() {
        if (!l) {
            if (i.length === 0)
                return [];
            var f = r ?? c
              , x = i[0];
            return [{
                start: Math.min(f, x),
                end: Math.max(f, x)
            }]
        }
        for (var S = [], v = 0; v < i.length - 1; v += 1)
            S.push({
                start: i[v],
                end: i[v + 1]
            });
        return S
    }, [i, l, r, c])
      , m = null;
    return (h.tracks || u.tracks) && (m = M.createElement(hx, {
        index: null,
        prefixCls: t,
        start: d[0].start,
        end: d[d.length - 1].end,
        replaceCls: nt(h.tracks, "".concat(t, "-tracks")),
        style: u.tracks
    })),
    a ? M.createElement(M.Fragment, null, m, d.map(function(f, x) {
        var S = f.start
          , v = f.end;
        return M.createElement(hx, {
            index: x,
            prefixCls: t,
            style: be(be({}, Vo(n, x)), u.track),
            start: S,
            end: v,
            key: x,
            onStartMove: s
        })
    })) : null
}
var BN = M.forwardRef(function(e, t) {
    var n, i = e.prefixCls, r = i === void 0 ? "rc-slider" : i, s = e.className, o = e.style, a = e.classNames, l = e.styles, c = e.disabled, u = c === void 0 ? !1 : c, h = e.keyboard, d = h === void 0 ? !0 : h, m = e.autoFocus, f = e.onFocus, x = e.onBlur, S = e.min, v = S === void 0 ? 0 : S, p = e.max, g = p === void 0 ? 100 : p, C = e.step, E = C === void 0 ? 1 : C, O = e.value, R = e.defaultValue, F = e.range, P = e.count, _ = e.onChange, T = e.onBeforeChange, L = e.onAfterChange, I = e.allowCross, k = I === void 0 ? !0 : I, w = e.pushable, b = w === void 0 ? !1 : w, A = e.draggableTrack, j = e.reverse, B = e.vertical, W = e.included, N = W === void 0 ? !0 : W, H = e.startPoint, X = e.trackStyle, ie = e.handleStyle, K = e.railStyle, D = e.dotStyle, V = e.activeDotStyle, G = e.marks, ee = e.dots, J = e.handleRender, te = e.tabIndex, z = te === void 0 ? 0 : te, Y = e.ariaLabelForHandle, U = e.ariaLabelledByForHandle, Z = e.ariaValueTextFormatterForHandle, $ = M.useRef(), ne = M.useRef(), oe = M.useMemo(function() {
        return B ? j ? "ttb" : "btt" : j ? "rtl" : "ltr"
    }, [j, B]), se = M.useMemo(function() {
        return isFinite(v) ? v : 0
    }, [v]), le = M.useMemo(function() {
        return isFinite(g) ? g : 100
    }, [g]), he = M.useMemo(function() {
        return E !== null && E <= 0 ? 1 : E
    }, [E]), Q = M.useMemo(function() {
        return typeof b == "boolean" ? b ? he : !1 : b >= 0 ? b : !1
    }, [b, he]), q = M.useMemo(function() {
        var qe = Object.keys(G || {});
        return qe.map(function(We) {
            var Ie = G[We]
              , ut = {
                value: Number(We)
            };
            return Ie && it(Ie) === "object" && !M.isValidElement(Ie) && ("label"in Ie || "style"in Ie) ? (ut.style = Ie.style,
            ut.label = Ie.label) : ut.label = Ie,
            ut
        }).filter(function(We) {
            var Ie = We.label;
            return Ie || typeof Ie == "number"
        }).sort(function(We, Ie) {
            return We.value - Ie.value
        })
    }, [G]), ae = RN(se, le, he, q, k, Q), re = Me(ae, 2), ce = re[0], ue = re[1], fe = C2(R, {
        value: O
    }), de = Me(fe, 2), ge = de[0], ye = de[1], pe = M.useMemo(function() {
        var qe = ge == null ? [] : Array.isArray(ge) ? ge : [ge]
          , We = Me(qe, 1)
          , Ie = We[0]
          , ut = Ie === void 0 ? se : Ie
          , ht = ge === null ? [] : [ut];
        if (F) {
            if (ht = Re(qe),
            P || ge === void 0) {
                var It = P >= 0 ? P + 1 : 2;
                for (ht = ht.slice(0, It); ht.length < It; ) {
                    var hn;
                    ht.push((hn = ht[ht.length - 1]) !== null && hn !== void 0 ? hn : se)
                }
            }
            ht.sort(function(ui, ot) {
                return ui - ot
            })
        }
        return ht.forEach(function(ui, ot) {
            ht[ot] = ce(ui)
        }),
        ht
    }, [ge, F, se, P, ce]), xe = M.useRef(pe);
    xe.current = pe;
    var ke = function(We) {
        return F ? We : We[0]
    }
      , Ee = function(We) {
        var Ie = Re(We).sort(function(ut, ht) {
            return ut - ht
        });
        _ && !m2(Ie, xe.current, !0) && _(ke(Ie)),
        ye(Ie)
    }
      , we = function() {
        L == null || L(ke(xe.current))
    }
      , ve = LN(ne, oe, pe, se, le, ce, Ee, we, ue)
      , _e = Me(ve, 4)
      , Oe = _e[0]
      , ze = _e[1]
      , Qe = _e[2]
      , Fe = _e[3]
      , rt = function(We, Ie) {
        if (!u) {
            var ut = 0
              , ht = le - se;
            pe.forEach(function(hn, ui) {
                var ot = Math.abs(We - hn);
                ot <= ht && (ht = ot,
                ut = ui)
            });
            var It = Re(pe);
            It[ut] = We,
            F && !pe.length && P === void 0 && It.push(We),
            T == null || T(ke(It)),
            Ee(It),
            L == null || L(ke(It)),
            Ie && Fe(Ie, ut, It)
        }
    }
      , Ne = function(We) {
        We.preventDefault();
        var Ie = ne.current.getBoundingClientRect(), ut = Ie.width, ht = Ie.height, It = Ie.left, hn = Ie.top, ui = Ie.bottom, ot = Ie.right, cs = We.clientX, lo = We.clientY, Mi;
        switch (oe) {
        case "btt":
            Mi = (ui - lo) / ht;
            break;
        case "ttb":
            Mi = (lo - hn) / ht;
            break;
        case "rtl":
            Mi = (ot - cs) / ut;
            break;
        default:
            Mi = (cs - It) / ut
        }
        var co = se + Mi * (le - se);
        rt(ce(co), We)
    }
      , Te = M.useState(null)
      , Ve = Me(Te, 2)
      , Ke = Ve[0]
      , st = Ve[1]
      , Qt = function(We, Ie) {
        if (!u) {
            var ut = ue(pe, We, Ie);
            T == null || T(ke(pe)),
            Ee(ut.values),
            L == null || L(ke(ut.values)),
            st(ut.value)
        }
    };
    M.useEffect(function() {
        if (Ke !== null) {
            var qe = pe.indexOf(Ke);
            qe >= 0 && $.current.focus(qe)
        }
        st(null)
    }, [Ke]);
    var un = M.useMemo(function() {
        return A && he === null ? !1 : A
    }, [A, he])
      , bn = function(We, Ie) {
        Fe(We, Ie),
        T == null || T(ke(xe.current))
    }
      , ct = Oe !== -1;
    M.useEffect(function() {
        if (!ct) {
            var qe = pe.lastIndexOf(ze);
            $.current.focus(qe)
        }
    }, [ct]);
    var Yn = M.useMemo(function() {
        return Re(Qe).sort(function(qe, We) {
            return qe - We
        })
    }, [Qe])
      , pr = M.useMemo(function() {
        return F ? [Yn[0], Yn[Yn.length - 1]] : [se, Yn[0]]
    }, [Yn, F, se])
      , ci = Me(pr, 2)
      , Gt = ci[0]
      , ls = ci[1];
    M.useImperativeHandle(t, function() {
        return {
            focus: function() {
                $.current.focus(0)
            },
            blur: function() {
                var We = document
                  , Ie = We.activeElement;
                ne.current.contains(Ie) && (Ie == null || Ie.blur())
            }
        }
    }),
    M.useEffect(function() {
        m && $.current.focus(0)
    }, []);
    var Ai = M.useMemo(function() {
        return {
            min: se,
            max: le,
            direction: oe,
            disabled: u,
            keyboard: d,
            step: he,
            included: N,
            includedStart: Gt,
            includedEnd: ls,
            range: F,
            tabIndex: z,
            ariaLabelForHandle: Y,
            ariaLabelledByForHandle: U,
            ariaValueTextFormatterForHandle: Z,
            styles: l || {},
            classNames: a || {}
        }
    }, [se, le, oe, u, d, he, N, Gt, ls, F, z, Y, U, Z, l, a]);
    return M.createElement(ro.Provider, {
        value: Ai
    }, M.createElement("div", {
        ref: ne,
        className: nt(r, s, (n = {},
        me(n, "".concat(r, "-disabled"), u),
        me(n, "".concat(r, "-vertical"), B),
        me(n, "".concat(r, "-horizontal"), !B),
        me(n, "".concat(r, "-with-marks"), q.length),
        n)),
        style: o,
        onMouseDown: Ne
    }, M.createElement("div", {
        className: nt("".concat(r, "-rail"), a == null ? void 0 : a.rail),
        style: be(be({}, K), l == null ? void 0 : l.rail)
    }), M.createElement(IN, {
        prefixCls: r,
        style: X,
        values: Yn,
        startPoint: H,
        onStartMove: un ? bn : null
    }), M.createElement(FN, {
        prefixCls: r,
        marks: q,
        dots: ee,
        style: D,
        activeStyle: V
    }), M.createElement(ON, {
        ref: $,
        prefixCls: r,
        style: ie,
        values: Qe,
        draggingIndex: Oe,
        onStartMove: bn,
        onOffsetChange: Qt,
        onFocus: f,
        onBlur: x,
        handleRender: J
    }), M.createElement(DN, {
        prefixCls: r,
        marks: q,
        onClick: rt
    })))
});
const zN = M.forwardRef((e,t)=>{
    const {open: n} = e
      , i = M.useRef(null)
      , r = M.useRef(null);
    function s() {
        Ci.cancel(r.current),
        r.current = null
    }
    function o() {
        r.current = Ci(()=>{
            var a;
            (a = i.current) === null || a === void 0 || a.forceAlign(),
            r.current = null
        }
        )
    }
    return M.useEffect(()=>(n ? o() : s(),
    s), [n, e.title]),
    M.createElement(tN, Object.assign({
        ref: Vd(i, t)
    }, e))
}
)
  , VN = zN
  , WN = e=>{
    const {componentCls: t, antCls: n, controlSize: i, dotSize: r, marginFull: s, marginPart: o, colorFillContentHover: a} = e;
    return {
        [t]: Object.assign(Object.assign({}, fl(e)), {
            position: "relative",
            height: i,
            margin: `${o}px ${s}px`,
            padding: 0,
            cursor: "pointer",
            touchAction: "none",
            "&-vertical": {
                margin: `${s}px ${o}px`
            },
            [`${t}-rail`]: {
                position: "absolute",
                backgroundColor: e.railBg,
                borderRadius: e.borderRadiusXS,
                transition: `background-color ${e.motionDurationMid}`
            },
            [`${t}-track,${t}-tracks`]: {
                position: "absolute",
                transition: `background-color ${e.motionDurationMid}`
            },
            [`${t}-track`]: {
                backgroundColor: e.trackBg,
                borderRadius: e.borderRadiusXS
            },
            [`${t}-track-draggable`]: {
                boxSizing: "content-box",
                backgroundClip: "content-box",
                border: "solid rgba(0,0,0,0)"
            },
            "&:hover": {
                [`${t}-rail`]: {
                    backgroundColor: e.railHoverBg
                },
                [`${t}-track`]: {
                    backgroundColor: e.trackHoverBg
                },
                [`${t}-dot`]: {
                    borderColor: a
                },
                [`${t}-handle::after`]: {
                    boxShadow: `0 0 0 ${e.handleLineWidth}px ${e.colorPrimaryBorderHover}`
                },
                [`${t}-dot-active`]: {
                    borderColor: e.dotActiveBorderColor
                }
            },
            [`${t}-handle`]: {
                position: "absolute",
                width: e.handleSize,
                height: e.handleSize,
                outline: "none",
                "&::before": {
                    content: '""',
                    position: "absolute",
                    insetInlineStart: -e.handleLineWidth,
                    insetBlockStart: -e.handleLineWidth,
                    width: e.handleSize + e.handleLineWidth * 2,
                    height: e.handleSize + e.handleLineWidth * 2,
                    backgroundColor: "transparent"
                },
                "&::after": {
                    content: '""',
                    position: "absolute",
                    insetBlockStart: 0,
                    insetInlineStart: 0,
                    width: e.handleSize,
                    height: e.handleSize,
                    backgroundColor: e.colorBgElevated,
                    boxShadow: `0 0 0 ${e.handleLineWidth}px ${e.handleColor}`,
                    borderRadius: "50%",
                    cursor: "pointer",
                    transition: `
            inset-inline-start ${e.motionDurationMid},
            inset-block-start ${e.motionDurationMid},
            width ${e.motionDurationMid},
            height ${e.motionDurationMid},
            box-shadow ${e.motionDurationMid}
          `
                },
                "&:hover, &:active, &:focus": {
                    "&::before": {
                        insetInlineStart: -((e.handleSizeHover - e.handleSize) / 2 + e.handleLineWidthHover),
                        insetBlockStart: -((e.handleSizeHover - e.handleSize) / 2 + e.handleLineWidthHover),
                        width: e.handleSizeHover + e.handleLineWidthHover * 2,
                        height: e.handleSizeHover + e.handleLineWidthHover * 2
                    },
                    "&::after": {
                        boxShadow: `0 0 0 ${e.handleLineWidthHover}px ${e.handleActiveColor}`,
                        width: e.handleSizeHover,
                        height: e.handleSizeHover,
                        insetInlineStart: (e.handleSize - e.handleSizeHover) / 2,
                        insetBlockStart: (e.handleSize - e.handleSizeHover) / 2
                    }
                }
            },
            [`${t}-mark`]: {
                position: "absolute",
                fontSize: e.fontSize
            },
            [`${t}-mark-text`]: {
                position: "absolute",
                display: "inline-block",
                color: e.colorTextDescription,
                textAlign: "center",
                wordBreak: "keep-all",
                cursor: "pointer",
                userSelect: "none",
                "&-active": {
                    color: e.colorText
                }
            },
            [`${t}-step`]: {
                position: "absolute",
                background: "transparent",
                pointerEvents: "none"
            },
            [`${t}-dot`]: {
                position: "absolute",
                width: r,
                height: r,
                backgroundColor: e.colorBgElevated,
                border: `${e.handleLineWidth}px solid ${e.dotBorderColor}`,
                borderRadius: "50%",
                cursor: "pointer",
                transition: `border-color ${e.motionDurationSlow}`,
                pointerEvents: "auto",
                "&-active": {
                    borderColor: e.dotActiveBorderColor
                }
            },
            [`&${t}-disabled`]: {
                cursor: "not-allowed",
                [`${t}-rail`]: {
                    backgroundColor: `${e.railBg} !important`
                },
                [`${t}-track`]: {
                    backgroundColor: `${e.trackBgDisabled} !important`
                },
                [`
          ${t}-dot
        `]: {
                    backgroundColor: e.colorBgElevated,
                    borderColor: e.trackBgDisabled,
                    boxShadow: "none",
                    cursor: "not-allowed"
                },
                [`${t}-handle::after`]: {
                    backgroundColor: e.colorBgElevated,
                    cursor: "not-allowed",
                    width: e.handleSize,
                    height: e.handleSize,
                    boxShadow: `0 0 0 ${e.handleLineWidth}px ${new An(e.colorTextDisabled).onBackground(e.colorBgContainer).toHexShortString()}`,
                    insetInlineStart: 0,
                    insetBlockStart: 0
                },
                [`
          ${t}-mark-text,
          ${t}-dot
        `]: {
                    cursor: "not-allowed !important"
                }
            },
            [`&-tooltip ${n}-tooltip-inner`]: {
                minWidth: "unset"
            }
        })
    }
}
  , rC = (e,t)=>{
    const {componentCls: n, railSize: i, handleSize: r, dotSize: s} = e
      , o = t ? "paddingBlock" : "paddingInline"
      , a = t ? "width" : "height"
      , l = t ? "height" : "width"
      , c = t ? "insetBlockStart" : "insetInlineStart"
      , u = t ? "top" : "insetInlineStart"
      , h = (i * 3 - r) / 2
      , d = (r - i) / 2
      , m = t ? {
        borderWidth: `${d}px 0`,
        transform: `translateY(-${d}px)`
    } : {
        borderWidth: `0 ${d}px`,
        transform: `translateX(-${d}px)`
    };
    return {
        [o]: i,
        [l]: i * 3,
        [`${n}-rail`]: {
            [a]: "100%",
            [l]: i
        },
        [`${n}-track,${n}-tracks`]: {
            [l]: i
        },
        [`${n}-track-draggable`]: Object.assign({}, m),
        [`${n}-handle`]: {
            [c]: h
        },
        [`${n}-mark`]: {
            insetInlineStart: 0,
            top: 0,
            [u]: i * 3 + (t ? 0 : e.marginFull),
            [a]: "100%"
        },
        [`${n}-step`]: {
            insetInlineStart: 0,
            top: 0,
            [u]: i,
            [a]: "100%",
            [l]: i
        },
        [`${n}-dot`]: {
            position: "absolute",
            [c]: (i - s) / 2
        }
    }
}
  , HN = e=>{
    const {componentCls: t, marginPartWithMark: n} = e;
    return {
        [`${t}-horizontal`]: Object.assign(Object.assign({}, rC(e, !0)), {
            [`&${t}-with-marks`]: {
                marginBottom: n
            }
        })
    }
}
  , UN = e=>{
    const {componentCls: t} = e;
    return {
        [`${t}-vertical`]: Object.assign(Object.assign({}, rC(e, !1)), {
            height: "100%"
        })
    }
}
  , GN = Aa("Slider", e=>{
    const t = qs(e, {
        marginPart: (e.controlHeight - e.controlSize) / 2,
        marginFull: e.controlSize / 2,
        marginPartWithMark: e.controlHeightLG - e.controlSize
    });
    return [WN(t), HN(t), UN(t)]
}
, e=>{
    const n = e.controlHeightLG / 4
      , i = e.controlHeightSM / 2
      , r = e.lineWidth + 1
      , s = e.lineWidth + 1 * 3;
    return {
        controlSize: n,
        railSize: 4,
        handleSize: n,
        handleSizeHover: i,
        dotSize: 8,
        handleLineWidth: r,
        handleLineWidthHover: s,
        railBg: e.colorFillTertiary,
        railHoverBg: e.colorFillSecondary,
        trackBg: e.colorPrimaryBorder,
        trackHoverBg: e.colorPrimaryBorderHover,
        handleColor: e.colorPrimaryBorder,
        handleActiveColor: e.colorPrimary,
        dotBorderColor: e.colorBorderSecondary,
        dotActiveBorderColor: e.colorPrimaryBorder,
        trackBgDisabled: e.colorBgContainerDisabled
    }
}
);
var XN = function(e, t) {
    var n = {};
    for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++)
            t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
    return n
};
function YN(e, t) {
    return e || e === null ? e : t || t === null ? t : n=>typeof n == "number" ? n.toString() : ""
}
const $N = Ce.forwardRef((e,t)=>{
    const {prefixCls: n, range: i, className: r, rootClassName: s, style: o, disabled: a, tooltipPrefixCls: l, tipFormatter: c, tooltipVisible: u, getTooltipPopupContainer: h, tooltipPlacement: d} = e
      , m = XN(e, ["prefixCls", "range", "className", "rootClassName", "style", "disabled", "tooltipPrefixCls", "tipFormatter", "tooltipVisible", "getTooltipPopupContainer", "tooltipPlacement"])
      , {direction: f, slider: x, getPrefixCls: S, getPopupContainer: v} = Ce.useContext(Xn)
      , p = Ce.useContext(w2)
      , g = a ?? p
      , [C,E] = Ce.useState({})
      , O = (b,A)=>{
        E(j=>Object.assign(Object.assign({}, j), {
            [b]: A
        }))
    }
      , R = (b,A)=>b || (A ? f === "rtl" ? "left" : "right" : "top")
      , F = S("slider", n)
      , [P,_] = GN(F)
      , T = nt(r, x == null ? void 0 : x.className, s, {
        [`${F}-rtl`]: f === "rtl"
    }, _);
    f === "rtl" && !m.vertical && (m.reverse = !m.reverse);
    const [L,I] = Ce.useMemo(()=>i ? typeof i == "object" ? [!0, i.draggableTrack] : [!0, !1] : [!1], [i])
      , k = (b,A)=>{
        var j;
        const {index: B, dragging: W} = A
          , {tooltip: N={}, vertical: H} = e
          , X = Object.assign({}, N)
          , {open: ie, placement: K, getPopupContainer: D, prefixCls: V, formatter: G} = X
          , ee = YN(G, c)
          , J = ee ? C[B] || W : !1
          , te = (j = ie ?? u) !== null && j !== void 0 ? j : ie === void 0 && J
          , z = Object.assign(Object.assign({}, b.props), {
            onMouseEnter: ()=>O(B, !0),
            onMouseLeave: ()=>O(B, !1),
            onFocus: Y=>{
                var U;
                O(B, !0),
                (U = m.onFocus) === null || U === void 0 || U.call(m, Y)
            }
            ,
            onBlur: Y=>{
                var U;
                O(B, !1),
                (U = m.onBlur) === null || U === void 0 || U.call(m, Y)
            }
        });
        return Ce.createElement(VN, Object.assign({}, X, {
            prefixCls: S("tooltip", V ?? l),
            title: ee ? ee(A.value) : "",
            open: te,
            placement: R(K ?? d, H),
            key: B,
            overlayClassName: `${F}-tooltip`,
            getPopupContainer: D || h || v
        }), Ce.cloneElement(b, z))
    }
      , w = Object.assign(Object.assign({}, x == null ? void 0 : x.style), o);
    return P(Ce.createElement(BN, Object.assign({}, m, {
        step: m.step,
        range: L,
        draggableTrack: I,
        className: T,
        style: w,
        disabled: g,
        ref: t,
        prefixCls: F,
        handleRender: k
    })))
}
)
  , KN = $N
  , QN = "data:image/svg+xml,%3csvg%20width='12'%20height='12'%20viewBox='0%200%2012%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M4.75%202.25H2.25C1.91848%202.25%201.60054%202.3817%201.36612%202.61612C1.1317%202.85054%201%203.16848%201%203.5V9.75C1%2010.0815%201.1317%2010.3995%201.36612%2010.6339C1.60054%2010.8683%201.91848%2011%202.25%2011H8.5C8.83152%2011%209.14946%2010.8683%209.38388%2010.6339C9.6183%2010.3995%209.75%2010.0815%209.75%209.75V7.25M7.25%201H11M11%201V4.75M11%201L4.75%207.25'%20stroke='white'%20stroke-width='1.5'%20strokeLinecap='round'%20strokeLinejoin='round'/%3e%3c/svg%3e"
  , sC = "/assets/bg-advertisement-BrvVrx3N.jpg"
  , qN = ()=>y.jsxs("article", {
    className: "ad-sing-up",
    style: {
        backgroundImage: `url(${sC})`
    },
    children: [y.jsxs("div", {
        children: [y.jsx("h3", {
            children: "Sing Up to IUH Tiers and enjoy all the perks"
        }), y.jsx("p", {
            children: "Unlock exclusive access to premium content, personalized insights, and unique perks by subscribing to IUH tiers now !"
        })]
    }), y.jsxs("button", {
        children: ["Sing Up Now ", y.jsx("img", {
            src: QN,
            alt: "Button Click"
        })]
    })]
})
  , ZN = "data:image/svg+xml,%3csvg%20width='15'%20height='13'%20viewBox='0%200%2015%2013'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M6.66667%202.62987C6.66667%203.32735%206.40327%203.99627%205.93443%204.48947C5.46559%204.98267%204.82971%205.25974%204.16667%205.25974C3.50363%205.25974%202.86774%204.98267%202.3989%204.48947C1.93006%203.99627%201.66667%203.32735%201.66667%202.62987C1.66667%201.93239%201.93006%201.26347%202.3989%200.770271C2.86774%200.277075%203.50363%200%204.16667%200C4.82971%200%205.46559%200.277075%205.93443%200.770271C6.40327%201.26347%206.66667%201.93239%206.66667%202.62987ZM13.3333%202.62987C13.3333%202.97523%2013.2687%203.31721%2013.143%203.63628C13.0174%203.95535%2012.8332%204.24526%2012.6011%204.48947C12.369%204.73368%2012.0934%204.92739%2011.79%205.05955C11.4867%205.19172%2011.1616%205.25974%2010.8333%205.25974C10.505%205.25974%2010.1799%205.19172%209.87662%205.05955C9.57331%204.92739%209.29771%204.73368%209.06557%204.48947C8.83342%204.24526%208.64927%203.95535%208.52363%203.63628C8.398%203.31721%208.33333%202.97523%208.33333%202.62987C8.33333%201.93239%208.59672%201.26347%209.06557%200.770271C9.53441%200.277075%2010.1703%200%2010.8333%200C11.4964%200%2012.1323%200.277075%2012.6011%200.770271C13.0699%201.26347%2013.3333%201.93239%2013.3333%202.62987ZM9.94167%2012.2727C9.98%2011.9861%2010%2011.6942%2010%2011.3961C10.0019%2010.0188%209.56144%208.68122%208.75%207.60032C9.38341%207.21563%2010.1019%207.0131%2010.8333%207.0131C11.5647%207.01309%2012.2832%207.21561%2012.9166%207.6003C13.55%207.98498%2014.076%208.53828%2014.4417%209.20458C14.8074%209.87089%2015%2010.6267%2015%2011.3961V12.2727H9.94167ZM4.16667%207.01299C5.27174%207.01299%206.33154%207.47478%207.11294%208.29677C7.89435%209.11877%208.33333%2010.2336%208.33333%2011.3961V12.2727H0V11.3961C0%2010.2336%200.438987%209.11877%201.22039%208.29677C2.00179%207.47478%203.0616%207.01299%204.16667%207.01299Z'%20fill='%232C406E'/%3e%3c/svg%3e"
  , JN = "data:image/svg+xml,%3csvg%20width='17'%20height='17'%20viewBox='0%200%2017%2017'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12.25%204.75V12.25M8.5%207.5625V12.25M4.75%2010.375V12.25M2.875%2016H14.125C14.6223%2016%2015.0992%2015.8025%2015.4508%2015.4508C15.8025%2015.0992%2016%2014.6223%2016%2014.125V2.875C16%202.37772%2015.8025%201.90081%2015.4508%201.54917C15.0992%201.19754%2014.6223%201%2014.125%201H2.875C2.37772%201%201.90081%201.19754%201.54917%201.54917C1.19754%201.90081%201%202.37772%201%202.875V14.125C1%2014.6223%201.19754%2015.0992%201.54917%2015.4508C1.90081%2015.8025%202.37772%2016%202.875%2016Z'%20stroke='%232C406E'%20stroke-width='1.5'%20strokeLinecap='round'%20strokeLinejoin='round'/%3e%3c/svg%3e"
  , eF = "data:image/svg+xml,%3csvg%20width='14'%20height='17'%20viewBox='0%200%2014%2017'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12.25%204.28125L12.25%2016M6.625%201L6.625%2016M1%209.4375L1%2016'%20stroke='%232C406E'%20stroke-width='2'%20strokeLinecap='round'%20strokeLinejoin='round'/%3e%3c/svg%3e"
  , tF = "data:image/svg+xml,%3csvg%20width='17'%20height='20'%20viewBox='0%200%2017%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9.58333%201L1.25%2011.8H8.75L7.91667%2019L16.25%208.2H8.75L9.58333%201Z'%20fill='%232C406E'%20stroke='%232C406E'%20strokeLinecap='round'%20strokeLinejoin='round'/%3e%3c/svg%3e";
var dx, fx, px, gx, mx, vx;
function Up() {
    return Up = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Up.apply(this, arguments)
}
const nF = e=>M.createElement("svg", Up({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    id: "kava_svg__Layer_1",
    x: 0,
    y: 0,
    style: {
        enableBackground: "new 0 0 2000 2210"
    },
    viewBox: "0 0 2000 2210"
}, e), dx || (dx = M.createElement("style", null, ".kava_svg__kava3{fill:#ff564f}")), M.createElement("path", {
    d: "M198.5 1841.3 321.6 2210l845-1105L321.6 0 192.5 360.7l561.3 744.1z",
    style: {
        opacity: .2,
        fill: "#ff564f",
        enableBackground: "new"
    }
}), M.createElement("path", {
    d: "M1999.7 2209.8h-401l-845.2-1105L1598.7 0h401l-833.3 1104.8z",
    style: {
        fill: "#f08179"
    }
}), fx || (fx = M.createElement("path", {
    d: "M0 0h321.4v2209.8H0z",
    className: "kava_svg__kava3"
})), px || (px = M.createElement("path", {
    id: "kava_svg___x30_",
    d: "M2000 2209.8h-401l-845.2-1105L1599 0h401l-833.3 1104.8z",
    className: "kava_svg__kava3"
})), gx || (gx = M.createElement("path", {
    id: "kava_svg___x30__1_",
    d: "M2000 2209.8h-401l-845.2-1105L1599 0h401l-833.3 1104.8z",
    className: "kava_svg__kava3"
})), mx || (mx = M.createElement("path", {
    id: "kava_svg___x30__2_",
    d: "M2000 2209.8h-401l-845.2-1105L1599 0h401l-833.3 1104.8z",
    className: "kava_svg__kava3"
})), vx || (vx = M.createElement("path", {
    id: "kava_svg___x30__3_",
    d: "M2000 2209.8h-401l-845.2-1105L1599 0h401l-833.3 1104.8z",
    className: "kava_svg__kava3"
})));
var yx, xx, bx, wx, Sx, Cx;
function Gp() {
    return Gp = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Gp.apply(this, arguments)
}
const iF = e=>M.createElement("svg", Gp({
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "0 0 32 32"
}, e), yx || (yx = M.createElement("defs", null, M.createElement("filter", {
    id: "ada_svg__a",
    width: "111.7%",
    height: "111.7%",
    x: "-5.8%",
    y: "-4.2%",
    filterUnits: "objectBoundingBox"
}, M.createElement("feOffset", {
    dy: .5,
    in: "SourceAlpha",
    result: "shadowOffsetOuter1"
}), M.createElement("feGaussianBlur", {
    in: "shadowOffsetOuter1",
    result: "shadowBlurOuter1",
    stdDeviation: .5
}), M.createElement("feComposite", {
    in: "shadowBlurOuter1",
    in2: "SourceAlpha",
    operator: "out",
    result: "shadowBlurOuter1"
}), M.createElement("feColorMatrix", {
    in: "shadowBlurOuter1",
    values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.199473505 0"
})), M.createElement("filter", {
    id: "ada_svg__d",
    width: "115.5%",
    height: "117.2%",
    x: "-7.5%",
    y: "-6%",
    filterUnits: "objectBoundingBox"
}, M.createElement("feOffset", {
    dy: .5,
    in: "SourceAlpha",
    result: "shadowOffsetOuter1"
}), M.createElement("feGaussianBlur", {
    in: "shadowOffsetOuter1",
    result: "shadowBlurOuter1",
    stdDeviation: .5
}), M.createElement("feColorMatrix", {
    in: "shadowBlurOuter1",
    values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.204257246 0"
})), M.createElement("linearGradient", {
    id: "ada_svg__c",
    x1: "50%",
    x2: "50%",
    y1: "0%",
    y2: "100%"
}, M.createElement("stop", {
    offset: "0%",
    stopColor: "#FFF",
    stopOpacity: .5
}), M.createElement("stop", {
    offset: "100%",
    stopOpacity: .5
})), M.createElement("circle", {
    id: "ada_svg__b",
    cx: 15,
    cy: 15,
    r: 15
}), M.createElement("path", {
    id: "ada_svg__e",
    d: "M15.725 5.06c.479-.247 1.064.324.81.795-.149.384-.71.486-.996.193-.303-.28-.204-.836.186-.989zm-5.155.546c.291-.118.66.144.63.457.03.338-.39.588-.687.427-.393-.15-.348-.778.057-.884zm10.558.893c-.455-.054-.527-.758-.09-.9.34-.162.652.143.702.46-.072.27-.302.518-.612.44zm-9.385 1.265c.487-.303 1.181.148 1.106.705-.025.561-.783.887-1.211.507-.414-.298-.351-.982.105-1.212m7.43.322c.217-.55 1.097-.568 1.344-.032.245.417-.056.934-.491 1.076-.577.106-1.124-.508-.853-1.044m-4.069 1.013c-.005-.474.433-.826.89-.859.304.06.634.187.764.488.243.416.027.987-.41 1.178-.2.11-.438.069-.656.056-.333-.16-.614-.477-.588-.863m-7.666.69c.445-.27 1.045.22.876.696-.092.411-.654.578-.975.316-.343-.246-.289-.837.1-1.013zM23.9 9.786c.377-.288 1 .043.954.511.026.427-.513.75-.887.53-.412-.183-.455-.807-.067-1.04zm-6.64.851c.622-.22 1.362.043 1.716.59.468.667.22 1.683-.507 2.066-.752.453-1.851.07-2.13-.758-.315-.74.145-1.666.92-1.898zm-3.653.073c.69-.32 1.619-.052 1.952.642.392.676.089 1.617-.612 1.966-.702.393-1.693.095-2.032-.63-.381-.702-.043-1.655.692-1.978zM9.95 11.94c.053-.437.472-.722.895-.752a.98.98 0 0 1 .87.857c-.03.45-.383.888-.867.886-.533.045-1-.477-.898-.991zm10.802-.656c.547-.313 1.306.142 1.282.76.037.655-.803 1.116-1.347.732-.566-.32-.522-1.22.065-1.492m-8.63 2.307c.638-.173 1.37.123 1.683.701.343.582.203 1.39-.33 1.818-.685.626-1.946.374-2.31-.48-.419-.783.09-1.833.956-2.04zm6.927-.003c.621-.175 1.351.06 1.685.617.442.637.231 1.588-.426 1.998-.69.477-1.756.227-2.136-.519-.46-.771.003-1.861.877-2.096m-11.04.726c.552-.205 1.164.394.94.933-.136.49-.839.672-1.202.31-.425-.34-.268-1.095.262-1.243m14.969.782a.836.836 0 0 1 .788-.874c.378.06.746.36.716.765.035.535-.62.898-1.084.647-.217-.109-.328-.328-.42-.538M5.294 14.58c.332-.143.743.14.667.503-.018.411-.635.57-.861.226-.2-.239-.08-.606.194-.73zm20.949-.009c.234-.163.61-.046.702.223.157.294-.131.696-.467.647-.472.042-.624-.665-.235-.87zm-12.317 1.973c.874-.223 1.814.494 1.82 1.38.056.895-.87 1.688-1.764 1.482-.692-.11-1.235-.766-1.212-1.453-.002-.658.502-1.27 1.156-1.409zm3.462-.001c.887-.244 1.855.486 1.841 1.392.047.878-.85 1.645-1.726 1.47-.825-.104-1.433-.995-1.203-1.783.116-.524.562-.95 1.088-1.08zm-6.676.545c.614-.103 1.19.57.941 1.144-.182.612-1.086.777-1.486.278-.468-.48-.118-1.356.545-1.422zm10.154.027c.548-.226 1.22.24 1.178.825.022.643-.808 1.087-1.343.711-.607-.337-.496-1.33.165-1.536zm2.838 2.8c-.214-.393.175-.914.62-.841.22-.004.375.167.516.311.029.233.078.511-.119.69-.267.333-.872.238-1.017-.16zm-16.268-.732c.415-.271 1.012.134.918.61-.05.423-.59.664-.945.424-.382-.217-.368-.836.027-1.034zm8.193.883c.543-.235 1.235.23 1.183.818.04.65-.815 1.1-1.346.71-.59-.335-.491-1.321.163-1.528zm-3.794.871c.462-.239 1.082.174 1.04.684.014.418-.4.774-.82.712-.347-.007-.573-.314-.685-.605.006-.317.139-.67.465-.79zm7.686.008c.476-.29 1.152.126 1.107.67.012.57-.752.934-1.195.56-.428-.293-.376-.997.088-1.23m1.337 3.25c-.212-.314.037-.693.38-.765.277.055.57.26.511.574-.04.427-.674.557-.891.192zm-10.611-.273c.084-.25.288-.497.587-.432.435.03.564.676.183.875-.342.227-.74-.084-.77-.443m5.12.287c.083-.37.568-.549.888-.353.212.09.274.322.328.52a8.822 8.822 0 0 0-.08.31c-.131.152-.3.305-.518.3-.405.047-.771-.404-.619-.777z"
}))), M.createElement("g", {
    fill: "none"
}, M.createElement("g", {
    transform: "translate(1)"
}, xx || (xx = M.createElement("use", {
    xlinkHref: "#ada_svg__b",
    fill: "#000",
    filter: "url(#ada_svg__a)"
})), bx || (bx = M.createElement("use", {
    xlinkHref: "#ada_svg__b",
    fill: "#0D1E30"
})), M.createElement("use", {
    xlinkHref: "#ada_svg__b",
    fill: "url(#ada_svg__c)",
    style: {
        mixBlendMode: "soft-light"
    }
}), wx || (wx = M.createElement("circle", {
    cx: 15,
    cy: 15,
    r: 14.5,
    stroke: "#000",
    strokeOpacity: .097
}))), Sx || (Sx = M.createElement("use", {
    xlinkHref: "#ada_svg__e",
    fill: "#000",
    filter: "url(#ada_svg__d)"
})), Cx || (Cx = M.createElement("use", {
    xlinkHref: "#ada_svg__e",
    fill: "#FFF"
}))));
var kx, Ax, Mx, Ex, Px, Tx;
function Xp() {
    return Xp = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Xp.apply(this, arguments)
}
const rF = e=>M.createElement("svg", Xp({
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "0 0 32 32"
}, e), kx || (kx = M.createElement("defs", null, M.createElement("filter", {
    id: "exp_svg__a",
    width: "111.7%",
    height: "111.7%",
    x: "-5.8%",
    y: "-4.2%",
    filterUnits: "objectBoundingBox"
}, M.createElement("feOffset", {
    dy: .5,
    in: "SourceAlpha",
    result: "shadowOffsetOuter1"
}), M.createElement("feGaussianBlur", {
    in: "shadowOffsetOuter1",
    result: "shadowBlurOuter1",
    stdDeviation: .5
}), M.createElement("feComposite", {
    in: "shadowBlurOuter1",
    in2: "SourceAlpha",
    operator: "out",
    result: "shadowBlurOuter1"
}), M.createElement("feColorMatrix", {
    in: "shadowBlurOuter1",
    values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.199473505 0"
})), M.createElement("filter", {
    id: "exp_svg__d",
    width: "117.5%",
    height: "115.9%",
    x: "-8.8%",
    y: "-5.7%",
    filterUnits: "objectBoundingBox"
}, M.createElement("feOffset", {
    dy: .5,
    in: "SourceAlpha",
    result: "shadowOffsetOuter1"
}), M.createElement("feGaussianBlur", {
    in: "shadowOffsetOuter1",
    result: "shadowBlurOuter1",
    stdDeviation: .5
}), M.createElement("feColorMatrix", {
    in: "shadowBlurOuter1",
    values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.204257246 0"
})), M.createElement("linearGradient", {
    id: "exp_svg__c",
    x1: "50%",
    x2: "50%",
    y1: "0%",
    y2: "100%"
}, M.createElement("stop", {
    offset: "0%",
    stopColor: "#FFF",
    stopOpacity: .5
}), M.createElement("stop", {
    offset: "100%",
    stopOpacity: .5
})), M.createElement("circle", {
    id: "exp_svg__b",
    cx: 16,
    cy: 15,
    r: 15
}), M.createElement("path", {
    id: "exp_svg__e",
    d: "M26 13.717c-.004.039-.01.077-.01.116-.005 1.22-.01 2.441-.012 3.662l-.004 2.507c0 .08-.007.16-.012.26-.044-.02-.076-.033-.106-.05l-4.654-2.595c-.083-.046-.09-.087-.05-.169.793-1.628.796-3.26.015-4.892-.037-.078-.03-.117.05-.161l4.656-2.613c.039-.022.084-.033.127-.049v3.984zM16.3 4c.078.047.155.097.235.142l9.049 5.085c.034.019.066.04.113.068-.042.027-.07.047-.101.064l-4.618 2.579c-.121.067-.12.066-.2-.048-1.024-1.435-2.428-2.255-4.212-2.463a1.3 1.3 0 0 0-.16-.01c-.094 0-.13-.036-.13-.135-.001-1.013-.007-2.027-.01-3.04l-.003-2.099c0-.048.011-.095.017-.143zm-.62 22c-.034-.025-.065-.053-.1-.073l-9.117-5.125c-.043-.024-.084-.05-.143-.084.04-.027.066-.048.096-.065 1.53-.855 3.06-1.709 4.59-2.566.092-.052.135-.032.192.047.956 1.326 2.262 2.11 3.901 2.377.167.027.338.04.507.048.096.004.134.03.134.13-.001.897.003 1.794.006 2.69l.005 2.546c0 .025-.007.05-.011.075h-.06zM6 19.45c.005-.03.015-.061.016-.092l.004-1.263.007-2.827.013-4.459.005-.961c0-.028.004-.056.007-.101.044.021.076.034.106.051 1.522.85 3.043 1.7 4.567 2.548.089.049.101.087.057.18-.8 1.641-.796 3.284 0 4.927.065.132.067.131-.063.204-1.528.86-3.056 1.718-4.585 2.575-.039.022-.09.024-.134.035v-.816zm13.473-.93c.163-.573.216-1.15.18-1.736-.042-.718-.22-1.4-.594-2.026-.43-.722-1.052-1.245-1.81-1.625-.2-.101-.222-.05-.103-.3.269-.563.74-.913 1.32-1.137a4.11 4.11 0 0 1 1.258-.246.236.236 0 0 1 .16.072 4.994 4.994 0 0 1 1.338 2.739c.383 2.607-1.316 5.054-3.954 5.702-2.927.72-5.896-1.082-6.504-3.944-.568-2.679 1.148-5.27 3.708-5.954 1.923-.513 3.629-.104 5.122 1.17l.169.144-.021.032c-.147-.018-.293-.04-.44-.054-.913-.086-1.811-.026-2.682.273a4.465 4.465 0 0 0-2.508 2.085c-.08.142-.086.143-.24.09a1.31 1.31 0 0 1-.519-.337 2.747 2.747 0 0 1-.629-1.039c-.117-.34-.203-.69-.303-1.035-.008-.027-.014-.055-.038-.084-.014.08-.03.158-.042.238-.012.08-.022.16-.03.24-.095.894-.044 1.774.265 2.627.384 1.064 1.107 1.83 2.163 2.296.138.061.138.062.064.188-.391.664-1.004.998-1.761 1.112-.352.053-.704.032-1.063.006.033.013.065.028.098.04 1.73.595 3.63.328 5.061-1.186a6.93 6.93 0 0 0 .938-1.267c.068-.118.073-.119.183-.039.469.342.748.81.94 1.335.179.483.25.985.267 1.496.001.041.004.082.007.123zm6.268 2.212-9.463 5.249c-.005-.055-.012-.089-.012-.122 0-1.73 0-3.46-.002-5.19 0-.077.023-.105.106-.112 1.84-.152 3.299-.958 4.37-2.423.093-.129.092-.13.23-.053l4.643 2.575c.036.02.072.043.128.076zM15.739 4.036c.003.056.006.09.006.124 0 1.707 0 3.414.002 5.12 0 .08-.012.12-.11.127-1.878.136-3.363.949-4.451 2.443-.086.118-.084.119-.21.049l-4.521-2.51c-.053-.03-.102-.066-.153-.1.052-.036.1-.077.156-.108l9.11-5.056c.051-.028.103-.053.17-.089z"
}))), M.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
}, Ax || (Ax = M.createElement("use", {
    xlinkHref: "#exp_svg__b",
    fill: "#000",
    filter: "url(#exp_svg__a)"
})), Mx || (Mx = M.createElement("use", {
    xlinkHref: "#exp_svg__b",
    fill: "#FFAA5C"
})), M.createElement("use", {
    xlinkHref: "#exp_svg__b",
    fill: "url(#exp_svg__c)",
    style: {
        mixBlendMode: "soft-light"
    }
}), Ex || (Ex = M.createElement("circle", {
    cx: 16,
    cy: 15,
    r: 14.5,
    stroke: "#000",
    strokeOpacity: .097
})), Px || (Px = M.createElement("use", {
    xlinkHref: "#exp_svg__e",
    fill: "#000",
    filter: "url(#exp_svg__d)"
})), Tx || (Tx = M.createElement("use", {
    xlinkHref: "#exp_svg__e",
    fill: "#FFF"
}))));
var jx;
function Yp() {
    return Yp = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Yp.apply(this, arguments)
}
const sF = e=>M.createElement("svg", Yp({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), jx || (jx = M.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#328332"
}), M.createElement("g", {
    fill: "#FFF"
}, M.createElement("path", {
    fillRule: "nonzero",
    d: "m15.989 16.553-6.721-.577 6.72-3.802v4.379zm0 4.46v6.94C13.652 24.315 11.076 20.311 9 17.07c2.45 1.38 5.008 2.823 6.989 3.944zm0-10.068L9 14.845 15.989 4z"
}), M.createElement("path", {
    fillOpacity: .601,
    fillRule: "nonzero",
    d: "m22.71 15.976-6.721.577v-4.379l6.72 3.802zm-6.721 5.038c1.98-1.12 4.537-2.564 6.988-3.944-2.076 3.242-4.652 7.246-6.988 10.882v-6.938zm0-10.069V4l6.988 10.845z"
}), M.createElement("path", {
    d: "m15.989 16.553 6.72-.577-6.72 3.775z",
    opacity: .2
}), M.createElement("path", {
    d: "m15.988 16.553-6.721-.577 6.721 3.775z",
    opacity: .603
})))));
var Ox, Lx, Rx, _x, Dx, Nx;
function $p() {
    return $p = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    $p.apply(this, arguments)
}
const oF = e=>M.createElement("svg", $p({
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "0 0 32 32"
}, e), Ox || (Ox = M.createElement("defs", null, M.createElement("filter", {
    id: "exmo_svg__a",
    width: "111.7%",
    height: "111.7%",
    x: "-5.8%",
    y: "-4.2%",
    filterUnits: "objectBoundingBox"
}, M.createElement("feOffset", {
    dy: .5,
    in: "SourceAlpha",
    result: "shadowOffsetOuter1"
}), M.createElement("feGaussianBlur", {
    in: "shadowOffsetOuter1",
    result: "shadowBlurOuter1",
    stdDeviation: .5
}), M.createElement("feComposite", {
    in: "shadowBlurOuter1",
    in2: "SourceAlpha",
    operator: "out",
    result: "shadowBlurOuter1"
}), M.createElement("feColorMatrix", {
    in: "shadowBlurOuter1",
    values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.199473505 0"
})), M.createElement("filter", {
    id: "exmo_svg__d",
    width: "115.9%",
    height: "138.9%",
    x: "-8%",
    y: "-13.9%",
    filterUnits: "objectBoundingBox"
}, M.createElement("feOffset", {
    dy: .5,
    in: "SourceAlpha",
    result: "shadowOffsetOuter1"
}), M.createElement("feGaussianBlur", {
    in: "shadowOffsetOuter1",
    result: "shadowBlurOuter1",
    stdDeviation: .5
}), M.createElement("feColorMatrix", {
    in: "shadowBlurOuter1",
    values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.204257246 0"
})), M.createElement("linearGradient", {
    id: "exmo_svg__c",
    x1: "50%",
    x2: "50%",
    y1: "0%",
    y2: "100%"
}, M.createElement("stop", {
    offset: "0%",
    stopColor: "#FFF",
    stopOpacity: .5
}), M.createElement("stop", {
    offset: "100%",
    stopOpacity: .5
})), M.createElement("circle", {
    id: "exmo_svg__b",
    cx: 16,
    cy: 15,
    r: 15
}), M.createElement("path", {
    id: "exmo_svg__e",
    d: "m19.7 12.055-2.869 7.75-.018.047-.526-1.055-1.1.5 2.885-7.797 1.1-.5.527 1.055zm7.18.183L24.012 20l-.527-1.058-1.1.5.067-.182 2.867-7.76 1.1-.5.525 1.055-.064.183zm-6.14 6.712 1.689-4.563-1.103.5-.524-1.057-1.694 4.562.525 1.058 1.107-.5zm-9.137-4.5H6.558l.86.8-.86.813h5.04l.856-.813-.851-.8zM5.86 17.833h8.155l-.857.807.857.805H5.86L5 18.64l.86-.808zm2.501-6.768h8.15l-.854.808.855.805h-8.15l-.86-.806.86-.807z"
}))), M.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
}, M.createElement("g", {
    fillRule: "nonzero"
}, Lx || (Lx = M.createElement("use", {
    xlinkHref: "#exmo_svg__b",
    fill: "#000",
    filter: "url(#exmo_svg__a)"
})), Rx || (Rx = M.createElement("use", {
    xlinkHref: "#exmo_svg__b",
    fill: "#347FFB",
    fillRule: "evenodd"
})), M.createElement("use", {
    xlinkHref: "#exmo_svg__b",
    fill: "url(#exmo_svg__c)",
    fillRule: "evenodd",
    style: {
        mixBlendMode: "soft-light"
    }
}), _x || (_x = M.createElement("circle", {
    cx: 16,
    cy: 15,
    r: 14.5,
    stroke: "#000",
    strokeOpacity: .097
}))), Dx || (Dx = M.createElement("use", {
    xlinkHref: "#exmo_svg__e",
    fill: "#000",
    filter: "url(#exmo_svg__d)"
})), Nx || (Nx = M.createElement("use", {
    xlinkHref: "#exmo_svg__e",
    fill: "#FFF"
}))));
var Fx;
function Kp() {
    return Kp = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Kp.apply(this, arguments)
}
const aF = e=>M.createElement("svg", Kp({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), Fx || (Fx = M.createElement("g", {
    fill: "none"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#F3BA2F"
}), M.createElement("path", {
    fill: "#FFF",
    d: "M12.116 14.404 16 10.52l3.886 3.886 2.26-2.26L16 6l-6.144 6.144zM6 16l2.26-2.26L10.52 16l-2.26 2.26zm6.116 1.596L16 21.48l3.886-3.886 2.26 2.259L16 26l-6.144-6.144-.003-.003zM21.48 16l2.26-2.26L26 16l-2.26 2.26zm-3.188-.002h.002V16L16 18.294l-2.291-2.29-.004-.004.004-.003.401-.402.195-.195L16 13.706l2.293 2.293z"
}))));
var Ix;
function Qp() {
    return Qp = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Qp.apply(this, arguments)
}
const lF = e=>M.createElement("svg", Qp({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 560 560.04"
}, e), Ix || (Ix = M.createElement("path", {
    fill: "#de5959",
    d: "m219.42 275.6-4.86-4.88a5.85 5.85 0 0 0-10 4.13v69.72a5.85 5.85 0 0 0 5.87 5.84h69.73a5.83 5.83 0 0 0 4.12-10 5.85 5.85 0 0 1 0-8.25l74.18-74.38a5.84 5.84 0 0 0 0-8.26l-6.76-6.73a5.84 5.84 0 0 1 4.13-10h69.7a5.86 5.86 0 0 1 5.86 5.84v69.72a5.86 5.86 0 0 1-10 4.13l-4.71-4.69a5.7 5.7 0 0 0-8.24 0l-125 125a5.89 5.89 0 0 1-8.27 0l-153-153a5.83 5.83 0 0 1 0-8.28L334 59.77a5.89 5.89 0 0 0 0-8.27L284.14 1.7a5.87 5.87 0 0 0-8.27 0L1.7 275.9a5.87 5.87 0 0 0 0 8.27l274.17 274.17a5.87 5.87 0 0 0 8.27 0L558.3 284.17a5.85 5.85 0 0 0 0-8.25L397 114.62a5.86 5.86 0 0 0-8.26 0l-161 161a5.83 5.83 0 0 1-8.28 0z"
})));
function qp() {
    return qp = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    qp.apply(this, arguments)
}
const cF = e=>M.createElement("svg", qp({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024"
}, e), M.createElement("circle", {
    cx: 512,
    cy: 512,
    r: 512,
    style: {
        fill: "#0052ff"
    }
}), M.createElement("path", {
    d: "M516.3 361.83c60.28 0 108.1 37.18 126.26 92.47H764C742 336.09 644.47 256 517.27 256 372.82 256 260 365.65 260 512.49S370 768 517.27 768c124.35 0 223.82-80.09 245.84-199.28H642.55c-17.22 55.3-65 93.45-125.32 93.45-83.23 0-141.56-63.89-141.56-149.68.04-86.77 57.43-150.66 140.63-150.66z",
    style: {
        fill: "#fff"
    }
}));
var Bx, zx;
function Zp() {
    return Zp = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Zp.apply(this, arguments)
}
const uF = e=>M.createElement("svg", Zp({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 146.5 146.5"
}, e), Bx || (Bx = M.createElement("circle", {
    cx: 73.25,
    cy: 73.25,
    r: 73.25,
    fill: "#ef0"
})), zx || (zx = M.createElement("g", {
    fill: "#fff"
}, M.createElement("ellipse", {
    cx: 92.63,
    cy: 72.54,
    rx: 10.21,
    ry: 10.33
}), M.createElement("path", {
    d: "m120.54 87.8-.3-.47-.08-.13c-1.12-1.76-1.46-2.13-2-2.94-7.47-11.5-3.2-18.89.16-22.66.41-.46.79-1 1.14-1.42a9.86 9.86 0 0 0 1.31-1.94l.06-.1a9.46 9.46 0 0 0 1-4.37 10 10 0 0 0-19.92 0 9.81 9.81 0 0 0 1.22 4.74c.12.24.69 1 .75 1.13a3.31 3.31 0 0 0 .42.53 13 13 0 0 0 1.12 1.22A19.92 19.92 0 0 1 108 65a17.76 17.76 0 0 1-1.75 18.44L103.77 87a3.62 3.62 0 0 0-.22.32l-.06.08a9.66 9.66 0 0 0-1.49 5.33 10 10 0 0 0 19.92 0 9.72 9.72 0 0 0-1.35-4.93zM81.87 87.8l-.29-.47-.09-.13c-1.12-1.76-1.46-2.13-2-2.94-7.47-11.5-3.2-18.89.16-22.66.41-.46.79-1 1.14-1.42a9.86 9.86 0 0 0 1.31-1.94l.06-.1a9.75 9.75 0 0 0 1-4.37 10 10 0 1 0-18.7 4.74c.12.24.69 1 .75 1.13a3.31 3.31 0 0 0 .42.53 13 13 0 0 0 1.12 1.22A20 20 0 0 1 69.36 65a17.77 17.77 0 0 1-1.7 18.44 20 20 0 0 1-2 2.41l-.17.17a20 20 0 0 1-3.64 2.61C51.43 93.6 43 86.73 43 86.73l-.85-.7a6.72 6.72 0 0 1-1.59-1.77c-7.47-11.5-3.2-18.89.16-22.66.41-.46.79-1 1.14-1.42a9.86 9.86 0 0 0 1.31-1.94l.06-.1a9.61 9.61 0 0 0 1.05-4.37 10 10 0 0 0-19.92 0 9.81 9.81 0 0 0 1.22 4.74c.12.24.69 1 .75 1.13a3.31 3.31 0 0 0 .42.53 13 13 0 0 0 1.12 1.22A19.92 19.92 0 0 1 30.43 65a17.76 17.76 0 0 1-1.75 18.44l-1.27 1.8a10 10 0 0 0-3.09 7.23v.23a10 10 0 0 0 17.06 6.9c.49-.34.81-.58 1.26-.87 11.5-7.47 18.89-3.2 22.67.16.3.27.62.53.94.77a10 10 0 0 0 17-7 9.72 9.72 0 0 0-1.35-4.93z"
}))));
function Jp() {
    return Jp = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Jp.apply(this, arguments)
}
const hF = e=>M.createElement("svg", Jp({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    style: {
        enableBackground: "new 0 0 2500 2500"
    },
    viewBox: "0 0 2500 2500"
}, e), M.createElement("path", {
    d: "M0 0h2500v2500H0z",
    style: {
        fill: "none"
    }
}), M.createElement("path", {
    d: "m2459.7 1566.6-540.6-937.7c-118.5-195.5-407.5-197.5-521.9 8.3l-567.6 975.2c-106 178.8 25 403.3 237.1 403.3H2204c214.1 0 374.2-230.8 255.7-449.1",
    style: {
        fill: "#3156aa"
    }
}), M.createElement("path", {
    d: "m1680 1639.4-33.3-58.2c-31.2-54.1-99.8-170.5-99.8-170.5l-457.4-794.3C971 439.7 690.3 425.1 571.8 647.6L39.5 1568.7c-110.2 193.4 20.8 444.9 259.9 447h1900.4c-293.1 2.1-386.7-149.7-519.8-376.3",
    style: {
        fill: "#1972e2"
    }
}), M.createElement("linearGradient", {
    id: "mexcLogo_svg__a",
    x1: 703.637,
    x2: 1935.647,
    y1: 1211.657,
    y2: 727.227,
    gradientTransform: "matrix(1 0 0 -1 0 2497.89)",
    gradientUnits: "userSpaceOnUse"
}, M.createElement("stop", {
    offset: 0,
    style: {
        stopColor: "#264ca2",
        stopOpacity: 0
    }
}), M.createElement("stop", {
    offset: 1,
    style: {
        stopColor: "#234588"
    }
})), M.createElement("path", {
    d: "m1680.1 1639.4-33.3-58.2c-31.2-54.1-99.8-170.5-99.8-170.5l-295.3-519.8-424.2 723.6c-106 178.8 25 403.4 237 403.4h1135.3c-295.2-2.2-386.7-151.9-519.7-378.5",
    style: {
        fill: "url(#mexcLogo_svg__a)"
    }
}));
function eg() {
    return eg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    eg.apply(this, arguments)
}
const dF = e=>M.createElement("svg", eg({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    style: {
        enableBackground: "new 0 0 400 400"
    },
    viewBox: "0 0 400 400"
}, e), M.createElement("linearGradient", {
    id: "inj_svg__a",
    x1: 0,
    x2: 400,
    y1: 182.253,
    y2: 182.253,
    gradientTransform: "matrix(1 0 0 -1 0 399.89)",
    gradientUnits: "userSpaceOnUse"
}, M.createElement("stop", {
    offset: 0,
    style: {
        stopColor: "#0082fa"
    }
}), M.createElement("stop", {
    offset: 1,
    style: {
        stopColor: "#00f2fe"
    }
})), M.createElement("path", {
    d: "M48.5 69.1C51 66 53.6 63 56.2 60c.1-.1.4-.2.5-.3.2-.3.6-.5.9-.8l.2-.3c1.8-1.7 3.8-3.5 6-5.2 8-6 16.2-10.6 24.9-13.7 28-9.8 59.1-3.8 83.5 19.3 34.1 31.9 31 83.4 3.8 117.6-34.4 51-93.4 122.1-11.7 185.8 14.7 11.5 25.6 20.9 71.9 34.3-30.3 5.6-58.4 3.8-89.6-4.1-22.1-12.5-56.9-39.2-68.7-75.3-17.9-54.7 31.5-136.6 55.3-168.1 32.7-43.6-20.2-90.8-59.3-38.1C53.7 138.6 18 216.3 30.4 274c7.2 32.7 16.9 56.5 55.2 89.3-7.1-4.2-14-8.9-20.7-14.3C-24 266.1-13.7 137.9 48.5 69.1z",
    style: {
        fill: "url(#inj_svg__a)"
    }
}), M.createElement("linearGradient", {
    id: "inj_svg__b",
    x1: 0,
    x2: 400,
    y1: 217.527,
    y2: 217.527,
    gradientTransform: "matrix(1 0 0 -1 0 399.89)",
    gradientUnits: "userSpaceOnUse"
}, M.createElement("stop", {
    offset: 0,
    style: {
        stopColor: "#0082fa"
    }
}), M.createElement("stop", {
    offset: 1,
    style: {
        stopColor: "#00f2fe"
    }
})), M.createElement("path", {
    d: "M351.5 330.9c-2.5 3.1-5.1 6.1-7.7 9.1-.1.1-.4.2-.5.3-.2.3-.6.5-.9.8l-.2.3c-1.8 1.7-3.8 3.5-6 5.1-8 6-16.2 10.6-24.9 13.7-28 9.8-59.1 3.8-83.5-19.3-34.1-31.9-31-83.4-3.8-117.6 34.4-51 93.4-122.1 11.7-185.8C221 26 210.1 16.6 163.8 3.2c30.3-5.6 58.4-3.8 89.6 4.1 22.1 12.5 56.9 39.2 68.7 75.3 17.9 54.7-31.5 136.6-55.3 168.1-32.7 43.6 20.2 90.8 59.3 38.1 20.4-27.5 56.1-105.2 43.7-162.9-7.2-32.7-16.9-56.5-55.2-89.3 7.1 4.2 14 8.9 20.7 14.3 88.7 83 78.4 211.2 16.2 280",
    style: {
        fill: "url(#inj_svg__b)"
    }
}));
var Vx;
function tg() {
    return tg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    tg.apply(this, arguments)
}
const fF = e=>M.createElement("svg", tg({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), Vx || (Vx = M.createElement("g", {
    fill: "none"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#516AFF"
}), M.createElement("g", {
    fill: "#FFF"
}, M.createElement("path", {
    d: "m18.286 12.479 2.2 1.257V7.45l-4.4-2.2L9.25 9.1v13.671l6.836 3.929 6.757-4.007v-6.757l-6.522-3.929-2.2 1.1 6.522 3.85.078 4.636-4.635 2.593-4.715-2.672V10.2l4.715-2.593 2.2 1.179v3.693z"
}), M.createElement("path", {
    d: "m15.85 16.25 1.493-.786 1.65 1.022-4.872 2.75v-5.657L15.85 14.6"
})))));
function ng() {
    return ng = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    ng.apply(this, arguments)
}
const pF = e=>M.createElement("svg", ng({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    style: {
        enableBackground: "new 0 0 3500 3500"
    },
    viewBox: "0 0 3500 3500"
}, e), M.createElement("path", {
    d: "M1750 0c966.5 0 1750 783.5 1750 1750s-783.5 1750-1750 1750S0 2716.5 0 1750 783.5 0 1750 0",
    style: {
        fill: "#00467a"
    }
}), M.createElement("linearGradient", {
    id: "coti_svg__a",
    x1: 1480.345,
    x2: 1252.889,
    y1: 249.463,
    y2: 1538.512,
    gradientTransform: "matrix(1 0 0 -1 0 2554)",
    gradientUnits: "userSpaceOnUse"
}, M.createElement("stop", {
    offset: .1,
    style: {
        stopColor: "#194aad"
    }
}), M.createElement("stop", {
    offset: .5,
    style: {
        stopColor: "#248fcb"
    }
}), M.createElement("stop", {
    offset: .8,
    style: {
        stopColor: "#2bbfdf"
    }
})), M.createElement("path", {
    d: "M762.6 1521.6c-35.1 0-50.7 15.6-50.7 46.8v803.7c0 35.1 15.6 46.8 50.7 46.8 386.3 3.9 858.3-339.4 1248.5-608.6V881.7c-386.2 265.3-870 643.8-1248.5 639.9z",
    style: {
        fill: "url(#coti_svg__a)"
    }
}), M.createElement("linearGradient", {
    id: "coti_svg__b",
    x1: 3511.147,
    x2: 3811.925,
    y1: -1272.658,
    y2: 432.942,
    gradientTransform: "matrix(-1 0 0 1 5851.79 2174.83)",
    gradientUnits: "userSpaceOnUse"
}, M.createElement("stop", {
    offset: .1,
    style: {
        stopColor: "#194aad"
    }
}), M.createElement("stop", {
    offset: .5,
    style: {
        stopColor: "#248fcb"
    }
}), M.createElement("stop", {
    offset: .8,
    style: {
        stopColor: "#2bbfdf"
    }
})), M.createElement("path", {
    d: "M2795.3 1884.4c35.1 0 50.7-15.6 50.7-46.8v-803.7c0-35.1-15.6-46.8-50.7-46.8-390.2-3.9-858.3 339.4-1248.5 608.6v924.7c386.3-265.3 870.1-643.8 1248.5-636",
    style: {
        fill: "url(#coti_svg__b)"
    }
}), M.createElement("path", {
    d: "M2011.1 1810.3v-530.6c-160 101.4-319.9 210.7-468.2 312.1v530.6c163.9-101.4 320-210.7 468.2-312.1",
    style: {
        fill: "#194aad"
    }
}));
var Wx;
function ig() {
    return ig = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    ig.apply(this, arguments)
}
const gF = e=>M.createElement("svg", ig({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), Wx || (Wx = M.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#136AAD"
}), M.createElement("path", {
    fill: "#FFF",
    d: "m7 11.09 2.667 1.13v6.353L16 14.786l6.394 3.787V12.22L25 11.09v11.974l-9-5.315-9 5.315zm.303-.489L16 5.5l8.758 5.101-2.364.978L16 7.883l-6.333 3.696zm1.879 11.821 1.97-1.13 4.878 2.825 4.818-2.825 2.03 1.13L16.03 26.5l-6.848-4.078z"
}))));
function rg() {
    return rg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    rg.apply(this, arguments)
}
const mF = e=>M.createElement("svg", rg({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    style: {
        enableBackground: "new 0 0 1000 1000"
    },
    viewBox: "0 0 1000 1000"
}, e), M.createElement("path", {
    d: "M500 0c276.1 0 500 223.9 500 500s-223.9 500-500 500S0 776.1 0 500 223.9 0 500 0",
    style: {
        fillRule: "evenodd",
        clipRule: "evenodd",
        fill: "#263145"
    }
}), M.createElement("path", {
    d: "M530.7 177h-69.9L172 680h514.8L650 620H276z",
    style: {
        fillRule: "evenodd",
        clipRule: "evenodd",
        fill: "#ccd9e2"
    }
}), M.createElement("path", {
    d: "m785.3 739 35.7-60.5L529.7 177 275 620h70l185.7-323.5z",
    style: {
        fillRule: "evenodd",
        clipRule: "evenodd",
        fill: "#aaa"
    }
}), M.createElement("path", {
    d: "m172 680 35.7 59h577.6L530.7 295.1l-35.2 62L684.4 680z",
    style: {
        fillRule: "evenodd",
        clipRule: "evenodd",
        fill: "#5a5967"
    }
}));
var Hx, Ux;
function sg() {
    return sg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    sg.apply(this, arguments)
}
const vF = e=>M.createElement("svg", sg({
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    id: "klay_svg__Layer_1",
    x: 0,
    y: 0,
    style: {
        enableBackground: "new 0 0 2000 1975.1"
    },
    viewBox: "0 0 2000 1975.1"
}, e), Hx || (Hx = M.createElement("style", null, ".klay_svg__st0{fill:#4f473b}")), Ux || (Ux = M.createElement("path", {
    d: "m1047.4 982.5 683.3 678.3c359.1-380.9 359.1-975.7 0-1356.6M997.5 1027.4l-673.3 668.3L997.5 1975l673.3-279.3M972.6 957.6l698.3-693.3L1027.4 0 389 1541.2zM0 982.5c-.5 252.3 95.9 495.1 269.3 678.3l668.3-1611",
    className: "klay_svg__st0"
})));
var Gx;
function og() {
    return og = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    og.apply(this, arguments)
}
const yF = e=>M.createElement("svg", og({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), Gx || (Gx = M.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#DE3F6B"
}), M.createElement("path", {
    fill: "#FFF",
    fillRule: "nonzero",
    d: "M9.752 11h.904c1.413.134 2.72.821 3.687 1.81 2.009 2.039 3.113 4.916 5.67 6.433 1.848 1.097 4.433.2 5.341-1.654.462-.008.927-.008 1.389-.006-.636 1.883-2.489 3.236-4.515 3.417h-.746c-1.247-.1-2.46-.564-3.403-1.366-1.37-1.123-2.25-2.664-3.315-4.036-.916-1.213-1.85-2.577-3.366-3.128-1.873-.679-4.16.383-4.843 2.187-.6 1.486-.112 3.328 1.23 4.28 1.006.752 2.407 1.033 3.615.595 1.342-.468 2.338-1.532 3.102-2.66.301.417.594.84.884 1.266-1.188 1.447-2.836 2.69-4.796 2.862h-.803C7.317 20.834 5.17 18.804 5 16.406v-.785c.16-2.393 2.28-4.447 4.752-4.621zm11.68 0h.75c2.493.157 4.613 2.228 4.818 4.626v1.23c-2.057.018-4.116.006-6.173.008.002-.36.002-.717 0-1.077 1.626-.004 3.25.007 4.873-.004-.115-.636-.264-1.287-.654-1.826-.95-1.404-2.959-1.978-4.565-1.37-1.28.46-2.244 1.466-2.987 2.54-.286-.397-.57-.8-.845-1.206 1.173-1.468 2.81-2.738 4.783-2.921"
}))));
var Xx, Yx, $x, Kx, Qx, qx, Zx, Jx, e5, t5, n5, i5, r5, s5, o5, a5, l5, c5, u5, h5, d5, f5, p5, g5, m5, v5, y5, x5, b5, w5, S5, C5, k5, A5, M5, E5, P5, T5, j5, O5, L5, R5, _5, D5, N5, F5, I5, B5, z5, V5, W5, H5, U5, G5, X5, Y5, $5, K5, Q5, q5, Z5, J5, e4, t4, n4, i4, r4, s4, o4, a4, l4, c4, u4, h4, d4, f4, p4, g4, m4, v4, y4, x4, b4, w4, S4, C4, k4, A4, M4, E4, P4, T4, j4, O4, L4, R4, _4, D4, N4, F4, I4, B4, z4, V4, W4, H4, U4, G4, X4;
function ag() {
    return ag = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    ag.apply(this, arguments)
}
const xF = e=>M.createElement("svg", ag({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 156.814 211.713"
}, e), Xx || (Xx = M.createElement("circle", {
    cx: 78.408,
    cy: 133.306,
    r: 78.407,
    fill: "#33348e"
})), Yx || (Yx = M.createElement("path", {
    fill: "none",
    stroke: "#fff",
    strokeWidth: .724,
    d: "M72.646 205.679C25.741 151.516 46.314 63.732 78.408 55.233m5.759 150.446c46.906-54.164 26.333-141.947-5.759-150.446"
})), $x || ($x = M.createElement("path", {
    fill: "none",
    stroke: "#fff",
    strokeWidth: .724,
    d: "M85.098 206.864c33.265-5.958 63.093-36.959 63.093-77.555 0-43.302-26.482-74.411-69.783-74.411-39.843 0-75.337 31.109-75.337 74.411 0 40.795 33.588 71.691 68.826 77.604"
})), Kx || (Kx = M.createElement("ellipse", {
    cx: 78.422,
    cy: 207.151,
    fill: "none",
    stroke: "#fff",
    strokeWidth: .724,
    rx: 6.75,
    ry: 3.213
})), Qx || (Qx = M.createElement("path", {
    fill: "#fff",
    d: "M40.919 189.967 21.73 168.784l14.426-13.004 4.096 4.505-8.555 7.732 3.194 3.516 5.55-5.129 4.096 4.506-5.55 5.129 7.804 8.655-5.872 5.273zm42.093.366c-.746 1.713-2.414 2.701-4.604 2.701-3.454 0-5.543-2.039-5.543-5.311 0-3.255 2.293-5.282 5.208-5.282 2.26 0 3.814.763 4.627 2.127l6.841-5.368c-2.108-3.538-6.14-5.519-12-5.519-7.564 0-13.51 5.257-13.51 13.704 0 8.484 5.419 13.775 14.375 13.775 5.684 0 10.013-2.567 11.946-7.007l-7.34-3.82zm38.683-24.938.949.353c1.667.875 4.047 2.491 2.92 4.642-1.043 1.991-2.746 1.998-4.581 1.038l-1.982-.896 2.694-5.137-4.453-9.285-14.105 26.853 7.282 3.889 5.754-10.926 1.516.679c6.897 3.615 11.029 1.842 13.639-3.134 2.492-4.751 1.341-9.315-5.558-12.933l-8.528-4.429m22.632-54.066c3.644.941 7.522 2.821 10.108 5.172l.469 2.232c-1.644-1.528-6.463-4.115-9.871-4.936l-.706-2.468zm1.527 6.583c3.644.938 7.523 2.82 10.108 5.169l.47 2.234c-1.645-1.527-6.465-4.113-9.873-4.938l-.705-2.465zm.705 6.581c3.644.94 7.521 2.82 10.107 5.171l.117 2.115c-1.644-1.528-6.464-4.113-9.872-4.937l-.352-2.349zm.353 6.58c3.645.941 7.523 2.82 10.108 5.172l-.119 2.116c-1.645-1.529-6.463-4.114-9.872-4.936l-.117-2.352z"
})), qx || (qx = M.createElement("path", {
    fill: "#65493c",
    d: "M102.031 57.384c-10.314-7.45-36.854-5.637-47.717.234"
})), Zx || (Zx = M.createElement("path", {
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M48.554 35.17c-3.172.234-7.52-.438-9.754-1.529-2.234-1.09-4.466.237-6.699 1.881.471-1.881 2-3.174 4.583-4.113-1.527-.354-4.818-1.646-6.111-3.644 3.527 1.058 7.051 1.058 9.754.47 2.704-.587 7.759-.705 10.108 2.233m53.71-3.173c2.585-.234 4.583-.234 6.581 2.351 1.999 2.585 7.053 2.468 8.227-.939.118 1.763-.704 4.112-.704 4.112 1.88-.822 3.173-1.881 3.877-2.702-.353 3.172-4.114 12.339-16.57 6.228M66.537 10.254c-1.646-1.058-4.466-2.232-5.994-.94-1.527 1.293-3.526 1.997-4.701.586.705 1.177 2.937 2.118 4.583.825 1.645-1.293 3.407-1.058 4.348 0"
})), Jx || (Jx = M.createElement("path", {
    fill: "#cf8c2c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M74.528 17.07c-.117-1.998-2.409-7.144-3.643-5.17-.587.94-2.114 1.057-2.82.47-.705-.588-2.703-1.059-3.526-.47-.823.587-2.351 0-2.351-.94 0-.941.824-1.292 1.998-1.06 1.177.237 4.114.237 4.818-.351.706-.588-.116-1.881-1.762-1.999-1.645-.116-5.759-.234-6.816 1.058-.942-1.058-1.293-4.348 1.057-3.996 2.35.353 2.703-.587 3.174-1.293.469-.704 1.998-1.527 3.643-1.646 1.646-.117 2.821-.468 4.584 0 1.762.47 2.35 0 2.585-.823.94 1.411.94 2.703.705 3.174 1.645-.471 4.231.117 4.702 1.176.47 1.057 1.175.94 2.115.94.942 0 1.645.235 1.998 1.645.353 1.41 1.175.472 1.881.823.704.353 2.703 1.175 3.056 2.351.352 1.175 1.292 1.527 2.937 2.585"
})), e5 || (e5 = M.createElement("path", {
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M49.259 26.12c-.117-1.88-2.115-3.995-3.525-5.288-1.41-1.293-1.292-3.174.823-4.701 2.115-1.527 10.341-4.936 16.571-3.057 6.229 1.882 19.275 3.174 30.087-1.056l11.283 12.222"
})), t5 || (t5 = M.createElement("path", {
    fill: "#7b002b",
    stroke: "#000",
    strokeWidth: .724,
    d: "M96.858 22.594c5.76 2 9.051.706 9.168-.587.117-1.293-3.555-.97-4.966-.852-1.057.087-2.827.026-3.097-.357"
})), n5 || (n5 = M.createElement("path", {
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M97.963 20.798c.271.383 2.04.444 3.097.357 1.411-.118 5.083-.441 4.966.852.235-.646-.059-1.762-.412-2.468h-7.522"
})), i5 || (i5 = M.createElement("path", {
    fill: "#7b002b",
    stroke: "#000",
    strokeWidth: .724,
    d: "M107.555 18.716c.94 1.059 0 2.939-2.469 2.234-2.468-.705-5.524-1.469-6.817-.647-.323.205-.398.368-.306.496-.325-.351-.252-1.701-.694-2.464l8.287-1.058"
})), r5 || (r5 = M.createElement("path", {
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M96.675 17.895c-.014.619.726 1.07 2.77.586 4.466-1.057 7.168-.823 8.11.235-.177-.646-.766-1.822-1-2.585H95.977"
})), s5 || (s5 = M.createElement("path", {
    fill: "#7b002b",
    stroke: "#000",
    strokeWidth: .724,
    d: "M93.687 16.602c-.118-1.059 1.76-3.291 3.995-2.586 2.233.706 5.29.588 6.935-.353 1.645-.94 4.112-.94 5.288-.117.94.94 0 3.172-1.646 3.643-1.646.47-7.052-.821-9.285-.94-1.211-.064-2.283.91-2.299 1.646-.522-1.118-.933-1.411-1.345-1.764-.469.236-1.233.881-1.643.471z"
})), o5 || (o5 = M.createElement("path", {
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M109.904 13.545c-.94-.941-1.176-2.115-1.881-3.645-.705-1.526-1.762-2.584-4.112-.821-2.351 1.764-7.405.821-9.403.354-1.998-.471-3.408 0-3.644 1.293-.234 1.292 1.411 4.583 2.822 5.876-.118-1.059 1.76-3.291 3.995-2.586 2.233.706 5.29.588 6.935-.353 1.645-.94 4.113-.94 5.288-.118z"
})), a5 || (a5 = M.createElement("path", {
    fill: "#cf8c2c",
    stroke: "#000",
    strokeWidth: .724,
    d: "m105.556 46.217 3.056-4.112c5.759-5.171-.94-9.757-3.408-11.049 5.055-6.581-.353-8.579-1.88-8.226-.588-1.292-2.352-1.88-3.645-1.998-1.292-.118-2.35.233-3.407-.823-1.058-1.057-4.232-1.175-6.935.354-2.702 1.527-7.169 1.879-9.754.117-2.586-1.764-8.581-.941-10.812 1.175-2.234 2.114-4.232 3.878-8.228-.471-5.455-5.935-12.34 1.41-11.752 5.876.587 4.466-1.529 8.11-4.349 8.698l5.642 9.166"
})), l5 || (l5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M78.408 36.234c1.135 3.001 7.836 3.729 9.768.978.796 3 6.017 3.972 7.948 1.595.568 3.002 5.793 4.253 7.156 3.002 1.023 2.877 4.542 3.251 6.475 1.251l1.93-2.252c1.591.126 1.818-1.125 2.613-2.124.795-1.002 1.478-1.501 3.408-1.751-.568-.626-.908-1.626-2.043-1.376l-4.318-2.501-2.613 5.252 1.363.875c-3.407 5.003-6.134 2.126-5.679-1.501l-1.25-.251c-1.478 3.753-5.225 2.877-5.225-1.25l-1.705-.624c-2.044 3.751-7.266 2.407-7.153-2.143l-1.703-.125c-.228 4.298-7.952 4.196-8.974-1.057-1.023 5.253-8.748 5.003-8.975.704l-1.704.125c.114 4.549-5.225 5.425-7.268 1.672l-1.706.626c0 4.126-3.749 5.002-5.226 1.25l-1.25.25c.456 3.627-2.271 6.503-5.678 1.5l1.362-.875-2.613-5.253-4.315 2.501c-1.137-.25-1.478.751-2.045 1.377 1.931.25 2.612.75 3.408 1.75.794 1.001 1.022 2.251 2.612 2.126l1.931 2.25c1.932 2.001 5.454 1.626 6.476-1.25 1.364 1.25 6.589 0 7.157-3.001 1.931 2.376 7.27 1.876 8.064-1.126 1.932 2.752 8.635 2.377 9.772-.624z"
})), c5 || (c5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M73.824 26.12h9.167v7.992h-9.167zm28.047 11.006.046-7.726-8.863-2.344-.045 7.726zm-46.928 0 .071-7.726 8.863-2.344-.072 7.726z"
})), u5 || (u5 = M.createElement("circle", {
    cx: 52.199,
    cy: 35.522,
    r: 2.161,
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724
})), h5 || (h5 = M.createElement("circle", {
    cx: 68.416,
    cy: 31.174,
    r: 2.161,
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724
})), d5 || (d5 = M.createElement("circle", {
    cx: 104.616,
    cy: 35.522,
    r: 2.161,
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724
})), f5 || (f5 = M.createElement("circle", {
    cx: 88.396,
    cy: 31.174,
    r: 2.161,
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724
})), p5 || (p5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M102.031 57.384c-10.314-7.45-36.854-5.637-47.717.234-1.764.234-3.174-2.585-1.645-3.997l-2.468-6.464c-1.059-.116-1.764-1.41-1.059-2.467.705-1.058 9.52-5.877 29.266-5.877 19.744 0 27.384 6.346 28.323 7.287.941.941.471 2.586-.705 2.586l-2.82 4.7c.939 1.41 0 3.761-1.175 3.998z"
})), g5 || (g5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M106.026 48.686c1.176 0 1.646-1.645.705-2.586-.939-.941-8.579-7.287-28.323-7.287-19.746 0-28.561 4.819-29.266 5.877-.705 1.057 0 2.351 1.059 2.467 3.995-1.88 15.867-5.17 28.677-5.17 10.106 0 21.976 2.821 27.148 6.699zm-3.995 8.698c-10.314-7.45-36.854-5.637-47.717.234-1.764.234-3.174-2.585-1.645-3.997 3.408-1.879 16.806-4.936 25.739-4.936 8.931 0 20.919 2.585 24.798 4.7.939 1.411 0 3.762-1.175 3.999z"
})), m5 || (m5 = M.createElement("circle", {
    cx: 78.408,
    cy: 45.394,
    r: 2.742,
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724
})), v5 || (v5 = M.createElement("circle", {
    cx: 63.128,
    cy: 46.804,
    r: 2.742,
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724
})), y5 || (y5 = M.createElement("circle", {
    cx: 53.844,
    cy: 49.391,
    r: 2.743,
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724
})), x5 || (x5 = M.createElement("circle", {
    cx: 92.746,
    cy: 46.804,
    r: 2.742,
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724
})), b5 || (b5 = M.createElement("circle", {
    cx: 102.031,
    cy: 49.391,
    r: 2.743,
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724
})), w5 || (w5 = M.createElement("circle", {
    cx: 58.356,
    cy: 47.914,
    r: 1.191,
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724
})), S5 || (S5 = M.createElement("circle", {
    cx: 69.287,
    cy: 45.563,
    r: 1.192,
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724
})), C5 || (C5 = M.createElement("circle", {
    cx: 97.401,
    cy: 47.914,
    r: 1.191,
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724
})), k5 || (k5 = M.createElement("path", {
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M86.471 46.755a1.191 1.191 0 1 1-.002-2.382 1.191 1.191 0 0 1 .002 2.382z"
})), A5 || (A5 = M.createElement("path", {
    fill: "#fff",
    stroke: "#000",
    strokeWidth: .724,
    d: "M78.408 137.536c.821-2.115 3.996-2.938 6.699-2.938h20.568c1.997 0 3.407-2.232 3.407-3.877V57.618h-61.35v73.102c0 1.645 1.41 3.877 3.408 3.877h20.567c2.704.001 5.877.824 6.701 2.939z"
})), M5 || (M5 = M.createElement("path", {
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M48.908 58.794h28.558v36.433H48.908z"
})), E5 || (E5 = M.createElement("path", {
    fill: "#fff",
    stroke: "#000",
    strokeWidth: .724,
    d: "M79.346 58.794h28.56v36.433h-28.56zm-1.88 74.511V96.872H48.908v33.73c0 1.176 1.057 2.703 2.468 2.703h26.09z"
})), P5 || (P5 = M.createElement("path", {
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M107.906 130.249V96.872h-28.56v36.433h25.975c1.175 0 2.585-1.645 2.585-3.056z"
})), T5 || (T5 = M.createElement("path", {
    d: "M78.408 170.014c-6.059 0-10.971-4.911-10.971-10.969 0-6.059 4.912-10.97 10.971-10.97 6.058 0 10.969 4.911 10.969 10.97 0 6.058-4.912 10.969-10.969 10.969v.998c6.608 0 11.967-5.359 11.967-11.967 0-6.609-5.359-11.968-11.967-11.968-6.61 0-11.967 5.359-11.967 11.968 0 6.608 5.357 11.967 11.967 11.967"
})), j5 || (j5 = M.createElement("path", {
    fill: "#fff",
    stroke: "#000",
    strokeWidth: .724,
    d: "m77.115 164.215.822 5.288h1.058l.705-5.288m-6.418-3.705-4.169 3.358.53.914 4.932-2.032m0-7.412-4.992-1.931-.529.917 4.228 3.254m6.418-3.705-.825-5.289h-1.056l-.704 5.289m6.417 3.704 4.168-3.358-.528-.914-4.933 2.033m0 7.411 4.992 1.932.528-.917-4.227-3.255"
})), O5 || (O5 = M.createElement("circle", {
    cx: 78.408,
    cy: 159.043,
    r: 5.678,
    fill: "#fff",
    stroke: "#000",
    strokeWidth: .724
})), L5 || (L5 = M.createElement("circle", {
    cx: 78.408,
    cy: 159.044,
    r: 3.045,
    fill: "#fff",
    stroke: "#000",
    strokeWidth: .724
})), R5 || (R5 = M.createElement("path", {
    fill: "#259271",
    d: "M116.486 124.961c-1.058.94-1.411 2.35-1.645 3.174-.353-.706-1.53.235-1.53 1.88-.351-.352-1.292 1.88-1.056 3.291-.705 0-.709 2.8-.587 3.996-.588.235-.588 1.292-.471 2.585l1.058 1.411c1.88-.94 4.23-3.29 3.172-3.172.588-1.881 1.177-3.644.588-3.174.94-2.35 1.292-4.114.704-3.761.94-1.293 1.999-2.702 1.292-2.468 1.177-1.176 2.469-2.586 1.646-2.469.941-.704 1.293-1.292 1.293-1.646"
})), _5 || (_5 = M.createElement("path", {
    fill: "#259271",
    d: "M121.54 124.607c-.234 1.293.116 2.352.47 3.41-.704-.237-.821.118-.47 1.41-.705.235-.352 2.233.353 3.525-.47.353-.587 1.529-.119 2.587-.705 0-1.174 2.819-1.058 3.642-.704-.235-1.41.939-2.115 1.997-.353-.586-1.41-.351-2.116.588-.47-.234-3.878.941-4.818 1.765l.351 3.29c1.411.471 4.82.234 3.998-.705 1.644.117 3.642-.94 2.937-1.176 2.116-.352 3.762-1.762 2.939-1.88 1.644-.939 2.703-2.82 1.88-2.82 1.057-.471 3.057-3.76 1.879-3.644 1.06-1.41 1.178-4.583.236-3.644.354-1.644.354-4.23-.469-3.525.233-1.881.585-3.174-.236-2.703.117-.824.236-1.764 0-2.234m-46.774 16.689c2.115-1.058 2.819-.705 2.703.118 1.762-.234 4.23.236 3.409 1.059 1.527-.589 3.877-.235 3.172.823 1.528-.47 3.291-1.529 3.291-.706 1.763-.94 4.231-1.058 3.525 0 1.293-.352 2.703-.94 3.878-.587l.117 2.232c-.822.94-2.702 1.41-3.524 1.763.705.47-.118.94-1.411.588 0 .469-1.646 1.057-3.056.234.117.588-.824.823-1.881-.117-.235.469-.705.94-2.232-.353-.472.235-1.411 0-2.117-.94-.469.47-1.762 0-2.585-.94-.705.354-.822.236-1.527-.587-.706-.823-1.059-1.41-1.763-1.527"
})), D5 || (D5 = M.createElement("path", {
    fill: "#259271",
    d: "M78.408 145.881c1.175.822 3.878.118 4.583 1.528.471-.235 1.292 0 1.645.823.824-.352 2 0 2.468.941 1.176-.235 2.233 0 3.056.705.941-.705 1.881-.94 2.233-.119 1.644-1.292 3.291-2.116 3.291-.821.47-.706 2.351-1.764 3.174-1.764l.47 1.174c-.587 1.177-1.88 2.352-2.469 2.704.471.353-.822 1.176-1.411 1.411.237.706-.822 1.292-1.878.822-.236.823-1.293.588-2.821-.588.117.824-2.115 1.292-3.174.588-.588.47-2.585-.235-3.172-1.41-.706.353-1.763 0-2.233-1.058-.705.587-1.41.235-1.763-.939-.822.234-2.115-1.412-1.997-3.057m38.428-54.885c-1.175.94-1.88 1.999-.939 2.938-.824.939-1.88 1.646-.941 3.057-.236 1.292.117 2.35.941 2.938-.706.705-1.058 2.937 0 3.408-.236 1.175-.471 1.645.821 2.351-.587.94-.353 3.526.706 4.819h2.938c.118-1.881.352-3.997-.235-4.819.235-.94.471-2.469-.234-3.174.469-1.41.351-3.759-.237-3.172.706-2.233.119-4.114-.469-3.409.706-1.879 1.056-3.408.469-3.173.354-.94 1.998-3.174.706-2.821m1.645.234c-.354 1.41.823 2.468 1.292 3.29-1.058-.117-.47.942.353 2.585-.94 0-.823.707-.353 2.705-.704.116-.704 1.644-.354 2.937-.704.235-.35 1.764-.116 2.939-.588.234-.588 1.646-.352 2.703-.471.117-1.529 2.585-1.058 3.526l2.232.352c1.528-1.527 2.938-3.995 2.116-3.761 1.292-1.762 2.82-5.405 1.527-4.937.824-1.527 1.411-4.465.471-3.877.234-1.999 0-4.23-.471-3.409.236-1.41-.586-3.643-.938-2.938-.118-.823-.118-2.116-1.059-2.704m-8.503-29.338c-.897.899-1.133 2.192-.545 2.779-.587 1.174.354 2.468 1.058 3.055-.823 1.411-.704 3.41 0 3.762-.588.823-.823 2.233-.117 2.82-.706 1.057-.353 2.82.821 3.761l2.587.118c0-1.528.352-2.585-.354-3.644-.704-1.057 0-1.527 0-2.703s0-1.176-.587-2.351c-.587-1.174 1.176-3.408.237-4.466-.942-1.056-.354-2.938-.824-3.878s-.587-.94-1.174-1.292"
})), N5 || (N5 = M.createElement("path", {
    fill: "#259271",
    d: "M119.777 57.971c.235 1.057.469 2.232 1.175 3.171.704.942.354 1.411.941 2.822.588 1.41.234 2.116-.119 3.291-.352 1.175.119 1.881.588 3.057.47 1.174-.236 1.88-.353 2.82-.117.94-1.527 3.761-.47 4.818h2.115c.704-1.293.823-2.115.704-3.055-.116-.941.236-1.528.824-2.115.587-.587 1.058-2.585.469-3.057-.585-.47-.704-1.527-.233-1.996.469-.471.469-1.528.116-1.764.47-.706.824-2.117.236-2.585.234-1.175 0-2.352-1.175-2.703.117-.942-2.351-3.997-3.407-3.997m-80.86 68.283c1.058.94 1.411 2.35 1.646 3.174.353-.706 1.528.235 1.528 1.88.353-.352 1.292 1.88 1.057 3.291.706 0 .709 2.8.588 3.996.587.235.587 1.292.47 2.585l-1.058 1.411c-1.88-.94-4.231-3.29-3.173-3.172-.587-1.881-1.176-3.644-.587-3.174-.94-2.35-1.293-4.114-.706-3.761-.939-1.293-1.998-2.702-1.292-2.468-1.176-1.176-2.469-2.586-1.646-2.469-.94-.704-1.293-1.292-1.293-1.646"
})), F5 || (F5 = M.createElement("path", {
    fill: "#259271",
    d: "M35.275 124.607c.235 1.293-.118 2.352-.471 3.41.706-.237.823.118.471 1.41.704.235.352 2.233-.354 3.525.471.353.589 1.529.117 2.587.706 0 1.176 2.819 1.059 3.642.705-.235 1.41.939 2.115 1.997.353-.586 1.41-.351 2.115.588.47-.234 3.879.941 4.819 1.765l-.353 3.29c-1.411.471-4.819.234-3.996-.705-1.645.117-3.644-.94-2.937-1.176-2.117-.352-3.761-1.762-2.939-1.88-1.646-.939-2.702-2.82-1.881-2.82-1.058-.471-3.055-3.76-1.88-3.644-1.058-1.41-1.175-4.583-.234-3.644-.353-1.644-.353-4.23.47-3.525-.235-1.881-.588-3.174.235-2.703-.117-.824-.235-1.764 0-2.234m46.777 16.689c-2.116-1.058-2.82-.705-2.703.118-1.764-.234-4.232.236-3.409 1.059-1.528-.589-3.879-.235-3.173.823-1.528-.47-3.291-1.529-3.291-.706-1.761-.94-4.23-1.058-3.525 0-1.292-.352-2.704-.94-3.878-.587l-.118 2.232c.823.94 2.704 1.41 3.526 1.763-.706.47.118.94 1.411.588 0 .469 1.645 1.057 3.055.234-.118.588.822.823 1.881-.117.234.469.705.94 2.232-.353.47.235 1.41 0 2.116-.94.47.47 1.764 0 2.586-.94.704.354.821.236 1.527-.587.705-.823 1.059-1.41 1.764-1.527"
})), I5 || (I5 = M.createElement("path", {
    fill: "#259271",
    d: "M78.408 145.881c-1.176.822-3.88.118-4.584 1.528-.471-.235-1.293 0-1.646.823-.821-.352-1.997 0-2.468.941-1.174-.235-2.231 0-3.054.705-.941-.705-1.881-.94-2.233-.119-1.646-1.292-3.292-2.116-3.292-.821-.469-.706-2.351-1.764-3.173-1.764l-.47 1.174c.587 1.177 1.88 2.352 2.469 2.704-.471.353.821 1.176 1.41 1.411-.235.706.823 1.292 1.882.822.233.823 1.292.588 2.821-.588-.119.824 2.114 1.292 3.172.588.587.47 2.584-.235 3.173-1.41.704.353 1.764 0 2.232-1.058.706.587 1.41.235 1.764-.939.823.234 2.115-1.412 1.999-3.057M39.975 91.936c1.176.94 1.881 1.999.94 2.938.824.939 1.881 1.646.941 3.057.234 1.292-.117 2.35-.941 2.938.706.705 1.058 2.937 0 3.408.236 1.175.47 1.645-.823 2.351.588.94.354 3.526-.705 4.819H36.45c-.119-1.881-.353-3.997.234-4.819-.234-.94-.47-2.469.236-3.174-.47-1.41-.352-3.759.234-3.172-.705-2.233-.118-4.114.47-3.409-.704-1.879-1.056-3.408-.47-3.173-.352-.94-1.997-3.174-.705-2.821m-1.645.234c.353 1.41-.821 2.468-1.292 3.29 1.058-.117.471.942-.353 2.585.941 0 .824.707.353 2.705.706.116.706 1.644.353 2.937.705.235.353 1.764.118 2.939.587.234.587 1.646.351 2.703.47.117 1.527 2.585 1.059 3.526l-2.233.352c-1.528-1.527-2.938-3.995-2.116-3.761-1.293-1.762-2.821-5.405-1.528-4.937-.823-1.527-1.411-4.465-.47-3.877-.234-1.999 0-4.23.47-3.409-.234-1.41.588-3.643.94-2.938.118-.823.118-2.116 1.059-2.704m8.502-29.338c.898.899 1.134 2.192.546 2.779.588 1.174-.354 2.468-1.059 3.055.823 1.411.705 3.41 0 3.762.587.823.823 2.233.117 2.82.706 1.057.353 2.82-.822 3.761l-2.585.118c0-1.528-.353-2.585.354-3.644.704-1.057 0-1.527 0-2.703s0-1.176.586-2.351c.588-1.174-1.175-3.408-.234-4.466.941-1.056.353-2.938.822-3.878.47-.94.587-.94 1.174-1.292"
})), B5 || (B5 = M.createElement("path", {
    fill: "#259271",
    d: "M37.037 57.971c-.234 1.057-.468 2.232-1.175 3.171-.704.942-.351 1.411-.94 2.822-.587 1.41-.235 2.116.117 3.291.354 1.175-.117 1.881-.587 3.057-.469 1.174.234 1.88.353 2.82.117.94 1.527 3.761.471 4.818H33.16c-.706-1.293-.823-2.115-.706-3.055.118-.941-.234-1.528-.823-2.115-.587-.587-1.058-2.585-.47-3.057.587-.47.706-1.527.235-1.996-.47-.471-.47-1.528-.117-1.764-.471-.706-.824-2.117-.236-2.585-.235-1.175 0-2.352 1.176-2.703-.119-.942 2.351-3.997 3.408-3.997"
})), z5 || (z5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m126.476 125.284-2.586-8.316h-6.464l-2.585 8.316zm-9.05-12.193h6.464v3.877h-6.464zm6.464 0h-6.464l-2.351-2.468c.706-.824 1.176-.824 1.881-1.059l1.057 1.293h1.294v-1.763h2.349v1.88h1.529l.705-1.293c.822.471 1.645 1.057 1.998 1.528z"
})), V5 || (V5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M119.545 113.091h1.981v3.877h-1.981zm-1.532 12.193.823-3.848c.354-1.88 2.469-1.88 3.057 0l.939 3.848h-4.819zm8.463-33.494-2.586-8.316h-6.464l-2.585 8.316zm-9.05-12.195h6.464v3.878h-6.464zm6.464 0h-6.464l-2.351-2.467c.706-.824 1.176-.824 1.881-1.058l1.057 1.292h1.294V75.6h2.349v1.88h1.529l.705-1.293c.822.47 1.645 1.057 1.998 1.527l-1.998 1.881z"
})), W5 || (W5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M119.545 79.595h1.981v3.878h-1.981zm-1.532 12.195.823-3.851c.354-1.88 2.469-1.88 3.057 0l.939 3.851h-4.819zm5.254-36.058-7.335-4.693-4.943 4.167 3.382 8.023zM108.488 52.234l4.942-4.164 2.5 2.967-4.942 4.164z"
})), H5 || (H5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m113.431 48.074-4.942 4.165-3.388-.372c.01-1.083.368-1.387.756-2.021l1.641.306.99-.833-1.136-1.347 1.797-1.515 1.212 1.437 1.167-.984-.293-1.443c.932-.17 1.939-.251 2.513-.118l-.317 2.725zM110.117 50.872l1.515-1.277 2.5 2.965-1.515 1.277zM116.796 61.186l-1.851-3.474c-.943-1.664.675-3.028 2.336-1.97l3.199 2.338-3.684 3.106zm-18.135 90.45 7.928-3.601-.806-6.413-8.573-1.529zM109.632 141.144l.807 6.415-3.848.484-.806-6.415z"
})), U5 || (U5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m110.438 147.553-.807-6.415 2.156-2.64c.905.596.963 1.062 1.284 1.734l-1.149 1.209.16 1.284 1.75-.22.292 2.332-1.865.233.189 1.517 1.372.539c-.365.875-.846 1.765-1.268 2.173zM109.884 143.24l.247 1.966-3.849.482-.246-1.966zM97.606 143.243l3.922.334c1.91.116 2.174 2.216.38 3.032l-3.701 1.414zm-67.268-17.959 2.586-8.316h6.464l2.585 8.316zm2.586-12.193h6.463v3.877h-6.463zm0 0h6.463l2.351-2.468c-.706-.824-1.175-.824-1.881-1.059l-1.058 1.293h-1.293v-1.763h-2.35v1.88h-1.528l-.705-1.293c-.824.471-1.645 1.057-1.998 1.528z"
})), G5 || (G5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M35.288 113.091h1.981v3.877h-1.981zm3.512 12.193-.822-3.848c-.354-1.88-2.468-1.88-3.057 0l-.938 3.848zM30.338 91.79l2.586-8.316h6.464l2.585 8.316zm2.586-12.195h6.463v3.878h-6.463zm0 0h6.463l2.351-2.467c-.706-.824-1.175-.824-1.881-1.058L38.8 77.362h-1.293V75.6h-2.35v1.88h-1.528l-.705-1.293c-.824.47-1.645 1.057-1.998 1.527l1.998 1.881z"
})), X5 || (X5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M35.288 79.595h1.981v3.878h-1.981zM38.8 91.79l-.822-3.851c-.354-1.88-2.468-1.88-3.057 0l-.938 3.851zm-5.254-36.058 7.337-4.693 4.942 4.167-3.381 8.023z"
})), Y5 || (Y5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m45.824 55.205-4.942-4.165 2.5-2.966 4.941 4.165zM43.382 48.074l4.942 4.165 3.389-.372c-.01-1.083-.37-1.387-.758-2.021l-1.641.306-.989-.833 1.136-1.347-1.797-1.515-1.21 1.437-1.169-.984.294-1.443c-.931-.17-1.939-.251-2.513-.118l.316 2.725z"
})), $5 || ($5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m44.203 53.835-1.514-1.277 2.5-2.964 1.514 1.277zM40.017 61.186l1.852-3.474c.943-1.664-.675-3.028-2.337-1.97l-3.199 2.338 3.684 3.106zm18.135 90.45-7.927-3.601.806-6.413 8.571-1.529zM51.03 141.621l-.806 6.415-3.848-.484.806-6.414z"
})), K5 || (K5 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m46.376 147.553.806-6.415-2.158-2.64c-.903.596-.961 1.062-1.283 1.734l1.151 1.209-.161 1.284-1.75-.22-.293 2.332 1.865.233-.189 1.517-1.37.539c.363.875.842 1.765 1.267 2.173l2.115-1.746zM50.77 143.727l-.248 1.965-3.846-.485.248-1.965zM59.206 143.243l-3.92.334c-1.91.116-2.174 2.216-.381 3.032l3.702 1.414.599-4.78z"
})), Q5 || (Q5 = M.createElement("path", {
    d: "M110.258 73.836c-.825.705 0 2.351 1.056 1.292l1.881-1.997c1.059.705 2.117.821 3.41.94-2.117-1.292-4.467-3.878-5.054-5.758-.237 1.174.117 2.82.468 3.76l-1.761 1.763z"
})), q5 || (q5 = M.createElement("path", {
    d: "m113.078 71.016 14.456-14.22c1.057-.941 1.645-.823 2.349-.941-.233.588-.822 1.292-1.292 1.998L114.02 72.074m-3.619 34.683c-.894.612-.25 2.336.913 1.397l2.082-1.787c.977.813 2.016 1.042 3.29 1.297-1.966-1.509-4.028-4.331-4.412-6.263-.36 1.145-.185 2.816.066 3.79l-1.939 1.566z"
})), Z5 || (Z5 = M.createElement("path", {
    d: "m113.506 104.252 15.885-12.602c1.152-.825 1.725-.645 2.438-.687-.296.56-.956 1.199-1.499 1.85l-16.003 12.59m-6.239 29.233c-1.042.294-.989 2.132.416 1.616l2.546-1.02c.664 1.084 1.573 1.635 2.698 2.285-1.375-2.062-2.421-5.397-2.164-7.351-.709.968-1.081 2.611-1.155 3.611z"
})), J5 || (J5 = M.createElement("path", {
    d: "m111.833 133.262 19.095-6.825c1.356-.408 1.84-.054 2.529.135-.46.435-1.29.827-2.012 1.27l-19.204 6.775m-26.239 2.261c-.532-.944-2.304-.458-1.473.785l1.594 2.234c-.897.9-1.218 1.914-1.584 3.16 1.68-1.823 4.673-3.625 6.632-3.837-1.108-.459-2.791-.433-3.781-.271l-1.388-2.071z"
})), e4 || (e4 = M.createElement("path", {
    d: "m88.221 140.193 11.137 16.946c.717 1.221.487 1.774.466 2.488-.531-.344-1.108-1.058-1.708-1.656L87 140.91M46.557 73.836c.822.705 0 2.351-1.058 1.292l-1.88-1.997c-1.058.705-2.118.821-3.41.94 2.116-1.292 4.466-3.878 5.055-5.758.235 1.174-.118 2.82-.47 3.76l1.763 1.763z"
})), t4 || (t4 = M.createElement("path", {
    d: "m43.737 71.016-14.456-14.22c-1.058-.941-1.646-.823-2.35-.941.234.588.821 1.292 1.292 1.998l14.573 14.221m3.617 34.683c.893.612.251 2.336-.914 1.397l-2.082-1.787c-.978.813-2.017 1.042-3.29 1.297 1.967-1.509 4.03-4.331 4.414-6.263.358 1.145.183 2.816-.067 3.79z"
})), n4 || (n4 = M.createElement("path", {
    d: "M43.308 104.252 27.423 91.651c-1.153-.825-1.724-.645-2.437-.687.295.56.956 1.199 1.496 1.85l16.004 12.59m6.24 29.232c1.042.294.988 2.132-.417 1.616l-2.546-1.02c-.663 1.084-1.575 1.635-2.698 2.285 1.375-2.062 2.421-5.397 2.164-7.351.709.968 1.081 2.611 1.155 3.611z"
})), i4 || (i4 = M.createElement("path", {
    d: "m44.981 133.262-19.095-6.825c-1.354-.408-1.84-.054-2.529.135.461.435 1.291.827 2.014 1.27l19.202 6.775m26.239 2.261c.532-.944 2.306-.458 1.473.785l-1.594 2.234c.898.9 1.218 1.914 1.586 3.16-1.68-1.823-4.674-3.625-6.632-3.837 1.107-.459 2.789-.433 3.779-.271l1.388-2.071z"
})), r4 || (r4 = M.createElement("path", {
    d: "m68.593 140.193-11.137 16.946c-.717 1.221-.487 1.774-.466 2.488.53-.344 1.108-1.058 1.708-1.656l11.114-17.061"
})), s4 || (s4 = M.createElement("circle", {
    cx: 78.408,
    cy: 144.823,
    r: 3.656,
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724
})), o4 || (o4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M54.549 102.161c3.996-3.292 12.222-3.645 17.159-.353l1.998-1.646c-5.758-3.996-15.866-3.878-21.037.235"
})), a4 || (a4 = M.createElement("path", {
    fill: "#65493c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M66.655 101.809c.706-.354 1.998.117 2.116.939.117.824 1.318 2.893 3.643 2.235 2.324-.659.471-4.232 1.645-5.407-1.057.469-2.468 1.41-3.056 2.233-.587.822-1.175.47-1.41-.588-.235-1.059-1.293-1.527-1.881-.823-.588.704-1.057 1.411-1.057 1.411z"
})), l4 || (l4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m67.947 128.692 1.54-22.536h3.852l1.542 22.536z"
})), c4 || (c4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M68.767 116.499h5.173l1.881-2.468c-.563-.822-.941-.822-1.503-1.058l-.848 1.293h-1.035v-1.763h-1.881v1.881h-1.223l-.563-1.292c-.659.469-1.316 1.057-1.599 1.528zm4.222 12.193-.489-3.848c-.209-1.88-1.47-1.88-1.821 0l-.561 3.848h2.871zm-3.492-22.536h3.843l1.398-1.833c-.419-.611-.698-.611-1.118-.785l-.629.959h-.768v-1.31h-1.398v1.398h-.908l-.419-.961c-.49.349-.978.786-1.188 1.136z"
})), u4 || (u4 = M.createElement("path", {
    fill: "#65493c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M58.897 101.809c-.707-.354-1.999.117-2.117.939-.117.824-1.319 2.893-3.641 2.235-2.326-.659-.471-4.232-1.647-5.407 1.058.469 2.469 1.41 3.056 2.233.588.822 1.176.47 1.411-.588.234-1.059 1.293-1.527 1.88-.823a17.991 17.991 0 0 1 1.058 1.411z"
})), h4 || (h4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m57.605 128.692-1.541-22.536H52.21l-1.54 22.536z"
})), d4 || (d4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M56.784 116.499h-5.173l-1.882-2.468c.566-.822.943-.822 1.505-1.058l.847 1.293h1.034v-1.763h1.882v1.881h1.222l.565-1.292c.658.469 1.316 1.057 1.599 1.528zm-4.222 12.193.491-3.848c.209-1.88 1.471-1.88 1.82 0l.562 3.848zm3.492-22.536H52.21l-1.396-1.833c.418-.611.698-.611 1.117-.785l.629.959h.77v-1.31h1.398v1.398h.909l.417-.961c.489.349.98.786 1.188 1.136z"
})), f4 || (f4 = M.createElement("path", {
    fill: "#1879bf",
    stroke: "#000",
    strokeWidth: .724,
    d: "m59.837 115.795-.821 13.161h6.933l-1.058-13.397c-.117-.822 0-1.999.471-2.82.469-.822.352-3.41.352-5.171 0-1.764-.94-2.585-1.528-2.704l-1.292-.235h-1.175c-1.999.704-2.235 1.528-2.468 3.057-.234 1.528-.234 3.525-.588 4.348-.353.821-.235 3.054 1.174 3.761z"
})), p4 || (p4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m61.013 101.692-.587-1.882.939.587.705-.821.353 1.057 1.057-.823.472 1.176.705-.589-.824 2.116"
})), g4 || (g4 = M.createElement("path", {
    fill: "#e6ac86",
    stroke: "#000",
    strokeWidth: .724,
    d: "M61.013 104.394c-.137-.82-.353-3.057.47-3.057s2.35-.036 2.35 1.647c0 2.585-2.468 3.525-2.82 1.41zm-.704 8.579c-.825.94-.942 2.351-.118 2.585.823.236 1.411-.822 1.411-1.645-.001-.822-1.059-1.41-1.293-.94z"
})), m4 || (m4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M85.459 65.257c3.996-3.29 12.222-3.644 17.159-.353l1.998-1.644c-5.759-3.997-15.867-3.878-21.038.235"
})), v4 || (v4 = M.createElement("path", {
    fill: "#65493c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M97.564 64.904c.704-.351 1.997.118 2.114.941.118.821 1.319 2.891 3.645 2.231 2.325-.658.469-4.231 1.645-5.405-1.057.47-2.469 1.41-3.056 2.232-.587.823-1.176.47-1.411-.588-.234-1.056-1.293-1.527-1.88-.821a18.764 18.764 0 0 0-1.057 1.41z"
})), y4 || (y4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m98.857 91.79 1.542-22.538h3.851l1.542 22.538z"
})), x4 || (x4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M99.676 79.595h5.175l1.879-2.467c-.564-.824-.939-.824-1.505-1.058l-.846 1.292h-1.034V75.6h-1.882v1.88h-1.222l-.565-1.293c-.658.47-1.317 1.057-1.599 1.527l1.599 1.881zm4.223 12.195-.489-3.851c-.211-1.88-1.471-1.88-1.822 0l-.56 3.851h2.871zm-3.492-22.538h3.843l1.398-1.833c-.42-.611-.699-.611-1.119-.786l-.628.962h-.77v-1.311h-1.398v1.397h-.907l-.42-.959c-.489.348-.978.785-1.188 1.133l1.189 1.397z"
})), b4 || (b4 = M.createElement("path", {
    fill: "#65493c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M89.808 64.904c-.705-.351-1.998.118-2.116.941-.119.821-1.318 2.891-3.643 2.231-2.326-.658-.471-4.231-1.646-5.405 1.058.47 2.467 1.41 3.056 2.232.587.823 1.175.47 1.41-.588.234-1.056 1.292-1.527 1.88-.821.588.705 1.059 1.41 1.059 1.41z"
})), w4 || (w4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m88.515 91.79-1.541-22.538h-3.852L81.58 91.79z"
})), S4 || (S4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "M87.695 79.595h-5.174l-1.882-2.467c.566-.824.941-.824 1.506-1.058l.846 1.292h1.036V75.6h1.88v1.88h1.224l.564-1.293c.657.47 1.316 1.057 1.598 1.527l-1.598 1.881zM83.471 91.79l.491-3.851c.21-1.88 1.471-1.88 1.82 0l.562 3.851h-2.873zm3.492-22.538h-3.841l-1.398-1.833c.418-.611.699-.611 1.118-.786l.629.962h.768v-1.311h1.397v1.397h.909l.417-.959c.49.348.98.785 1.19 1.133l-1.189 1.397z"
})), C4 || (C4 = M.createElement("path", {
    fill: "#1879bf",
    stroke: "#000",
    strokeWidth: .724,
    d: "m90.747 78.891-.822 13.163h6.933l-1.057-13.399c-.118-.824 0-1.999.471-2.821.47-.823.352-3.408.352-5.172 0-1.761-.94-2.585-1.527-2.703l-1.293-.233h-1.176c-1.997.704-2.231 1.526-2.468 3.055-.234 1.528-.234 3.526-.587 4.348-.353.823-.236 3.056 1.174 3.762z"
})), k4 || (k4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m91.923 64.788-.589-1.882.941.589.705-.823.353 1.057 1.058-.823.47 1.176.704-.587-.821 2.114"
})), A4 || (A4 = M.createElement("path", {
    fill: "#e6ac86",
    stroke: "#000",
    strokeWidth: .724,
    d: "M91.923 67.49c-.137-.819-.353-3.055.47-3.055s2.351-.038 2.351 1.646c0 2.585-2.469 3.525-2.821 1.409zm-.706 8.58c-.821.94-.94 2.351-.117 2.585.823.236 1.41-.824 1.41-1.646s-1.058-1.409-1.293-.939z"
})), M4 || (M4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m106.496 130.573-1.419-4.564h-3.548l-1.419 4.564zm-1.419-4.577h-3.548l-.92-1.354c.387-.452.646-.452 1.033-.581l.21.709h.709v-.968h1.288v1.033h.47l.387-.71c.452.258.797.581.99.838l-.619 1.033z"
})), E4 || (E4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m101.852 130.573.451-2.112c.193-1.033 1.355-1.033 1.677 0l.517 2.112zm4.337-13.516-1.418-4.563h-3.547l-1.419 4.563zm-1.418-4.576h-3.547l-.92-1.355c.387-.452.644-.452 1.032-.579l.211.708h.708v-.967h1.291v1.033h.468l.388-.71c.45.256.797.581.99.838z"
})), P4 || (P4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m101.546 117.057.451-2.111c.194-1.033 1.354-1.033 1.676 0l.517 2.111h-2.644zm4.95-11.752-1.419-4.564h-3.548l-1.419 4.564zm-1.419-4.577h-3.548l-.92-1.354c.387-.452.646-.452 1.033-.581l.21.71h.709v-.969h1.288v1.033h.47l.387-.709c.452.259.797.581.99.838l-.619 1.032z"
})), T4 || (T4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m101.852 105.305.451-2.113c.193-1.032 1.355-1.032 1.677 0l.517 2.113zm-15.576 25.268-1.419-4.564h-3.546l-1.419 4.564zm-1.419-4.577H81.31l-.92-1.354c.387-.452.645-.452 1.033-.581l.21.709h.709v-.968h1.29v1.033h.469l.386-.71c.452.258.797.581.992.838z"
})), j4 || (j4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m81.633 130.573.451-2.112c.193-1.033 1.354-1.033 1.678 0l.515 2.112h-2.644zm4.643-13.516-1.419-4.563h-3.546l-1.419 4.563zm-1.419-4.576H81.31l-.92-1.355c.387-.452.645-.452 1.033-.579l.21.708h.709v-.967h1.29v1.033h.469l.386-.71c.452.256.797.581.992.838z"
})), O4 || (O4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m81.633 117.057.451-2.111c.193-1.033 1.354-1.033 1.678 0l.515 2.111h-2.644zm4.643-11.752-1.419-4.564h-3.546l-1.419 4.564zm-1.419-4.577H81.31l-.92-1.354c.387-.452.645-.452 1.033-.581l.21.71h.709v-.969h1.29v1.033h.469l.386-.709c.452.259.797.581.992.838l-.622 1.032z"
})), L4 || (L4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m81.633 105.305.451-2.113c.193-1.032 1.354-1.032 1.678 0l.515 2.113h-2.644zm15.096 0-1.419-4.564h-3.547l-1.42 4.564zm-1.419-4.577h-3.546l-.919-1.354c.385-.452.645-.452 1.032-.581l.21.71h.708v-.969h1.29v1.033h.469l.387-.709c.451.259.797.581.991.838l-.622 1.032z"
})), R4 || (R4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m92.086 105.305.45-2.113c.194-1.032 1.355-1.032 1.676 0l.518 2.113z"
})), _4 || (_4 = M.createElement("path", {
    fill: "#fff",
    stroke: "#000",
    strokeWidth: .724,
    d: "M99.554 106.422v14.513c0 2.146-.985 3.438-2.847 3.438h-2.292c-.578 0-1.258.206-1.435.735-.176-.53-.854-.735-1.436-.735h-2.291c-1.861 0-2.847-1.293-2.847-3.438v-14.513h13.148z"
})), D4 || (D4 = M.createElement("path", {
    fill: "#1879bf",
    d: "m91.334 107.861.706 3.349h1.647l.585-3.349zm0 12.575.706-3.35h1.647l.585 3.35zm-4.053-4.995 3.349-.704v-1.646l-3.349-.588zm10.811 0-3.348-.704v-1.646l3.348-.588zm-6.287-2.586h1.998v2.468h-1.998z"
})), N4 || (N4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m76.409 93.67-1.419-4.564h-3.548l-1.419 4.564zm-1.419-4.577h-3.548l-.92-1.356c.387-.45.646-.45 1.033-.58l.21.709h.71v-.968h1.29v1.033h.468l.388-.708c.452.258.797.579.99.838z"
})), F4 || (F4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m71.765 93.67.452-2.112c.193-1.033 1.355-1.033 1.677 0l.516 2.112h-2.645zm4.339-13.517-1.42-4.563h-3.547l-1.42 4.563zm-1.42-4.575h-3.547l-.92-1.355c.387-.45.646-.45 1.032-.58l.212.709h.708v-.967h1.291v1.031h.468l.388-.709c.451.258.796.581.99.838z"
})), I4 || (I4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m71.46 80.153.45-2.111c.193-1.032 1.355-1.032 1.677 0l.516 2.111zm4.949-11.752-1.419-4.564h-3.548l-1.419 4.564zm-1.419-4.577h-3.548l-.92-1.354c.387-.453.646-.453 1.033-.582l.21.71h.71v-.968h1.29v1.033h.468l.388-.71c.452.258.797.581.99.838z"
})), B4 || (B4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m71.765 68.401.452-2.112c.193-1.033 1.355-1.033 1.677 0l.516 2.112h-2.645zM56.189 93.67l-1.418-4.564h-3.549l-1.417 4.564zm-1.418-4.577h-3.549l-.919-1.356c.387-.45.645-.45 1.033-.58l.21.709h.709v-.968h1.29v1.033h.469l.386-.708c.453.258.797.579.992.838l-.621 1.032z"
})), z4 || (z4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m51.546 93.67.451-2.112c.193-1.033 1.354-1.033 1.677 0l.515 2.112zm4.643-13.517-1.418-4.563h-3.549l-1.417 4.563zm-1.418-4.575h-3.549l-.919-1.355c.387-.45.645-.45 1.033-.58l.21.709h.709v-.967h1.29v1.031h.469l.386-.709c.453.258.797.581.992.838l-.621 1.033z"
})), V4 || (V4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m51.546 80.153.451-2.111c.193-1.032 1.354-1.032 1.677 0l.515 2.111zm4.643-11.752-1.418-4.564h-3.549l-1.417 4.564zm-1.418-4.577h-3.549l-.919-1.354c.387-.453.645-.453 1.033-.582l.21.71h.709v-.968h1.29v1.033h.469l.386-.71c.453.258.797.581.992.838l-.621 1.033z"
})), W4 || (W4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m51.546 68.401.451-2.112c.193-1.033 1.354-1.033 1.677 0l.515 2.112zm15.097 0-1.42-4.564h-3.548l-1.418 4.564zm-1.42-4.577h-3.547l-.919-1.354c.386-.453.645-.453 1.033-.582l.209.71h.709v-.968h1.29v1.033h.469l.387-.71a3.4 3.4 0 0 1 .991.838l-.622 1.033z"
})), H4 || (H4 = M.createElement("path", {
    fill: "#f0c560",
    stroke: "#000",
    strokeWidth: .724,
    d: "m61.999 68.401.45-2.112c.194-1.033 1.356-1.033 1.677 0l.518 2.112z"
})), U4 || (U4 = M.createElement("path", {
    fill: "#fff",
    stroke: "#000",
    strokeWidth: .724,
    d: "M69.467 69.518v14.515c0 2.143-.987 3.438-2.847 3.438h-2.292c-.58 0-1.259.205-1.435.733-.177-.529-.856-.733-1.436-.733h-2.291c-1.862 0-2.846-1.295-2.846-3.438V69.518h13.147z"
})), G4 || (G4 = M.createElement("path", {
    fill: "#1879bf",
    d: "m61.248 70.957.705 3.35h1.646l.587-3.35zm0 12.576.705-3.349h1.646l.587 3.349zm-4.054-4.994 3.349-.707v-1.645l-3.349-.587zm10.811 0-3.348-.707v-1.645l3.348-.587zm-6.286-2.587h1.997v2.469h-1.997z"
})), X4 || (X4 = M.createElement("path", {
    fill: "#cc1e4c",
    stroke: "#000",
    strokeWidth: .724,
    d: "M67.829 4.613c-1.174-.352-1.998-.47-2.704 0-.704.471.118 1.175.824.941.706-.236 1.175-.941 1.88-.941z"
})));
var Y4;
function lg() {
    return lg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    lg.apply(this, arguments)
}
const bF = e=>M.createElement("svg", lg({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), Y4 || (Y4 = M.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#F7931A"
}), M.createElement("path", {
    fill: "#FFF",
    fillRule: "nonzero",
    d: "M23.189 14.02c.314-2.096-1.283-3.223-3.465-3.975l.708-2.84-1.728-.43-.69 2.765c-.454-.114-.92-.22-1.385-.326l.695-2.783L15.596 6l-.708 2.839c-.376-.086-.746-.17-1.104-.26l.002-.009-2.384-.595-.46 1.846s1.283.294 1.256.312c.7.175.826.638.805 1.006l-.806 3.235c.048.012.11.03.18.057l-.183-.045-1.13 4.532c-.086.212-.303.531-.793.41.018.025-1.256-.313-1.256-.313l-.858 1.978 2.25.561c.418.105.828.215 1.231.318l-.715 2.872 1.727.43.708-2.84c.472.127.93.245 1.378.357l-.706 2.828 1.728.43.715-2.866c2.948.558 5.164.333 6.097-2.333.752-2.146-.037-3.385-1.588-4.192 1.13-.26 1.98-1.003 2.207-2.538zm-3.95 5.538c-.533 2.147-4.148.986-5.32.695l.95-3.805c1.172.293 4.929.872 4.37 3.11m.535-5.569c-.487 1.953-3.495.96-4.47.717l.86-3.45c.975.243 4.118.696 3.61 2.733"
}))));
var $4;
function cg() {
    return cg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    cg.apply(this, arguments)
}
const wF = e=>M.createElement("svg", cg({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), $4 || ($4 = M.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#627EEA"
}), M.createElement("g", {
    fill: "#FFF",
    fillRule: "nonzero"
}, M.createElement("path", {
    fillOpacity: .602,
    d: "M16.498 4v8.87l7.497 3.35z"
}), M.createElement("path", {
    d: "M16.498 4 9 16.22l7.498-3.35z"
}), M.createElement("path", {
    fillOpacity: .602,
    d: "M16.498 21.968v6.027L24 17.616z"
}), M.createElement("path", {
    d: "M16.498 27.995v-6.028L9 17.616z"
}), M.createElement("path", {
    fillOpacity: .2,
    d: "m16.498 20.573 7.497-4.353-7.497-3.348z"
}), M.createElement("path", {
    fillOpacity: .602,
    d: "m9 16.22 7.498 4.353v-7.701z"
})))));
var K4;
function ug() {
    return ug = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    ug.apply(this, arguments)
}
const SF = e=>M.createElement("svg", ug({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), K4 || (K4 = M.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#26A17B"
}), M.createElement("path", {
    fill: "#FFF",
    d: "M17.922 17.383v-.002c-.11.008-.677.042-1.942.042-1.01 0-1.721-.03-1.971-.042v.003c-3.888-.171-6.79-.848-6.79-1.658 0-.809 2.902-1.486 6.79-1.66v2.644c.254.018.982.061 1.988.061 1.207 0 1.812-.05 1.925-.06v-2.643c3.88.173 6.775.85 6.775 1.658 0 .81-2.895 1.485-6.775 1.657m0-3.59v-2.366h5.414V7.819H8.595v3.608h5.414v2.365c-4.4.202-7.709 1.074-7.709 2.118 0 1.044 3.309 1.915 7.709 2.118v7.582h3.913v-7.584c4.393-.202 7.694-1.073 7.694-2.116 0-1.043-3.301-1.914-7.694-2.117"
}))));
var Q4;
function hg() {
    return hg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    hg.apply(this, arguments)
}
const CF = e=>M.createElement("svg", hg({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), Q4 || (Q4 = M.createElement("g", {
    fill: "none"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#23292F"
}), M.createElement("path", {
    fill: "#FFF",
    d: "M23.07 8h2.89l-6.015 5.957a5.621 5.621 0 0 1-7.89 0L6.035 8H8.93l4.57 4.523a3.556 3.556 0 0 0 4.996 0zM8.895 24.563H6l6.055-5.993a5.621 5.621 0 0 1 7.89 0L26 24.562h-2.895L18.5 20a3.556 3.556 0 0 0-4.996 0l-4.61 4.563z"
}))));
var q4;
function dg() {
    return dg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    dg.apply(this, arguments)
}
const kF = e=>M.createElement("svg", dg({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), q4 || (q4 = M.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#6cde07"
}), M.createElement("path", {
    fill: "#fff",
    d: "M22.5 19.154c0 2.57-2.086 4.276-5.166 4.533V26h-2.11v-2.336A11.495 11.495 0 0 1 9.5 21.35l1.552-2.126c1.383 1.075 2.692 1.776 4.269 2.01v-4.58c-3.541-.888-5.19-2.173-5.19-4.813 0-2.523 2.061-4.252 5.093-4.486V6h2.11v1.402a9.49 9.49 0 0 1 4.56 1.776l-1.359 2.196c-1.067-.771-2.158-1.262-3.298-1.495v4.439c3.687.888 5.263 2.313 5.263 4.836zm-7.18-5.327V9.715c-1.527.117-2.327.935-2.327 1.963 0 .98.46 1.612 2.328 2.15zm4.318 5.49c0-1.05-.51-1.681-2.401-2.219v4.23c1.528-.118 2.401-.889 2.401-2.01z"
}))));
var Z4;
function fg() {
    return fg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    fg.apply(this, arguments)
}
const AF = e=>M.createElement("svg", fg({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), Z4 || (Z4 = M.createElement("g", {
    fill: "none"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#000"
}), M.createElement("path", {
    fill: "#FFF",
    d: "M27.986 14.669v.064c-1.387.868-2.784 1.726-4.177 2.592a.18.18 0 0 0-.06.075c.372.1.757.175 1.11.337.326.145.66.334.844.651.176.322.22.7.122 1.053-.053.264-.164.512-.264.763-.418 1.002-.838 2.001-1.253 3.007a.585.585 0 0 1-.08.139c-.137-.003-.268-.053-.402-.084-.676-.167-1.356-.331-2.032-.5-.22-.062-.446-.098-.663-.17.006-.137.084-.254.13-.377l.928-2.221c.07-.154.111-.346.011-.496-.125-.214-.376-.295-.598-.356-.816-.21-1.638-.404-2.456-.607-.117-.025-.231-.078-.354-.062-.072.126-.114.268-.172.404-.348.816-.682 1.637-1.028 2.453-.05.114-.08.24-.156.34-.136 0-.264-.053-.395-.084-.699-.172-1.398-.348-2.1-.518-.197-.053-.403-.086-.598-.153a.469.469 0 0 1 .036-.161l3.533-8.47a.181.181 0 0 1 .056-.072c.123.008.24.058.36.086.595.142 1.191.295 1.787.44.309.08.626.142.933.234.016.058-.012.117-.034.172-.24.546-.46 1.1-.693 1.646l-.721 1.732c-.081.203-.187.398-.243.612.104-.036.193-.097.284-.159l4.706-2.95c.086-.054.164-.126.262-.151.144-.011.28.044.417.075.48.103.952.24 1.428.35.516.115 1.022.257 1.532.366zM16.882 12.97c.025.504-.167.983-.364 1.434-.532 1.278-1.07 2.553-1.599 3.831-.192.451-.359.922-.654 1.32-.21.296-.502.524-.84.654a2.884 2.884 0 0 1-1.318.095c-.76-.095-1.5-.3-2.244-.479-1.01-.253-2.027-.498-3.037-.752-.671-.161-1.348-.334-1.972-.64a1.654 1.654 0 0 1-.662-.582 1.114 1.114 0 0 1-.159-.69c.053-.443.217-.864.395-1.27l1.63-3.915c.13-.3.244-.61.411-.893a2.43 2.43 0 0 1 .56-.688c.268-.204.583-.335.916-.382.245-.022.49-.01.735-.005a19.32 19.32 0 0 1 2.247.47c1.036.25 2.069.513 3.104.763.476.117.95.237 1.415.396.311.114.629.23.902.428.31.201.508.536.534.905zm-3.62.891c.02-.147-.085-.273-.208-.337-.25-.136-.535-.186-.807-.256-.722-.18-1.444-.358-2.17-.534a1.442 1.442 0 0 0-.634-.04c-.245.07-.368.318-.451.535-.41.975-.81 1.952-1.222 2.924-.045.114-.09.228-.1.35 0 .14.097.262.216.32.179.092.374.143.563.193l2.255.554c.262.061.537.128.805.07.225-.073.34-.304.423-.507l1.105-2.651c.087-.2.198-.398.226-.62z"
}))));
var J4;
function pg() {
    return pg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    pg.apply(this, arguments)
}
const MF = e=>M.createElement("svg", pg({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), J4 || (J4 = M.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#E84142",
    fillRule: "nonzero"
}), M.createElement("path", {
    fill: "#FFF",
    d: "M11.518 22.75H8.49c-.636 0-.95 0-1.142-.123A.77.77 0 0 1 7 22.025c-.012-.226.145-.503.46-1.055l7.472-13.193c.318-.56.48-.84.682-.944a.77.77 0 0 1 .698 0c.203.104.364.384.682.944l1.536 2.686.008.014c.343.6.517.906.593 1.226a2.26 2.26 0 0 1 0 1.066c-.076.323-.249.63-.597 1.24l-3.926 6.95-.01.017c-.346.606-.52.913-.764 1.145a2.284 2.284 0 0 1-.93.54c-.319.089-.675.089-1.387.089zm7.643 0h4.336c.64 0 .962 0 1.154-.126a.768.768 0 0 0 .348-.607c.011-.219-.142-.484-.443-1.005l-.032-.054-2.172-3.722-.025-.042c-.305-.517-.46-.778-.657-.879a.762.762 0 0 0-.693 0c-.2.104-.36.377-.678.925l-2.165 3.722-.007.013c-.317.548-.476.821-.464 1.046a.777.777 0 0 0 .348.606c.188.123.51.123 1.15.123z"
}))));
var eb;
function gg() {
    return gg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    gg.apply(this, arguments)
}
const EF = e=>M.createElement("svg", gg({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
}, e), eb || (eb = M.createElement("g", {
    fill: "none"
}, M.createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#E756CC"
}), M.createElement("path", {
    fill: "#FFF",
    d: "M12.77 16.533c.095.225.19.448.29.67.091.211.188.42.281.63l.214.488c.074.167.152.334.228.5l.187.42.286.644c.168.37.33.742.495 1.113.2.439.386.883.59 1.32.248.499.428 1.021.653 1.528.225-.61.471-1.2.743-1.791.169-.372.33-.747.5-1.12.133-.294.259-.593.39-.89.13-.292.265-.583.39-.876l.13-.281c.073-.164.145-.328.219-.491.074-.167.146-.335.221-.501.115-.253.227-.508.34-.763a14.4 14.4 0 0 0 .258-.599c-2.138-.003-4.277-.003-6.415 0zm7.718-2.84H11.5l.938 2.253h7.017l1.032-2.254zm6.642-2.105c.22.533.394 1.083.532 1.642a10.487 10.487 0 0 0-1.867-.139c-.477-.008-.962.045-1.436 0l-.04-.163c.16-.217.367-.382.594-.526.666-.42 1.432-.724 2.217-.814m-15.216-6.5c1.352.433 2.778.67 4.114 1.146.19.09.41.105.418.358-1.113.177-2.197.182-3.318.268-1.199.08-2.364.198-3.567.038-.375-.03-.755-.122-1.13-.11a12.496 12.496 0 0 1 3.001-1.778c.176-.035.317.031.482.078zm9.13 12.104c-.083.187-.168.372-.253.557-.094.208-.19.418-.286.625-.09.197-.176.395-.266.591-.154.332-.308.664-.457.999-.157.341-.31.684-.47 1.024l-.575 1.258c-.144.308-.282.618-.423.927-.233.523-.477 1.041-.715 1.562-.222.513-.462 1.018-.692 1.526-.264.58-.528 1.161-.798 1.739-.106 0-.212 0-.318-.002-.298-.663-.606-1.322-.901-1.986-.21-.472-.43-.939-.64-1.41-.191-.43-.39-.856-.582-1.286l-.465-1.024c-.21-.482-.437-.957-.651-1.438-.19-.424-.385-.846-.573-1.271-.075-.165-.149-.33-.225-.494-.131-.3-.27-.593-.405-.891-.096-.214-.196-.426-.292-.641l-.216-.48c-.08-.183-.163-.364-.25-.544-2.197-.005-4.394.005-6.591-.004v-.61c2.102-.004 4.203.005 6.304-.004a9.544 9.544 0 0 0-.22-.527c-.125-.264-.24-.53-.361-.795-.107-.234-.21-.47-.32-.703-.15-.322-.291-.649-.442-.972-.18-.388-.346-.784-.533-1.169-1 .162-1.934.54-2.73 1.165l-.017.012c-.343.247-.648.57-.942.876a6.717 6.717 0 0 0-.648.819 11.784 11.784 0 0 1 1.948-5.219c.454.395 1.007.65 1.62.618-.259-.574-.534-1.141-.775-1.722.467-.55.991-1.049 1.547-1.51.405.977.854 1.937 1.277 2.906.055.152.192.136.324.185.343.079.584.28.894.432.353.181.767.273 1.157.343.164.033.33.052.497.07l.043.1c-.748.203-1.494.215-2.261.251.064.259.174.497.286.738 3.548.007 7.096-.004 10.644.005.234-.465.43-.948.655-1.417-.655.227-1.308.441-1.994.557-.113.014-.232.014-.346.014.161-.1.328-.187.499-.27.747-.353 1.476-.76 2.153-1.232.196-.133.242-.326.338-.528.324-.718.641-1.44.967-2.156.941.767 1.77 1.667 2.44 2.677-.44-.182-.872-.223-1.345-.181l-.792 1.733c-.155.347-.319.69-.474 1.037l-.492 1.077c-.117.262-.245.52-.353.785-.134.253-.24.52-.364.779-.12.259-.23.521-.353.78-.072.145-.14.293-.207.441 2.125.01 4.25.001 6.375.005.003.205-.001.409-.008.612-2.21.004-4.421-.002-6.631.004-.116.213-.216.437-.317.657z"
}))))
  , tn = ({name: e, className: t})=>{
    switch (e) {
    case "kava":
        return y.jsx(nF, {
            className: t
        });
    case "ada":
        return y.jsx(iF, {
            className: t
        });
    case "exp":
        return y.jsx(rF, {
            className: t
        });
    case "etc":
        return y.jsx(sF, {
            className: t
        });
    case "exmo":
        return y.jsx(oF, {
            className: t
        });
    case "gate":
        return y.jsx(lF, {
            className: t
        });
    case "bnb":
        return y.jsx(aF, {
            className: t
        });
    case "ce":
        return y.jsx(cF, {
            className: t
        });
    case "lbank":
        return y.jsx(uF, {
            className: t
        });
    case "mexcLogo":
        return y.jsx(hF, {
            className: t
        });
    case "inj":
        return y.jsx(dF, {
            className: t
        });
    case "band":
        return y.jsx(fF, {
            className: t
        });
    case "coti":
        return y.jsx(pF, {
            className: t
        });
    case "wan":
        return y.jsx(gF, {
            className: t
        });
    case "arpa":
        return y.jsx(mF, {
            className: t
        });
    case "klay":
        return y.jsx(vF, {
            className: t
        });
    case "ae":
        return y.jsx(yF, {
            className: t
        });
    case "porto":
        return y.jsx(xF, {
            className: t
        });
    case "btc":
        return y.jsx(bF, {
            className: t
        });
    case "eth":
        return y.jsx(wF, {
            className: t
        });
    case "usdt":
        return y.jsx(SF, {
            className: t
        });
    case "xrp":
        return y.jsx(CF, {
            className: t
        });
    case "usd":
        return y.jsx(kF, {
            className: t
        });
    case "ok":
        return y.jsx(AF, {
            className: t
        });
    case "avax":
        return y.jsx(MF, {
            className: t
        });
    case "atlas":
        return y.jsx(EF, {
            className: t
        });
    default:
        return null
    }
}
  , Di = e=>e.slice(0, 1) === "+" ? {
    color: "#03A66D"
} : e.slice(0, 1) === "-" ? {
    color: "#CF304A"
} : {}
  , tb = e=>{
    let t = {};
    return typeof e == "string" && (t = Di(e)),
    t
}
  , fu = ({dataTop: e, numberTitle: t})=>{
    const n = [["Social Activity", "INTERACTIONS", ZN], ["Volume", "VOLUME", eF], ["Gainers", "TOTAL GAIN", tF], ["Losers", "TOTAL LOSS", JN]];
    return y.jsxs("section", {
        className: "top-products",
        children: [y.jsxs("div", {
            className: "top-products__title",
            children: [y.jsx("div", {
                children: y.jsx("img", {
                    src: n[t][2],
                    alt: n[t][0]
                })
            }), y.jsxs("h2", {
                children: ["Top 5 ", n[t][0]]
            })]
        }), y.jsxs("div", {
            className: "top-products__subtitle",
            children: [y.jsx("h3", {
                children: "TOKEN"
            }), y.jsx("h3", {
                children: n[t][1]
            })]
        }), y.jsx("div", {
            className: "content-top",
            children: e.map(({title: i, subtitle: r, svg: s, amountMoney: o, period: a, procent: l},c)=>y.jsxs("div", {
                className: "content-top__item",
                children: [y.jsxs("div", {
                    className: "content-top__left",
                    children: [y.jsx(tn, {
                        name: s,
                        className: "svg-25px"
                    }), y.jsxs("div", {
                        children: [y.jsx("h4", {
                            className: "content-top__main-title",
                            children: i
                        }), y.jsx("h4", {
                            className: "content-top__subtitle",
                            children: r
                        })]
                    })]
                }), y.jsxs("div", {
                    className: "content-top__right",
                    children: [y.jsx("h4", {
                        className: "content-top__main-title",
                        children: o
                    }), y.jsxs("div", {
                        className: "content-top__amount",
                        children: [y.jsx("h5", {
                            children: a
                        }), y.jsx("h5", {
                            style: Di(l),
                            children: l
                        })]
                    })]
                })]
            }, c))
        })]
    })
}
  , pu = [[{
    title: "Cardano",
    subtitle: "ADA",
    svg: "ada",
    amountMoney: "5.06K",
    period: "7d",
    procent: "+49.28%"
}, {
    title: "Trust Wallet Token",
    subtitle: "TWT",
    svg: "exp",
    amountMoney: "26.38K",
    period: "7d",
    procent: "+13.78%"
}, {
    title: "Ethereum Classic",
    subtitle: "ETC",
    svg: "etc",
    amountMoney: "256",
    period: "7d",
    procent: "+10.34%"
}, {
    title: "Kava",
    subtitle: "KAVA",
    svg: "kava",
    amountMoney: "64",
    period: "7d",
    procent: "+255.56%"
}, {
    title: "Monero",
    subtitle: "XMR",
    svg: "exmo",
    amountMoney: "1.99K",
    period: "7d",
    procent: "+9.87%"
}], [{
    title: "Binance",
    subtitle: "",
    svg: "bnb",
    amountMoney: "$ 11.82B",
    period: "24h",
    procent: "-4.87%"
}, {
    title: "Gate.io",
    subtitle: "",
    svg: "gate",
    amountMoney: "$ 976.92M",
    period: "24h",
    procent: "-3.44%"
}, {
    title: "Coinbase Exchange",
    subtitle: "",
    svg: "ce",
    amountMoney: "$ 1.46B",
    period: "24h",
    procent: "-9.09%"
}, {
    title: "LBank",
    subtitle: "",
    svg: "lbank",
    amountMoney: "$ 1.46B",
    period: "24h",
    procent: "+13.11%"
}, {
    title: "MEXC Global",
    subtitle: "",
    svg: "mexcLogo",
    amountMoney: "$ 946.82M",
    period: "24h",
    procent: "-12.53%"
}], [{
    title: "ADAUP",
    subtitle: "ADAUP",
    svg: "bnb",
    amountMoney: "$0.503",
    period: "24h",
    procent: "+22.38%"
}, {
    title: "Injective",
    subtitle: "INJ",
    svg: "inj",
    amountMoney: "$8.988",
    period: "24h",
    procent: "+22.13%"
}, {
    title: "Band Protocol",
    subtitle: "BAND",
    svg: "band",
    amountMoney: "$1.726",
    period: "24h",
    procent: "+20.73%"
}, {
    title: "COTI",
    subtitle: "COTI",
    svg: "coti",
    amountMoney: "$0.08018",
    period: "24h",
    procent: "+18.35%"
}, {
    title: "Conflux",
    subtitle: "WAN",
    svg: "wan",
    amountMoney: "$0.321",
    period: "24h",
    procent: "+17.84%"
}], [{
    title: "ARPA Chain",
    subtitle: "ARPA",
    svg: "arpa",
    amountMoney: "$0.05045",
    period: "24h",
    procent: "-9.06%"
}, {
    title: "Klaytn",
    subtitle: "KLAY",
    svg: "klay",
    amountMoney: "$0.1730",
    period: "24h",
    procent: "-6.49%"
}, {
    title: "Ethernity Chain",
    subtitle: "ERN",
    svg: "ae",
    amountMoney: "$1.853",
    period: "24h",
    procent: "-5.12%"
}, {
    title: "FC Porto Fan Token",
    subtitle: "PORTO",
    svg: "porto",
    amountMoney: "$2.3739",
    period: "24h",
    procent: "-1.98%"
}, {
    title: "Orion Protocol",
    subtitle: "ORN",
    svg: "wan",
    amountMoney: "$1.0530",
    period: "24h",
    procent: "-1.89%"
}]];
var nb;
function mg() {
    return mg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    mg.apply(this, arguments)
}
const PF = e=>M.createElement("svg", mg({
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 14,
    fill: "none"
}, e), nb || (nb = M.createElement("path", {
    stroke: "#2C406E",
    strokeOpacity: .4,
    strokeWidth: 1.2,
    d: "M2.5 7H13M2.5 7A1.5 1.5 0 0 1 1 5.5v-3A1.5 1.5 0 0 1 2.5 1H13a1.5 1.5 0 0 1 1.5 1.5v3A1.5 1.5 0 0 1 13 7M2.5 7A1.5 1.5 0 0 0 1 8.5v3A1.5 1.5 0 0 0 2.5 13H13a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 13 7m-1.5-3h.008m-.008 6h.008"
})));
var ib;
function vg() {
    return vg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    vg.apply(this, arguments)
}
const oC = e=>M.createElement("svg", vg({
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 14,
    fill: "none"
}, e), ib || (ib = M.createElement("path", {
    stroke: "#2C406E",
    strokeWidth: 1.2,
    d: "m11.5 13 3-3M1 1h9.75zm0 3h6.75zm0 3h6.75zm10.5-3v9zm0 9-3-3z"
})));
var rb;
function yg() {
    return yg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    yg.apply(this, arguments)
}
const j2 = e=>M.createElement("svg", yg({
    xmlns: "http://www.w3.org/2000/svg",
    width: 17,
    height: 16,
    fill: "none"
}, e), rb || (rb = M.createElement("path", {
    fill: "#2B7AFF",
    stroke: "#2B7AFF",
    d: "m1.272 6.732.294-.405-.294.405 3.916 2.844-1.496 4.603c-.173.534.438.979.893.648L8.5 11.983l3.915 2.844c.455.33 1.067-.114.893-.648l-1.496-4.603 3.916-2.844c.454-.33.22-1.05-.341-1.05h-4.84L9.052 1.08c-.174-.535-.93-.535-1.104 0L6.453 5.682h-4.84c-.562 0-.795.72-.34 1.05Zm5.087-.76.399.13-.4-.13Z"
})))
  , TF = ["Token", "Price", "Market Cap", "Volume", "Social Following", "Social Interactions", "Circulating Suppy", "24h Curve"]
  , sb = [{
    value: "",
    label: "Choose value"
}, {
    value: "1",
    label: "Extreme Fear"
}, {
    value: "2",
    label: "Fear"
}, {
    value: "3",
    label: "Neutral"
}, {
    value: "4",
    label: "Greed"
}, {
    value: "5",
    label: "Extreme Greed"
}]
  , Ns = [{
    id: 0,
    token: ["Bitcoin", "BTC", "btc"],
    price: [2902599, "-2.39%", "+1.15%"],
    marketCap: 1532,
    volume: [30.92, "+19.23%"],
    socialFollowing: ["-29.24%", "-46.12%", 12.65, 25.75],
    socialInteractions: ["-46.12%", "-29.24%", 25.75, 12.65],
    circulatingSuppy: [19.36, 90],
    tFhCurve: [5, 3, 10, 7, 10, 5, 3, 10, 7, 10, 5, 3, 10, 2, 10],
    sentiment: [2, 40, "Fear", "#D16072"]
}, {
    id: 1,
    token: ["Ethereum", "ETH", "eth"],
    price: [188793, "-3.11%", "-4.02%"],
    marketCap: 285,
    volume: [15.08, "+31.94%"],
    socialFollowing: ["-27.57%", "-36.81%", 9.43, 13.1],
    socialInteractions: ["+36.81%", "-27.57%", 13.1, 9.43],
    circulatingSuppy: [120.4, 0],
    tFhCurve: [10, 2, 9, 3, 7, 4, 5].reverse(),
    sentiment: [5, 90, "Extreme Greed", "#03A66D"]
}, {
    id: 2,
    token: ["Tether", "USDT", "usdt"],
    price: [101, "+0%", "-0%"],
    marketCap: 569,
    volume: [42.96, "+24.53%"],
    socialFollowing: ["+17.28%", "-22.04%", 2.23, 1.32],
    socialInteractions: ["-22.04%", "+17.28%", 1.32, 2.23],
    circulatingSuppy: [81.59, 40],
    tFhCurve: [10, 5, 10, 1, 10, 5, 10],
    sentiment: [3, 50, "Neutral", "#2C406E"]
}, {
    id: 3,
    token: ["BNB", "BNB", "bnb"],
    price: [3308, "-3.14%", "+1.61%"],
    marketCap: 56187,
    volume: [875.15, "+8.5%"],
    socialFollowing: ["+17.05%", "-19.56%", 2.65, 5.68],
    socialInteractions: ["-19.56%", "+17.05%", 5.68, 2.65],
    circulatingSuppy: [155.86, 25],
    tFhCurve: [10, 2, 9, 3, 7, 4, 5],
    sentiment: [4, 60, "Greed", "#72BCA2"]
}, {
    id: 4,
    token: ["XRP", "XRP", "xrp"],
    price: [.459, "-3.91%", "-6.3%"],
    marketCap: 22731,
    volume: [1.57, "+27.37%"],
    socialFollowing: ["-12.09%", "+34.16%", 896, 1.06],
    socialInteractions: ["+34.16%", "-12.09%", 1.06, 896],
    circulatingSuppy: [51.75, 65],
    tFhCurve: [5, 3, 2, 5, 2, 4, 8, 12, 9, 13, 14, 15],
    sentiment: [4, 60, "Greed", "#72BCA2"]
}, {
    id: 5,
    token: ["USD Coin", "USDC", "usd"],
    price: [.9999, "-0.02%", "-0.02%"],
    marketCap: 8161,
    volume: [6.44, "+12.52%"],
    socialFollowing: ["-51.81%", "+12.45%", 78, 360],
    socialInteractions: ["+12.45%", "-51.81%", 360, 78],
    circulatingSuppy: [30.369, 30],
    tFhCurve: [10, 5, 3, 10, 5, 2, 10, 5, 3, 10, 5, 2, 10, 5, 3],
    sentiment: [3, 50, "Neutral", "#2C406E"]
}, {
    id: 6,
    token: ["Cardano", "ADA", "ada"],
    price: [.4103, "-0.78%", "-0.89%"],
    marketCap: 5155,
    volume: [504.71, "+43.07%"],
    socialFollowing: ["-20.05%", "+11.12%", 423, 642],
    socialInteractions: ["+11.12%", "-20.05%", 642, 423],
    circulatingSuppy: [34.8, 70],
    tFhCurve: [1, 5, 2, 5, 5, 3, 10, 5, 11, 10, 5, 12, 10, 5, 2].reverse(),
    sentiment: [2, 40, "Fear", "#D16072"]
}, {
    id: 7,
    token: ["Arbitrum", "ARB", "atlas"],
    price: [1.532, "-7.75%", "+28.14%"],
    marketCap: 235,
    volume: [1.36, "-18.17%"],
    socialFollowing: ["-19.03%", "-23.67%", 354, 129],
    socialInteractions: ["-23.67%", "-19.03%", 129, 354],
    circulatingSuppy: [1.27, 10],
    tFhCurve: [10, 5, 2, 10, 10, 5, 2, 10, 10, 5, 2, 10, 2],
    sentiment: [3, 50, "Neutral", "#2C406E"]
}, {
    id: 8,
    token: ["OKB", "OKB", "ok"],
    price: [47.48, "-2%", "-12.65%"],
    marketCap: 3068,
    volume: [17.17, "-9.31%"],
    socialFollowing: ["+26.92%", "-16.05%", 10, 33],
    socialInteractions: ["-16.05%", "+26.92%", 33, 10],
    circulatingSuppy: [60, 20],
    tFhCurve: [5, 3, 10, 5, 2, 10, 5, 3, 10, 5, 2, 10, 5, 3, 10],
    sentiment: [4, 70, "Greed", "#72BCA2"]
}, {
    id: 9,
    token: ["Avalanche", "AVAX", "avax"],
    price: [17.4, "-3.62%", "-9.34%"],
    marketCap: 1428,
    volume: [292.69, "+31.84%"],
    socialFollowing: ["-19.82%", "+11.32%", 522, 254],
    socialInteractions: ["+11.32%", "-19.82%", 254, 522],
    circulatingSuppy: [326.97, 80],
    tFhCurve: [1, 5, 2, 5, 5, 3, 10, 5, 11, 10, 5, 12, 10, 5, 2],
    sentiment: [1, 15, "Extreme Fear", "#CF304A"]
}]
  , aC = M.createContext({
    transformPagePoint: e=>e,
    isStatic: !1,
    reducedMotion: "never"
})
  , qd = M.createContext({})
  , O2 = M.createContext(null)
  , Zd = typeof document < "u"
  , jF = Zd ? M.useLayoutEffect : M.useEffect
  , lC = M.createContext({
    strict: !1
});
function OF(e, t, n, i) {
    const {visualElement: r} = M.useContext(qd)
      , s = M.useContext(lC)
      , o = M.useContext(O2)
      , a = M.useContext(aC).reducedMotion
      , l = M.useRef();
    i = i || s.renderer,
    !l.current && i && (l.current = i(e, {
        visualState: t,
        parent: r,
        props: n,
        presenceContext: o,
        blockInitialAnimation: o ? o.initial === !1 : !1,
        reducedMotionConfig: a
    }));
    const c = l.current;
    M.useInsertionEffect(()=>{
        c && c.update(n, o)
    }
    );
    const u = M.useRef(!!window.HandoffAppearAnimations);
    return jF(()=>{
        c && (c.render(),
        u.current && c.animationState && c.animationState.animateChanges())
    }
    ),
    M.useEffect(()=>{
        c && (c.updateFeatures(),
        !u.current && c.animationState && c.animationState.animateChanges(),
        window.HandoffAppearAnimations = void 0,
        u.current = !1)
    }
    ),
    c
}
function Wo(e) {
    return typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current")
}
function LF(e, t, n) {
    return M.useCallback(i=>{
        i && e.mount && e.mount(i),
        t && (i ? t.mount(i) : t.unmount()),
        n && (typeof n == "function" ? n(i) : Wo(n) && (n.current = i))
    }
    , [t])
}
function Kl(e) {
    return typeof e == "string" || Array.isArray(e)
}
function Jd(e) {
    return typeof e == "object" && typeof e.start == "function"
}
const L2 = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , R2 = ["initial", ...L2];
function ef(e) {
    return Jd(e.animate) || R2.some(t=>Kl(e[t]))
}
function cC(e) {
    return !!(ef(e) || e.variants)
}
function RF(e, t) {
    if (ef(e)) {
        const {initial: n, animate: i} = e;
        return {
            initial: n === !1 || Kl(n) ? n : void 0,
            animate: Kl(i) ? i : void 0
        }
    }
    return e.inherit !== !1 ? t : {}
}
function _F(e) {
    const {initial: t, animate: n} = RF(e, M.useContext(qd));
    return M.useMemo(()=>({
        initial: t,
        animate: n
    }), [ob(t), ob(n)])
}
function ob(e) {
    return Array.isArray(e) ? e.join(" ") : e
}
const ab = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , Ql = {};
for (const e in ab)
    Ql[e] = {
        isEnabled: t=>ab[e].some(n=>!!t[n])
    };
function DF(e) {
    for (const t in e)
        Ql[t] = {
            ...Ql[t],
            ...e[t]
        }
}
const uC = M.createContext({})
  , hC = M.createContext({})
  , NF = Symbol.for("motionComponentSymbol");
function FF({preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: i, Component: r}) {
    e && DF(e);
    function s(a, l) {
        let c;
        const u = {
            ...M.useContext(aC),
            ...a,
            layoutId: IF(a)
        }
          , {isStatic: h} = u
          , d = _F(a)
          , m = i(a, h);
        if (!h && Zd) {
            d.visualElement = OF(r, m, u, t);
            const f = M.useContext(hC)
              , x = M.useContext(lC).strict;
            d.visualElement && (c = d.visualElement.loadFeatures(u, x, e, f))
        }
        return M.createElement(qd.Provider, {
            value: d
        }, c && d.visualElement ? M.createElement(c, {
            visualElement: d.visualElement,
            ...u
        }) : null, n(r, a, LF(m, d.visualElement, l), m, h, d.visualElement))
    }
    const o = M.forwardRef(s);
    return o[NF] = r,
    o
}
function IF({layoutId: e}) {
    const t = M.useContext(uC).id;
    return t && e !== void 0 ? t + "-" + e : e
}
function BF(e) {
    function t(i, r={}) {
        return FF(e(i, r))
    }
    if (typeof Proxy > "u")
        return t;
    const n = new Map;
    return new Proxy(t,{
        get: (i,r)=>(n.has(r) || n.set(r, t(r)),
        n.get(r))
    })
}
const zF = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function _2(e) {
    return typeof e != "string" || e.includes("-") ? !1 : !!(zF.indexOf(e) > -1 || /[A-Z]/.test(e))
}
const Gh = {};
function VF(e) {
    Object.assign(Gh, e)
}
const wc = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , so = new Set(wc);
function dC(e, {layout: t, layoutId: n}) {
    return so.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Gh[e] || e === "opacity")
}
const jn = e=>!!(e && e.getVelocity)
  , WF = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , HF = wc.length;
function UF(e, {enableHardwareAcceleration: t=!0, allowTransformNone: n=!0}, i, r) {
    let s = "";
    for (let o = 0; o < HF; o++) {
        const a = wc[o];
        if (e[a] !== void 0) {
            const l = WF[a] || a;
            s += `${l}(${e[a]}) `
        }
    }
    return t && !e.z && (s += "translateZ(0)"),
    s = s.trim(),
    r ? s = r(e, i ? "" : s) : n && i && (s = "none"),
    s
}
const fC = e=>t=>typeof t == "string" && t.startsWith(e)
  , pC = fC("--")
  , xg = fC("var(--")
  , GF = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g
  , XF = (e,t)=>t && typeof e == "number" ? t.transform(e) : e
  , Qr = (e,t,n)=>Math.min(Math.max(n, e), t)
  , oo = {
    test: e=>typeof e == "number",
    parse: parseFloat,
    transform: e=>e
}
  , gl = {
    ...oo,
    transform: e=>Qr(0, 1, e)
}
  , gu = {
    ...oo,
    default: 1
}
  , ml = e=>Math.round(e * 1e5) / 1e5
  , tf = /(-)?([\d]*\.?[\d])+/g
  , gC = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi
  , YF = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function Sc(e) {
    return typeof e == "string"
}
const Cc = e=>({
    test: t=>Sc(t) && t.endsWith(e) && t.split(" ").length === 1,
    parse: parseFloat,
    transform: t=>`${t}${e}`
})
  , xr = Cc("deg")
  , Bi = Cc("%")
  , De = Cc("px")
  , $F = Cc("vh")
  , KF = Cc("vw")
  , lb = {
    ...Bi,
    parse: e=>Bi.parse(e) / 100,
    transform: e=>Bi.transform(e * 100)
}
  , cb = {
    ...oo,
    transform: Math.round
}
  , mC = {
    borderWidth: De,
    borderTopWidth: De,
    borderRightWidth: De,
    borderBottomWidth: De,
    borderLeftWidth: De,
    borderRadius: De,
    radius: De,
    borderTopLeftRadius: De,
    borderTopRightRadius: De,
    borderBottomRightRadius: De,
    borderBottomLeftRadius: De,
    width: De,
    maxWidth: De,
    height: De,
    maxHeight: De,
    size: De,
    top: De,
    right: De,
    bottom: De,
    left: De,
    padding: De,
    paddingTop: De,
    paddingRight: De,
    paddingBottom: De,
    paddingLeft: De,
    margin: De,
    marginTop: De,
    marginRight: De,
    marginBottom: De,
    marginLeft: De,
    rotate: xr,
    rotateX: xr,
    rotateY: xr,
    rotateZ: xr,
    scale: gu,
    scaleX: gu,
    scaleY: gu,
    scaleZ: gu,
    skew: xr,
    skewX: xr,
    skewY: xr,
    distance: De,
    translateX: De,
    translateY: De,
    translateZ: De,
    x: De,
    y: De,
    z: De,
    perspective: De,
    transformPerspective: De,
    opacity: gl,
    originX: lb,
    originY: lb,
    originZ: De,
    zIndex: cb,
    fillOpacity: gl,
    strokeOpacity: gl,
    numOctaves: cb
};
function D2(e, t, n, i) {
    const {style: r, vars: s, transform: o, transformOrigin: a} = e;
    let l = !1
      , c = !1
      , u = !0;
    for (const h in t) {
        const d = t[h];
        if (pC(h)) {
            s[h] = d;
            continue
        }
        const m = mC[h]
          , f = XF(d, m);
        if (so.has(h)) {
            if (l = !0,
            o[h] = f,
            !u)
                continue;
            d !== (m.default || 0) && (u = !1)
        } else
            h.startsWith("origin") ? (c = !0,
            a[h] = f) : r[h] = f
    }
    if (t.transform || (l || i ? r.transform = UF(e.transform, n, u, i) : r.transform && (r.transform = "none")),
    c) {
        const {originX: h="50%", originY: d="50%", originZ: m=0} = a;
        r.transformOrigin = `${h} ${d} ${m}`
    }
}
const N2 = ()=>({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});
function vC(e, t, n) {
    for (const i in t)
        !jn(t[i]) && !dC(i, n) && (e[i] = t[i])
}
function QF({transformTemplate: e}, t, n) {
    return M.useMemo(()=>{
        const i = N2();
        return D2(i, t, {
            enableHardwareAcceleration: !n
        }, e),
        Object.assign({}, i.vars, i.style)
    }
    , [t])
}
function qF(e, t, n) {
    const i = e.style || {}
      , r = {};
    return vC(r, i, e),
    Object.assign(r, QF(e, t, n)),
    e.transformValues ? e.transformValues(r) : r
}
function ZF(e, t, n) {
    const i = {}
      , r = qF(e, t, n);
    return e.drag && e.dragListener !== !1 && (i.draggable = !1,
    r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none",
    r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`),
    e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (i.tabIndex = 0),
    i.style = r,
    i
}
const JF = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "ignoreStrict", "viewport"]);
function Xh(e) {
    return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || JF.has(e)
}
let yC = e=>!Xh(e);
function eI(e) {
    e && (yC = t=>t.startsWith("on") ? !Xh(t) : e(t))
}
try {
    eI(require("@emotion/is-prop-valid").default)
} catch {}
function tI(e, t, n) {
    const i = {};
    for (const r in e)
        r === "values" && typeof e.values == "object" || (yC(r) || n === !0 && Xh(r) || !t && !Xh(r) || e.draggable && r.startsWith("onDrag")) && (i[r] = e[r]);
    return i
}
function ub(e, t, n) {
    return typeof e == "string" ? e : De.transform(t + n * e)
}
function nI(e, t, n) {
    const i = ub(t, e.x, e.width)
      , r = ub(n, e.y, e.height);
    return `${i} ${r}`
}
const iI = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , rI = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function sI(e, t, n=1, i=0, r=!0) {
    e.pathLength = 1;
    const s = r ? iI : rI;
    e[s.offset] = De.transform(-i);
    const o = De.transform(t)
      , a = De.transform(n);
    e[s.array] = `${o} ${a}`
}
function F2(e, {attrX: t, attrY: n, attrScale: i, originX: r, originY: s, pathLength: o, pathSpacing: a=1, pathOffset: l=0, ...c}, u, h, d) {
    if (D2(e, c, u, d),
    h) {
        e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
        return
    }
    e.attrs = e.style,
    e.style = {};
    const {attrs: m, style: f, dimensions: x} = e;
    m.transform && (x && (f.transform = m.transform),
    delete m.transform),
    x && (r !== void 0 || s !== void 0 || f.transform) && (f.transformOrigin = nI(x, r !== void 0 ? r : .5, s !== void 0 ? s : .5)),
    t !== void 0 && (m.x = t),
    n !== void 0 && (m.y = n),
    i !== void 0 && (m.scale = i),
    o !== void 0 && sI(m, o, a, l, !1)
}
const xC = ()=>({
    ...N2(),
    attrs: {}
})
  , I2 = e=>typeof e == "string" && e.toLowerCase() === "svg";
function oI(e, t, n, i) {
    const r = M.useMemo(()=>{
        const s = xC();
        return F2(s, t, {
            enableHardwareAcceleration: !1
        }, I2(i), e.transformTemplate),
        {
            ...s.attrs,
            style: {
                ...s.style
            }
        }
    }
    , [t]);
    if (e.style) {
        const s = {};
        vC(s, e.style, e),
        r.style = {
            ...s,
            ...r.style
        }
    }
    return r
}
function aI(e=!1) {
    return (n,i,r,{latestValues: s},o)=>{
        const l = (_2(n) ? oI : ZF)(i, s, o, n)
          , u = {
            ...tI(i, typeof n == "string", e),
            ...l,
            ref: r
        }
          , {children: h} = i
          , d = M.useMemo(()=>jn(h) ? h.get() : h, [h]);
        return M.createElement(n, {
            ...u,
            children: d
        })
    }
}
const B2 = e=>e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function bC(e, {style: t, vars: n}, i, r) {
    Object.assign(e.style, t, r && r.getProjectionStyles(i));
    for (const s in n)
        e.style.setProperty(s, n[s])
}
const wC = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function SC(e, t, n, i) {
    bC(e, t, void 0, i);
    for (const r in t.attrs)
        e.setAttribute(wC.has(r) ? r : B2(r), t.attrs[r])
}
function z2(e, t) {
    const {style: n} = e
      , i = {};
    for (const r in n)
        (jn(n[r]) || t.style && jn(t.style[r]) || dC(r, e)) && (i[r] = n[r]);
    return i
}
function CC(e, t) {
    const n = z2(e, t);
    for (const i in e)
        if (jn(e[i]) || jn(t[i])) {
            const r = wc.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
            n[r] = e[i]
        }
    return n
}
function V2(e, t, n, i={}, r={}) {
    return typeof t == "function" && (t = t(n !== void 0 ? n : e.custom, i, r)),
    typeof t == "string" && (t = e.variants && e.variants[t]),
    typeof t == "function" && (t = t(n !== void 0 ? n : e.custom, i, r)),
    t
}
function lI(e) {
    const t = M.useRef(null);
    return t.current === null && (t.current = e()),
    t.current
}
const Yh = e=>Array.isArray(e)
  , cI = e=>!!(e && typeof e == "object" && e.mix && e.toValue)
  , uI = e=>Yh(e) ? e[e.length - 1] || 0 : e;
function th(e) {
    const t = jn(e) ? e.get() : e;
    return cI(t) ? t.toValue() : t
}
function hI({scrapeMotionValuesFromProps: e, createRenderState: t, onMount: n}, i, r, s) {
    const o = {
        latestValues: dI(i, r, s, e),
        renderState: t()
    };
    return n && (o.mount = a=>n(i, a, o)),
    o
}
const kC = e=>(t,n)=>{
    const i = M.useContext(qd)
      , r = M.useContext(O2)
      , s = ()=>hI(e, t, i, r);
    return n ? s() : lI(s)
}
;
function dI(e, t, n, i) {
    const r = {}
      , s = i(e, {});
    for (const d in s)
        r[d] = th(s[d]);
    let {initial: o, animate: a} = e;
    const l = ef(e)
      , c = cC(e);
    t && c && !l && e.inherit !== !1 && (o === void 0 && (o = t.initial),
    a === void 0 && (a = t.animate));
    let u = n ? n.initial === !1 : !1;
    u = u || o === !1;
    const h = u ? a : o;
    return h && typeof h != "boolean" && !Jd(h) && (Array.isArray(h) ? h : [h]).forEach(m=>{
        const f = V2(e, m);
        if (!f)
            return;
        const {transitionEnd: x, transition: S, ...v} = f;
        for (const p in v) {
            let g = v[p];
            if (Array.isArray(g)) {
                const C = u ? g.length - 1 : 0;
                g = g[C]
            }
            g !== null && (r[p] = g)
        }
        for (const p in x)
            r[p] = x[p]
    }
    ),
    r
}
const Et = e=>e;
class hb {
    constructor() {
        this.order = [],
        this.scheduled = new Set
    }
    add(t) {
        if (!this.scheduled.has(t))
            return this.scheduled.add(t),
            this.order.push(t),
            !0
    }
    remove(t) {
        const n = this.order.indexOf(t);
        n !== -1 && (this.order.splice(n, 1),
        this.scheduled.delete(t))
    }
    clear() {
        this.order.length = 0,
        this.scheduled.clear()
    }
}
function fI(e) {
    let t = new hb
      , n = new hb
      , i = 0
      , r = !1
      , s = !1;
    const o = new WeakSet
      , a = {
        schedule: (l,c=!1,u=!1)=>{
            const h = u && r
              , d = h ? t : n;
            return c && o.add(l),
            d.add(l) && h && r && (i = t.order.length),
            l
        }
        ,
        cancel: l=>{
            n.remove(l),
            o.delete(l)
        }
        ,
        process: l=>{
            if (r) {
                s = !0;
                return
            }
            if (r = !0,
            [t,n] = [n, t],
            n.clear(),
            i = t.order.length,
            i)
                for (let c = 0; c < i; c++) {
                    const u = t.order[c];
                    u(l),
                    o.has(u) && (a.schedule(u),
                    e())
                }
            r = !1,
            s && (s = !1,
            a.process(l))
        }
    };
    return a
}
const mu = ["prepare", "read", "update", "preRender", "render", "postRender"]
  , pI = 40;
function gI(e, t) {
    let n = !1
      , i = !0;
    const r = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , s = mu.reduce((h,d)=>(h[d] = fI(()=>n = !0),
    h), {})
      , o = h=>s[h].process(r)
      , a = ()=>{
        const h = performance.now();
        n = !1,
        r.delta = i ? 1e3 / 60 : Math.max(Math.min(h - r.timestamp, pI), 1),
        r.timestamp = h,
        r.isProcessing = !0,
        mu.forEach(o),
        r.isProcessing = !1,
        n && t && (i = !1,
        e(a))
    }
      , l = ()=>{
        n = !0,
        i = !0,
        r.isProcessing || e(a)
    }
    ;
    return {
        schedule: mu.reduce((h,d)=>{
            const m = s[d];
            return h[d] = (f,x=!1,S=!1)=>(n || l(),
            m.schedule(f, x, S)),
            h
        }
        , {}),
        cancel: h=>mu.forEach(d=>s[d].cancel(h)),
        state: r,
        steps: s
    }
}
const {schedule: gt, cancel: dr, state: Yt, steps: y0} = gI(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Et, !0)
  , mI = {
    useVisualState: kC({
        scrapeMotionValuesFromProps: CC,
        createRenderState: xC,
        onMount: (e,t,{renderState: n, latestValues: i})=>{
            gt.read(()=>{
                try {
                    n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect()
                } catch {
                    n.dimensions = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
                }
            }
            ),
            gt.render(()=>{
                F2(n, i, {
                    enableHardwareAcceleration: !1
                }, I2(t.tagName), e.transformTemplate),
                SC(t, n)
            }
            )
        }
    })
}
  , vI = {
    useVisualState: kC({
        scrapeMotionValuesFromProps: z2,
        createRenderState: N2
    })
};
function yI(e, {forwardMotionProps: t=!1}, n, i) {
    return {
        ..._2(e) ? mI : vI,
        preloadedFeatures: n,
        useRender: aI(t),
        createVisualElement: i,
        Component: e
    }
}
function ir(e, t, n, i={
    passive: !0
}) {
    return e.addEventListener(t, n, i),
    ()=>e.removeEventListener(t, n)
}
const AC = e=>e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;
function nf(e, t="page") {
    return {
        point: {
            x: e[t + "X"],
            y: e[t + "Y"]
        }
    }
}
const xI = e=>t=>AC(t) && e(t, nf(t));
function or(e, t, n, i) {
    return ir(e, t, xI(n), i)
}
const bI = (e,t)=>n=>t(e(n))
  , Ur = (...e)=>e.reduce(bI);
function MC(e) {
    let t = null;
    return ()=>{
        const n = ()=>{
            t = null
        }
        ;
        return t === null ? (t = e,
        n) : !1
    }
}
const db = MC("dragHorizontal")
  , fb = MC("dragVertical");
function EC(e) {
    let t = !1;
    if (e === "y")
        t = fb();
    else if (e === "x")
        t = db();
    else {
        const n = db()
          , i = fb();
        n && i ? t = ()=>{
            n(),
            i()
        }
        : (n && n(),
        i && i())
    }
    return t
}
function PC() {
    const e = EC(!0);
    return e ? (e(),
    !1) : !0
}
class ss {
    constructor(t) {
        this.isMounted = !1,
        this.node = t
    }
    update() {}
}
function pb(e, t) {
    const n = "pointer" + (t ? "enter" : "leave")
      , i = "onHover" + (t ? "Start" : "End")
      , r = (s,o)=>{
        if (s.type === "touch" || PC())
            return;
        const a = e.getProps();
        e.animationState && a.whileHover && e.animationState.setActive("whileHover", t),
        a[i] && gt.update(()=>a[i](s, o))
    }
    ;
    return or(e.current, n, r, {
        passive: !e.getProps()[i]
    })
}
class wI extends ss {
    mount() {
        this.unmount = Ur(pb(this.node, !0), pb(this.node, !1))
    }
    unmount() {}
}
class SI extends ss {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let t = !1;
        try {
            t = this.node.current.matches(":focus-visible")
        } catch {
            t = !0
        }
        !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = Ur(ir(this.node.current, "focus", ()=>this.onFocus()), ir(this.node.current, "blur", ()=>this.onBlur()))
    }
    unmount() {}
}
const TC = (e,t)=>t ? e === t ? !0 : TC(e, t.parentElement) : !1;
function x0(e, t) {
    if (!t)
        return;
    const n = new PointerEvent("pointer" + e);
    t(n, nf(n))
}
class CI extends ss {
    constructor() {
        super(...arguments),
        this.removeStartListeners = Et,
        this.removeEndListeners = Et,
        this.removeAccessibleListeners = Et,
        this.startPointerPress = (t,n)=>{
            if (this.removeEndListeners(),
            this.isPressing)
                return;
            const i = this.node.getProps()
              , s = or(window, "pointerup", (a,l)=>{
                if (!this.checkPressEnd())
                    return;
                const {onTap: c, onTapCancel: u} = this.node.getProps();
                gt.update(()=>{
                    TC(this.node.current, a.target) ? c && c(a, l) : u && u(a, l)
                }
                )
            }
            , {
                passive: !(i.onTap || i.onPointerUp)
            })
              , o = or(window, "pointercancel", (a,l)=>this.cancelPress(a, l), {
                passive: !(i.onTapCancel || i.onPointerCancel)
            });
            this.removeEndListeners = Ur(s, o),
            this.startPress(t, n)
        }
        ,
        this.startAccessiblePress = ()=>{
            const t = s=>{
                if (s.key !== "Enter" || this.isPressing)
                    return;
                const o = a=>{
                    a.key !== "Enter" || !this.checkPressEnd() || x0("up", (l,c)=>{
                        const {onTap: u} = this.node.getProps();
                        u && gt.update(()=>u(l, c))
                    }
                    )
                }
                ;
                this.removeEndListeners(),
                this.removeEndListeners = ir(this.node.current, "keyup", o),
                x0("down", (a,l)=>{
                    this.startPress(a, l)
                }
                )
            }
              , n = ir(this.node.current, "keydown", t)
              , i = ()=>{
                this.isPressing && x0("cancel", (s,o)=>this.cancelPress(s, o))
            }
              , r = ir(this.node.current, "blur", i);
            this.removeAccessibleListeners = Ur(n, r)
        }
    }
    startPress(t, n) {
        this.isPressing = !0;
        const {onTapStart: i, whileTap: r} = this.node.getProps();
        r && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
        i && gt.update(()=>i(t, n))
    }
    checkPressEnd() {
        return this.removeEndListeners(),
        this.isPressing = !1,
        this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
        !PC()
    }
    cancelPress(t, n) {
        if (!this.checkPressEnd())
            return;
        const {onTapCancel: i} = this.node.getProps();
        i && gt.update(()=>i(t, n))
    }
    mount() {
        const t = this.node.getProps()
          , n = or(this.node.current, "pointerdown", this.startPointerPress, {
            passive: !(t.onTapStart || t.onPointerStart)
        })
          , i = ir(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = Ur(n, i)
    }
    unmount() {
        this.removeStartListeners(),
        this.removeEndListeners(),
        this.removeAccessibleListeners()
    }
}
const bg = new WeakMap
  , b0 = new WeakMap
  , kI = e=>{
    const t = bg.get(e.target);
    t && t(e)
}
  , AI = e=>{
    e.forEach(kI)
}
;
function MI({root: e, ...t}) {
    const n = e || document;
    b0.has(n) || b0.set(n, {});
    const i = b0.get(n)
      , r = JSON.stringify(t);
    return i[r] || (i[r] = new IntersectionObserver(AI,{
        root: e,
        ...t
    })),
    i[r]
}
function EI(e, t, n) {
    const i = MI(t);
    return bg.set(e, n),
    i.observe(e),
    ()=>{
        bg.delete(e),
        i.unobserve(e)
    }
}
const PI = {
    some: 0,
    all: 1
};
class TI extends ss {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {viewport: t={}} = this.node.getProps()
          , {root: n, margin: i, amount: r="some", once: s} = t
          , o = {
            root: n ? n.current : void 0,
            rootMargin: i,
            threshold: typeof r == "number" ? r : PI[r]
        }
          , a = l=>{
            const {isIntersecting: c} = l;
            if (this.isInView === c || (this.isInView = c,
            s && !c && this.hasEnteredView))
                return;
            c && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", c);
            const {onViewportEnter: u, onViewportLeave: h} = this.node.getProps()
              , d = c ? u : h;
            d && d(l)
        }
        ;
        return EI(this.node.current, o, a)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: t, prevProps: n} = this.node;
        ["amount", "margin", "root"].some(jI(t, n)) && this.startObserver()
    }
    unmount() {}
}
function jI({viewport: e={}}, {viewport: t={}}={}) {
    return n=>e[n] !== t[n]
}
const OI = {
    inView: {
        Feature: TI
    },
    tap: {
        Feature: CI
    },
    focus: {
        Feature: SI
    },
    hover: {
        Feature: wI
    }
};
function jC(e, t) {
    if (!Array.isArray(t))
        return !1;
    const n = t.length;
    if (n !== e.length)
        return !1;
    for (let i = 0; i < n; i++)
        if (t[i] !== e[i])
            return !1;
    return !0
}
function LI(e) {
    const t = {};
    return e.values.forEach((n,i)=>t[i] = n.get()),
    t
}
function RI(e) {
    const t = {};
    return e.values.forEach((n,i)=>t[i] = n.getVelocity()),
    t
}
function rf(e, t, n) {
    const i = e.getProps();
    return V2(i, t, n !== void 0 ? n : i.custom, LI(e), RI(e))
}
const _I = "framerAppearId"
  , DI = "data-" + B2(_I);
let NI = Et
  , W2 = Et;
const Gr = e=>e * 1e3
  , ar = e=>e / 1e3
  , FI = {
    current: !1
}
  , OC = e=>Array.isArray(e) && typeof e[0] == "number";
function LC(e) {
    return !!(!e || typeof e == "string" && RC[e] || OC(e) || Array.isArray(e) && e.every(LC))
}
const qa = ([e,t,n,i])=>`cubic-bezier(${e}, ${t}, ${n}, ${i})`
  , RC = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: qa([0, .65, .55, 1]),
    circOut: qa([.55, 0, 1, .45]),
    backIn: qa([.31, .01, .66, -.59]),
    backOut: qa([.33, 1.53, .69, .99])
};
function _C(e) {
    if (e)
        return OC(e) ? qa(e) : Array.isArray(e) ? e.map(_C) : RC[e]
}
function II(e, t, n, {delay: i=0, duration: r, repeat: s=0, repeatType: o="loop", ease: a, times: l}={}) {
    const c = {
        [t]: n
    };
    l && (c.offset = l);
    const u = _C(a);
    return Array.isArray(u) && (c.easing = u),
    e.animate(c, {
        delay: i,
        duration: r,
        easing: Array.isArray(u) ? "linear" : u,
        fill: "both",
        iterations: s + 1,
        direction: o === "reverse" ? "alternate" : "normal"
    })
}
function BI(e, {repeat: t, repeatType: n="loop"}) {
    const i = t && n !== "loop" && t % 2 === 1 ? 0 : e.length - 1;
    return e[i]
}
const DC = (e,t,n)=>(((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e
  , zI = 1e-7
  , VI = 12;
function WI(e, t, n, i, r) {
    let s, o, a = 0;
    do
        o = t + (n - t) / 2,
        s = DC(o, i, r) - e,
        s > 0 ? n = o : t = o;
    while (Math.abs(s) > zI && ++a < VI);
    return o
}
function kc(e, t, n, i) {
    if (e === t && n === i)
        return Et;
    const r = s=>WI(s, 0, 1, e, n);
    return s=>s === 0 || s === 1 ? s : DC(r(s), t, i)
}
const HI = kc(.42, 0, 1, 1)
  , UI = kc(0, 0, .58, 1)
  , NC = kc(.42, 0, .58, 1)
  , GI = e=>Array.isArray(e) && typeof e[0] != "number"
  , FC = e=>t=>t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2
  , IC = e=>t=>1 - e(1 - t)
  , BC = e=>1 - Math.sin(Math.acos(e))
  , H2 = IC(BC)
  , XI = FC(H2)
  , zC = kc(.33, 1.53, .69, .99)
  , U2 = IC(zC)
  , YI = FC(U2)
  , $I = e=>(e *= 2) < 1 ? .5 * U2(e) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
  , KI = {
    linear: Et,
    easeIn: HI,
    easeInOut: NC,
    easeOut: UI,
    circIn: BC,
    circInOut: XI,
    circOut: H2,
    backIn: U2,
    backInOut: YI,
    backOut: zC,
    anticipate: $I
}
  , gb = e=>{
    if (Array.isArray(e)) {
        W2(e.length === 4);
        const [t,n,i,r] = e;
        return kc(t, n, i, r)
    } else if (typeof e == "string")
        return KI[e];
    return e
}
  , G2 = (e,t)=>n=>!!(Sc(n) && YF.test(n) && n.startsWith(e) || t && Object.prototype.hasOwnProperty.call(n, t))
  , VC = (e,t,n)=>i=>{
    if (!Sc(i))
        return i;
    const [r,s,o,a] = i.match(tf);
    return {
        [e]: parseFloat(r),
        [t]: parseFloat(s),
        [n]: parseFloat(o),
        alpha: a !== void 0 ? parseFloat(a) : 1
    }
}
  , QI = e=>Qr(0, 255, e)
  , w0 = {
    ...oo,
    transform: e=>Math.round(QI(e))
}
  , Fs = {
    test: G2("rgb", "red"),
    parse: VC("red", "green", "blue"),
    transform: ({red: e, green: t, blue: n, alpha: i=1})=>"rgba(" + w0.transform(e) + ", " + w0.transform(t) + ", " + w0.transform(n) + ", " + ml(gl.transform(i)) + ")"
};
function qI(e) {
    let t = ""
      , n = ""
      , i = ""
      , r = "";
    return e.length > 5 ? (t = e.substring(1, 3),
    n = e.substring(3, 5),
    i = e.substring(5, 7),
    r = e.substring(7, 9)) : (t = e.substring(1, 2),
    n = e.substring(2, 3),
    i = e.substring(3, 4),
    r = e.substring(4, 5),
    t += t,
    n += n,
    i += i,
    r += r),
    {
        red: parseInt(t, 16),
        green: parseInt(n, 16),
        blue: parseInt(i, 16),
        alpha: r ? parseInt(r, 16) / 255 : 1
    }
}
const wg = {
    test: G2("#"),
    parse: qI,
    transform: Fs.transform
}
  , Ho = {
    test: G2("hsl", "hue"),
    parse: VC("hue", "saturation", "lightness"),
    transform: ({hue: e, saturation: t, lightness: n, alpha: i=1})=>"hsla(" + Math.round(e) + ", " + Bi.transform(ml(t)) + ", " + Bi.transform(ml(n)) + ", " + ml(gl.transform(i)) + ")"
}
  , dn = {
    test: e=>Fs.test(e) || wg.test(e) || Ho.test(e),
    parse: e=>Fs.test(e) ? Fs.parse(e) : Ho.test(e) ? Ho.parse(e) : wg.parse(e),
    transform: e=>Sc(e) ? e : e.hasOwnProperty("red") ? Fs.transform(e) : Ho.transform(e)
}
  , wt = (e,t,n)=>-n * e + n * t + e;
function S0(e, t, n) {
    return n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
}
function ZI({hue: e, saturation: t, lightness: n, alpha: i}) {
    e /= 360,
    t /= 100,
    n /= 100;
    let r = 0
      , s = 0
      , o = 0;
    if (!t)
        r = s = o = n;
    else {
        const a = n < .5 ? n * (1 + t) : n + t - n * t
          , l = 2 * n - a;
        r = S0(l, a, e + 1 / 3),
        s = S0(l, a, e),
        o = S0(l, a, e - 1 / 3)
    }
    return {
        red: Math.round(r * 255),
        green: Math.round(s * 255),
        blue: Math.round(o * 255),
        alpha: i
    }
}
const C0 = (e,t,n)=>{
    const i = e * e;
    return Math.sqrt(Math.max(0, n * (t * t - i) + i))
}
  , JI = [wg, Fs, Ho]
  , eB = e=>JI.find(t=>t.test(e));
function mb(e) {
    const t = eB(e);
    let n = t.parse(e);
    return t === Ho && (n = ZI(n)),
    n
}
const WC = (e,t)=>{
    const n = mb(e)
      , i = mb(t)
      , r = {
        ...n
    };
    return s=>(r.red = C0(n.red, i.red, s),
    r.green = C0(n.green, i.green, s),
    r.blue = C0(n.blue, i.blue, s),
    r.alpha = wt(n.alpha, i.alpha, s),
    Fs.transform(r))
}
;
function tB(e) {
    var t, n;
    return isNaN(e) && Sc(e) && (((t = e.match(tf)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(gC)) === null || n === void 0 ? void 0 : n.length) || 0) > 0
}
const HC = {
    regex: GF,
    countKey: "Vars",
    token: "${v}",
    parse: Et
}
  , UC = {
    regex: gC,
    countKey: "Colors",
    token: "${c}",
    parse: dn.parse
}
  , GC = {
    regex: tf,
    countKey: "Numbers",
    token: "${n}",
    parse: oo.parse
};
function k0(e, {regex: t, countKey: n, token: i, parse: r}) {
    const s = e.tokenised.match(t);
    s && (e["num" + n] = s.length,
    e.tokenised = e.tokenised.replace(t, i),
    e.values.push(...s.map(r)))
}
function $h(e) {
    const t = e.toString()
      , n = {
        value: t,
        tokenised: t,
        values: [],
        numVars: 0,
        numColors: 0,
        numNumbers: 0
    };
    return n.value.includes("var(--") && k0(n, HC),
    k0(n, UC),
    k0(n, GC),
    n
}
function XC(e) {
    return $h(e).values
}
function YC(e) {
    const {values: t, numColors: n, numVars: i, tokenised: r} = $h(e)
      , s = t.length;
    return o=>{
        let a = r;
        for (let l = 0; l < s; l++)
            l < i ? a = a.replace(HC.token, o[l]) : l < i + n ? a = a.replace(UC.token, dn.transform(o[l])) : a = a.replace(GC.token, ml(o[l]));
        return a
    }
}
const nB = e=>typeof e == "number" ? 0 : e;
function iB(e) {
    const t = XC(e);
    return YC(e)(t.map(nB))
}
const qr = {
    test: tB,
    parse: XC,
    createTransformer: YC,
    getAnimatableNone: iB
}
  , $C = (e,t)=>n=>`${n > 0 ? t : e}`;
function KC(e, t) {
    return typeof e == "number" ? n=>wt(e, t, n) : dn.test(e) ? WC(e, t) : e.startsWith("var(") ? $C(e, t) : qC(e, t)
}
const QC = (e,t)=>{
    const n = [...e]
      , i = n.length
      , r = e.map((s,o)=>KC(s, t[o]));
    return s=>{
        for (let o = 0; o < i; o++)
            n[o] = r[o](s);
        return n
    }
}
  , rB = (e,t)=>{
    const n = {
        ...e,
        ...t
    }
      , i = {};
    for (const r in n)
        e[r] !== void 0 && t[r] !== void 0 && (i[r] = KC(e[r], t[r]));
    return r=>{
        for (const s in i)
            n[s] = i[s](r);
        return n
    }
}
  , qC = (e,t)=>{
    const n = qr.createTransformer(t)
      , i = $h(e)
      , r = $h(t);
    return i.numVars === r.numVars && i.numColors === r.numColors && i.numNumbers >= r.numNumbers ? Ur(QC(i.values, r.values), n) : $C(e, t)
}
  , ql = (e,t,n)=>{
    const i = t - e;
    return i === 0 ? 1 : (n - e) / i
}
  , vb = (e,t)=>n=>wt(e, t, n);
function sB(e) {
    return typeof e == "number" ? vb : typeof e == "string" ? dn.test(e) ? WC : qC : Array.isArray(e) ? QC : typeof e == "object" ? rB : vb
}
function oB(e, t, n) {
    const i = []
      , r = n || sB(e[0])
      , s = e.length - 1;
    for (let o = 0; o < s; o++) {
        let a = r(e[o], e[o + 1]);
        if (t) {
            const l = Array.isArray(t) ? t[o] || Et : t;
            a = Ur(l, a)
        }
        i.push(a)
    }
    return i
}
function ZC(e, t, {clamp: n=!0, ease: i, mixer: r}={}) {
    const s = e.length;
    if (W2(s === t.length),
    s === 1)
        return ()=>t[0];
    e[0] > e[s - 1] && (e = [...e].reverse(),
    t = [...t].reverse());
    const o = oB(t, i, r)
      , a = o.length
      , l = c=>{
        let u = 0;
        if (a > 1)
            for (; u < e.length - 2 && !(c < e[u + 1]); u++)
                ;
        const h = ql(e[u], e[u + 1], c);
        return o[u](h)
    }
    ;
    return n ? c=>l(Qr(e[0], e[s - 1], c)) : l
}
function aB(e, t) {
    const n = e[e.length - 1];
    for (let i = 1; i <= t; i++) {
        const r = ql(0, t, i);
        e.push(wt(n, 1, r))
    }
}
function lB(e) {
    const t = [0];
    return aB(t, e.length - 1),
    t
}
function cB(e, t) {
    return e.map(n=>n * t)
}
function uB(e, t) {
    return e.map(()=>t || NC).splice(0, e.length - 1)
}
function Kh({duration: e=300, keyframes: t, times: n, ease: i="easeInOut"}) {
    const r = GI(i) ? i.map(gb) : gb(i)
      , s = {
        done: !1,
        value: t[0]
    }
      , o = cB(n && n.length === t.length ? n : lB(t), e)
      , a = ZC(o, t, {
        ease: Array.isArray(r) ? r : uB(t, r)
    });
    return {
        calculatedDuration: e,
        next: l=>(s.value = a(l),
        s.done = l >= e,
        s)
    }
}
function JC(e, t) {
    return t ? e * (1e3 / t) : 0
}
const hB = 5;
function ek(e, t, n) {
    const i = Math.max(t - hB, 0);
    return JC(n - e(i), t - i)
}
const A0 = .001
  , dB = .01
  , yb = 10
  , fB = .05
  , pB = 1;
function gB({duration: e=800, bounce: t=.25, velocity: n=0, mass: i=1}) {
    let r, s;
    NI(e <= Gr(yb));
    let o = 1 - t;
    o = Qr(fB, pB, o),
    e = Qr(dB, yb, ar(e)),
    o < 1 ? (r = c=>{
        const u = c * o
          , h = u * e
          , d = u - n
          , m = Sg(c, o)
          , f = Math.exp(-h);
        return A0 - d / m * f
    }
    ,
    s = c=>{
        const h = c * o * e
          , d = h * n + n
          , m = Math.pow(o, 2) * Math.pow(c, 2) * e
          , f = Math.exp(-h)
          , x = Sg(Math.pow(c, 2), o);
        return (-r(c) + A0 > 0 ? -1 : 1) * ((d - m) * f) / x
    }
    ) : (r = c=>{
        const u = Math.exp(-c * e)
          , h = (c - n) * e + 1;
        return -A0 + u * h
    }
    ,
    s = c=>{
        const u = Math.exp(-c * e)
          , h = (n - c) * (e * e);
        return u * h
    }
    );
    const a = 5 / e
      , l = vB(r, s, a);
    if (e = Gr(e),
    isNaN(l))
        return {
            stiffness: 100,
            damping: 10,
            duration: e
        };
    {
        const c = Math.pow(l, 2) * i;
        return {
            stiffness: c,
            damping: o * 2 * Math.sqrt(i * c),
            duration: e
        }
    }
}
const mB = 12;
function vB(e, t, n) {
    let i = n;
    for (let r = 1; r < mB; r++)
        i = i - e(i) / t(i);
    return i
}
function Sg(e, t) {
    return e * Math.sqrt(1 - t * t)
}
const yB = ["duration", "bounce"]
  , xB = ["stiffness", "damping", "mass"];
function xb(e, t) {
    return t.some(n=>e[n] !== void 0)
}
function bB(e) {
    let t = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...e
    };
    if (!xb(e, xB) && xb(e, yB)) {
        const n = gB(e);
        t = {
            ...t,
            ...n,
            velocity: 0,
            mass: 1
        },
        t.isResolvedFromDuration = !0
    }
    return t
}
function tk({keyframes: e, restDelta: t, restSpeed: n, ...i}) {
    const r = e[0]
      , s = e[e.length - 1]
      , o = {
        done: !1,
        value: r
    }
      , {stiffness: a, damping: l, mass: c, velocity: u, duration: h, isResolvedFromDuration: d} = bB(i)
      , m = u ? -ar(u) : 0
      , f = l / (2 * Math.sqrt(a * c))
      , x = s - r
      , S = ar(Math.sqrt(a / c))
      , v = Math.abs(x) < 5;
    n || (n = v ? .01 : 2),
    t || (t = v ? .005 : .5);
    let p;
    if (f < 1) {
        const g = Sg(S, f);
        p = C=>{
            const E = Math.exp(-f * S * C);
            return s - E * ((m + f * S * x) / g * Math.sin(g * C) + x * Math.cos(g * C))
        }
    } else if (f === 1)
        p = g=>s - Math.exp(-S * g) * (x + (m + S * x) * g);
    else {
        const g = S * Math.sqrt(f * f - 1);
        p = C=>{
            const E = Math.exp(-f * S * C)
              , O = Math.min(g * C, 300);
            return s - E * ((m + f * S * x) * Math.sinh(O) + g * x * Math.cosh(O)) / g
        }
    }
    return {
        calculatedDuration: d && h || null,
        next: g=>{
            const C = p(g);
            if (d)
                o.done = g >= h;
            else {
                let E = m;
                g !== 0 && (f < 1 ? E = ek(p, g, C) : E = 0);
                const O = Math.abs(E) <= n
                  , R = Math.abs(s - C) <= t;
                o.done = O && R
            }
            return o.value = o.done ? s : C,
            o
        }
    }
}
function bb({keyframes: e, velocity: t=0, power: n=.8, timeConstant: i=325, bounceDamping: r=10, bounceStiffness: s=500, modifyTarget: o, min: a, max: l, restDelta: c=.5, restSpeed: u}) {
    const h = e[0]
      , d = {
        done: !1,
        value: h
    }
      , m = F=>a !== void 0 && F < a || l !== void 0 && F > l
      , f = F=>a === void 0 ? l : l === void 0 || Math.abs(a - F) < Math.abs(l - F) ? a : l;
    let x = n * t;
    const S = h + x
      , v = o === void 0 ? S : o(S);
    v !== S && (x = v - h);
    const p = F=>-x * Math.exp(-F / i)
      , g = F=>v + p(F)
      , C = F=>{
        const P = p(F)
          , _ = g(F);
        d.done = Math.abs(P) <= c,
        d.value = d.done ? v : _
    }
    ;
    let E, O;
    const R = F=>{
        m(d.value) && (E = F,
        O = tk({
            keyframes: [d.value, f(d.value)],
            velocity: ek(g, F, d.value),
            damping: r,
            stiffness: s,
            restDelta: c,
            restSpeed: u
        }))
    }
    ;
    return R(0),
    {
        calculatedDuration: null,
        next: F=>{
            let P = !1;
            return !O && E === void 0 && (P = !0,
            C(F),
            R(F)),
            E !== void 0 && F > E ? O.next(F - E) : (!P && C(F),
            d)
        }
    }
}
const wB = e=>{
    const t = ({timestamp: n})=>e(n);
    return {
        start: ()=>gt.update(t, !0),
        stop: ()=>dr(t),
        now: ()=>Yt.isProcessing ? Yt.timestamp : performance.now()
    }
}
  , wb = 2e4;
function Sb(e) {
    let t = 0;
    const n = 50;
    let i = e.next(t);
    for (; !i.done && t < wb; )
        t += n,
        i = e.next(t);
    return t >= wb ? 1 / 0 : t
}
const SB = {
    decay: bb,
    inertia: bb,
    tween: Kh,
    keyframes: Kh,
    spring: tk
};
function Qh({autoplay: e=!0, delay: t=0, driver: n=wB, keyframes: i, type: r="keyframes", repeat: s=0, repeatDelay: o=0, repeatType: a="loop", onPlay: l, onStop: c, onComplete: u, onUpdate: h, ...d}) {
    let m = 1, f = !1, x, S;
    const v = ()=>{
        S = new Promise(N=>{
            x = N
        }
        )
    }
    ;
    v();
    let p;
    const g = SB[r] || Kh;
    let C;
    g !== Kh && typeof i[0] != "number" && (C = ZC([0, 100], i, {
        clamp: !1
    }),
    i = [0, 100]);
    const E = g({
        ...d,
        keyframes: i
    });
    let O;
    a === "mirror" && (O = g({
        ...d,
        keyframes: [...i].reverse(),
        velocity: -(d.velocity || 0)
    }));
    let R = "idle"
      , F = null
      , P = null
      , _ = null;
    E.calculatedDuration === null && s && (E.calculatedDuration = Sb(E));
    const {calculatedDuration: T} = E;
    let L = 1 / 0
      , I = 1 / 0;
    T !== null && (L = T + o,
    I = L * (s + 1) - o);
    let k = 0;
    const w = N=>{
        if (P === null)
            return;
        m > 0 && (P = Math.min(P, N)),
        m < 0 && (P = Math.min(N - I / m, P)),
        F !== null ? k = F : k = Math.round(N - P) * m;
        const H = k - t * (m >= 0 ? 1 : -1)
          , X = m >= 0 ? H < 0 : H > I;
        k = Math.max(H, 0),
        R === "finished" && F === null && (k = I);
        let ie = k
          , K = E;
        if (s) {
            const ee = k / L;
            let J = Math.floor(ee)
              , te = ee % 1;
            !te && ee >= 1 && (te = 1),
            te === 1 && J--,
            J = Math.min(J, s + 1);
            const z = !!(J % 2);
            z && (a === "reverse" ? (te = 1 - te,
            o && (te -= o / L)) : a === "mirror" && (K = O));
            let Y = Qr(0, 1, te);
            k > I && (Y = a === "reverse" && z ? 1 : 0),
            ie = Y * L
        }
        const D = X ? {
            done: !1,
            value: i[0]
        } : K.next(ie);
        C && (D.value = C(D.value));
        let {done: V} = D;
        !X && T !== null && (V = m >= 0 ? k >= I : k <= 0);
        const G = F === null && (R === "finished" || R === "running" && V);
        return h && h(D.value),
        G && j(),
        D
    }
      , b = ()=>{
        p && p.stop(),
        p = void 0
    }
      , A = ()=>{
        R = "idle",
        b(),
        x(),
        v(),
        P = _ = null
    }
      , j = ()=>{
        R = "finished",
        u && u(),
        b(),
        x()
    }
      , B = ()=>{
        if (f)
            return;
        p || (p = n(w));
        const N = p.now();
        l && l(),
        F !== null ? P = N - F : (!P || R === "finished") && (P = N),
        R === "finished" && v(),
        _ = P,
        F = null,
        R = "running",
        p.start()
    }
    ;
    e && B();
    const W = {
        then(N, H) {
            return S.then(N, H)
        },
        get time() {
            return ar(k)
        },
        set time(N) {
            N = Gr(N),
            k = N,
            F !== null || !p || m === 0 ? F = N : P = p.now() - N / m
        },
        get duration() {
            const N = E.calculatedDuration === null ? Sb(E) : E.calculatedDuration;
            return ar(N)
        },
        get speed() {
            return m
        },
        set speed(N) {
            N === m || !p || (m = N,
            W.time = ar(k))
        },
        get state() {
            return R
        },
        play: B,
        pause: ()=>{
            R = "paused",
            F = k
        }
        ,
        stop: ()=>{
            f = !0,
            R !== "idle" && (R = "idle",
            c && c(),
            A())
        }
        ,
        cancel: ()=>{
            _ !== null && w(_),
            A()
        }
        ,
        complete: ()=>{
            R = "finished"
        }
        ,
        sample: N=>(P = 0,
        w(N))
    };
    return W
}
function CB(e) {
    let t;
    return ()=>(t === void 0 && (t = e()),
    t)
}
const kB = CB(()=>Object.hasOwnProperty.call(Element.prototype, "animate"))
  , AB = new Set(["opacity", "clipPath", "filter", "transform", "backgroundColor"])
  , vu = 10
  , MB = 2e4
  , EB = (e,t)=>t.type === "spring" || e === "backgroundColor" || !LC(t.ease);
function PB(e, t, {onUpdate: n, onComplete: i, ...r}) {
    if (!(kB() && AB.has(t) && !r.repeatDelay && r.repeatType !== "mirror" && r.damping !== 0 && r.type !== "inertia"))
        return !1;
    let o = !1, a, l;
    const c = ()=>{
        l = new Promise(p=>{
            a = p
        }
        )
    }
    ;
    c();
    let {keyframes: u, duration: h=300, ease: d, times: m} = r;
    if (EB(t, r)) {
        const p = Qh({
            ...r,
            repeat: 0,
            delay: 0
        });
        let g = {
            done: !1,
            value: u[0]
        };
        const C = [];
        let E = 0;
        for (; !g.done && E < MB; )
            g = p.sample(E),
            C.push(g.value),
            E += vu;
        m = void 0,
        u = C,
        h = E - vu,
        d = "linear"
    }
    const f = II(e.owner.current, t, u, {
        ...r,
        duration: h,
        ease: d,
        times: m
    });
    r.syncStart && (f.startTime = Yt.isProcessing ? Yt.timestamp : document.timeline ? document.timeline.currentTime : performance.now());
    const x = ()=>f.cancel()
      , S = ()=>{
        gt.update(x),
        a(),
        c()
    }
    ;
    return f.onfinish = ()=>{
        e.set(BI(u, r)),
        i && i(),
        S()
    }
    ,
    {
        then(p, g) {
            return l.then(p, g)
        },
        attachTimeline(p) {
            return f.timeline = p,
            f.onfinish = null,
            Et
        },
        get time() {
            return ar(f.currentTime || 0)
        },
        set time(p) {
            f.currentTime = Gr(p)
        },
        get speed() {
            return f.playbackRate
        },
        set speed(p) {
            f.playbackRate = p
        },
        get duration() {
            return ar(h)
        },
        play: ()=>{
            o || (f.play(),
            dr(x))
        }
        ,
        pause: ()=>f.pause(),
        stop: ()=>{
            if (o = !0,
            f.playState === "idle")
                return;
            const {currentTime: p} = f;
            if (p) {
                const g = Qh({
                    ...r,
                    autoplay: !1
                });
                e.setWithVelocity(g.sample(p - vu).value, g.sample(p).value, vu)
            }
            S()
        }
        ,
        complete: ()=>f.finish(),
        cancel: S
    }
}
function TB({keyframes: e, delay: t, onUpdate: n, onComplete: i}) {
    const r = ()=>(n && n(e[e.length - 1]),
    i && i(),
    {
        time: 0,
        speed: 1,
        duration: 0,
        play: Et,
        pause: Et,
        stop: Et,
        then: s=>(s(),
        Promise.resolve()),
        cancel: Et,
        complete: Et
    });
    return t ? Qh({
        keyframes: [0, 1],
        duration: 0,
        delay: t,
        onComplete: r
    }) : r()
}
const jB = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , OB = e=>({
    type: "spring",
    stiffness: 550,
    damping: e === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , LB = {
    type: "keyframes",
    duration: .8
}
  , RB = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , _B = (e,{keyframes: t})=>t.length > 2 ? LB : so.has(e) ? e.startsWith("scale") ? OB(t[1]) : jB : RB
  , Cg = (e,t)=>e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (qr.test(t) || t === "0") && !t.startsWith("url("))
  , DB = new Set(["brightness", "contrast", "saturate", "opacity"]);
function NB(e) {
    const [t,n] = e.slice(0, -1).split("(");
    if (t === "drop-shadow")
        return e;
    const [i] = n.match(tf) || [];
    if (!i)
        return e;
    const r = n.replace(i, "");
    let s = DB.has(t) ? 1 : 0;
    return i !== n && (s *= 100),
    t + "(" + s + r + ")"
}
const FB = /([a-z-]*)\(.*?\)/g
  , kg = {
    ...qr,
    getAnimatableNone: e=>{
        const t = e.match(FB);
        return t ? t.map(NB).join(" ") : e
    }
}
  , IB = {
    ...mC,
    color: dn,
    backgroundColor: dn,
    outlineColor: dn,
    fill: dn,
    stroke: dn,
    borderColor: dn,
    borderTopColor: dn,
    borderRightColor: dn,
    borderBottomColor: dn,
    borderLeftColor: dn,
    filter: kg,
    WebkitFilter: kg
}
  , X2 = e=>IB[e];
function nk(e, t) {
    let n = X2(e);
    return n !== kg && (n = qr),
    n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
}
const ik = e=>/^0[^.\s]+$/.test(e);
function BB(e) {
    if (typeof e == "number")
        return e === 0;
    if (e !== null)
        return e === "none" || e === "0" || ik(e)
}
function zB(e, t, n, i) {
    const r = Cg(t, n);
    let s;
    Array.isArray(n) ? s = [...n] : s = [null, n];
    const o = i.from !== void 0 ? i.from : e.get();
    let a;
    const l = [];
    for (let c = 0; c < s.length; c++)
        s[c] === null && (s[c] = c === 0 ? o : s[c - 1]),
        BB(s[c]) && l.push(c),
        typeof s[c] == "string" && s[c] !== "none" && s[c] !== "0" && (a = s[c]);
    if (r && l.length && a)
        for (let c = 0; c < l.length; c++) {
            const u = l[c];
            s[u] = nk(t, a)
        }
    return s
}
function VB({when: e, delay: t, delayChildren: n, staggerChildren: i, staggerDirection: r, repeat: s, repeatType: o, repeatDelay: a, from: l, elapsed: c, ...u}) {
    return !!Object.keys(u).length
}
function rk(e, t) {
    return e[t] || e.default || e
}
const Y2 = (e,t,n,i={})=>r=>{
    const s = rk(i, e) || {}
      , o = s.delay || i.delay || 0;
    let {elapsed: a=0} = i;
    a = a - Gr(o);
    const l = zB(t, e, n, s)
      , c = l[0]
      , u = l[l.length - 1]
      , h = Cg(e, c)
      , d = Cg(e, u);
    let m = {
        keyframes: l,
        velocity: t.getVelocity(),
        ease: "easeOut",
        ...s,
        delay: -a,
        onUpdate: f=>{
            t.set(f),
            s.onUpdate && s.onUpdate(f)
        }
        ,
        onComplete: ()=>{
            r(),
            s.onComplete && s.onComplete()
        }
    };
    if (VB(s) || (m = {
        ...m,
        ..._B(e, m)
    }),
    m.duration && (m.duration = Gr(m.duration)),
    m.repeatDelay && (m.repeatDelay = Gr(m.repeatDelay)),
    !h || !d || FI.current || s.type === !1)
        return TB(m);
    if (t.owner && t.owner.current instanceof HTMLElement && !t.owner.getProps().onUpdate) {
        const f = PB(t, e, m);
        if (f)
            return f
    }
    return Qh(m)
}
;
function qh(e) {
    return !!(jn(e) && e.add)
}
const sk = e=>/^\-?\d*\.?\d+$/.test(e);
function $2(e, t) {
    e.indexOf(t) === -1 && e.push(t)
}
function K2(e, t) {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}
class Q2 {
    constructor() {
        this.subscriptions = []
    }
    add(t) {
        return $2(this.subscriptions, t),
        ()=>K2(this.subscriptions, t)
    }
    notify(t, n, i) {
        const r = this.subscriptions.length;
        if (r)
            if (r === 1)
                this.subscriptions[0](t, n, i);
            else
                for (let s = 0; s < r; s++) {
                    const o = this.subscriptions[s];
                    o && o(t, n, i)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
const WB = e=>!isNaN(parseFloat(e));
class HB {
    constructor(t, n={}) {
        this.version = "10.16.5",
        this.timeDelta = 0,
        this.lastUpdated = 0,
        this.canTrackVelocity = !1,
        this.events = {},
        this.updateAndNotify = (i,r=!0)=>{
            this.prev = this.current,
            this.current = i;
            const {delta: s, timestamp: o} = Yt;
            this.lastUpdated !== o && (this.timeDelta = s,
            this.lastUpdated = o,
            gt.postRender(this.scheduleVelocityCheck)),
            this.prev !== this.current && this.events.change && this.events.change.notify(this.current),
            this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()),
            r && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }
        ,
        this.scheduleVelocityCheck = ()=>gt.postRender(this.velocityCheck),
        this.velocityCheck = ({timestamp: i})=>{
            i !== this.lastUpdated && (this.prev = this.current,
            this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()))
        }
        ,
        this.hasAnimated = !1,
        this.prev = this.current = t,
        this.canTrackVelocity = WB(this.current),
        this.owner = n.owner
    }
    onChange(t) {
        return this.on("change", t)
    }
    on(t, n) {
        this.events[t] || (this.events[t] = new Q2);
        const i = this.events[t].add(n);
        return t === "change" ? ()=>{
            i(),
            gt.read(()=>{
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : i
    }
    clearListeners() {
        for (const t in this.events)
            this.events[t].clear()
    }
    attach(t, n) {
        this.passiveEffect = t,
        this.stopPassiveEffect = n
    }
    set(t, n=!0) {
        !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify)
    }
    setWithVelocity(t, n, i) {
        this.set(n),
        this.prev = t,
        this.timeDelta = i
    }
    jump(t) {
        this.updateAndNotify(t),
        this.prev = t,
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        return this.canTrackVelocity ? JC(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0
    }
    start(t) {
        return this.stop(),
        new Promise(n=>{
            this.hasAnimated = !0,
            this.animation = t(n),
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then(()=>{
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function pa(e, t) {
    return new HB(e,t)
}
const ok = e=>t=>t.test(e)
  , UB = {
    test: e=>e === "auto",
    parse: e=>e
}
  , ak = [oo, De, Bi, xr, KF, $F, UB]
  , Ba = e=>ak.find(ok(e))
  , GB = [...ak, dn, qr]
  , XB = e=>GB.find(ok(e));
function YB(e, t, n) {
    e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, pa(n))
}
function $B(e, t) {
    const n = rf(e, t);
    let {transitionEnd: i={}, transition: r={}, ...s} = n ? e.makeTargetAnimatable(n, !1) : {};
    s = {
        ...s,
        ...i
    };
    for (const o in s) {
        const a = uI(s[o]);
        YB(e, o, a)
    }
}
function KB(e, t, n) {
    var i, r;
    const s = Object.keys(t).filter(a=>!e.hasValue(a))
      , o = s.length;
    if (o)
        for (let a = 0; a < o; a++) {
            const l = s[a]
              , c = t[l];
            let u = null;
            Array.isArray(c) && (u = c[0]),
            u === null && (u = (r = (i = n[l]) !== null && i !== void 0 ? i : e.readValue(l)) !== null && r !== void 0 ? r : t[l]),
            u != null && (typeof u == "string" && (sk(u) || ik(u)) ? u = parseFloat(u) : !XB(u) && qr.test(c) && (u = nk(l, c)),
            e.addValue(l, pa(u, {
                owner: e
            })),
            n[l] === void 0 && (n[l] = u),
            u !== null && e.setBaseTarget(l, u))
        }
}
function QB(e, t) {
    return t ? (t[e] || t.default || t).from : void 0
}
function qB(e, t, n) {
    const i = {};
    for (const r in e) {
        const s = QB(r, t);
        if (s !== void 0)
            i[r] = s;
        else {
            const o = n.getValue(r);
            o && (i[r] = o.get())
        }
    }
    return i
}
function ZB({protectedKeys: e, needsAnimating: t}, n) {
    const i = e.hasOwnProperty(n) && t[n] !== !0;
    return t[n] = !1,
    i
}
function lk(e, t, {delay: n=0, transitionOverride: i, type: r}={}) {
    let {transition: s=e.getDefaultTransition(), transitionEnd: o, ...a} = e.makeTargetAnimatable(t);
    const l = e.getValue("willChange");
    i && (s = i);
    const c = []
      , u = r && e.animationState && e.animationState.getState()[r];
    for (const h in a) {
        const d = e.getValue(h)
          , m = a[h];
        if (!d || m === void 0 || u && ZB(u, h))
            continue;
        const f = {
            delay: n,
            elapsed: 0,
            ...s
        };
        if (window.HandoffAppearAnimations && !d.hasAnimated) {
            const S = e.getProps()[DI];
            S && (f.elapsed = window.HandoffAppearAnimations(S, h, d, gt),
            f.syncStart = !0)
        }
        d.start(Y2(h, d, m, e.shouldReduceMotion && so.has(h) ? {
            type: !1
        } : f));
        const x = d.animation;
        qh(l) && (l.add(h),
        x.then(()=>l.remove(h))),
        c.push(x)
    }
    return o && Promise.all(c).then(()=>{
        o && $B(e, o)
    }
    ),
    c
}
function Ag(e, t, n={}) {
    const i = rf(e, t, n.custom);
    let {transition: r=e.getDefaultTransition() || {}} = i || {};
    n.transitionOverride && (r = n.transitionOverride);
    const s = i ? ()=>Promise.all(lk(e, i, n)) : ()=>Promise.resolve()
      , o = e.variantChildren && e.variantChildren.size ? (l=0)=>{
        const {delayChildren: c=0, staggerChildren: u, staggerDirection: h} = r;
        return JB(e, t, c + l, u, h, n)
    }
    : ()=>Promise.resolve()
      , {when: a} = r;
    if (a) {
        const [l,c] = a === "beforeChildren" ? [s, o] : [o, s];
        return l().then(()=>c())
    } else
        return Promise.all([s(), o(n.delay)])
}
function JB(e, t, n=0, i=0, r=1, s) {
    const o = []
      , a = (e.variantChildren.size - 1) * i
      , l = r === 1 ? (c=0)=>c * i : (c=0)=>a - c * i;
    return Array.from(e.variantChildren).sort(ez).forEach((c,u)=>{
        c.notify("AnimationStart", t),
        o.push(Ag(c, t, {
            ...s,
            delay: n + l(u)
        }).then(()=>c.notify("AnimationComplete", t)))
    }
    ),
    Promise.all(o)
}
function ez(e, t) {
    return e.sortNodePosition(t)
}
function tz(e, t, n={}) {
    e.notify("AnimationStart", t);
    let i;
    if (Array.isArray(t)) {
        const r = t.map(s=>Ag(e, s, n));
        i = Promise.all(r)
    } else if (typeof t == "string")
        i = Ag(e, t, n);
    else {
        const r = typeof t == "function" ? rf(e, t, n.custom) : t;
        i = Promise.all(lk(e, r, n))
    }
    return i.then(()=>e.notify("AnimationComplete", t))
}
const nz = [...L2].reverse()
  , iz = L2.length;
function rz(e) {
    return t=>Promise.all(t.map(({animation: n, options: i})=>tz(e, n, i)))
}
function sz(e) {
    let t = rz(e);
    const n = az();
    let i = !0;
    const r = (l,c)=>{
        const u = rf(e, c);
        if (u) {
            const {transition: h, transitionEnd: d, ...m} = u;
            l = {
                ...l,
                ...m,
                ...d
            }
        }
        return l
    }
    ;
    function s(l) {
        t = l(e)
    }
    function o(l, c) {
        const u = e.getProps()
          , h = e.getVariantContext(!0) || {}
          , d = []
          , m = new Set;
        let f = {}
          , x = 1 / 0;
        for (let v = 0; v < iz; v++) {
            const p = nz[v]
              , g = n[p]
              , C = u[p] !== void 0 ? u[p] : h[p]
              , E = Kl(C)
              , O = p === c ? g.isActive : null;
            O === !1 && (x = v);
            let R = C === h[p] && C !== u[p] && E;
            if (R && i && e.manuallyAnimateOnMount && (R = !1),
            g.protectedKeys = {
                ...f
            },
            !g.isActive && O === null || !C && !g.prevProp || Jd(C) || typeof C == "boolean")
                continue;
            const F = oz(g.prevProp, C);
            let P = F || p === c && g.isActive && !R && E || v > x && E;
            const _ = Array.isArray(C) ? C : [C];
            let T = _.reduce(r, {});
            O === !1 && (T = {});
            const {prevResolvedValues: L={}} = g
              , I = {
                ...L,
                ...T
            }
              , k = w=>{
                P = !0,
                m.delete(w),
                g.needsAnimating[w] = !0
            }
            ;
            for (const w in I) {
                const b = T[w]
                  , A = L[w];
                f.hasOwnProperty(w) || (b !== A ? Yh(b) && Yh(A) ? !jC(b, A) || F ? k(w) : g.protectedKeys[w] = !0 : b !== void 0 ? k(w) : m.add(w) : b !== void 0 && m.has(w) ? k(w) : g.protectedKeys[w] = !0)
            }
            g.prevProp = C,
            g.prevResolvedValues = T,
            g.isActive && (f = {
                ...f,
                ...T
            }),
            i && e.blockInitialAnimation && (P = !1),
            P && !R && d.push(..._.map(w=>({
                animation: w,
                options: {
                    type: p,
                    ...l
                }
            })))
        }
        if (m.size) {
            const v = {};
            m.forEach(p=>{
                const g = e.getBaseTarget(p);
                g !== void 0 && (v[p] = g)
            }
            ),
            d.push({
                animation: v
            })
        }
        let S = !!d.length;
        return i && u.initial === !1 && !e.manuallyAnimateOnMount && (S = !1),
        i = !1,
        S ? t(d) : Promise.resolve()
    }
    function a(l, c, u) {
        var h;
        if (n[l].isActive === c)
            return Promise.resolve();
        (h = e.variantChildren) === null || h === void 0 || h.forEach(m=>{
            var f;
            return (f = m.animationState) === null || f === void 0 ? void 0 : f.setActive(l, c)
        }
        ),
        n[l].isActive = c;
        const d = o(u, l);
        for (const m in n)
            n[m].protectedKeys = {};
        return d
    }
    return {
        animateChanges: o,
        setActive: a,
        setAnimateFunction: s,
        getState: ()=>n
    }
}
function oz(e, t) {
    return typeof t == "string" ? t !== e : Array.isArray(t) ? !jC(t, e) : !1
}
function gs(e=!1) {
    return {
        isActive: e,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function az() {
    return {
        animate: gs(!0),
        whileInView: gs(),
        whileHover: gs(),
        whileTap: gs(),
        whileDrag: gs(),
        whileFocus: gs(),
        exit: gs()
    }
}
class lz extends ss {
    constructor(t) {
        super(t),
        t.animationState || (t.animationState = sz(t))
    }
    updateAnimationControlsSubscription() {
        const {animate: t} = this.node.getProps();
        this.unmount(),
        Jd(t) && (this.unmount = t.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: t} = this.node.getProps()
          , {animate: n} = this.node.prevProps || {};
        t !== n && this.updateAnimationControlsSubscription()
    }
    unmount() {}
}
let cz = 0;
class uz extends ss {
    constructor() {
        super(...arguments),
        this.id = cz++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: t, onExitComplete: n, custom: i} = this.node.presenceContext
          , {isPresent: r} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || t === r)
            return;
        const s = this.node.animationState.setActive("exit", !t, {
            custom: i ?? this.node.getProps().custom
        });
        n && !t && s.then(()=>n(this.id))
    }
    mount() {
        const {register: t} = this.node.presenceContext || {};
        t && (this.unmount = t(this.id))
    }
    unmount() {}
}
const hz = {
    animation: {
        Feature: lz
    },
    exit: {
        Feature: uz
    }
}
  , Cb = (e,t)=>Math.abs(e - t);
function dz(e, t) {
    const n = Cb(e.x, t.x)
      , i = Cb(e.y, t.y);
    return Math.sqrt(n ** 2 + i ** 2)
}
class ck {
    constructor(t, n, {transformPagePoint: i}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.updatePoint = ()=>{
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const c = E0(this.lastMoveEventInfo, this.history)
              , u = this.startEvent !== null
              , h = dz(c.offset, {
                x: 0,
                y: 0
            }) >= 3;
            if (!u && !h)
                return;
            const {point: d} = c
              , {timestamp: m} = Yt;
            this.history.push({
                ...d,
                timestamp: m
            });
            const {onStart: f, onMove: x} = this.handlers;
            u || (f && f(this.lastMoveEvent, c),
            this.startEvent = this.lastMoveEvent),
            x && x(this.lastMoveEvent, c)
        }
        ,
        this.handlePointerMove = (c,u)=>{
            this.lastMoveEvent = c,
            this.lastMoveEventInfo = M0(u, this.transformPagePoint),
            gt.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (c,u)=>{
            if (this.end(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const {onEnd: h, onSessionEnd: d} = this.handlers
              , m = E0(c.type === "pointercancel" ? this.lastMoveEventInfo : M0(u, this.transformPagePoint), this.history);
            this.startEvent && h && h(c, m),
            d && d(c, m)
        }
        ,
        !AC(t))
            return;
        this.handlers = n,
        this.transformPagePoint = i;
        const r = nf(t)
          , s = M0(r, this.transformPagePoint)
          , {point: o} = s
          , {timestamp: a} = Yt;
        this.history = [{
            ...o,
            timestamp: a
        }];
        const {onSessionStart: l} = n;
        l && l(t, E0(s, this.history)),
        this.removeListeners = Ur(or(window, "pointermove", this.handlePointerMove), or(window, "pointerup", this.handlePointerUp), or(window, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(t) {
        this.handlers = t
    }
    end() {
        this.removeListeners && this.removeListeners(),
        dr(this.updatePoint)
    }
}
function M0(e, t) {
    return t ? {
        point: t(e.point)
    } : e
}
function kb(e, t) {
    return {
        x: e.x - t.x,
        y: e.y - t.y
    }
}
function E0({point: e}, t) {
    return {
        point: e,
        delta: kb(e, uk(t)),
        offset: kb(e, fz(t)),
        velocity: pz(t, .1)
    }
}
function fz(e) {
    return e[0]
}
function uk(e) {
    return e[e.length - 1]
}
function pz(e, t) {
    if (e.length < 2)
        return {
            x: 0,
            y: 0
        };
    let n = e.length - 1
      , i = null;
    const r = uk(e);
    for (; n >= 0 && (i = e[n],
    !(r.timestamp - i.timestamp > Gr(t))); )
        n--;
    if (!i)
        return {
            x: 0,
            y: 0
        };
    const s = ar(r.timestamp - i.timestamp);
    if (s === 0)
        return {
            x: 0,
            y: 0
        };
    const o = {
        x: (r.x - i.x) / s,
        y: (r.y - i.y) / s
    };
    return o.x === 1 / 0 && (o.x = 0),
    o.y === 1 / 0 && (o.y = 0),
    o
}
function Hn(e) {
    return e.max - e.min
}
function Mg(e, t=0, n=.01) {
    return Math.abs(e - t) <= n
}
function Ab(e, t, n, i=.5) {
    e.origin = i,
    e.originPoint = wt(t.min, t.max, e.origin),
    e.scale = Hn(n) / Hn(t),
    (Mg(e.scale, 1, 1e-4) || isNaN(e.scale)) && (e.scale = 1),
    e.translate = wt(n.min, n.max, e.origin) - e.originPoint,
    (Mg(e.translate) || isNaN(e.translate)) && (e.translate = 0)
}
function vl(e, t, n, i) {
    Ab(e.x, t.x, n.x, i ? i.originX : void 0),
    Ab(e.y, t.y, n.y, i ? i.originY : void 0)
}
function Mb(e, t, n) {
    e.min = n.min + t.min,
    e.max = e.min + Hn(t)
}
function gz(e, t, n) {
    Mb(e.x, t.x, n.x),
    Mb(e.y, t.y, n.y)
}
function Eb(e, t, n) {
    e.min = t.min - n.min,
    e.max = e.min + Hn(t)
}
function yl(e, t, n) {
    Eb(e.x, t.x, n.x),
    Eb(e.y, t.y, n.y)
}
function mz(e, {min: t, max: n}, i) {
    return t !== void 0 && e < t ? e = i ? wt(t, e, i.min) : Math.max(e, t) : n !== void 0 && e > n && (e = i ? wt(n, e, i.max) : Math.min(e, n)),
    e
}
function Pb(e, t, n) {
    return {
        min: t !== void 0 ? e.min + t : void 0,
        max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
    }
}
function vz(e, {top: t, left: n, bottom: i, right: r}) {
    return {
        x: Pb(e.x, n, r),
        y: Pb(e.y, t, i)
    }
}
function Tb(e, t) {
    let n = t.min - e.min
      , i = t.max - e.max;
    return t.max - t.min < e.max - e.min && ([n,i] = [i, n]),
    {
        min: n,
        max: i
    }
}
function yz(e, t) {
    return {
        x: Tb(e.x, t.x),
        y: Tb(e.y, t.y)
    }
}
function xz(e, t) {
    let n = .5;
    const i = Hn(e)
      , r = Hn(t);
    return r > i ? n = ql(t.min, t.max - i, e.min) : i > r && (n = ql(e.min, e.max - r, t.min)),
    Qr(0, 1, n)
}
function bz(e, t) {
    const n = {};
    return t.min !== void 0 && (n.min = t.min - e.min),
    t.max !== void 0 && (n.max = t.max - e.min),
    n
}
const Eg = .35;
function wz(e=Eg) {
    return e === !1 ? e = 0 : e === !0 && (e = Eg),
    {
        x: jb(e, "left", "right"),
        y: jb(e, "top", "bottom")
    }
}
function jb(e, t, n) {
    return {
        min: Ob(e, t),
        max: Ob(e, n)
    }
}
function Ob(e, t) {
    return typeof e == "number" ? e : e[t] || 0
}
const Lb = ()=>({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , Uo = ()=>({
    x: Lb(),
    y: Lb()
})
  , Rb = ()=>({
    min: 0,
    max: 0
})
  , _t = ()=>({
    x: Rb(),
    y: Rb()
});
function Oi(e) {
    return [e("x"), e("y")]
}
function hk({top: e, left: t, right: n, bottom: i}) {
    return {
        x: {
            min: t,
            max: n
        },
        y: {
            min: e,
            max: i
        }
    }
}
function Sz({x: e, y: t}) {
    return {
        top: t.min,
        right: e.max,
        bottom: t.max,
        left: e.min
    }
}
function Cz(e, t) {
    if (!t)
        return e;
    const n = t({
        x: e.left,
        y: e.top
    })
      , i = t({
        x: e.right,
        y: e.bottom
    });
    return {
        top: n.y,
        left: n.x,
        bottom: i.y,
        right: i.x
    }
}
function P0(e) {
    return e === void 0 || e === 1
}
function Pg({scale: e, scaleX: t, scaleY: n}) {
    return !P0(e) || !P0(t) || !P0(n)
}
function As(e) {
    return Pg(e) || dk(e) || e.z || e.rotate || e.rotateX || e.rotateY
}
function dk(e) {
    return _b(e.x) || _b(e.y)
}
function _b(e) {
    return e && e !== "0%"
}
function Zh(e, t, n) {
    const i = e - n
      , r = t * i;
    return n + r
}
function Db(e, t, n, i, r) {
    return r !== void 0 && (e = Zh(e, r, i)),
    Zh(e, n, i) + t
}
function Tg(e, t=0, n=1, i, r) {
    e.min = Db(e.min, t, n, i, r),
    e.max = Db(e.max, t, n, i, r)
}
function fk(e, {x: t, y: n}) {
    Tg(e.x, t.translate, t.scale, t.originPoint),
    Tg(e.y, n.translate, n.scale, n.originPoint)
}
function kz(e, t, n, i=!1) {
    const r = n.length;
    if (!r)
        return;
    t.x = t.y = 1;
    let s, o;
    for (let a = 0; a < r; a++) {
        s = n[a],
        o = s.projectionDelta;
        const l = s.instance;
        l && l.style && l.style.display === "contents" || (i && s.options.layoutScroll && s.scroll && s !== s.root && Go(e, {
            x: -s.scroll.offset.x,
            y: -s.scroll.offset.y
        }),
        o && (t.x *= o.x.scale,
        t.y *= o.y.scale,
        fk(e, o)),
        i && As(s.latestValues) && Go(e, s.latestValues))
    }
    t.x = Nb(t.x),
    t.y = Nb(t.y)
}
function Nb(e) {
    return Number.isInteger(e) || e > 1.0000000000001 || e < .999999999999 ? e : 1
}
function Cr(e, t) {
    e.min = e.min + t,
    e.max = e.max + t
}
function Fb(e, t, [n,i,r]) {
    const s = t[r] !== void 0 ? t[r] : .5
      , o = wt(e.min, e.max, s);
    Tg(e, t[n], t[i], o, t.scale)
}
const Az = ["x", "scaleX", "originX"]
  , Mz = ["y", "scaleY", "originY"];
function Go(e, t) {
    Fb(e.x, t, Az),
    Fb(e.y, t, Mz)
}
function pk(e, t) {
    return hk(Cz(e.getBoundingClientRect(), t))
}
function Ez(e, t, n) {
    const i = pk(e, n)
      , {scroll: r} = t;
    return r && (Cr(i.x, r.offset.x),
    Cr(i.y, r.offset.y)),
    i
}
const Pz = new WeakMap;
class Tz {
    constructor(t) {
        this.openGlobalLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = _t(),
        this.visualElement = t
    }
    start(t, {snapToCursor: n=!1}={}) {
        const {presenceContext: i} = this.visualElement;
        if (i && i.isPresent === !1)
            return;
        const r = l=>{
            this.stopAnimation(),
            n && this.snapToCursor(nf(l, "page").point)
        }
          , s = (l,c)=>{
            const {drag: u, dragPropagation: h, onDragStart: d} = this.getProps();
            if (u && !h && (this.openGlobalLock && this.openGlobalLock(),
            this.openGlobalLock = EC(u),
            !this.openGlobalLock))
                return;
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            Oi(f=>{
                let x = this.getAxisMotionValue(f).get() || 0;
                if (Bi.test(x)) {
                    const {projection: S} = this.visualElement;
                    if (S && S.layout) {
                        const v = S.layout.layoutBox[f];
                        v && (x = Hn(v) * (parseFloat(x) / 100))
                    }
                }
                this.originPoint[f] = x
            }
            ),
            d && gt.update(()=>d(l, c), !1, !0);
            const {animationState: m} = this.visualElement;
            m && m.setActive("whileDrag", !0)
        }
          , o = (l,c)=>{
            const {dragPropagation: u, dragDirectionLock: h, onDirectionLock: d, onDrag: m} = this.getProps();
            if (!u && !this.openGlobalLock)
                return;
            const {offset: f} = c;
            if (h && this.currentDirection === null) {
                this.currentDirection = jz(f),
                this.currentDirection !== null && d && d(this.currentDirection);
                return
            }
            this.updateAxis("x", c.point, f),
            this.updateAxis("y", c.point, f),
            this.visualElement.render(),
            m && m(l, c)
        }
          , a = (l,c)=>this.stop(l, c);
        this.panSession = new ck(t,{
            onSessionStart: r,
            onStart: s,
            onMove: o,
            onSessionEnd: a
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint()
        })
    }
    stop(t, n) {
        const i = this.isDragging;
        if (this.cancel(),
        !i)
            return;
        const {velocity: r} = n;
        this.startAnimation(r);
        const {onDragEnd: s} = this.getProps();
        s && gt.update(()=>s(t, n))
    }
    cancel() {
        this.isDragging = !1;
        const {projection: t, animationState: n} = this.visualElement;
        t && (t.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: i} = this.getProps();
        !i && this.openGlobalLock && (this.openGlobalLock(),
        this.openGlobalLock = null),
        n && n.setActive("whileDrag", !1)
    }
    updateAxis(t, n, i) {
        const {drag: r} = this.getProps();
        if (!i || !yu(t, r, this.currentDirection))
            return;
        const s = this.getAxisMotionValue(t);
        let o = this.originPoint[t] + i[t];
        this.constraints && this.constraints[t] && (o = mz(o, this.constraints[t], this.elastic[t])),
        s.set(o)
    }
    resolveConstraints() {
        const {dragConstraints: t, dragElastic: n} = this.getProps()
          , {layout: i} = this.visualElement.projection || {}
          , r = this.constraints;
        t && Wo(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && i ? this.constraints = vz(i.layoutBox, t) : this.constraints = !1,
        this.elastic = wz(n),
        r !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Oi(s=>{
            this.getAxisMotionValue(s) && (this.constraints[s] = bz(i.layoutBox[s], this.constraints[s]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: t, onMeasureDragConstraints: n} = this.getProps();
        if (!t || !Wo(t))
            return !1;
        const i = t.current
          , {projection: r} = this.visualElement;
        if (!r || !r.layout)
            return !1;
        const s = Ez(i, r.root, this.visualElement.getTransformPagePoint());
        let o = yz(r.layout.layoutBox, s);
        if (n) {
            const a = n(Sz(o));
            this.hasMutatedConstraints = !!a,
            a && (o = hk(a))
        }
        return o
    }
    startAnimation(t) {
        const {drag: n, dragMomentum: i, dragElastic: r, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a} = this.getProps()
          , l = this.constraints || {}
          , c = Oi(u=>{
            if (!yu(u, n, this.currentDirection))
                return;
            let h = l && l[u] || {};
            o && (h = {
                min: 0,
                max: 0
            });
            const d = r ? 200 : 1e6
              , m = r ? 40 : 1e7
              , f = {
                type: "inertia",
                velocity: i ? t[u] : 0,
                bounceStiffness: d,
                bounceDamping: m,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...s,
                ...h
            };
            return this.startAxisValueAnimation(u, f)
        }
        );
        return Promise.all(c).then(a)
    }
    startAxisValueAnimation(t, n) {
        const i = this.getAxisMotionValue(t);
        return i.start(Y2(t, i, 0, n))
    }
    stopAnimation() {
        Oi(t=>this.getAxisMotionValue(t).stop())
    }
    getAxisMotionValue(t) {
        const n = "_drag" + t.toUpperCase()
          , i = this.visualElement.getProps()
          , r = i[n];
        return r || this.visualElement.getValue(t, (i.initial ? i.initial[t] : void 0) || 0)
    }
    snapToCursor(t) {
        Oi(n=>{
            const {drag: i} = this.getProps();
            if (!yu(n, i, this.currentDirection))
                return;
            const {projection: r} = this.visualElement
              , s = this.getAxisMotionValue(n);
            if (r && r.layout) {
                const {min: o, max: a} = r.layout.layoutBox[n];
                s.set(t[n] - wt(o, a, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: t, dragConstraints: n} = this.getProps()
          , {projection: i} = this.visualElement;
        if (!Wo(n) || !i || !this.constraints)
            return;
        this.stopAnimation();
        const r = {
            x: 0,
            y: 0
        };
        Oi(o=>{
            const a = this.getAxisMotionValue(o);
            if (a) {
                const l = a.get();
                r[o] = xz({
                    min: l,
                    max: l
                }, this.constraints[o])
            }
        }
        );
        const {transformTemplate: s} = this.visualElement.getProps();
        this.visualElement.current.style.transform = s ? s({}, "") : "none",
        i.root && i.root.updateScroll(),
        i.updateLayout(),
        this.resolveConstraints(),
        Oi(o=>{
            if (!yu(o, t, null))
                return;
            const a = this.getAxisMotionValue(o)
              , {min: l, max: c} = this.constraints[o];
            a.set(wt(l, c, r[o]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        Pz.set(this.visualElement, this);
        const t = this.visualElement.current
          , n = or(t, "pointerdown", l=>{
            const {drag: c, dragListener: u=!0} = this.getProps();
            c && u && this.start(l)
        }
        )
          , i = ()=>{
            const {dragConstraints: l} = this.getProps();
            Wo(l) && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: r} = this.visualElement
          , s = r.addEventListener("measure", i);
        r && !r.layout && (r.root && r.root.updateScroll(),
        r.updateLayout()),
        i();
        const o = ir(window, "resize", ()=>this.scalePositionWithinConstraints())
          , a = r.addEventListener("didUpdate", ({delta: l, hasLayoutChanged: c})=>{
            this.isDragging && c && (Oi(u=>{
                const h = this.getAxisMotionValue(u);
                h && (this.originPoint[u] += l[u].translate,
                h.set(h.get() + l[u].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return ()=>{
            o(),
            n(),
            s(),
            a && a()
        }
    }
    getProps() {
        const t = this.visualElement.getProps()
          , {drag: n=!1, dragDirectionLock: i=!1, dragPropagation: r=!1, dragConstraints: s=!1, dragElastic: o=Eg, dragMomentum: a=!0} = t;
        return {
            ...t,
            drag: n,
            dragDirectionLock: i,
            dragPropagation: r,
            dragConstraints: s,
            dragElastic: o,
            dragMomentum: a
        }
    }
}
function yu(e, t, n) {
    return (t === !0 || t === e) && (n === null || n === e)
}
function jz(e, t=10) {
    let n = null;
    return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"),
    n
}
class Oz extends ss {
    constructor(t) {
        super(t),
        this.removeGroupControls = Et,
        this.removeListeners = Et,
        this.controls = new Tz(t)
    }
    mount() {
        const {dragControls: t} = this.node.getProps();
        t && (this.removeGroupControls = t.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || Et
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
const Ib = e=>(t,n)=>{
    e && gt.update(()=>e(t, n))
}
;
class Lz extends ss {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = Et
    }
    onPointerDown(t) {
        this.session = new ck(t,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint()
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: t, onPanStart: n, onPan: i, onPanEnd: r} = this.node.getProps();
        return {
            onSessionStart: Ib(t),
            onStart: Ib(n),
            onMove: i,
            onEnd: (s,o)=>{
                delete this.session,
                r && gt.update(()=>r(s, o))
            }
        }
    }
    mount() {
        this.removePointerDownListener = or(this.node.current, "pointerdown", t=>this.onPointerDown(t))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
function Rz() {
    const e = M.useContext(O2);
    if (e === null)
        return [!0, null];
    const {isPresent: t, onExitComplete: n, register: i} = e
      , r = M.useId();
    return M.useEffect(()=>i(r), []),
    !t && n ? [!1, ()=>n && n(r)] : [!0]
}
const nh = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function Bb(e, t) {
    return t.max === t.min ? 0 : e / (t.max - t.min) * 100
}
const za = {
    correct: (e,t)=>{
        if (!t.target)
            return e;
        if (typeof e == "string")
            if (De.test(e))
                e = parseFloat(e);
            else
                return e;
        const n = Bb(e, t.target.x)
          , i = Bb(e, t.target.y);
        return `${n}% ${i}%`
    }
}
  , _z = {
    correct: (e,{treeScale: t, projectionDelta: n})=>{
        const i = e
          , r = qr.parse(e);
        if (r.length > 5)
            return i;
        const s = qr.createTransformer(e)
          , o = typeof r[0] != "number" ? 1 : 0
          , a = n.x.scale * t.x
          , l = n.y.scale * t.y;
        r[0 + o] /= a,
        r[1 + o] /= l;
        const c = wt(a, l, .5);
        return typeof r[2 + o] == "number" && (r[2 + o] /= c),
        typeof r[3 + o] == "number" && (r[3 + o] /= c),
        s(r)
    }
};
class Dz extends Ce.Component {
    componentDidMount() {
        const {visualElement: t, layoutGroup: n, switchLayoutGroup: i, layoutId: r} = this.props
          , {projection: s} = t;
        VF(Nz),
        s && (n.group && n.group.add(s),
        i && i.register && r && i.register(s),
        s.root.didUpdate(),
        s.addEventListener("animationComplete", ()=>{
            this.safeToRemove()
        }
        ),
        s.setOptions({
            ...s.options,
            onExitComplete: ()=>this.safeToRemove()
        })),
        nh.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(t) {
        const {layoutDependency: n, visualElement: i, drag: r, isPresent: s} = this.props
          , o = i.projection;
        return o && (o.isPresent = s,
        r || t.layoutDependency !== n || n === void 0 ? o.willUpdate() : this.safeToRemove(),
        t.isPresent !== s && (s ? o.promote() : o.relegate() || gt.postRender(()=>{
            const a = o.getStack();
            (!a || !a.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: t} = this.props.visualElement;
        t && (t.root.didUpdate(),
        queueMicrotask(()=>{
            !t.currentAnimation && t.isLead() && this.safeToRemove()
        }
        ))
    }
    componentWillUnmount() {
        const {visualElement: t, layoutGroup: n, switchLayoutGroup: i} = this.props
          , {projection: r} = t;
        r && (r.scheduleCheckAfterUnmount(),
        n && n.group && n.group.remove(r),
        i && i.deregister && i.deregister(r))
    }
    safeToRemove() {
        const {safeToRemove: t} = this.props;
        t && t()
    }
    render() {
        return null
    }
}
function gk(e) {
    const [t,n] = Rz()
      , i = M.useContext(uC);
    return Ce.createElement(Dz, {
        ...e,
        layoutGroup: i,
        switchLayoutGroup: M.useContext(hC),
        isPresent: t,
        safeToRemove: n
    })
}
const Nz = {
    borderRadius: {
        ...za,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: za,
    borderTopRightRadius: za,
    borderBottomLeftRadius: za,
    borderBottomRightRadius: za,
    boxShadow: _z
}
  , mk = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , Fz = mk.length
  , zb = e=>typeof e == "string" ? parseFloat(e) : e
  , Vb = e=>typeof e == "number" || De.test(e);
function Iz(e, t, n, i, r, s) {
    r ? (e.opacity = wt(0, n.opacity !== void 0 ? n.opacity : 1, Bz(i)),
    e.opacityExit = wt(t.opacity !== void 0 ? t.opacity : 1, 0, zz(i))) : s && (e.opacity = wt(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, i));
    for (let o = 0; o < Fz; o++) {
        const a = `border${mk[o]}Radius`;
        let l = Wb(t, a)
          , c = Wb(n, a);
        if (l === void 0 && c === void 0)
            continue;
        l || (l = 0),
        c || (c = 0),
        l === 0 || c === 0 || Vb(l) === Vb(c) ? (e[a] = Math.max(wt(zb(l), zb(c), i), 0),
        (Bi.test(c) || Bi.test(l)) && (e[a] += "%")) : e[a] = c
    }
    (t.rotate || n.rotate) && (e.rotate = wt(t.rotate || 0, n.rotate || 0, i))
}
function Wb(e, t) {
    return e[t] !== void 0 ? e[t] : e.borderRadius
}
const Bz = vk(0, .5, H2)
  , zz = vk(.5, .95, Et);
function vk(e, t, n) {
    return i=>i < e ? 0 : i > t ? 1 : n(ql(e, t, i))
}
function Hb(e, t) {
    e.min = t.min,
    e.max = t.max
}
function Qn(e, t) {
    Hb(e.x, t.x),
    Hb(e.y, t.y)
}
function Ub(e, t, n, i, r) {
    return e -= t,
    e = Zh(e, 1 / n, i),
    r !== void 0 && (e = Zh(e, 1 / r, i)),
    e
}
function Vz(e, t=0, n=1, i=.5, r, s=e, o=e) {
    if (Bi.test(t) && (t = parseFloat(t),
    t = wt(o.min, o.max, t / 100) - o.min),
    typeof t != "number")
        return;
    let a = wt(s.min, s.max, i);
    e === s && (a -= t),
    e.min = Ub(e.min, t, n, a, r),
    e.max = Ub(e.max, t, n, a, r)
}
function Gb(e, t, [n,i,r], s, o) {
    Vz(e, t[n], t[i], t[r], t.scale, s, o)
}
const Wz = ["x", "scaleX", "originX"]
  , Hz = ["y", "scaleY", "originY"];
function Xb(e, t, n, i) {
    Gb(e.x, t, Wz, n ? n.x : void 0, i ? i.x : void 0),
    Gb(e.y, t, Hz, n ? n.y : void 0, i ? i.y : void 0)
}
function Yb(e) {
    return e.translate === 0 && e.scale === 1
}
function yk(e) {
    return Yb(e.x) && Yb(e.y)
}
function Uz(e, t) {
    return e.x.min === t.x.min && e.x.max === t.x.max && e.y.min === t.y.min && e.y.max === t.y.max
}
function xk(e, t) {
    return Math.round(e.x.min) === Math.round(t.x.min) && Math.round(e.x.max) === Math.round(t.x.max) && Math.round(e.y.min) === Math.round(t.y.min) && Math.round(e.y.max) === Math.round(t.y.max)
}
function $b(e) {
    return Hn(e.x) / Hn(e.y)
}
class Gz {
    constructor() {
        this.members = []
    }
    add(t) {
        $2(this.members, t),
        t.scheduleRender()
    }
    remove(t) {
        if (K2(this.members, t),
        t === this.prevLead && (this.prevLead = void 0),
        t === this.lead) {
            const n = this.members[this.members.length - 1];
            n && this.promote(n)
        }
    }
    relegate(t) {
        const n = this.members.findIndex(r=>t === r);
        if (n === 0)
            return !1;
        let i;
        for (let r = n; r >= 0; r--) {
            const s = this.members[r];
            if (s.isPresent !== !1) {
                i = s;
                break
            }
        }
        return i ? (this.promote(i),
        !0) : !1
    }
    promote(t, n) {
        const i = this.lead;
        if (t !== i && (this.prevLead = i,
        this.lead = t,
        t.show(),
        i)) {
            i.instance && i.scheduleRender(),
            t.scheduleRender(),
            t.resumeFrom = i,
            n && (t.resumeFrom.preserveOpacity = !0),
            i.snapshot && (t.snapshot = i.snapshot,
            t.snapshot.latestValues = i.animationValues || i.latestValues),
            t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
            const {crossfade: r} = t.options;
            r === !1 && i.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(t=>{
            const {options: n, resumingFrom: i} = t;
            n.onExitComplete && n.onExitComplete(),
            i && i.options.onExitComplete && i.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(t=>{
            t.instance && t.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function Kb(e, t, n) {
    let i = "";
    const r = e.x.translate / t.x
      , s = e.y.translate / t.y;
    if ((r || s) && (i = `translate3d(${r}px, ${s}px, 0) `),
    (t.x !== 1 || t.y !== 1) && (i += `scale(${1 / t.x}, ${1 / t.y}) `),
    n) {
        const {rotate: l, rotateX: c, rotateY: u} = n;
        l && (i += `rotate(${l}deg) `),
        c && (i += `rotateX(${c}deg) `),
        u && (i += `rotateY(${u}deg) `)
    }
    const o = e.x.scale * t.x
      , a = e.y.scale * t.y;
    return (o !== 1 || a !== 1) && (i += `scale(${o}, ${a})`),
    i || "none"
}
const Xz = (e,t)=>e.depth - t.depth;
class Yz {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(t) {
        $2(this.children, t),
        this.isDirty = !0
    }
    remove(t) {
        K2(this.children, t),
        this.isDirty = !0
    }
    forEach(t) {
        this.isDirty && this.children.sort(Xz),
        this.isDirty = !1,
        this.children.forEach(t)
    }
}
function $z(e, t) {
    const n = performance.now()
      , i = ({timestamp: r})=>{
        const s = r - n;
        s >= t && (dr(i),
        e(s - t))
    }
    ;
    return gt.read(i, !0),
    ()=>dr(i)
}
function Kz(e) {
    window.MotionDebug && window.MotionDebug.record(e)
}
function Qz(e) {
    return e instanceof SVGElement && e.tagName !== "svg"
}
function qz(e, t, n) {
    const i = jn(e) ? e : pa(e);
    return i.start(Y2("", i, t, n)),
    i.animation
}
const Qb = ["", "X", "Y", "Z"]
  , qb = 1e3;
let Zz = 0;
const Ms = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
};
function bk({attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: i, resetTransform: r}) {
    return class {
        constructor(o={}, a=t == null ? void 0 : t()) {
            this.id = Zz++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.checkUpdateFailed = ()=>{
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = ()=>{
                Ms.totalNodes = Ms.resolvedTargetDeltas = Ms.recalculatedProjection = 0,
                this.nodes.forEach(tV),
                this.nodes.forEach(oV),
                this.nodes.forEach(aV),
                this.nodes.forEach(nV),
                Kz(Ms)
            }
            ,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = o,
            this.root = a ? a.root || a : this,
            this.path = a ? [...a.path, a] : [],
            this.parent = a,
            this.depth = a ? a.depth + 1 : 0;
            for (let l = 0; l < this.path.length; l++)
                this.path[l].shouldResetTransform = !0;
            this.root === this && (this.nodes = new Yz)
        }
        addEventListener(o, a) {
            return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Q2),
            this.eventHandlers.get(o).add(a)
        }
        notifyListeners(o, ...a) {
            const l = this.eventHandlers.get(o);
            l && l.notify(...a)
        }
        hasListeners(o) {
            return this.eventHandlers.has(o)
        }
        mount(o, a=this.root.hasTreeAnimated) {
            if (this.instance)
                return;
            this.isSVG = Qz(o),
            this.instance = o;
            const {layoutId: l, layout: c, visualElement: u} = this.options;
            if (u && !u.current && u.mount(o),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            a && (c || l) && (this.isLayoutDirty = !0),
            e) {
                let h;
                const d = ()=>this.root.updateBlockedByResize = !1;
                e(o, ()=>{
                    this.root.updateBlockedByResize = !0,
                    h && h(),
                    h = $z(d, 250),
                    nh.hasAnimatedSinceResize && (nh.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(Jb))
                }
                )
            }
            l && this.root.registerSharedNode(l, this),
            this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({delta: h, hasLayoutChanged: d, hasRelativeTargetChanged: m, layout: f})=>{
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const x = this.options.transition || u.getDefaultTransition() || dV
                  , {onLayoutAnimationStart: S, onLayoutAnimationComplete: v} = u.getProps()
                  , p = !this.targetLayout || !xk(this.targetLayout, f) || m
                  , g = !d && m;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || g || d && (p || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0),
                    this.setAnimationOrigin(h, g);
                    const C = {
                        ...rk(x, "layout"),
                        onPlay: S,
                        onComplete: v
                    };
                    (u.shouldReduceMotion || this.options.layoutRoot) && (C.delay = 0,
                    C.type = !1),
                    this.startAnimation(C)
                } else
                    d || Jb(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = f
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const o = this.getStack();
            o && o.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            dr(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(lV),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: o} = this.options;
            return o && o.getProps().transformTemplate
        }
        willUpdate(o=!0) {
            if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (!this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let u = 0; u < this.path.length; u++) {
                const h = this.path[u];
                h.shouldResetTransform = !0,
                h.updateScroll("snapshot"),
                h.options.layoutRoot && h.willUpdate(!1)
            }
            const {layoutId: a, layout: l} = this.options;
            if (a === void 0 && !l)
                return;
            const c = this.getTransformTemplate();
            this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            o && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
            this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(Zb);
                return
            }
            this.isUpdating || this.nodes.forEach(rV),
            this.isUpdating = !1,
            this.nodes.forEach(sV),
            this.nodes.forEach(Jz),
            this.nodes.forEach(eV),
            this.clearAllSnapshots();
            const a = performance.now();
            Yt.delta = Qr(0, 1e3 / 60, a - Yt.timestamp),
            Yt.timestamp = a,
            Yt.isProcessing = !0,
            y0.update.process(Yt),
            y0.preRender.process(Yt),
            y0.render.process(Yt),
            Yt.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
            queueMicrotask(()=>this.update()))
        }
        clearAllSnapshots() {
            this.nodes.forEach(iV),
            this.sharedNodes.forEach(cV)
        }
        scheduleUpdateProjection() {
            gt.preRender(this.updateProjection, !1, !0)
        }
        scheduleCheckAfterUnmount() {
            gt.postRender(()=>{
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let l = 0; l < this.path.length; l++)
                    this.path[l].updateScroll();
            const o = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = _t(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: a} = this.options;
            a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0)
        }
        updateScroll(o="measure") {
            let a = !!(this.options.layoutScroll && this.instance);
            this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1),
            a && (this.scroll = {
                animationId: this.root.animationId,
                phase: o,
                isRoot: i(this.instance),
                offset: n(this.instance)
            })
        }
        resetTransform() {
            if (!r)
                return;
            const o = this.isLayoutDirty || this.shouldResetTransform
              , a = this.projectionDelta && !yk(this.projectionDelta)
              , l = this.getTransformTemplate()
              , c = l ? l(this.latestValues, "") : void 0
              , u = c !== this.prevTransformTemplateValue;
            o && (a || As(this.latestValues) || u) && (r(this.instance, c),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(o=!0) {
            const a = this.measurePageBox();
            let l = this.removeElementScroll(a);
            return o && (l = this.removeTransform(l)),
            fV(l),
            {
                animationId: this.root.animationId,
                measuredBox: a,
                layoutBox: l,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            const {visualElement: o} = this.options;
            if (!o)
                return _t();
            const a = o.measureViewportBox()
              , {scroll: l} = this.root;
            return l && (Cr(a.x, l.offset.x),
            Cr(a.y, l.offset.y)),
            a
        }
        removeElementScroll(o) {
            const a = _t();
            Qn(a, o);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l]
                  , {scroll: u, options: h} = c;
                if (c !== this.root && u && h.layoutScroll) {
                    if (u.isRoot) {
                        Qn(a, o);
                        const {scroll: d} = this.root;
                        d && (Cr(a.x, -d.offset.x),
                        Cr(a.y, -d.offset.y))
                    }
                    Cr(a.x, u.offset.x),
                    Cr(a.y, u.offset.y)
                }
            }
            return a
        }
        applyTransform(o, a=!1) {
            const l = _t();
            Qn(l, o);
            for (let c = 0; c < this.path.length; c++) {
                const u = this.path[c];
                !a && u.options.layoutScroll && u.scroll && u !== u.root && Go(l, {
                    x: -u.scroll.offset.x,
                    y: -u.scroll.offset.y
                }),
                As(u.latestValues) && Go(l, u.latestValues)
            }
            return As(this.latestValues) && Go(l, this.latestValues),
            l
        }
        removeTransform(o) {
            const a = _t();
            Qn(a, o);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l];
                if (!c.instance || !As(c.latestValues))
                    continue;
                Pg(c.latestValues) && c.updateSnapshot();
                const u = _t()
                  , h = c.measurePageBox();
                Qn(u, h),
                Xb(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u)
            }
            return As(this.latestValues) && Xb(a, this.latestValues),
            a
        }
        setTargetDelta(o) {
            this.targetDelta = o,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(o) {
            this.options = {
                ...this.options,
                ...o,
                crossfade: o.crossfade !== void 0 ? o.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Yt.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(o=!1) {
            var a;
            const l = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
            const c = !!this.resumingFrom || this !== l;
            if (!(o || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget))
                return;
            const {layout: h, layoutId: d} = this.options;
            if (!(!this.layout || !(h || d))) {
                if (this.resolvedRelativeTargetAt = Yt.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    const m = this.getClosestProjectingParent();
                    m && m.layout && this.animationProgress !== 1 ? (this.relativeParent = m,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = _t(),
                    this.relativeTargetOrigin = _t(),
                    yl(this.relativeTargetOrigin, this.layout.layoutBox, m.layout.layoutBox),
                    Qn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = _t(),
                    this.targetWithTransforms = _t()),
                    this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                    gz(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Qn(this.target, this.layout.layoutBox),
                    fk(this.target, this.targetDelta)) : Qn(this.target, this.layout.layoutBox),
                    this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const m = this.getClosestProjectingParent();
                        m && !!m.resumingFrom == !!this.resumingFrom && !m.options.layoutScroll && m.target && this.animationProgress !== 1 ? (this.relativeParent = m,
                        this.forceRelativeParentToResolveTarget(),
                        this.relativeTarget = _t(),
                        this.relativeTargetOrigin = _t(),
                        yl(this.relativeTargetOrigin, this.target, m.target),
                        Qn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    Ms.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || Pg(this.parent.latestValues) || dk(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var o;
            const a = this.getLead()
              , l = !!this.resumingFrom || this !== a;
            let c = !0;
            if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (c = !1),
            l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1),
            this.resolvedRelativeTargetAt === Yt.timestamp && (c = !1),
            c)
                return;
            const {layout: u, layoutId: h} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(u || h))
                return;
            Qn(this.layoutCorrected, this.layout.layoutBox);
            const d = this.treeScale.x
              , m = this.treeScale.y;
            kz(this.layoutCorrected, this.treeScale, this.path, l),
            a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox);
            const {target: f} = a;
            if (!f) {
                this.projectionTransform && (this.projectionDelta = Uo(),
                this.projectionTransform = "none",
                this.scheduleRender());
                return
            }
            this.projectionDelta || (this.projectionDelta = Uo(),
            this.projectionDeltaWithTransform = Uo());
            const x = this.projectionTransform;
            vl(this.projectionDelta, this.layoutCorrected, f, this.latestValues),
            this.projectionTransform = Kb(this.projectionDelta, this.treeScale),
            (this.projectionTransform !== x || this.treeScale.x !== d || this.treeScale.y !== m) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", f)),
            Ms.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(o=!0) {
            if (this.options.scheduleRender && this.options.scheduleRender(),
            o) {
                const a = this.getStack();
                a && a.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        setAnimationOrigin(o, a=!1) {
            const l = this.snapshot
              , c = l ? l.latestValues : {}
              , u = {
                ...this.latestValues
            }
              , h = Uo();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !a;
            const d = _t()
              , m = l ? l.source : void 0
              , f = this.layout ? this.layout.source : void 0
              , x = m !== f
              , S = this.getStack()
              , v = !S || S.members.length <= 1
              , p = !!(x && !v && this.options.crossfade === !0 && !this.path.some(hV));
            this.animationProgress = 0;
            let g;
            this.mixTargetDelta = C=>{
                const E = C / 1e3;
                e6(h.x, o.x, E),
                e6(h.y, o.y, E),
                this.setTargetDelta(h),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (yl(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                uV(this.relativeTarget, this.relativeTargetOrigin, d, E),
                g && Uz(this.relativeTarget, g) && (this.isProjectionDirty = !1),
                g || (g = _t()),
                Qn(g, this.relativeTarget)),
                x && (this.animationValues = u,
                Iz(u, c, this.latestValues, E, p, v)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = E
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(o) {
            this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && (dr(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = gt.update(()=>{
                nh.hasAnimatedSinceResize = !0,
                this.currentAnimation = qz(0, qb, {
                    ...o,
                    onUpdate: a=>{
                        this.mixTargetDelta(a),
                        o.onUpdate && o.onUpdate(a)
                    }
                    ,
                    onComplete: ()=>{
                        o.onComplete && o.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const o = this.getStack();
            o && o.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(qb),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const o = this.getLead();
            let {targetWithTransforms: a, target: l, layout: c, latestValues: u} = o;
            if (!(!a || !l || !c)) {
                if (this !== o && this.layout && c && wk(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
                    l = this.target || _t();
                    const h = Hn(this.layout.layoutBox.x);
                    l.x.min = o.target.x.min,
                    l.x.max = l.x.min + h;
                    const d = Hn(this.layout.layoutBox.y);
                    l.y.min = o.target.y.min,
                    l.y.max = l.y.min + d
                }
                Qn(a, l),
                Go(a, u),
                vl(this.projectionDeltaWithTransform, this.layoutCorrected, a, u)
            }
        }
        registerSharedNode(o, a) {
            this.sharedNodes.has(o) || this.sharedNodes.set(o, new Gz),
            this.sharedNodes.get(o).add(a);
            const c = a.options.initialPromotionConfig;
            a.promote({
                transition: c ? c.transition : void 0,
                preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
            })
        }
        isLead() {
            const o = this.getStack();
            return o ? o.lead === this : !0
        }
        getLead() {
            var o;
            const {layoutId: a} = this.options;
            return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this
        }
        getPrevLead() {
            var o;
            const {layoutId: a} = this.options;
            return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0
        }
        getStack() {
            const {layoutId: o} = this.options;
            if (o)
                return this.root.sharedNodes.get(o)
        }
        promote({needsReset: o, transition: a, preserveFollowOpacity: l}={}) {
            const c = this.getStack();
            c && c.promote(this, l),
            o && (this.projectionDelta = void 0,
            this.needsReset = !0),
            a && this.setOptions({
                transition: a
            })
        }
        relegate() {
            const o = this.getStack();
            return o ? o.relegate(this) : !1
        }
        resetRotation() {
            const {visualElement: o} = this.options;
            if (!o)
                return;
            let a = !1;
            const {latestValues: l} = o;
            if ((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0),
            !a)
                return;
            const c = {};
            for (let u = 0; u < Qb.length; u++) {
                const h = "rotate" + Qb[u];
                l[h] && (c[h] = l[h],
                o.setStaticValue(h, 0))
            }
            o.render();
            for (const u in c)
                o.setStaticValue(u, c[u]);
            o.scheduleRender()
        }
        getProjectionStyles(o={}) {
            var a, l;
            const c = {};
            if (!this.instance || this.isSVG)
                return c;
            if (this.isVisible)
                c.visibility = "";
            else
                return {
                    visibility: "hidden"
                };
            const u = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                c.opacity = "",
                c.pointerEvents = th(o.pointerEvents) || "",
                c.transform = u ? u(this.latestValues, "") : "none",
                c;
            const h = this.getLead();
            if (!this.projectionDelta || !this.layout || !h.target) {
                const x = {};
                return this.options.layoutId && (x.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                x.pointerEvents = th(o.pointerEvents) || ""),
                this.hasProjected && !As(this.latestValues) && (x.transform = u ? u({}, "") : "none",
                this.hasProjected = !1),
                x
            }
            const d = h.animationValues || h.latestValues;
            this.applyTransformsToTarget(),
            c.transform = Kb(this.projectionDeltaWithTransform, this.treeScale, d),
            u && (c.transform = u(d, c.transform));
            const {x: m, y: f} = this.projectionDelta;
            c.transformOrigin = `${m.origin * 100}% ${f.origin * 100}% 0`,
            h.animationValues ? c.opacity = h === this ? (l = (a = d.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : c.opacity = h === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0;
            for (const x in Gh) {
                if (d[x] === void 0)
                    continue;
                const {correct: S, applyTo: v} = Gh[x]
                  , p = c.transform === "none" ? d[x] : S(d[x], h);
                if (v) {
                    const g = v.length;
                    for (let C = 0; C < g; C++)
                        c[v[C]] = p
                } else
                    c[x] = p
            }
            return this.options.layoutId && (c.pointerEvents = h === this ? th(o.pointerEvents) || "" : "none"),
            c
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(o=>{
                var a;
                return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop()
            }
            ),
            this.root.nodes.forEach(Zb),
            this.root.sharedNodes.clear()
        }
    }
}
function Jz(e) {
    e.updateLayout()
}
function eV(e) {
    var t;
    const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
    if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
        const {layoutBox: i, measuredBox: r} = e.layout
          , {animationType: s} = e.options
          , o = n.source !== e.layout.source;
        s === "size" ? Oi(h=>{
            const d = o ? n.measuredBox[h] : n.layoutBox[h]
              , m = Hn(d);
            d.min = i[h].min,
            d.max = d.min + m
        }
        ) : wk(s, n.layoutBox, i) && Oi(h=>{
            const d = o ? n.measuredBox[h] : n.layoutBox[h]
              , m = Hn(i[h]);
            d.max = d.min + m,
            e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0,
            e.relativeTarget[h].max = e.relativeTarget[h].min + m)
        }
        );
        const a = Uo();
        vl(a, i, n.layoutBox);
        const l = Uo();
        o ? vl(l, e.applyTransform(r, !0), n.measuredBox) : vl(l, i, n.layoutBox);
        const c = !yk(a);
        let u = !1;
        if (!e.resumeFrom) {
            const h = e.getClosestProjectingParent();
            if (h && !h.resumeFrom) {
                const {snapshot: d, layout: m} = h;
                if (d && m) {
                    const f = _t();
                    yl(f, n.layoutBox, d.layoutBox);
                    const x = _t();
                    yl(x, i, m.layoutBox),
                    xk(f, x) || (u = !0),
                    h.options.layoutRoot && (e.relativeTarget = x,
                    e.relativeTargetOrigin = f,
                    e.relativeParent = h)
                }
            }
        }
        e.notifyListeners("didUpdate", {
            layout: i,
            snapshot: n,
            delta: l,
            layoutDelta: a,
            hasLayoutChanged: c,
            hasRelativeTargetChanged: u
        })
    } else if (e.isLead()) {
        const {onExitComplete: i} = e.options;
        i && i()
    }
    e.options.transition = void 0
}
function tV(e) {
    Ms.totalNodes++,
    e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty),
    e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)),
    e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty))
}
function nV(e) {
    e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1
}
function iV(e) {
    e.clearSnapshot()
}
function Zb(e) {
    e.clearMeasurements()
}
function rV(e) {
    e.isLayoutDirty = !1
}
function sV(e) {
    const {visualElement: t} = e.options;
    t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"),
    e.resetTransform()
}
function Jb(e) {
    e.finishAnimation(),
    e.targetDelta = e.relativeTarget = e.target = void 0,
    e.isProjectionDirty = !0
}
function oV(e) {
    e.resolveTargetDelta()
}
function aV(e) {
    e.calcProjection()
}
function lV(e) {
    e.resetRotation()
}
function cV(e) {
    e.removeLeadSnapshot()
}
function e6(e, t, n) {
    e.translate = wt(t.translate, 0, n),
    e.scale = wt(t.scale, 1, n),
    e.origin = t.origin,
    e.originPoint = t.originPoint
}
function t6(e, t, n, i) {
    e.min = wt(t.min, n.min, i),
    e.max = wt(t.max, n.max, i)
}
function uV(e, t, n, i) {
    t6(e.x, t.x, n.x, i),
    t6(e.y, t.y, n.y, i)
}
function hV(e) {
    return e.animationValues && e.animationValues.opacityExit !== void 0
}
const dV = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
  , n6 = e=>typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(e)
  , i6 = n6("applewebkit/") && !n6("chrome/") ? Math.round : Et;
function r6(e) {
    e.min = i6(e.min),
    e.max = i6(e.max)
}
function fV(e) {
    r6(e.x),
    r6(e.y)
}
function wk(e, t, n) {
    return e === "position" || e === "preserve-aspect" && !Mg($b(t), $b(n), .2)
}
const pV = bk({
    attachResizeListener: (e,t)=>ir(e, "resize", t),
    measureScroll: ()=>({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: ()=>!0
})
  , T0 = {
    current: void 0
}
  , Sk = bk({
    measureScroll: e=>({
        x: e.scrollLeft,
        y: e.scrollTop
    }),
    defaultParent: ()=>{
        if (!T0.current) {
            const e = new pV({});
            e.mount(window),
            e.setOptions({
                layoutScroll: !0
            }),
            T0.current = e
        }
        return T0.current
    }
    ,
    resetTransform: (e,t)=>{
        e.style.transform = t !== void 0 ? t : "none"
    }
    ,
    checkIsScrollRoot: e=>window.getComputedStyle(e).position === "fixed"
})
  , gV = {
    pan: {
        Feature: Lz
    },
    drag: {
        Feature: Oz,
        ProjectionNode: Sk,
        MeasureLayout: gk
    }
}
  , mV = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function vV(e) {
    const t = mV.exec(e);
    if (!t)
        return [, ];
    const [,n,i] = t;
    return [n, i]
}
function jg(e, t, n=1) {
    const [i,r] = vV(e);
    if (!i)
        return;
    const s = window.getComputedStyle(t).getPropertyValue(i);
    if (s) {
        const o = s.trim();
        return sk(o) ? parseFloat(o) : o
    } else
        return xg(r) ? jg(r, t, n + 1) : r
}
function yV(e, {...t}, n) {
    const i = e.current;
    if (!(i instanceof Element))
        return {
            target: t,
            transitionEnd: n
        };
    n && (n = {
        ...n
    }),
    e.values.forEach(r=>{
        const s = r.get();
        if (!xg(s))
            return;
        const o = jg(s, i);
        o && r.set(o)
    }
    );
    for (const r in t) {
        const s = t[r];
        if (!xg(s))
            continue;
        const o = jg(s, i);
        o && (t[r] = o,
        n || (n = {}),
        n[r] === void 0 && (n[r] = s))
    }
    return {
        target: t,
        transitionEnd: n
    }
}
const xV = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
  , Ck = e=>xV.has(e)
  , bV = e=>Object.keys(e).some(Ck)
  , s6 = e=>e === oo || e === De
  , o6 = (e,t)=>parseFloat(e.split(", ")[t])
  , a6 = (e,t)=>(n,{transform: i})=>{
    if (i === "none" || !i)
        return 0;
    const r = i.match(/^matrix3d\((.+)\)$/);
    if (r)
        return o6(r[1], t);
    {
        const s = i.match(/^matrix\((.+)\)$/);
        return s ? o6(s[1], e) : 0
    }
}
  , wV = new Set(["x", "y", "z"])
  , SV = wc.filter(e=>!wV.has(e));
function CV(e) {
    const t = [];
    return SV.forEach(n=>{
        const i = e.getValue(n);
        i !== void 0 && (t.push([n, i.get()]),
        i.set(n.startsWith("scale") ? 1 : 0))
    }
    ),
    t.length && e.render(),
    t
}
const ga = {
    width: ({x: e},{paddingLeft: t="0", paddingRight: n="0"})=>e.max - e.min - parseFloat(t) - parseFloat(n),
    height: ({y: e},{paddingTop: t="0", paddingBottom: n="0"})=>e.max - e.min - parseFloat(t) - parseFloat(n),
    top: (e,{top: t})=>parseFloat(t),
    left: (e,{left: t})=>parseFloat(t),
    bottom: ({y: e},{top: t})=>parseFloat(t) + (e.max - e.min),
    right: ({x: e},{left: t})=>parseFloat(t) + (e.max - e.min),
    x: a6(4, 13),
    y: a6(5, 14)
};
ga.translateX = ga.x;
ga.translateY = ga.y;
const kV = (e,t,n)=>{
    const i = t.measureViewportBox()
      , r = t.current
      , s = getComputedStyle(r)
      , {display: o} = s
      , a = {};
    o === "none" && t.setStaticValue("display", e.display || "block"),
    n.forEach(c=>{
        a[c] = ga[c](i, s)
    }
    ),
    t.render();
    const l = t.measureViewportBox();
    return n.forEach(c=>{
        const u = t.getValue(c);
        u && u.jump(a[c]),
        e[c] = ga[c](l, s)
    }
    ),
    e
}
  , AV = (e,t,n={},i={})=>{
    t = {
        ...t
    },
    i = {
        ...i
    };
    const r = Object.keys(t).filter(Ck);
    let s = []
      , o = !1;
    const a = [];
    if (r.forEach(l=>{
        const c = e.getValue(l);
        if (!e.hasValue(l))
            return;
        let u = n[l]
          , h = Ba(u);
        const d = t[l];
        let m;
        if (Yh(d)) {
            const f = d.length
              , x = d[0] === null ? 1 : 0;
            u = d[x],
            h = Ba(u);
            for (let S = x; S < f && d[S] !== null; S++)
                m ? W2(Ba(d[S]) === m) : m = Ba(d[S])
        } else
            m = Ba(d);
        if (h !== m)
            if (s6(h) && s6(m)) {
                const f = c.get();
                typeof f == "string" && c.set(parseFloat(f)),
                typeof d == "string" ? t[l] = parseFloat(d) : Array.isArray(d) && m === De && (t[l] = d.map(parseFloat))
            } else
                h != null && h.transform && (m != null && m.transform) && (u === 0 || d === 0) ? u === 0 ? c.set(m.transform(u)) : t[l] = h.transform(d) : (o || (s = CV(e),
                o = !0),
                a.push(l),
                i[l] = i[l] !== void 0 ? i[l] : t[l],
                c.jump(d))
    }
    ),
    a.length) {
        const l = a.indexOf("height") >= 0 ? window.pageYOffset : null
          , c = kV(t, e, a);
        return s.length && s.forEach(([u,h])=>{
            e.getValue(u).set(h)
        }
        ),
        e.render(),
        Zd && l !== null && window.scrollTo({
            top: l
        }),
        {
            target: c,
            transitionEnd: i
        }
    } else
        return {
            target: t,
            transitionEnd: i
        }
}
;
function MV(e, t, n, i) {
    return bV(t) ? AV(e, t, n, i) : {
        target: t,
        transitionEnd: i
    }
}
const EV = (e,t,n,i)=>{
    const r = yV(e, t, i);
    return t = r.target,
    i = r.transitionEnd,
    MV(e, t, n, i)
}
  , Og = {
    current: null
}
  , kk = {
    current: !1
};
function PV() {
    if (kk.current = !0,
    !!Zd)
        if (window.matchMedia) {
            const e = window.matchMedia("(prefers-reduced-motion)")
              , t = ()=>Og.current = e.matches;
            e.addListener(t),
            t()
        } else
            Og.current = !1
}
function TV(e, t, n) {
    const {willChange: i} = t;
    for (const r in t) {
        const s = t[r]
          , o = n[r];
        if (jn(s))
            e.addValue(r, s),
            qh(i) && i.add(r);
        else if (jn(o))
            e.addValue(r, pa(s, {
                owner: e
            })),
            qh(i) && i.remove(r);
        else if (o !== s)
            if (e.hasValue(r)) {
                const a = e.getValue(r);
                !a.hasAnimated && a.set(s)
            } else {
                const a = e.getStaticValue(r);
                e.addValue(r, pa(a !== void 0 ? a : s, {
                    owner: e
                }))
            }
    }
    for (const r in n)
        t[r] === void 0 && e.removeValue(r);
    return t
}
const l6 = new WeakMap
  , Ak = Object.keys(Ql)
  , jV = Ak.length
  , c6 = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]
  , OV = R2.length;
class LV {
    constructor({parent: t, props: n, presenceContext: i, reducedMotionConfig: r, visualState: s}, o={}) {
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = ()=>this.notify("Update", this.latestValues),
        this.render = ()=>{
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.scheduleRender = ()=>gt.render(this.render, !1, !0);
        const {latestValues: a, renderState: l} = s;
        this.latestValues = a,
        this.baseTarget = {
            ...a
        },
        this.initialValues = n.initial ? {
            ...a
        } : {},
        this.renderState = l,
        this.parent = t,
        this.props = n,
        this.presenceContext = i,
        this.depth = t ? t.depth + 1 : 0,
        this.reducedMotionConfig = r,
        this.options = o,
        this.isControllingVariants = ef(n),
        this.isVariantNode = cC(n),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = !!(t && t.current);
        const {willChange: c, ...u} = this.scrapeMotionValuesFromProps(n, {});
        for (const h in u) {
            const d = u[h];
            a[h] !== void 0 && jn(d) && (d.set(a[h], !1),
            qh(c) && c.add(h))
        }
    }
    scrapeMotionValuesFromProps(t, n) {
        return {}
    }
    mount(t) {
        this.current = t,
        l6.set(t, this),
        this.projection && !this.projection.instance && this.projection.mount(t),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach((n,i)=>this.bindToMotionValue(i, n)),
        kk.current || PV(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Og.current,
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        l6.delete(this.current),
        this.projection && this.projection.unmount(),
        dr(this.notifyUpdate),
        dr(this.render),
        this.valueSubscriptions.forEach(t=>t()),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (const t in this.events)
            this.events[t].clear();
        for (const t in this.features)
            this.features[t].unmount();
        this.current = null
    }
    bindToMotionValue(t, n) {
        const i = so.has(t)
          , r = n.on("change", o=>{
            this.latestValues[t] = o,
            this.props.onUpdate && gt.update(this.notifyUpdate, !1, !0),
            i && this.projection && (this.projection.isTransformDirty = !0)
        }
        )
          , s = n.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(t, ()=>{
            r(),
            s()
        }
        )
    }
    sortNodePosition(t) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current)
    }
    loadFeatures({children: t, ...n}, i, r, s) {
        let o, a;
        for (let l = 0; l < jV; l++) {
            const c = Ak[l]
              , {isEnabled: u, Feature: h, ProjectionNode: d, MeasureLayout: m} = Ql[c];
            d && (o = d),
            u(n) && (!this.features[c] && h && (this.features[c] = new h(this)),
            m && (a = m))
        }
        if (!this.projection && o) {
            this.projection = new o(this.latestValues,this.parent && this.parent.projection);
            const {layoutId: l, layout: c, drag: u, dragConstraints: h, layoutScroll: d, layoutRoot: m} = n;
            this.projection.setOptions({
                layoutId: l,
                layout: c,
                alwaysMeasureLayout: !!u || h && Wo(h),
                visualElement: this,
                scheduleRender: ()=>this.scheduleRender(),
                animationType: typeof c == "string" ? c : "both",
                initialPromotionConfig: s,
                layoutScroll: d,
                layoutRoot: m
            })
        }
        return a
    }
    updateFeatures() {
        for (const t in this.features) {
            const n = this.features[t];
            n.isMounted ? n.update() : (n.mount(),
            n.isMounted = !0)
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.options, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : _t()
    }
    getStaticValue(t) {
        return this.latestValues[t]
    }
    setStaticValue(t, n) {
        this.latestValues[t] = n
    }
    makeTargetAnimatable(t, n=!0) {
        return this.makeTargetAnimatableFromInstance(t, this.props, n)
    }
    update(t, n) {
        (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = t,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = n;
        for (let i = 0; i < c6.length; i++) {
            const r = c6[i];
            this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](),
            delete this.propEventSubscriptions[r]);
            const s = t["on" + r];
            s && (this.propEventSubscriptions[r] = this.on(r, s))
        }
        this.prevMotionValues = TV(this, this.scrapeMotionValuesFromProps(t, this.prevProps), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(t) {
        return this.props.variants ? this.props.variants[t] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    getVariantContext(t=!1) {
        if (t)
            return this.parent ? this.parent.getVariantContext() : void 0;
        if (!this.isControllingVariants) {
            const i = this.parent ? this.parent.getVariantContext() || {} : {};
            return this.props.initial !== void 0 && (i.initial = this.props.initial),
            i
        }
        const n = {};
        for (let i = 0; i < OV; i++) {
            const r = R2[i]
              , s = this.props[r];
            (Kl(s) || s === !1) && (n[r] = s)
        }
        return n
    }
    addVariantChild(t) {
        const n = this.getClosestVariantNode();
        if (n)
            return n.variantChildren && n.variantChildren.add(t),
            ()=>n.variantChildren.delete(t)
    }
    addValue(t, n) {
        n !== this.values.get(t) && (this.removeValue(t),
        this.bindToMotionValue(t, n)),
        this.values.set(t, n),
        this.latestValues[t] = n.get()
    }
    removeValue(t) {
        this.values.delete(t);
        const n = this.valueSubscriptions.get(t);
        n && (n(),
        this.valueSubscriptions.delete(t)),
        delete this.latestValues[t],
        this.removeValueFromRenderState(t, this.renderState)
    }
    hasValue(t) {
        return this.values.has(t)
    }
    getValue(t, n) {
        if (this.props.values && this.props.values[t])
            return this.props.values[t];
        let i = this.values.get(t);
        return i === void 0 && n !== void 0 && (i = pa(n, {
            owner: this
        }),
        this.addValue(t, i)),
        i
    }
    readValue(t) {
        var n;
        return this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (n = this.getBaseTargetFromProps(this.props, t)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, t, this.options)
    }
    setBaseTarget(t, n) {
        this.baseTarget[t] = n
    }
    getBaseTarget(t) {
        var n;
        const {initial: i} = this.props
          , r = typeof i == "string" || typeof i == "object" ? (n = V2(this.props, i)) === null || n === void 0 ? void 0 : n[t] : void 0;
        if (i && r !== void 0)
            return r;
        const s = this.getBaseTargetFromProps(this.props, t);
        return s !== void 0 && !jn(s) ? s : this.initialValues[t] !== void 0 && r === void 0 ? void 0 : this.baseTarget[t]
    }
    on(t, n) {
        return this.events[t] || (this.events[t] = new Q2),
        this.events[t].add(n)
    }
    notify(t, ...n) {
        this.events[t] && this.events[t].notify(...n)
    }
}
class Mk extends LV {
    sortInstanceNodePosition(t, n) {
        return t.compareDocumentPosition(n) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(t, n) {
        return t.style ? t.style[n] : void 0
    }
    removeValueFromRenderState(t, {vars: n, style: i}) {
        delete n[t],
        delete i[t]
    }
    makeTargetAnimatableFromInstance({transition: t, transitionEnd: n, ...i}, {transformValues: r}, s) {
        let o = qB(i, t || {}, this);
        if (r && (n && (n = r(n)),
        i && (i = r(i)),
        o && (o = r(o))),
        s) {
            KB(this, i, o);
            const a = EV(this, i, o, n);
            n = a.transitionEnd,
            i = a.target
        }
        return {
            transition: t,
            transitionEnd: n,
            ...i
        }
    }
}
function RV(e) {
    return window.getComputedStyle(e)
}
class _V extends Mk {
    readValueFromInstance(t, n) {
        if (so.has(n)) {
            const i = X2(n);
            return i && i.default || 0
        } else {
            const i = RV(t)
              , r = (pC(n) ? i.getPropertyValue(n) : i[n]) || 0;
            return typeof r == "string" ? r.trim() : r
        }
    }
    measureInstanceViewportBox(t, {transformPagePoint: n}) {
        return pk(t, n)
    }
    build(t, n, i, r) {
        D2(t, n, i, r.transformTemplate)
    }
    scrapeMotionValuesFromProps(t, n) {
        return z2(t, n)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: t} = this.props;
        jn(t) && (this.childSubscription = t.on("change", n=>{
            this.current && (this.current.textContent = `${n}`)
        }
        ))
    }
    renderInstance(t, n, i, r) {
        bC(t, n, i, r)
    }
}
class DV extends Mk {
    constructor() {
        super(...arguments),
        this.isSVGTag = !1
    }
    getBaseTargetFromProps(t, n) {
        return t[n]
    }
    readValueFromInstance(t, n) {
        if (so.has(n)) {
            const i = X2(n);
            return i && i.default || 0
        }
        return n = wC.has(n) ? n : B2(n),
        t.getAttribute(n)
    }
    measureInstanceViewportBox() {
        return _t()
    }
    scrapeMotionValuesFromProps(t, n) {
        return CC(t, n)
    }
    build(t, n, i, r) {
        F2(t, n, i, this.isSVGTag, r.transformTemplate)
    }
    renderInstance(t, n, i, r) {
        SC(t, n, i, r)
    }
    mount(t) {
        this.isSVGTag = I2(t.tagName),
        super.mount(t)
    }
}
const NV = (e,t)=>_2(e) ? new DV(t,{
    enableHardwareAcceleration: !1
}) : new _V(t,{
    enableHardwareAcceleration: !0
})
  , FV = {
    layout: {
        ProjectionNode: Sk,
        MeasureLayout: gk
    }
}
  , IV = {
    ...hz,
    ...OI,
    ...gV,
    ...FV
}
  , u6 = BF((e,t)=>yI(e, t, IV, NV));
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
function Ac(e) {
    return e + .5 | 0
}
const Or = (e,t,n)=>Math.max(Math.min(e, n), t);
function Za(e) {
    return Or(Ac(e * 2.55), 0, 255)
}
function Xr(e) {
    return Or(Ac(e * 255), 0, 255)
}
function er(e) {
    return Or(Ac(e / 2.55) / 100, 0, 1)
}
function h6(e) {
    return Or(Ac(e * 100), 0, 100)
}
const qn = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
}
  , Lg = [..."0123456789ABCDEF"]
  , BV = e=>Lg[e & 15]
  , zV = e=>Lg[(e & 240) >> 4] + Lg[e & 15]
  , xu = e=>(e & 240) >> 4 === (e & 15)
  , VV = e=>xu(e.r) && xu(e.g) && xu(e.b) && xu(e.a);
function WV(e) {
    var t = e.length, n;
    return e[0] === "#" && (t === 4 || t === 5 ? n = {
        r: 255 & qn[e[1]] * 17,
        g: 255 & qn[e[2]] * 17,
        b: 255 & qn[e[3]] * 17,
        a: t === 5 ? qn[e[4]] * 17 : 255
    } : (t === 7 || t === 9) && (n = {
        r: qn[e[1]] << 4 | qn[e[2]],
        g: qn[e[3]] << 4 | qn[e[4]],
        b: qn[e[5]] << 4 | qn[e[6]],
        a: t === 9 ? qn[e[7]] << 4 | qn[e[8]] : 255
    })),
    n
}
const HV = (e,t)=>e < 255 ? t(e) : "";
function UV(e) {
    var t = VV(e) ? BV : zV;
    return e ? "#" + t(e.r) + t(e.g) + t(e.b) + HV(e.a, t) : void 0
}
const GV = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function Ek(e, t, n) {
    const i = t * Math.min(n, 1 - n)
      , r = (s,o=(s + e / 30) % 12)=>n - i * Math.max(Math.min(o - 3, 9 - o, 1), -1);
    return [r(0), r(8), r(4)]
}
function XV(e, t, n) {
    const i = (r,s=(r + e / 60) % 6)=>n - n * t * Math.max(Math.min(s, 4 - s, 1), 0);
    return [i(5), i(3), i(1)]
}
function YV(e, t, n) {
    const i = Ek(e, 1, .5);
    let r;
    for (t + n > 1 && (r = 1 / (t + n),
    t *= r,
    n *= r),
    r = 0; r < 3; r++)
        i[r] *= 1 - t - n,
        i[r] += t;
    return i
}
function $V(e, t, n, i, r) {
    return e === r ? (t - n) / i + (t < n ? 6 : 0) : t === r ? (n - e) / i + 2 : (e - t) / i + 4
}
function q2(e) {
    const n = e.r / 255
      , i = e.g / 255
      , r = e.b / 255
      , s = Math.max(n, i, r)
      , o = Math.min(n, i, r)
      , a = (s + o) / 2;
    let l, c, u;
    return s !== o && (u = s - o,
    c = a > .5 ? u / (2 - s - o) : u / (s + o),
    l = $V(n, i, r, u, s),
    l = l * 60 + .5),
    [l | 0, c || 0, a]
}
function Z2(e, t, n, i) {
    return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, i)).map(Xr)
}
function J2(e, t, n) {
    return Z2(Ek, e, t, n)
}
function KV(e, t, n) {
    return Z2(YV, e, t, n)
}
function QV(e, t, n) {
    return Z2(XV, e, t, n)
}
function Pk(e) {
    return (e % 360 + 360) % 360
}
function qV(e) {
    const t = GV.exec(e);
    let n = 255, i;
    if (!t)
        return;
    t[5] !== i && (n = t[6] ? Za(+t[5]) : Xr(+t[5]));
    const r = Pk(+t[2])
      , s = +t[3] / 100
      , o = +t[4] / 100;
    return t[1] === "hwb" ? i = KV(r, s, o) : t[1] === "hsv" ? i = QV(r, s, o) : i = J2(r, s, o),
    {
        r: i[0],
        g: i[1],
        b: i[2],
        a: n
    }
}
function ZV(e, t) {
    var n = q2(e);
    n[0] = Pk(n[0] + t),
    n = J2(n),
    e.r = n[0],
    e.g = n[1],
    e.b = n[2]
}
function JV(e) {
    if (!e)
        return;
    const t = q2(e)
      , n = t[0]
      , i = h6(t[1])
      , r = h6(t[2]);
    return e.a < 255 ? `hsla(${n}, ${i}%, ${r}%, ${er(e.a)})` : `hsl(${n}, ${i}%, ${r}%)`
}
const d6 = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
}
  , f6 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
};
function eW() {
    const e = {}
      , t = Object.keys(f6)
      , n = Object.keys(d6);
    let i, r, s, o, a;
    for (i = 0; i < t.length; i++) {
        for (o = a = t[i],
        r = 0; r < n.length; r++)
            s = n[r],
            a = a.replace(s, d6[s]);
        s = parseInt(f6[o], 16),
        e[a] = [s >> 16 & 255, s >> 8 & 255, s & 255]
    }
    return e
}
let bu;
function tW(e) {
    bu || (bu = eW(),
    bu.transparent = [0, 0, 0, 0]);
    const t = bu[e.toLowerCase()];
    return t && {
        r: t[0],
        g: t[1],
        b: t[2],
        a: t.length === 4 ? t[3] : 255
    }
}
const nW = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function iW(e) {
    const t = nW.exec(e);
    let n = 255, i, r, s;
    if (t) {
        if (t[7] !== i) {
            const o = +t[7];
            n = t[8] ? Za(o) : Or(o * 255, 0, 255)
        }
        return i = +t[1],
        r = +t[3],
        s = +t[5],
        i = 255 & (t[2] ? Za(i) : Or(i, 0, 255)),
        r = 255 & (t[4] ? Za(r) : Or(r, 0, 255)),
        s = 255 & (t[6] ? Za(s) : Or(s, 0, 255)),
        {
            r: i,
            g: r,
            b: s,
            a: n
        }
    }
}
function rW(e) {
    return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${er(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`)
}
const j0 = e=>e <= .0031308 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - .055
  , So = e=>e <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);
function sW(e, t, n) {
    const i = So(er(e.r))
      , r = So(er(e.g))
      , s = So(er(e.b));
    return {
        r: Xr(j0(i + n * (So(er(t.r)) - i))),
        g: Xr(j0(r + n * (So(er(t.g)) - r))),
        b: Xr(j0(s + n * (So(er(t.b)) - s))),
        a: e.a + n * (t.a - e.a)
    }
}
function wu(e, t, n) {
    if (e) {
        let i = q2(e);
        i[t] = Math.max(0, Math.min(i[t] + i[t] * n, t === 0 ? 360 : 1)),
        i = J2(i),
        e.r = i[0],
        e.g = i[1],
        e.b = i[2]
    }
}
function Tk(e, t) {
    return e && Object.assign(t || {}, e)
}
function p6(e) {
    var t = {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    return Array.isArray(e) ? e.length >= 3 && (t = {
        r: e[0],
        g: e[1],
        b: e[2],
        a: 255
    },
    e.length > 3 && (t.a = Xr(e[3]))) : (t = Tk(e, {
        r: 0,
        g: 0,
        b: 0,
        a: 1
    }),
    t.a = Xr(t.a)),
    t
}
function oW(e) {
    return e.charAt(0) === "r" ? iW(e) : qV(e)
}
class Zl {
    constructor(t) {
        if (t instanceof Zl)
            return t;
        const n = typeof t;
        let i;
        n === "object" ? i = p6(t) : n === "string" && (i = WV(t) || tW(t) || oW(t)),
        this._rgb = i,
        this._valid = !!i
    }
    get valid() {
        return this._valid
    }
    get rgb() {
        var t = Tk(this._rgb);
        return t && (t.a = er(t.a)),
        t
    }
    set rgb(t) {
        this._rgb = p6(t)
    }
    rgbString() {
        return this._valid ? rW(this._rgb) : void 0
    }
    hexString() {
        return this._valid ? UV(this._rgb) : void 0
    }
    hslString() {
        return this._valid ? JV(this._rgb) : void 0
    }
    mix(t, n) {
        if (t) {
            const i = this.rgb
              , r = t.rgb;
            let s;
            const o = n === s ? .5 : n
              , a = 2 * o - 1
              , l = i.a - r.a
              , c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;
            s = 1 - c,
            i.r = 255 & c * i.r + s * r.r + .5,
            i.g = 255 & c * i.g + s * r.g + .5,
            i.b = 255 & c * i.b + s * r.b + .5,
            i.a = o * i.a + (1 - o) * r.a,
            this.rgb = i
        }
        return this
    }
    interpolate(t, n) {
        return t && (this._rgb = sW(this._rgb, t._rgb, n)),
        this
    }
    clone() {
        return new Zl(this.rgb)
    }
    alpha(t) {
        return this._rgb.a = Xr(t),
        this
    }
    clearer(t) {
        const n = this._rgb;
        return n.a *= 1 - t,
        this
    }
    greyscale() {
        const t = this._rgb
          , n = Ac(t.r * .3 + t.g * .59 + t.b * .11);
        return t.r = t.g = t.b = n,
        this
    }
    opaquer(t) {
        const n = this._rgb;
        return n.a *= 1 + t,
        this
    }
    negate() {
        const t = this._rgb;
        return t.r = 255 - t.r,
        t.g = 255 - t.g,
        t.b = 255 - t.b,
        this
    }
    lighten(t) {
        return wu(this._rgb, 2, t),
        this
    }
    darken(t) {
        return wu(this._rgb, 2, -t),
        this
    }
    saturate(t) {
        return wu(this._rgb, 1, t),
        this
    }
    desaturate(t) {
        return wu(this._rgb, 1, -t),
        this
    }
    rotate(t) {
        return ZV(this._rgb, t),
        this
    }
}
/*!
 * Chart.js v4.4.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
function Yi() {}
const aW = (()=>{
    let e = 0;
    return ()=>e++
}
)();
function ft(e) {
    return e === null || typeof e > "u"
}
function yt(e) {
    if (Array.isArray && Array.isArray(e))
        return !0;
    const t = Object.prototype.toString.call(e);
    return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]"
}
function Xe(e) {
    return e !== null && Object.prototype.toString.call(e) === "[object Object]"
}
function Pt(e) {
    return (typeof e == "number" || e instanceof Number) && isFinite(+e)
}
function _n(e, t) {
    return Pt(e) ? e : t
}
function He(e, t) {
    return typeof e > "u" ? t : e
}
const lW = (e,t)=>typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t
  , jk = (e,t)=>typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function at(e, t, n) {
    if (e && typeof e.call == "function")
        return e.apply(n, t)
}
function Ze(e, t, n, i) {
    let r, s, o;
    if (yt(e))
        if (s = e.length,
        i)
            for (r = s - 1; r >= 0; r--)
                t.call(n, e[r], r);
        else
            for (r = 0; r < s; r++)
                t.call(n, e[r], r);
    else if (Xe(e))
        for (o = Object.keys(e),
        s = o.length,
        r = 0; r < s; r++)
            t.call(n, e[o[r]], o[r])
}
function Jh(e, t) {
    let n, i, r, s;
    if (!e || !t || e.length !== t.length)
        return !1;
    for (n = 0,
    i = e.length; n < i; ++n)
        if (r = e[n],
        s = t[n],
        r.datasetIndex !== s.datasetIndex || r.index !== s.index)
            return !1;
    return !0
}
function ed(e) {
    if (yt(e))
        return e.map(ed);
    if (Xe(e)) {
        const t = Object.create(null)
          , n = Object.keys(e)
          , i = n.length;
        let r = 0;
        for (; r < i; ++r)
            t[n[r]] = ed(e[n[r]]);
        return t
    }
    return e
}
function Ok(e) {
    return ["__proto__", "prototype", "constructor"].indexOf(e) === -1
}
function cW(e, t, n, i) {
    if (!Ok(e))
        return;
    const r = t[e]
      , s = n[e];
    Xe(r) && Xe(s) ? Jl(r, s, i) : t[e] = ed(s)
}
function Jl(e, t, n) {
    const i = yt(t) ? t : [t]
      , r = i.length;
    if (!Xe(e))
        return e;
    n = n || {};
    const s = n.merger || cW;
    let o;
    for (let a = 0; a < r; ++a) {
        if (o = i[a],
        !Xe(o))
            continue;
        const l = Object.keys(o);
        for (let c = 0, u = l.length; c < u; ++c)
            s(l[c], e, o, n)
    }
    return e
}
function xl(e, t) {
    return Jl(e, t, {
        merger: uW
    })
}
function uW(e, t, n) {
    if (!Ok(e))
        return;
    const i = t[e]
      , r = n[e];
    Xe(i) && Xe(r) ? xl(i, r) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = ed(r))
}
const g6 = {
    "": e=>e,
    x: e=>e.x,
    y: e=>e.y
};
function hW(e) {
    const t = e.split(".")
      , n = [];
    let i = "";
    for (const r of t)
        i += r,
        i.endsWith("\\") ? i = i.slice(0, -1) + "." : (n.push(i),
        i = "");
    return n
}
function dW(e) {
    const t = hW(e);
    return n=>{
        for (const i of t) {
            if (i === "")
                break;
            n = n && n[i]
        }
        return n
    }
}
function ec(e, t) {
    return (g6[t] || (g6[t] = dW(t)))(e)
}
function ev(e) {
    return e.charAt(0).toUpperCase() + e.slice(1)
}
const td = e=>typeof e < "u"
  , Zr = e=>typeof e == "function"
  , m6 = (e,t)=>{
    if (e.size !== t.size)
        return !1;
    for (const n of e)
        if (!t.has(n))
            return !1;
    return !0
}
;
function fW(e) {
    return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu"
}
const xt = Math.PI
  , mt = 2 * xt
  , pW = mt + xt
  , nd = Number.POSITIVE_INFINITY
  , gW = xt / 180
  , Rt = xt / 2
  , ms = xt / 4
  , v6 = xt * 2 / 3
  , Lr = Math.log10
  , ma = Math.sign;
function bl(e, t, n) {
    return Math.abs(e - t) < n
}
function y6(e) {
    const t = Math.round(e);
    e = bl(e, t, e / 1e3) ? t : e;
    const n = Math.pow(10, Math.floor(Lr(e)))
      , i = e / n;
    return (i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * n
}
function mW(e) {
    const t = []
      , n = Math.sqrt(e);
    let i;
    for (i = 1; i < n; i++)
        e % i === 0 && (t.push(i),
        t.push(e / i));
    return n === (n | 0) && t.push(n),
    t.sort((r,s)=>r - s).pop(),
    t
}
function tc(e) {
    return !isNaN(parseFloat(e)) && isFinite(e)
}
function vW(e, t) {
    const n = Math.round(e);
    return n - t <= e && n + t >= e
}
function Lk(e, t, n) {
    let i, r, s;
    for (i = 0,
    r = e.length; i < r; i++)
        s = e[i][n],
        isNaN(s) || (t.min = Math.min(t.min, s),
        t.max = Math.max(t.max, s))
}
function Ni(e) {
    return e * (xt / 180)
}
function tv(e) {
    return e * (180 / xt)
}
function x6(e) {
    if (!Pt(e))
        return;
    let t = 1
      , n = 0;
    for (; Math.round(e * t) / t !== e; )
        t *= 10,
        n++;
    return n
}
function Rk(e, t) {
    const n = t.x - e.x
      , i = t.y - e.y
      , r = Math.sqrt(n * n + i * i);
    let s = Math.atan2(i, n);
    return s < -.5 * xt && (s += mt),
    {
        angle: s,
        distance: r
    }
}
function Rg(e, t) {
    return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
}
function yW(e, t) {
    return (e - t + pW) % mt - xt
}
function Nn(e) {
    return (e % mt + mt) % mt
}
function nc(e, t, n, i) {
    const r = Nn(e)
      , s = Nn(t)
      , o = Nn(n)
      , a = Nn(s - r)
      , l = Nn(o - r)
      , c = Nn(r - s)
      , u = Nn(r - o);
    return r === s || r === o || i && s === o || a > l && c < u
}
function gn(e, t, n) {
    return Math.max(t, Math.min(n, e))
}
function xW(e) {
    return gn(e, -32768, 32767)
}
function Is(e, t, n, i=1e-6) {
    return e >= Math.min(t, n) - i && e <= Math.max(t, n) + i
}
function nv(e, t, n) {
    n = n || (o=>e[o] < t);
    let i = e.length - 1, r = 0, s;
    for (; i - r > 1; )
        s = r + i >> 1,
        n(s) ? r = s : i = s;
    return {
        lo: r,
        hi: i
    }
}
const Bs = (e,t,n,i)=>nv(e, n, i ? r=>{
    const s = e[r][t];
    return s < n || s === n && e[r + 1][t] === n
}
: r=>e[r][t] < n)
  , bW = (e,t,n)=>nv(e, n, i=>e[i][t] >= n);
function wW(e, t, n) {
    let i = 0
      , r = e.length;
    for (; i < r && e[i] < t; )
        i++;
    for (; r > i && e[r - 1] > n; )
        r--;
    return i > 0 || r < e.length ? e.slice(i, r) : e
}
const _k = ["push", "pop", "shift", "splice", "unshift"];
function SW(e, t) {
    if (e._chartjs) {
        e._chartjs.listeners.push(t);
        return
    }
    Object.defineProperty(e, "_chartjs", {
        configurable: !0,
        enumerable: !1,
        value: {
            listeners: [t]
        }
    }),
    _k.forEach(n=>{
        const i = "_onData" + ev(n)
          , r = e[n];
        Object.defineProperty(e, n, {
            configurable: !0,
            enumerable: !1,
            value(...s) {
                const o = r.apply(this, s);
                return e._chartjs.listeners.forEach(a=>{
                    typeof a[i] == "function" && a[i](...s)
                }
                ),
                o
            }
        })
    }
    )
}
function b6(e, t) {
    const n = e._chartjs;
    if (!n)
        return;
    const i = n.listeners
      , r = i.indexOf(t);
    r !== -1 && i.splice(r, 1),
    !(i.length > 0) && (_k.forEach(s=>{
        delete e[s]
    }
    ),
    delete e._chartjs)
}
function CW(e) {
    const t = new Set(e);
    return t.size === e.length ? e : Array.from(t)
}
const Dk = function() {
    return typeof window > "u" ? function(e) {
        return e()
    }
    : window.requestAnimationFrame
}();
function Nk(e, t) {
    let n = []
      , i = !1;
    return function(...r) {
        n = r,
        i || (i = !0,
        Dk.call(window, ()=>{
            i = !1,
            e.apply(t, n)
        }
        ))
    }
}
function kW(e, t) {
    let n;
    return function(...i) {
        return t ? (clearTimeout(n),
        n = setTimeout(e, t, i)) : e.apply(this, i),
        t
    }
}
const iv = e=>e === "start" ? "left" : e === "end" ? "right" : "center"
  , on = (e,t,n)=>e === "start" ? t : e === "end" ? n : (t + n) / 2
  , AW = (e,t,n,i)=>e === (i ? "left" : "right") ? n : e === "center" ? (t + n) / 2 : t;
function MW(e, t, n) {
    const i = t.length;
    let r = 0
      , s = i;
    if (e._sorted) {
        const {iScale: o, _parsed: a} = e
          , l = o.axis
          , {min: c, max: u, minDefined: h, maxDefined: d} = o.getUserBounds();
        h && (r = gn(Math.min(Bs(a, l, c).lo, n ? i : Bs(t, l, o.getPixelForValue(c)).lo), 0, i - 1)),
        d ? s = gn(Math.max(Bs(a, o.axis, u, !0).hi + 1, n ? 0 : Bs(t, l, o.getPixelForValue(u), !0).hi + 1), r, i) - r : s = i - r
    }
    return {
        start: r,
        count: s
    }
}
function EW(e) {
    const {xScale: t, yScale: n, _scaleRanges: i} = e
      , r = {
        xmin: t.min,
        xmax: t.max,
        ymin: n.min,
        ymax: n.max
    };
    if (!i)
        return e._scaleRanges = r,
        !0;
    const s = i.xmin !== t.min || i.xmax !== t.max || i.ymin !== n.min || i.ymax !== n.max;
    return Object.assign(i, r),
    s
}
const Su = e=>e === 0 || e === 1
  , w6 = (e,t,n)=>-(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * mt / n))
  , S6 = (e,t,n)=>Math.pow(2, -10 * e) * Math.sin((e - t) * mt / n) + 1
  , wl = {
    linear: e=>e,
    easeInQuad: e=>e * e,
    easeOutQuad: e=>-e * (e - 2),
    easeInOutQuad: e=>(e /= .5) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1),
    easeInCubic: e=>e * e * e,
    easeOutCubic: e=>(e -= 1) * e * e + 1,
    easeInOutCubic: e=>(e /= .5) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2),
    easeInQuart: e=>e * e * e * e,
    easeOutQuart: e=>-((e -= 1) * e * e * e - 1),
    easeInOutQuart: e=>(e /= .5) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2),
    easeInQuint: e=>e * e * e * e * e,
    easeOutQuint: e=>(e -= 1) * e * e * e * e + 1,
    easeInOutQuint: e=>(e /= .5) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2),
    easeInSine: e=>-Math.cos(e * Rt) + 1,
    easeOutSine: e=>Math.sin(e * Rt),
    easeInOutSine: e=>-.5 * (Math.cos(xt * e) - 1),
    easeInExpo: e=>e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
    easeOutExpo: e=>e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
    easeInOutExpo: e=>Su(e) ? e : e < .5 ? .5 * Math.pow(2, 10 * (e * 2 - 1)) : .5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
    easeInCirc: e=>e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
    easeOutCirc: e=>Math.sqrt(1 - (e -= 1) * e),
    easeInOutCirc: e=>(e /= .5) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
    easeInElastic: e=>Su(e) ? e : w6(e, .075, .3),
    easeOutElastic: e=>Su(e) ? e : S6(e, .075, .3),
    easeInOutElastic(e) {
        return Su(e) ? e : e < .5 ? .5 * w6(e * 2, .1125, .45) : .5 + .5 * S6(e * 2 - 1, .1125, .45)
    },
    easeInBack(e) {
        return e * e * ((1.70158 + 1) * e - 1.70158)
    },
    easeOutBack(e) {
        return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1
    },
    easeInOutBack(e) {
        let t = 1.70158;
        return (e /= .5) < 1 ? .5 * (e * e * (((t *= 1.525) + 1) * e - t)) : .5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2)
    },
    easeInBounce: e=>1 - wl.easeOutBounce(1 - e),
    easeOutBounce(e) {
        return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
    },
    easeInOutBounce: e=>e < .5 ? wl.easeInBounce(e * 2) * .5 : wl.easeOutBounce(e * 2 - 1) * .5 + .5
};
function rv(e) {
    if (e && typeof e == "object") {
        const t = e.toString();
        return t === "[object CanvasPattern]" || t === "[object CanvasGradient]"
    }
    return !1
}
function C6(e) {
    return rv(e) ? e : new Zl(e)
}
function O0(e) {
    return rv(e) ? e : new Zl(e).saturate(.5).darken(.1).hexString()
}
const PW = ["x", "y", "borderWidth", "radius", "tension"]
  , TW = ["color", "borderColor", "backgroundColor"];
function jW(e) {
    e.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0
    }),
    e.describe("animation", {
        _fallback: !1,
        _indexable: !1,
        _scriptable: t=>t !== "onProgress" && t !== "onComplete" && t !== "fn"
    }),
    e.set("animations", {
        colors: {
            type: "color",
            properties: TW
        },
        numbers: {
            type: "number",
            properties: PW
        }
    }),
    e.describe("animations", {
        _fallback: "animation"
    }),
    e.set("transitions", {
        active: {
            animation: {
                duration: 400
            }
        },
        resize: {
            animation: {
                duration: 0
            }
        },
        show: {
            animations: {
                colors: {
                    from: "transparent"
                },
                visible: {
                    type: "boolean",
                    duration: 0
                }
            }
        },
        hide: {
            animations: {
                colors: {
                    to: "transparent"
                },
                visible: {
                    type: "boolean",
                    easing: "linear",
                    fn: t=>t | 0
                }
            }
        }
    })
}
function OW(e) {
    e.set("layout", {
        autoPadding: !0,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }
    })
}
const k6 = new Map;
function LW(e, t) {
    t = t || {};
    const n = e + JSON.stringify(t);
    let i = k6.get(n);
    return i || (i = new Intl.NumberFormat(e,t),
    k6.set(n, i)),
    i
}
function sf(e, t, n) {
    return LW(t, n).format(e)
}
const Fk = {
    values(e) {
        return yt(e) ? e : "" + e
    },
    numeric(e, t, n) {
        if (e === 0)
            return "0";
        const i = this.chart.options.locale;
        let r, s = e;
        if (n.length > 1) {
            const c = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
            (c < 1e-4 || c > 1e15) && (r = "scientific"),
            s = RW(e, n)
        }
        const o = Lr(Math.abs(s))
          , a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0)
          , l = {
            notation: r,
            minimumFractionDigits: a,
            maximumFractionDigits: a
        };
        return Object.assign(l, this.options.ticks.format),
        sf(e, i, l)
    },
    logarithmic(e, t, n) {
        if (e === 0)
            return "0";
        const i = n[t].significand || e / Math.pow(10, Math.floor(Lr(e)));
        return [1, 2, 3, 5, 10, 15].includes(i) || t > .8 * n.length ? Fk.numeric.call(this, e, t, n) : ""
    }
};
function RW(e, t) {
    let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
    return Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e)),
    n
}
var of = {
    formatters: Fk
};
function _W(e) {
    e.set("scale", {
        display: !0,
        offset: !1,
        reverse: !1,
        beginAtZero: !1,
        bounds: "ticks",
        clip: !0,
        grace: 0,
        grid: {
            display: !0,
            lineWidth: 1,
            drawOnChartArea: !0,
            drawTicks: !0,
            tickLength: 8,
            tickWidth: (t,n)=>n.lineWidth,
            tickColor: (t,n)=>n.color,
            offset: !1
        },
        border: {
            display: !0,
            dash: [],
            dashOffset: 0,
            width: 1
        },
        title: {
            display: !1,
            text: "",
            padding: {
                top: 4,
                bottom: 4
            }
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: !1,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: !0,
            autoSkip: !0,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: of.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: !1,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
        }
    }),
    e.route("scale.ticks", "color", "", "color"),
    e.route("scale.grid", "color", "", "borderColor"),
    e.route("scale.border", "color", "", "borderColor"),
    e.route("scale.title", "color", "", "color"),
    e.describe("scale", {
        _fallback: !1,
        _scriptable: t=>!t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
        _indexable: t=>t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
    }),
    e.describe("scales", {
        _fallback: "scale"
    }),
    e.describe("scale.ticks", {
        _scriptable: t=>t !== "backdropPadding" && t !== "callback",
        _indexable: t=>t !== "backdropPadding"
    })
}
const Zs = Object.create(null)
  , _g = Object.create(null);
function Sl(e, t) {
    if (!t)
        return e;
    const n = t.split(".");
    for (let i = 0, r = n.length; i < r; ++i) {
        const s = n[i];
        e = e[s] || (e[s] = Object.create(null))
    }
    return e
}
function L0(e, t, n) {
    return typeof t == "string" ? Jl(Sl(e, t), n) : Jl(Sl(e, ""), t)
}
class DW {
    constructor(t, n) {
        this.animation = void 0,
        this.backgroundColor = "rgba(0,0,0,0.1)",
        this.borderColor = "rgba(0,0,0,0.1)",
        this.color = "#666",
        this.datasets = {},
        this.devicePixelRatio = i=>i.chart.platform.getDevicePixelRatio(),
        this.elements = {},
        this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
        this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: "normal",
            lineHeight: 1.2,
            weight: null
        },
        this.hover = {},
        this.hoverBackgroundColor = (i,r)=>O0(r.backgroundColor),
        this.hoverBorderColor = (i,r)=>O0(r.borderColor),
        this.hoverColor = (i,r)=>O0(r.color),
        this.indexAxis = "x",
        this.interaction = {
            mode: "nearest",
            intersect: !0,
            includeInvisible: !1
        },
        this.maintainAspectRatio = !0,
        this.onHover = null,
        this.onClick = null,
        this.parsing = !0,
        this.plugins = {},
        this.responsive = !0,
        this.scale = void 0,
        this.scales = {},
        this.showLine = !0,
        this.drawActiveElementsOnTop = !0,
        this.describe(t),
        this.apply(n)
    }
    set(t, n) {
        return L0(this, t, n)
    }
    get(t) {
        return Sl(this, t)
    }
    describe(t, n) {
        return L0(_g, t, n)
    }
    override(t, n) {
        return L0(Zs, t, n)
    }
    route(t, n, i, r) {
        const s = Sl(this, t)
          , o = Sl(this, i)
          , a = "_" + n;
        Object.defineProperties(s, {
            [a]: {
                value: s[n],
                writable: !0
            },
            [n]: {
                enumerable: !0,
                get() {
                    const l = this[a]
                      , c = o[r];
                    return Xe(l) ? Object.assign({}, c, l) : He(l, c)
                },
                set(l) {
                    this[a] = l
                }
            }
        })
    }
    apply(t) {
        t.forEach(n=>n(this))
    }
}
var Tt = new DW({
    _scriptable: e=>!e.startsWith("on"),
    _indexable: e=>e !== "events",
    hover: {
        _fallback: "interaction"
    },
    interaction: {
        _scriptable: !1,
        _indexable: !1
    }
},[jW, OW, _W]);
function NW(e) {
    return !e || ft(e.size) || ft(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family
}
function id(e, t, n, i, r) {
    let s = t[r];
    return s || (s = t[r] = e.measureText(r).width,
    n.push(r)),
    s > i && (i = s),
    i
}
function FW(e, t, n, i) {
    i = i || {};
    let r = i.data = i.data || {}
      , s = i.garbageCollect = i.garbageCollect || [];
    i.font !== t && (r = i.data = {},
    s = i.garbageCollect = [],
    i.font = t),
    e.save(),
    e.font = t;
    let o = 0;
    const a = n.length;
    let l, c, u, h, d;
    for (l = 0; l < a; l++)
        if (h = n[l],
        h != null && !yt(h))
            o = id(e, r, s, o, h);
        else if (yt(h))
            for (c = 0,
            u = h.length; c < u; c++)
                d = h[c],
                d != null && !yt(d) && (o = id(e, r, s, o, d));
    e.restore();
    const m = s.length / 2;
    if (m > n.length) {
        for (l = 0; l < m; l++)
            delete r[s[l]];
        s.splice(0, m)
    }
    return o
}
function vs(e, t, n) {
    const i = e.currentDevicePixelRatio
      , r = n !== 0 ? Math.max(n / 2, .5) : 0;
    return Math.round((t - r) * i) / i + r
}
function A6(e, t) {
    t = t || e.getContext("2d"),
    t.save(),
    t.resetTransform(),
    t.clearRect(0, 0, e.width, e.height),
    t.restore()
}
function Dg(e, t, n, i) {
    Ik(e, t, n, i, null)
}
function Ik(e, t, n, i, r) {
    let s, o, a, l, c, u, h, d;
    const m = t.pointStyle
      , f = t.rotation
      , x = t.radius;
    let S = (f || 0) * gW;
    if (m && typeof m == "object" && (s = m.toString(),
    s === "[object HTMLImageElement]" || s === "[object HTMLCanvasElement]")) {
        e.save(),
        e.translate(n, i),
        e.rotate(S),
        e.drawImage(m, -m.width / 2, -m.height / 2, m.width, m.height),
        e.restore();
        return
    }
    if (!(isNaN(x) || x <= 0)) {
        switch (e.beginPath(),
        m) {
        default:
            r ? e.ellipse(n, i, r / 2, x, 0, 0, mt) : e.arc(n, i, x, 0, mt),
            e.closePath();
            break;
        case "triangle":
            u = r ? r / 2 : x,
            e.moveTo(n + Math.sin(S) * u, i - Math.cos(S) * x),
            S += v6,
            e.lineTo(n + Math.sin(S) * u, i - Math.cos(S) * x),
            S += v6,
            e.lineTo(n + Math.sin(S) * u, i - Math.cos(S) * x),
            e.closePath();
            break;
        case "rectRounded":
            c = x * .516,
            l = x - c,
            o = Math.cos(S + ms) * l,
            h = Math.cos(S + ms) * (r ? r / 2 - c : l),
            a = Math.sin(S + ms) * l,
            d = Math.sin(S + ms) * (r ? r / 2 - c : l),
            e.arc(n - h, i - a, c, S - xt, S - Rt),
            e.arc(n + d, i - o, c, S - Rt, S),
            e.arc(n + h, i + a, c, S, S + Rt),
            e.arc(n - d, i + o, c, S + Rt, S + xt),
            e.closePath();
            break;
        case "rect":
            if (!f) {
                l = Math.SQRT1_2 * x,
                u = r ? r / 2 : l,
                e.rect(n - u, i - l, 2 * u, 2 * l);
                break
            }
            S += ms;
        case "rectRot":
            h = Math.cos(S) * (r ? r / 2 : x),
            o = Math.cos(S) * x,
            a = Math.sin(S) * x,
            d = Math.sin(S) * (r ? r / 2 : x),
            e.moveTo(n - h, i - a),
            e.lineTo(n + d, i - o),
            e.lineTo(n + h, i + a),
            e.lineTo(n - d, i + o),
            e.closePath();
            break;
        case "crossRot":
            S += ms;
        case "cross":
            h = Math.cos(S) * (r ? r / 2 : x),
            o = Math.cos(S) * x,
            a = Math.sin(S) * x,
            d = Math.sin(S) * (r ? r / 2 : x),
            e.moveTo(n - h, i - a),
            e.lineTo(n + h, i + a),
            e.moveTo(n + d, i - o),
            e.lineTo(n - d, i + o);
            break;
        case "star":
            h = Math.cos(S) * (r ? r / 2 : x),
            o = Math.cos(S) * x,
            a = Math.sin(S) * x,
            d = Math.sin(S) * (r ? r / 2 : x),
            e.moveTo(n - h, i - a),
            e.lineTo(n + h, i + a),
            e.moveTo(n + d, i - o),
            e.lineTo(n - d, i + o),
            S += ms,
            h = Math.cos(S) * (r ? r / 2 : x),
            o = Math.cos(S) * x,
            a = Math.sin(S) * x,
            d = Math.sin(S) * (r ? r / 2 : x),
            e.moveTo(n - h, i - a),
            e.lineTo(n + h, i + a),
            e.moveTo(n + d, i - o),
            e.lineTo(n - d, i + o);
            break;
        case "line":
            o = r ? r / 2 : Math.cos(S) * x,
            a = Math.sin(S) * x,
            e.moveTo(n - o, i - a),
            e.lineTo(n + o, i + a);
            break;
        case "dash":
            e.moveTo(n, i),
            e.lineTo(n + Math.cos(S) * (r ? r / 2 : x), i + Math.sin(S) * x);
            break;
        case !1:
            e.closePath();
            break
        }
        e.fill(),
        t.borderWidth > 0 && e.stroke()
    }
}
function rr(e, t, n) {
    return n = n || .5,
    !t || e && e.x > t.left - n && e.x < t.right + n && e.y > t.top - n && e.y < t.bottom + n
}
function af(e, t) {
    e.save(),
    e.beginPath(),
    e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top),
    e.clip()
}
function lf(e) {
    e.restore()
}
function IW(e, t, n, i, r) {
    if (!t)
        return e.lineTo(n.x, n.y);
    if (r === "middle") {
        const s = (t.x + n.x) / 2;
        e.lineTo(s, t.y),
        e.lineTo(s, n.y)
    } else
        r === "after" != !!i ? e.lineTo(t.x, n.y) : e.lineTo(n.x, t.y);
    e.lineTo(n.x, n.y)
}
function BW(e, t, n, i) {
    if (!t)
        return e.lineTo(n.x, n.y);
    e.bezierCurveTo(i ? t.cp1x : t.cp2x, i ? t.cp1y : t.cp2y, i ? n.cp2x : n.cp1x, i ? n.cp2y : n.cp1y, n.x, n.y)
}
function zW(e, t) {
    t.translation && e.translate(t.translation[0], t.translation[1]),
    ft(t.rotation) || e.rotate(t.rotation),
    t.color && (e.fillStyle = t.color),
    t.textAlign && (e.textAlign = t.textAlign),
    t.textBaseline && (e.textBaseline = t.textBaseline)
}
function VW(e, t, n, i, r) {
    if (r.strikethrough || r.underline) {
        const s = e.measureText(i)
          , o = t - s.actualBoundingBoxLeft
          , a = t + s.actualBoundingBoxRight
          , l = n - s.actualBoundingBoxAscent
          , c = n + s.actualBoundingBoxDescent
          , u = r.strikethrough ? (l + c) / 2 : c;
        e.strokeStyle = e.fillStyle,
        e.beginPath(),
        e.lineWidth = r.decorationWidth || 2,
        e.moveTo(o, u),
        e.lineTo(a, u),
        e.stroke()
    }
}
function WW(e, t) {
    const n = e.fillStyle;
    e.fillStyle = t.color,
    e.fillRect(t.left, t.top, t.width, t.height),
    e.fillStyle = n
}
function Js(e, t, n, i, r, s={}) {
    const o = yt(t) ? t : [t]
      , a = s.strokeWidth > 0 && s.strokeColor !== "";
    let l, c;
    for (e.save(),
    e.font = r.string,
    zW(e, s),
    l = 0; l < o.length; ++l)
        c = o[l],
        s.backdrop && WW(e, s.backdrop),
        a && (s.strokeColor && (e.strokeStyle = s.strokeColor),
        ft(s.strokeWidth) || (e.lineWidth = s.strokeWidth),
        e.strokeText(c, n, i, s.maxWidth)),
        e.fillText(c, n, i, s.maxWidth),
        VW(e, n, i, c, s),
        i += Number(r.lineHeight);
    e.restore()
}
function rd(e, t) {
    const {x: n, y: i, w: r, h: s, radius: o} = t;
    e.arc(n + o.topLeft, i + o.topLeft, o.topLeft, 1.5 * xt, xt, !0),
    e.lineTo(n, i + s - o.bottomLeft),
    e.arc(n + o.bottomLeft, i + s - o.bottomLeft, o.bottomLeft, xt, Rt, !0),
    e.lineTo(n + r - o.bottomRight, i + s),
    e.arc(n + r - o.bottomRight, i + s - o.bottomRight, o.bottomRight, Rt, 0, !0),
    e.lineTo(n + r, i + o.topRight),
    e.arc(n + r - o.topRight, i + o.topRight, o.topRight, 0, -Rt, !0),
    e.lineTo(n + o.topLeft, i)
}
const HW = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/
  , UW = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function GW(e, t) {
    const n = ("" + e).match(HW);
    if (!n || n[1] === "normal")
        return t * 1.2;
    switch (e = +n[2],
    n[3]) {
    case "px":
        return e;
    case "%":
        e /= 100;
        break
    }
    return t * e
}
const XW = e=>+e || 0;
function sv(e, t) {
    const n = {}
      , i = Xe(t)
      , r = i ? Object.keys(t) : t
      , s = Xe(e) ? i ? o=>He(e[o], e[t[o]]) : o=>e[o] : ()=>e;
    for (const o of r)
        n[o] = XW(s(o));
    return n
}
function YW(e) {
    return sv(e, {
        top: "y",
        right: "x",
        bottom: "y",
        left: "x"
    })
}
function ea(e) {
    return sv(e, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
}
function cn(e) {
    const t = YW(e);
    return t.width = t.left + t.right,
    t.height = t.top + t.bottom,
    t
}
function Ht(e, t) {
    e = e || {},
    t = t || Tt.font;
    let n = He(e.size, t.size);
    typeof n == "string" && (n = parseInt(n, 10));
    let i = He(e.style, t.style);
    i && !("" + i).match(UW) && (console.warn('Invalid font style specified: "' + i + '"'),
    i = void 0);
    const r = {
        family: He(e.family, t.family),
        lineHeight: GW(He(e.lineHeight, t.lineHeight), n),
        size: n,
        style: i,
        weight: He(e.weight, t.weight),
        string: ""
    };
    return r.string = NW(r),
    r
}
function Cu(e, t, n, i) {
    let r = !0, s, o, a;
    for (s = 0,
    o = e.length; s < o; ++s)
        if (a = e[s],
        a !== void 0 && (t !== void 0 && typeof a == "function" && (a = a(t),
        r = !1),
        n !== void 0 && yt(a) && (a = a[n % a.length],
        r = !1),
        a !== void 0))
            return i && !r && (i.cacheable = !1),
            a
}
function $W(e, t, n) {
    const {min: i, max: r} = e
      , s = jk(t, (r - i) / 2)
      , o = (a,l)=>n && a === 0 ? 0 : a + l;
    return {
        min: o(i, -Math.abs(s)),
        max: o(r, s)
    }
}
function os(e, t) {
    return Object.assign(Object.create(e), t)
}
function ov(e, t=[""], n, i, r=()=>e[0]) {
    const s = n || e;
    typeof i > "u" && (i = Wk("_fallback", e));
    const o = {
        [Symbol.toStringTag]: "Object",
        _cacheable: !0,
        _scopes: e,
        _rootScopes: s,
        _fallback: i,
        _getTarget: r,
        override: a=>ov([a, ...e], t, s, i)
    };
    return new Proxy(o,{
        deleteProperty(a, l) {
            return delete a[l],
            delete a._keys,
            delete e[0][l],
            !0
        },
        get(a, l) {
            return zk(a, l, ()=>nH(l, t, e, a))
        },
        getOwnPropertyDescriptor(a, l) {
            return Reflect.getOwnPropertyDescriptor(a._scopes[0], l)
        },
        getPrototypeOf() {
            return Reflect.getPrototypeOf(e[0])
        },
        has(a, l) {
            return E6(a).includes(l)
        },
        ownKeys(a) {
            return E6(a)
        },
        set(a, l, c) {
            const u = a._storage || (a._storage = r());
            return a[l] = u[l] = c,
            delete a._keys,
            !0
        }
    })
}
function va(e, t, n, i) {
    const r = {
        _cacheable: !1,
        _proxy: e,
        _context: t,
        _subProxy: n,
        _stack: new Set,
        _descriptors: Bk(e, i),
        setContext: s=>va(e, s, n, i),
        override: s=>va(e.override(s), t, n, i)
    };
    return new Proxy(r,{
        deleteProperty(s, o) {
            return delete s[o],
            delete e[o],
            !0
        },
        get(s, o, a) {
            return zk(s, o, ()=>QW(s, o, a))
        },
        getOwnPropertyDescriptor(s, o) {
            return s._descriptors.allKeys ? Reflect.has(e, o) ? {
                enumerable: !0,
                configurable: !0
            } : void 0 : Reflect.getOwnPropertyDescriptor(e, o)
        },
        getPrototypeOf() {
            return Reflect.getPrototypeOf(e)
        },
        has(s, o) {
            return Reflect.has(e, o)
        },
        ownKeys() {
            return Reflect.ownKeys(e)
        },
        set(s, o, a) {
            return e[o] = a,
            delete s[o],
            !0
        }
    })
}
function Bk(e, t={
    scriptable: !0,
    indexable: !0
}) {
    const {_scriptable: n=t.scriptable, _indexable: i=t.indexable, _allKeys: r=t.allKeys} = e;
    return {
        allKeys: r,
        scriptable: n,
        indexable: i,
        isScriptable: Zr(n) ? n : ()=>n,
        isIndexable: Zr(i) ? i : ()=>i
    }
}
const KW = (e,t)=>e ? e + ev(t) : t
  , av = (e,t)=>Xe(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function zk(e, t, n) {
    if (Object.prototype.hasOwnProperty.call(e, t))
        return e[t];
    const i = n();
    return e[t] = i,
    i
}
function QW(e, t, n) {
    const {_proxy: i, _context: r, _subProxy: s, _descriptors: o} = e;
    let a = i[t];
    return Zr(a) && o.isScriptable(t) && (a = qW(t, a, e, n)),
    yt(a) && a.length && (a = ZW(t, a, e, o.isIndexable)),
    av(t, a) && (a = va(a, r, s && s[t], o)),
    a
}
function qW(e, t, n, i) {
    const {_proxy: r, _context: s, _subProxy: o, _stack: a} = n;
    if (a.has(e))
        throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + e);
    a.add(e);
    let l = t(s, o || i);
    return a.delete(e),
    av(e, l) && (l = lv(r._scopes, r, e, l)),
    l
}
function ZW(e, t, n, i) {
    const {_proxy: r, _context: s, _subProxy: o, _descriptors: a} = n;
    if (typeof s.index < "u" && i(e))
        return t[s.index % t.length];
    if (Xe(t[0])) {
        const l = t
          , c = r._scopes.filter(u=>u !== l);
        t = [];
        for (const u of l) {
            const h = lv(c, r, e, u);
            t.push(va(h, s, o && o[e], a))
        }
    }
    return t
}
function Vk(e, t, n) {
    return Zr(e) ? e(t, n) : e
}
const JW = (e,t)=>e === !0 ? t : typeof e == "string" ? ec(t, e) : void 0;
function eH(e, t, n, i, r) {
    for (const s of t) {
        const o = JW(n, s);
        if (o) {
            e.add(o);
            const a = Vk(o._fallback, n, r);
            if (typeof a < "u" && a !== n && a !== i)
                return a
        } else if (o === !1 && typeof i < "u" && n !== i)
            return null
    }
    return !1
}
function lv(e, t, n, i) {
    const r = t._rootScopes
      , s = Vk(t._fallback, n, i)
      , o = [...e, ...r]
      , a = new Set;
    a.add(i);
    let l = M6(a, o, n, s || n, i);
    return l === null || typeof s < "u" && s !== n && (l = M6(a, o, s, l, i),
    l === null) ? !1 : ov(Array.from(a), [""], r, s, ()=>tH(t, n, i))
}
function M6(e, t, n, i, r) {
    for (; n; )
        n = eH(e, t, n, i, r);
    return n
}
function tH(e, t, n) {
    const i = e._getTarget();
    t in i || (i[t] = {});
    const r = i[t];
    return yt(r) && Xe(n) ? n : r || {}
}
function nH(e, t, n, i) {
    let r;
    for (const s of t)
        if (r = Wk(KW(s, e), n),
        typeof r < "u")
            return av(e, r) ? lv(n, i, e, r) : r
}
function Wk(e, t) {
    for (const n of t) {
        if (!n)
            continue;
        const i = n[e];
        if (typeof i < "u")
            return i
    }
}
function E6(e) {
    let t = e._keys;
    return t || (t = e._keys = iH(e._scopes)),
    t
}
function iH(e) {
    const t = new Set;
    for (const n of e)
        for (const i of Object.keys(n).filter(r=>!r.startsWith("_")))
            t.add(i);
    return Array.from(t)
}
const rH = Number.EPSILON || 1e-14
  , ya = (e,t)=>t < e.length && !e[t].skip && e[t]
  , Hk = e=>e === "x" ? "y" : "x";
function sH(e, t, n, i) {
    const r = e.skip ? t : e
      , s = t
      , o = n.skip ? t : n
      , a = Rg(s, r)
      , l = Rg(o, s);
    let c = a / (a + l)
      , u = l / (a + l);
    c = isNaN(c) ? 0 : c,
    u = isNaN(u) ? 0 : u;
    const h = i * c
      , d = i * u;
    return {
        previous: {
            x: s.x - h * (o.x - r.x),
            y: s.y - h * (o.y - r.y)
        },
        next: {
            x: s.x + d * (o.x - r.x),
            y: s.y + d * (o.y - r.y)
        }
    }
}
function oH(e, t, n) {
    const i = e.length;
    let r, s, o, a, l, c = ya(e, 0);
    for (let u = 0; u < i - 1; ++u)
        if (l = c,
        c = ya(e, u + 1),
        !(!l || !c)) {
            if (bl(t[u], 0, rH)) {
                n[u] = n[u + 1] = 0;
                continue
            }
            r = n[u] / t[u],
            s = n[u + 1] / t[u],
            a = Math.pow(r, 2) + Math.pow(s, 2),
            !(a <= 9) && (o = 3 / Math.sqrt(a),
            n[u] = r * o * t[u],
            n[u + 1] = s * o * t[u])
        }
}
function aH(e, t, n="x") {
    const i = Hk(n)
      , r = e.length;
    let s, o, a, l = ya(e, 0);
    for (let c = 0; c < r; ++c) {
        if (o = a,
        a = l,
        l = ya(e, c + 1),
        !a)
            continue;
        const u = a[n]
          , h = a[i];
        o && (s = (u - o[n]) / 3,
        a[`cp1${n}`] = u - s,
        a[`cp1${i}`] = h - s * t[c]),
        l && (s = (l[n] - u) / 3,
        a[`cp2${n}`] = u + s,
        a[`cp2${i}`] = h + s * t[c])
    }
}
function lH(e, t="x") {
    const n = Hk(t)
      , i = e.length
      , r = Array(i).fill(0)
      , s = Array(i);
    let o, a, l, c = ya(e, 0);
    for (o = 0; o < i; ++o)
        if (a = l,
        l = c,
        c = ya(e, o + 1),
        !!l) {
            if (c) {
                const u = c[t] - l[t];
                r[o] = u !== 0 ? (c[n] - l[n]) / u : 0
            }
            s[o] = a ? c ? ma(r[o - 1]) !== ma(r[o]) ? 0 : (r[o - 1] + r[o]) / 2 : r[o - 1] : r[o]
        }
    oH(e, r, s),
    aH(e, s, t)
}
function ku(e, t, n) {
    return Math.max(Math.min(e, n), t)
}
function cH(e, t) {
    let n, i, r, s, o, a = rr(e[0], t);
    for (n = 0,
    i = e.length; n < i; ++n)
        o = s,
        s = a,
        a = n < i - 1 && rr(e[n + 1], t),
        s && (r = e[n],
        o && (r.cp1x = ku(r.cp1x, t.left, t.right),
        r.cp1y = ku(r.cp1y, t.top, t.bottom)),
        a && (r.cp2x = ku(r.cp2x, t.left, t.right),
        r.cp2y = ku(r.cp2y, t.top, t.bottom)))
}
function uH(e, t, n, i, r) {
    let s, o, a, l;
    if (t.spanGaps && (e = e.filter(c=>!c.skip)),
    t.cubicInterpolationMode === "monotone")
        lH(e, r);
    else {
        let c = i ? e[e.length - 1] : e[0];
        for (s = 0,
        o = e.length; s < o; ++s)
            a = e[s],
            l = sH(c, a, e[Math.min(s + 1, o - (i ? 0 : 1)) % o], t.tension),
            a.cp1x = l.previous.x,
            a.cp1y = l.previous.y,
            a.cp2x = l.next.x,
            a.cp2y = l.next.y,
            c = a
    }
    t.capBezierPoints && cH(e, n)
}
function Uk() {
    return typeof window < "u" && typeof document < "u"
}
function cv(e) {
    let t = e.parentNode;
    return t && t.toString() === "[object ShadowRoot]" && (t = t.host),
    t
}
function sd(e, t, n) {
    let i;
    return typeof e == "string" ? (i = parseInt(e, 10),
    e.indexOf("%") !== -1 && (i = i / 100 * t.parentNode[n])) : i = e,
    i
}
const cf = e=>e.ownerDocument.defaultView.getComputedStyle(e, null);
function hH(e, t) {
    return cf(e).getPropertyValue(t)
}
const dH = ["top", "right", "bottom", "left"];
function Gs(e, t, n) {
    const i = {};
    n = n ? "-" + n : "";
    for (let r = 0; r < 4; r++) {
        const s = dH[r];
        i[s] = parseFloat(e[t + "-" + s + n]) || 0
    }
    return i.width = i.left + i.right,
    i.height = i.top + i.bottom,
    i
}
const fH = (e,t,n)=>(e > 0 || t > 0) && (!n || !n.shadowRoot);
function pH(e, t) {
    const n = e.touches
      , i = n && n.length ? n[0] : e
      , {offsetX: r, offsetY: s} = i;
    let o = !1, a, l;
    if (fH(r, s, e.target))
        a = r,
        l = s;
    else {
        const c = t.getBoundingClientRect();
        a = i.clientX - c.left,
        l = i.clientY - c.top,
        o = !0
    }
    return {
        x: a,
        y: l,
        box: o
    }
}
function Es(e, t) {
    if ("native"in e)
        return e;
    const {canvas: n, currentDevicePixelRatio: i} = t
      , r = cf(n)
      , s = r.boxSizing === "border-box"
      , o = Gs(r, "padding")
      , a = Gs(r, "border", "width")
      , {x: l, y: c, box: u} = pH(e, n)
      , h = o.left + (u && a.left)
      , d = o.top + (u && a.top);
    let {width: m, height: f} = t;
    return s && (m -= o.width + a.width,
    f -= o.height + a.height),
    {
        x: Math.round((l - h) / m * n.width / i),
        y: Math.round((c - d) / f * n.height / i)
    }
}
function gH(e, t, n) {
    let i, r;
    if (t === void 0 || n === void 0) {
        const s = cv(e);
        if (!s)
            t = e.clientWidth,
            n = e.clientHeight;
        else {
            const o = s.getBoundingClientRect()
              , a = cf(s)
              , l = Gs(a, "border", "width")
              , c = Gs(a, "padding");
            t = o.width - c.width - l.width,
            n = o.height - c.height - l.height,
            i = sd(a.maxWidth, s, "clientWidth"),
            r = sd(a.maxHeight, s, "clientHeight")
        }
    }
    return {
        width: t,
        height: n,
        maxWidth: i || nd,
        maxHeight: r || nd
    }
}
const Au = e=>Math.round(e * 10) / 10;
function mH(e, t, n, i) {
    const r = cf(e)
      , s = Gs(r, "margin")
      , o = sd(r.maxWidth, e, "clientWidth") || nd
      , a = sd(r.maxHeight, e, "clientHeight") || nd
      , l = gH(e, t, n);
    let {width: c, height: u} = l;
    if (r.boxSizing === "content-box") {
        const d = Gs(r, "border", "width")
          , m = Gs(r, "padding");
        c -= m.width + d.width,
        u -= m.height + d.height
    }
    return c = Math.max(0, c - s.width),
    u = Math.max(0, i ? c / i : u - s.height),
    c = Au(Math.min(c, o, l.maxWidth)),
    u = Au(Math.min(u, a, l.maxHeight)),
    c && !u && (u = Au(c / 2)),
    (t !== void 0 || n !== void 0) && i && l.height && u > l.height && (u = l.height,
    c = Au(Math.floor(u * i))),
    {
        width: c,
        height: u
    }
}
function P6(e, t, n) {
    const i = t || 1
      , r = Math.floor(e.height * i)
      , s = Math.floor(e.width * i);
    e.height = Math.floor(e.height),
    e.width = Math.floor(e.width);
    const o = e.canvas;
    return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = `${e.height}px`,
    o.style.width = `${e.width}px`),
    e.currentDevicePixelRatio !== i || o.height !== r || o.width !== s ? (e.currentDevicePixelRatio = i,
    o.height = r,
    o.width = s,
    e.ctx.setTransform(i, 0, 0, i, 0, 0),
    !0) : !1
}
const vH = function() {
    let e = !1;
    try {
        const t = {
            get passive() {
                return e = !0,
                !1
            }
        };
        window.addEventListener("test", null, t),
        window.removeEventListener("test", null, t)
    } catch {}
    return e
}();
function T6(e, t) {
    const n = hH(e, t)
      , i = n && n.match(/^(\d+)(\.\d+)?px$/);
    return i ? +i[1] : void 0
}
function Ps(e, t, n, i) {
    return {
        x: e.x + n * (t.x - e.x),
        y: e.y + n * (t.y - e.y)
    }
}
function yH(e, t, n, i) {
    return {
        x: e.x + n * (t.x - e.x),
        y: i === "middle" ? n < .5 ? e.y : t.y : i === "after" ? n < 1 ? e.y : t.y : n > 0 ? t.y : e.y
    }
}
function xH(e, t, n, i) {
    const r = {
        x: e.cp2x,
        y: e.cp2y
    }
      , s = {
        x: t.cp1x,
        y: t.cp1y
    }
      , o = Ps(e, r, n)
      , a = Ps(r, s, n)
      , l = Ps(s, t, n)
      , c = Ps(o, a, n)
      , u = Ps(a, l, n);
    return Ps(c, u, n)
}
const bH = function(e, t) {
    return {
        x(n) {
            return e + e + t - n
        },
        setWidth(n) {
            t = n
        },
        textAlign(n) {
            return n === "center" ? n : n === "right" ? "left" : "right"
        },
        xPlus(n, i) {
            return n - i
        },
        leftForLtr(n, i) {
            return n - i
        }
    }
}
  , wH = function() {
    return {
        x(e) {
            return e
        },
        setWidth(e) {},
        textAlign(e) {
            return e
        },
        xPlus(e, t) {
            return e + t
        },
        leftForLtr(e, t) {
            return e
        }
    }
};
function ta(e, t, n) {
    return e ? bH(t, n) : wH()
}
function Gk(e, t) {
    let n, i;
    (t === "ltr" || t === "rtl") && (n = e.canvas.style,
    i = [n.getPropertyValue("direction"), n.getPropertyPriority("direction")],
    n.setProperty("direction", t, "important"),
    e.prevTextDirection = i)
}
function Xk(e, t) {
    t !== void 0 && (delete e.prevTextDirection,
    e.canvas.style.setProperty("direction", t[0], t[1]))
}
function Yk(e) {
    return e === "angle" ? {
        between: nc,
        compare: yW,
        normalize: Nn
    } : {
        between: Is,
        compare: (t,n)=>t - n,
        normalize: t=>t
    }
}
function j6({start: e, end: t, count: n, loop: i, style: r}) {
    return {
        start: e % n,
        end: t % n,
        loop: i && (t - e + 1) % n === 0,
        style: r
    }
}
function SH(e, t, n) {
    const {property: i, start: r, end: s} = n
      , {between: o, normalize: a} = Yk(i)
      , l = t.length;
    let {start: c, end: u, loop: h} = e, d, m;
    if (h) {
        for (c += l,
        u += l,
        d = 0,
        m = l; d < m && o(a(t[c % l][i]), r, s); ++d)
            c--,
            u--;
        c %= l,
        u %= l
    }
    return u < c && (u += l),
    {
        start: c,
        end: u,
        loop: h,
        style: e.style
    }
}
function $k(e, t, n) {
    if (!n)
        return [e];
    const {property: i, start: r, end: s} = n
      , o = t.length
      , {compare: a, between: l, normalize: c} = Yk(i)
      , {start: u, end: h, loop: d, style: m} = SH(e, t, n)
      , f = [];
    let x = !1, S = null, v, p, g;
    const C = ()=>l(r, g, v) && a(r, g) !== 0
      , E = ()=>a(s, v) === 0 || l(s, g, v)
      , O = ()=>x || C()
      , R = ()=>!x || E();
    for (let F = u, P = u; F <= h; ++F)
        p = t[F % o],
        !p.skip && (v = c(p[i]),
        v !== g && (x = l(v, r, s),
        S === null && O() && (S = a(v, r) === 0 ? F : P),
        S !== null && R() && (f.push(j6({
            start: S,
            end: F,
            loop: d,
            count: o,
            style: m
        })),
        S = null),
        P = F,
        g = v));
    return S !== null && f.push(j6({
        start: S,
        end: h,
        loop: d,
        count: o,
        style: m
    })),
    f
}
function Kk(e, t) {
    const n = []
      , i = e.segments;
    for (let r = 0; r < i.length; r++) {
        const s = $k(i[r], e.points, t);
        s.length && n.push(...s)
    }
    return n
}
function CH(e, t, n, i) {
    let r = 0
      , s = t - 1;
    if (n && !i)
        for (; r < t && !e[r].skip; )
            r++;
    for (; r < t && e[r].skip; )
        r++;
    for (r %= t,
    n && (s += r); s > r && e[s % t].skip; )
        s--;
    return s %= t,
    {
        start: r,
        end: s
    }
}
function kH(e, t, n, i) {
    const r = e.length
      , s = [];
    let o = t, a = e[t], l;
    for (l = t + 1; l <= n; ++l) {
        const c = e[l % r];
        c.skip || c.stop ? a.skip || (i = !1,
        s.push({
            start: t % r,
            end: (l - 1) % r,
            loop: i
        }),
        t = o = c.stop ? l : null) : (o = l,
        a.skip && (t = l)),
        a = c
    }
    return o !== null && s.push({
        start: t % r,
        end: o % r,
        loop: i
    }),
    s
}
function AH(e, t) {
    const n = e.points
      , i = e.options.spanGaps
      , r = n.length;
    if (!r)
        return [];
    const s = !!e._loop
      , {start: o, end: a} = CH(n, r, s, i);
    if (i === !0)
        return O6(e, [{
            start: o,
            end: a,
            loop: s
        }], n, t);
    const l = a < o ? a + r : a
      , c = !!e._fullLoop && o === 0 && a === r - 1;
    return O6(e, kH(n, o, l, c), n, t)
}
function O6(e, t, n, i) {
    return !i || !i.setContext || !n ? t : MH(e, t, n, i)
}
function MH(e, t, n, i) {
    const r = e._chart.getContext()
      , s = L6(e.options)
      , {_datasetIndex: o, options: {spanGaps: a}} = e
      , l = n.length
      , c = [];
    let u = s
      , h = t[0].start
      , d = h;
    function m(f, x, S, v) {
        const p = a ? -1 : 1;
        if (f !== x) {
            for (f += l; n[f % l].skip; )
                f -= p;
            for (; n[x % l].skip; )
                x += p;
            f % l !== x % l && (c.push({
                start: f % l,
                end: x % l,
                loop: S,
                style: v
            }),
            u = v,
            h = x % l)
        }
    }
    for (const f of t) {
        h = a ? h : f.start;
        let x = n[h % l], S;
        for (d = h + 1; d <= f.end; d++) {
            const v = n[d % l];
            S = L6(i.setContext(os(r, {
                type: "segment",
                p0: x,
                p1: v,
                p0DataIndex: (d - 1) % l,
                p1DataIndex: d % l,
                datasetIndex: o
            }))),
            EH(S, u) && m(h, d - 1, f.loop, u),
            x = v,
            u = S
        }
        h < d - 1 && m(h, d - 1, f.loop, u)
    }
    return c
}
function L6(e) {
    return {
        backgroundColor: e.backgroundColor,
        borderCapStyle: e.borderCapStyle,
        borderDash: e.borderDash,
        borderDashOffset: e.borderDashOffset,
        borderJoinStyle: e.borderJoinStyle,
        borderWidth: e.borderWidth,
        borderColor: e.borderColor
    }
}
function EH(e, t) {
    if (!t)
        return !1;
    const n = []
      , i = function(r, s) {
        return rv(s) ? (n.includes(s) || n.push(s),
        n.indexOf(s)) : s
    };
    return JSON.stringify(e, i) !== JSON.stringify(t, i)
}
/*!
 * Chart.js v4.4.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
class PH {
    constructor() {
        this._request = null,
        this._charts = new Map,
        this._running = !1,
        this._lastDate = void 0
    }
    _notify(t, n, i, r) {
        const s = n.listeners[r]
          , o = n.duration;
        s.forEach(a=>a({
            chart: t,
            initial: n.initial,
            numSteps: o,
            currentStep: Math.min(i - n.start, o)
        }))
    }
    _refresh() {
        this._request || (this._running = !0,
        this._request = Dk.call(window, ()=>{
            this._update(),
            this._request = null,
            this._running && this._refresh()
        }
        ))
    }
    _update(t=Date.now()) {
        let n = 0;
        this._charts.forEach((i,r)=>{
            if (!i.running || !i.items.length)
                return;
            const s = i.items;
            let o = s.length - 1, a = !1, l;
            for (; o >= 0; --o)
                l = s[o],
                l._active ? (l._total > i.duration && (i.duration = l._total),
                l.tick(t),
                a = !0) : (s[o] = s[s.length - 1],
                s.pop());
            a && (r.draw(),
            this._notify(r, i, t, "progress")),
            s.length || (i.running = !1,
            this._notify(r, i, t, "complete"),
            i.initial = !1),
            n += s.length
        }
        ),
        this._lastDate = t,
        n === 0 && (this._running = !1)
    }
    _getAnims(t) {
        const n = this._charts;
        let i = n.get(t);
        return i || (i = {
            running: !1,
            initial: !0,
            items: [],
            listeners: {
                complete: [],
                progress: []
            }
        },
        n.set(t, i)),
        i
    }
    listen(t, n, i) {
        this._getAnims(t).listeners[n].push(i)
    }
    add(t, n) {
        !n || !n.length || this._getAnims(t).items.push(...n)
    }
    has(t) {
        return this._getAnims(t).items.length > 0
    }
    start(t) {
        const n = this._charts.get(t);
        n && (n.running = !0,
        n.start = Date.now(),
        n.duration = n.items.reduce((i,r)=>Math.max(i, r._duration), 0),
        this._refresh())
    }
    running(t) {
        if (!this._running)
            return !1;
        const n = this._charts.get(t);
        return !(!n || !n.running || !n.items.length)
    }
    stop(t) {
        const n = this._charts.get(t);
        if (!n || !n.items.length)
            return;
        const i = n.items;
        let r = i.length - 1;
        for (; r >= 0; --r)
            i[r].cancel();
        n.items = [],
        this._notify(t, n, Date.now(), "complete")
    }
    remove(t) {
        return this._charts.delete(t)
    }
}
var Ki = new PH;
const R6 = "transparent"
  , TH = {
    boolean(e, t, n) {
        return n > .5 ? t : e
    },
    color(e, t, n) {
        const i = C6(e || R6)
          , r = i.valid && C6(t || R6);
        return r && r.valid ? r.mix(i, n).hexString() : t
    },
    number(e, t, n) {
        return e + (t - e) * n
    }
};
class jH {
    constructor(t, n, i, r) {
        const s = n[i];
        r = Cu([t.to, r, s, t.from]);
        const o = Cu([t.from, s, r]);
        this._active = !0,
        this._fn = t.fn || TH[t.type || typeof o],
        this._easing = wl[t.easing] || wl.linear,
        this._start = Math.floor(Date.now() + (t.delay || 0)),
        this._duration = this._total = Math.floor(t.duration),
        this._loop = !!t.loop,
        this._target = n,
        this._prop = i,
        this._from = o,
        this._to = r,
        this._promises = void 0
    }
    active() {
        return this._active
    }
    update(t, n, i) {
        if (this._active) {
            this._notify(!1);
            const r = this._target[this._prop]
              , s = i - this._start
              , o = this._duration - s;
            this._start = i,
            this._duration = Math.floor(Math.max(o, t.duration)),
            this._total += s,
            this._loop = !!t.loop,
            this._to = Cu([t.to, n, r, t.from]),
            this._from = Cu([t.from, r, n])
        }
    }
    cancel() {
        this._active && (this.tick(Date.now()),
        this._active = !1,
        this._notify(!1))
    }
    tick(t) {
        const n = t - this._start
          , i = this._duration
          , r = this._prop
          , s = this._from
          , o = this._loop
          , a = this._to;
        let l;
        if (this._active = s !== a && (o || n < i),
        !this._active) {
            this._target[r] = a,
            this._notify(!0);
            return
        }
        if (n < 0) {
            this._target[r] = s;
            return
        }
        l = n / i % 2,
        l = o && l > 1 ? 2 - l : l,
        l = this._easing(Math.min(1, Math.max(0, l))),
        this._target[r] = this._fn(s, a, l)
    }
    wait() {
        const t = this._promises || (this._promises = []);
        return new Promise((n,i)=>{
            t.push({
                res: n,
                rej: i
            })
        }
        )
    }
    _notify(t) {
        const n = t ? "res" : "rej"
          , i = this._promises || [];
        for (let r = 0; r < i.length; r++)
            i[r][n]()
    }
}
class Qk {
    constructor(t, n) {
        this._chart = t,
        this._properties = new Map,
        this.configure(n)
    }
    configure(t) {
        if (!Xe(t))
            return;
        const n = Object.keys(Tt.animation)
          , i = this._properties;
        Object.getOwnPropertyNames(t).forEach(r=>{
            const s = t[r];
            if (!Xe(s))
                return;
            const o = {};
            for (const a of n)
                o[a] = s[a];
            (yt(s.properties) && s.properties || [r]).forEach(a=>{
                (a === r || !i.has(a)) && i.set(a, o)
            }
            )
        }
        )
    }
    _animateOptions(t, n) {
        const i = n.options
          , r = LH(t, i);
        if (!r)
            return [];
        const s = this._createAnimations(r, i);
        return i.$shared && OH(t.options.$animations, i).then(()=>{
            t.options = i
        }
        , ()=>{}
        ),
        s
    }
    _createAnimations(t, n) {
        const i = this._properties
          , r = []
          , s = t.$animations || (t.$animations = {})
          , o = Object.keys(n)
          , a = Date.now();
        let l;
        for (l = o.length - 1; l >= 0; --l) {
            const c = o[l];
            if (c.charAt(0) === "$")
                continue;
            if (c === "options") {
                r.push(...this._animateOptions(t, n));
                continue
            }
            const u = n[c];
            let h = s[c];
            const d = i.get(c);
            if (h)
                if (d && h.active()) {
                    h.update(d, u, a);
                    continue
                } else
                    h.cancel();
            if (!d || !d.duration) {
                t[c] = u;
                continue
            }
            s[c] = h = new jH(d,t,c,u),
            r.push(h)
        }
        return r
    }
    update(t, n) {
        if (this._properties.size === 0) {
            Object.assign(t, n);
            return
        }
        const i = this._createAnimations(t, n);
        if (i.length)
            return Ki.add(this._chart, i),
            !0
    }
}
function OH(e, t) {
    const n = []
      , i = Object.keys(t);
    for (let r = 0; r < i.length; r++) {
        const s = e[i[r]];
        s && s.active() && n.push(s.wait())
    }
    return Promise.all(n)
}
function LH(e, t) {
    if (!t)
        return;
    let n = e.options;
    if (!n) {
        e.options = t;
        return
    }
    return n.$shared && (e.options = n = Object.assign({}, n, {
        $shared: !1,
        $animations: {}
    })),
    n
}
function _6(e, t) {
    const n = e && e.options || {}
      , i = n.reverse
      , r = n.min === void 0 ? t : 0
      , s = n.max === void 0 ? t : 0;
    return {
        start: i ? s : r,
        end: i ? r : s
    }
}
function RH(e, t, n) {
    if (n === !1)
        return !1;
    const i = _6(e, n)
      , r = _6(t, n);
    return {
        top: r.end,
        right: i.end,
        bottom: r.start,
        left: i.start
    }
}
function _H(e) {
    let t, n, i, r;
    return Xe(e) ? (t = e.top,
    n = e.right,
    i = e.bottom,
    r = e.left) : t = n = i = r = e,
    {
        top: t,
        right: n,
        bottom: i,
        left: r,
        disabled: e === !1
    }
}
function qk(e, t) {
    const n = []
      , i = e._getSortedDatasetMetas(t);
    let r, s;
    for (r = 0,
    s = i.length; r < s; ++r)
        n.push(i[r].index);
    return n
}
function D6(e, t, n, i={}) {
    const r = e.keys
      , s = i.mode === "single";
    let o, a, l, c;
    if (t !== null) {
        for (o = 0,
        a = r.length; o < a; ++o) {
            if (l = +r[o],
            l === n) {
                if (i.all)
                    continue;
                break
            }
            c = e.values[l],
            Pt(c) && (s || t === 0 || ma(t) === ma(c)) && (t += c)
        }
        return t
    }
}
function DH(e) {
    const t = Object.keys(e)
      , n = new Array(t.length);
    let i, r, s;
    for (i = 0,
    r = t.length; i < r; ++i)
        s = t[i],
        n[i] = {
            x: s,
            y: e[s]
        };
    return n
}
function N6(e, t) {
    const n = e && e.options.stacked;
    return n || n === void 0 && t.stack !== void 0
}
function NH(e, t, n) {
    return `${e.id}.${t.id}.${n.stack || n.type}`
}
function FH(e) {
    const {min: t, max: n, minDefined: i, maxDefined: r} = e.getUserBounds();
    return {
        min: i ? t : Number.NEGATIVE_INFINITY,
        max: r ? n : Number.POSITIVE_INFINITY
    }
}
function IH(e, t, n) {
    const i = e[t] || (e[t] = {});
    return i[n] || (i[n] = {})
}
function F6(e, t, n, i) {
    for (const r of t.getMatchingVisibleMetas(i).reverse()) {
        const s = e[r.index];
        if (n && s > 0 || !n && s < 0)
            return r.index
    }
    return null
}
function I6(e, t) {
    const {chart: n, _cachedMeta: i} = e
      , r = n._stacks || (n._stacks = {})
      , {iScale: s, vScale: o, index: a} = i
      , l = s.axis
      , c = o.axis
      , u = NH(s, o, i)
      , h = t.length;
    let d;
    for (let m = 0; m < h; ++m) {
        const f = t[m]
          , {[l]: x, [c]: S} = f
          , v = f._stacks || (f._stacks = {});
        d = v[c] = IH(r, u, x),
        d[a] = S,
        d._top = F6(d, o, !0, i.type),
        d._bottom = F6(d, o, !1, i.type);
        const p = d._visualValues || (d._visualValues = {});
        p[a] = S
    }
}
function R0(e, t) {
    const n = e.scales;
    return Object.keys(n).filter(i=>n[i].axis === t).shift()
}
function BH(e, t) {
    return os(e, {
        active: !1,
        dataset: void 0,
        datasetIndex: t,
        index: t,
        mode: "default",
        type: "dataset"
    })
}
function zH(e, t, n) {
    return os(e, {
        active: !1,
        dataIndex: t,
        parsed: void 0,
        raw: void 0,
        element: n,
        index: t,
        mode: "default",
        type: "data"
    })
}
function Va(e, t) {
    const n = e.controller.index
      , i = e.vScale && e.vScale.axis;
    if (i) {
        t = t || e._parsed;
        for (const r of t) {
            const s = r._stacks;
            if (!s || s[i] === void 0 || s[i][n] === void 0)
                return;
            delete s[i][n],
            s[i]._visualValues !== void 0 && s[i]._visualValues[n] !== void 0 && delete s[i]._visualValues[n]
        }
    }
}
const _0 = e=>e === "reset" || e === "none"
  , B6 = (e,t)=>t ? e : Object.assign({}, e)
  , VH = (e,t,n)=>e && !t.hidden && t._stacked && {
    keys: qk(n, !0),
    values: null
};
class na {
    constructor(t, n) {
        this.chart = t,
        this._ctx = t.ctx,
        this.index = n,
        this._cachedDataOpts = {},
        this._cachedMeta = this.getMeta(),
        this._type = this._cachedMeta.type,
        this.options = void 0,
        this._parsing = !1,
        this._data = void 0,
        this._objectData = void 0,
        this._sharedOptions = void 0,
        this._drawStart = void 0,
        this._drawCount = void 0,
        this.enableOptionSharing = !1,
        this.supportsDecimation = !1,
        this.$context = void 0,
        this._syncList = [],
        this.datasetElementType = new.target.datasetElementType,
        this.dataElementType = new.target.dataElementType,
        this.initialize()
    }
    initialize() {
        const t = this._cachedMeta;
        this.configure(),
        this.linkScales(),
        t._stacked = N6(t.vScale, t),
        this.addElements(),
        this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")
    }
    updateIndex(t) {
        this.index !== t && Va(this._cachedMeta),
        this.index = t
    }
    linkScales() {
        const t = this.chart
          , n = this._cachedMeta
          , i = this.getDataset()
          , r = (h,d,m,f)=>h === "x" ? d : h === "r" ? f : m
          , s = n.xAxisID = He(i.xAxisID, R0(t, "x"))
          , o = n.yAxisID = He(i.yAxisID, R0(t, "y"))
          , a = n.rAxisID = He(i.rAxisID, R0(t, "r"))
          , l = n.indexAxis
          , c = n.iAxisID = r(l, s, o, a)
          , u = n.vAxisID = r(l, o, s, a);
        n.xScale = this.getScaleForId(s),
        n.yScale = this.getScaleForId(o),
        n.rScale = this.getScaleForId(a),
        n.iScale = this.getScaleForId(c),
        n.vScale = this.getScaleForId(u)
    }
    getDataset() {
        return this.chart.data.datasets[this.index]
    }
    getMeta() {
        return this.chart.getDatasetMeta(this.index)
    }
    getScaleForId(t) {
        return this.chart.scales[t]
    }
    _getOtherScale(t) {
        const n = this._cachedMeta;
        return t === n.iScale ? n.vScale : n.iScale
    }
    reset() {
        this._update("reset")
    }
    _destroy() {
        const t = this._cachedMeta;
        this._data && b6(this._data, this),
        t._stacked && Va(t)
    }
    _dataCheck() {
        const t = this.getDataset()
          , n = t.data || (t.data = [])
          , i = this._data;
        if (Xe(n))
            this._data = DH(n);
        else if (i !== n) {
            if (i) {
                b6(i, this);
                const r = this._cachedMeta;
                Va(r),
                r._parsed = []
            }
            n && Object.isExtensible(n) && SW(n, this),
            this._syncList = [],
            this._data = n
        }
    }
    addElements() {
        const t = this._cachedMeta;
        this._dataCheck(),
        this.datasetElementType && (t.dataset = new this.datasetElementType)
    }
    buildOrUpdateElements(t) {
        const n = this._cachedMeta
          , i = this.getDataset();
        let r = !1;
        this._dataCheck();
        const s = n._stacked;
        n._stacked = N6(n.vScale, n),
        n.stack !== i.stack && (r = !0,
        Va(n),
        n.stack = i.stack),
        this._resyncElements(t),
        (r || s !== n._stacked) && I6(this, n._parsed)
    }
    configure() {
        const t = this.chart.config
          , n = t.datasetScopeKeys(this._type)
          , i = t.getOptionScopes(this.getDataset(), n, !0);
        this.options = t.createResolver(i, this.getContext()),
        this._parsing = this.options.parsing,
        this._cachedDataOpts = {}
    }
    parse(t, n) {
        const {_cachedMeta: i, _data: r} = this
          , {iScale: s, _stacked: o} = i
          , a = s.axis;
        let l = t === 0 && n === r.length ? !0 : i._sorted, c = t > 0 && i._parsed[t - 1], u, h, d;
        if (this._parsing === !1)
            i._parsed = r,
            i._sorted = !0,
            d = r;
        else {
            yt(r[t]) ? d = this.parseArrayData(i, r, t, n) : Xe(r[t]) ? d = this.parseObjectData(i, r, t, n) : d = this.parsePrimitiveData(i, r, t, n);
            const m = ()=>h[a] === null || c && h[a] < c[a];
            for (u = 0; u < n; ++u)
                i._parsed[u + t] = h = d[u],
                l && (m() && (l = !1),
                c = h);
            i._sorted = l
        }
        o && I6(this, d)
    }
    parsePrimitiveData(t, n, i, r) {
        const {iScale: s, vScale: o} = t
          , a = s.axis
          , l = o.axis
          , c = s.getLabels()
          , u = s === o
          , h = new Array(r);
        let d, m, f;
        for (d = 0,
        m = r; d < m; ++d)
            f = d + i,
            h[d] = {
                [a]: u || s.parse(c[f], f),
                [l]: o.parse(n[f], f)
            };
        return h
    }
    parseArrayData(t, n, i, r) {
        const {xScale: s, yScale: o} = t
          , a = new Array(r);
        let l, c, u, h;
        for (l = 0,
        c = r; l < c; ++l)
            u = l + i,
            h = n[u],
            a[l] = {
                x: s.parse(h[0], u),
                y: o.parse(h[1], u)
            };
        return a
    }
    parseObjectData(t, n, i, r) {
        const {xScale: s, yScale: o} = t
          , {xAxisKey: a="x", yAxisKey: l="y"} = this._parsing
          , c = new Array(r);
        let u, h, d, m;
        for (u = 0,
        h = r; u < h; ++u)
            d = u + i,
            m = n[d],
            c[u] = {
                x: s.parse(ec(m, a), d),
                y: o.parse(ec(m, l), d)
            };
        return c
    }
    getParsed(t) {
        return this._cachedMeta._parsed[t]
    }
    getDataElement(t) {
        return this._cachedMeta.data[t]
    }
    applyStack(t, n, i) {
        const r = this.chart
          , s = this._cachedMeta
          , o = n[t.axis]
          , a = {
            keys: qk(r, !0),
            values: n._stacks[t.axis]._visualValues
        };
        return D6(a, o, s.index, {
            mode: i
        })
    }
    updateRangeFromParsed(t, n, i, r) {
        const s = i[n.axis];
        let o = s === null ? NaN : s;
        const a = r && i._stacks[n.axis];
        r && a && (r.values = a,
        o = D6(r, s, this._cachedMeta.index)),
        t.min = Math.min(t.min, o),
        t.max = Math.max(t.max, o)
    }
    getMinMax(t, n) {
        const i = this._cachedMeta
          , r = i._parsed
          , s = i._sorted && t === i.iScale
          , o = r.length
          , a = this._getOtherScale(t)
          , l = VH(n, i, this.chart)
          , c = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        }
          , {min: u, max: h} = FH(a);
        let d, m;
        function f() {
            m = r[d];
            const x = m[a.axis];
            return !Pt(m[t.axis]) || u > x || h < x
        }
        for (d = 0; d < o && !(!f() && (this.updateRangeFromParsed(c, t, m, l),
        s)); ++d)
            ;
        if (s) {
            for (d = o - 1; d >= 0; --d)
                if (!f()) {
                    this.updateRangeFromParsed(c, t, m, l);
                    break
                }
        }
        return c
    }
    getAllParsedValues(t) {
        const n = this._cachedMeta._parsed
          , i = [];
        let r, s, o;
        for (r = 0,
        s = n.length; r < s; ++r)
            o = n[r][t.axis],
            Pt(o) && i.push(o);
        return i
    }
    getMaxOverflow() {
        return !1
    }
    getLabelAndValue(t) {
        const n = this._cachedMeta
          , i = n.iScale
          , r = n.vScale
          , s = this.getParsed(t);
        return {
            label: i ? "" + i.getLabelForValue(s[i.axis]) : "",
            value: r ? "" + r.getLabelForValue(s[r.axis]) : ""
        }
    }
    _update(t) {
        const n = this._cachedMeta;
        this.update(t || "default"),
        n._clip = _H(He(this.options.clip, RH(n.xScale, n.yScale, this.getMaxOverflow())))
    }
    update(t) {}
    draw() {
        const t = this._ctx
          , n = this.chart
          , i = this._cachedMeta
          , r = i.data || []
          , s = n.chartArea
          , o = []
          , a = this._drawStart || 0
          , l = this._drawCount || r.length - a
          , c = this.options.drawActiveElementsOnTop;
        let u;
        for (i.dataset && i.dataset.draw(t, s, a, l),
        u = a; u < a + l; ++u) {
            const h = r[u];
            h.hidden || (h.active && c ? o.push(h) : h.draw(t, s))
        }
        for (u = 0; u < o.length; ++u)
            o[u].draw(t, s)
    }
    getStyle(t, n) {
        const i = n ? "active" : "default";
        return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i)
    }
    getContext(t, n, i) {
        const r = this.getDataset();
        let s;
        if (t >= 0 && t < this._cachedMeta.data.length) {
            const o = this._cachedMeta.data[t];
            s = o.$context || (o.$context = zH(this.getContext(), t, o)),
            s.parsed = this.getParsed(t),
            s.raw = r.data[t],
            s.index = s.dataIndex = t
        } else
            s = this.$context || (this.$context = BH(this.chart.getContext(), this.index)),
            s.dataset = r,
            s.index = s.datasetIndex = this.index;
        return s.active = !!n,
        s.mode = i,
        s
    }
    resolveDatasetElementOptions(t) {
        return this._resolveElementOptions(this.datasetElementType.id, t)
    }
    resolveDataElementOptions(t, n) {
        return this._resolveElementOptions(this.dataElementType.id, n, t)
    }
    _resolveElementOptions(t, n="default", i) {
        const r = n === "active"
          , s = this._cachedDataOpts
          , o = t + "-" + n
          , a = s[o]
          , l = this.enableOptionSharing && td(i);
        if (a)
            return B6(a, l);
        const c = this.chart.config
          , u = c.datasetElementScopeKeys(this._type, t)
          , h = r ? [`${t}Hover`, "hover", t, ""] : [t, ""]
          , d = c.getOptionScopes(this.getDataset(), u)
          , m = Object.keys(Tt.elements[t])
          , f = ()=>this.getContext(i, r, n)
          , x = c.resolveNamedOptions(d, m, f, h);
        return x.$shared && (x.$shared = l,
        s[o] = Object.freeze(B6(x, l))),
        x
    }
    _resolveAnimations(t, n, i) {
        const r = this.chart
          , s = this._cachedDataOpts
          , o = `animation-${n}`
          , a = s[o];
        if (a)
            return a;
        let l;
        if (r.options.animation !== !1) {
            const u = this.chart.config
              , h = u.datasetAnimationScopeKeys(this._type, n)
              , d = u.getOptionScopes(this.getDataset(), h);
            l = u.createResolver(d, this.getContext(t, i, n))
        }
        const c = new Qk(r,l && l.animations);
        return l && l._cacheable && (s[o] = Object.freeze(c)),
        c
    }
    getSharedOptions(t) {
        if (t.$shared)
            return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
    }
    includeOptions(t, n) {
        return !n || _0(t) || this.chart._animationsDisabled
    }
    _getSharedOptions(t, n) {
        const i = this.resolveDataElementOptions(t, n)
          , r = this._sharedOptions
          , s = this.getSharedOptions(i)
          , o = this.includeOptions(n, s) || s !== r;
        return this.updateSharedOptions(s, n, i),
        {
            sharedOptions: s,
            includeOptions: o
        }
    }
    updateElement(t, n, i, r) {
        _0(r) ? Object.assign(t, i) : this._resolveAnimations(n, r).update(t, i)
    }
    updateSharedOptions(t, n, i) {
        t && !_0(n) && this._resolveAnimations(void 0, n).update(t, i)
    }
    _setStyle(t, n, i, r) {
        t.active = r;
        const s = this.getStyle(n, r);
        this._resolveAnimations(n, i, r).update(t, {
            options: !r && this.getSharedOptions(s) || s
        })
    }
    removeHoverStyle(t, n, i) {
        this._setStyle(t, i, "active", !1)
    }
    setHoverStyle(t, n, i) {
        this._setStyle(t, i, "active", !0)
    }
    _removeDatasetHoverStyle() {
        const t = this._cachedMeta.dataset;
        t && this._setStyle(t, void 0, "active", !1)
    }
    _setDatasetHoverStyle() {
        const t = this._cachedMeta.dataset;
        t && this._setStyle(t, void 0, "active", !0)
    }
    _resyncElements(t) {
        const n = this._data
          , i = this._cachedMeta.data;
        for (const [a,l,c] of this._syncList)
            this[a](l, c);
        this._syncList = [];
        const r = i.length
          , s = n.length
          , o = Math.min(s, r);
        o && this.parse(0, o),
        s > r ? this._insertElements(r, s - r, t) : s < r && this._removeElements(s, r - s)
    }
    _insertElements(t, n, i=!0) {
        const r = this._cachedMeta
          , s = r.data
          , o = t + n;
        let a;
        const l = c=>{
            for (c.length += n,
            a = c.length - 1; a >= o; a--)
                c[a] = c[a - n]
        }
        ;
        for (l(s),
        a = t; a < o; ++a)
            s[a] = new this.dataElementType;
        this._parsing && l(r._parsed),
        this.parse(t, n),
        i && this.updateElements(s, t, n, "reset")
    }
    updateElements(t, n, i, r) {}
    _removeElements(t, n) {
        const i = this._cachedMeta;
        if (this._parsing) {
            const r = i._parsed.splice(t, n);
            i._stacked && Va(i, r)
        }
        i.data.splice(t, n)
    }
    _sync(t) {
        if (this._parsing)
            this._syncList.push(t);
        else {
            const [n,i,r] = t;
            this[n](i, r)
        }
        this.chart._dataChanges.push([this.index, ...t])
    }
    _onDataPush() {
        const t = arguments.length;
        this._sync(["_insertElements", this.getDataset().data.length - t, t])
    }
    _onDataPop() {
        this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
    }
    _onDataShift() {
        this._sync(["_removeElements", 0, 1])
    }
    _onDataSplice(t, n) {
        n && this._sync(["_removeElements", t, n]);
        const i = arguments.length - 2;
        i && this._sync(["_insertElements", t, i])
    }
    _onDataUnshift() {
        this._sync(["_insertElements", 0, arguments.length])
    }
}
je(na, "defaults", {}),
je(na, "datasetElementType", null),
je(na, "dataElementType", null);
function WH(e, t, n) {
    let i = 1
      , r = 1
      , s = 0
      , o = 0;
    if (t < mt) {
        const a = e
          , l = a + t
          , c = Math.cos(a)
          , u = Math.sin(a)
          , h = Math.cos(l)
          , d = Math.sin(l)
          , m = (g,C,E)=>nc(g, a, l, !0) ? 1 : Math.max(C, C * n, E, E * n)
          , f = (g,C,E)=>nc(g, a, l, !0) ? -1 : Math.min(C, C * n, E, E * n)
          , x = m(0, c, h)
          , S = m(Rt, u, d)
          , v = f(xt, c, h)
          , p = f(xt + Rt, u, d);
        i = (x - v) / 2,
        r = (S - p) / 2,
        s = -(x + v) / 2,
        o = -(S + p) / 2
    }
    return {
        ratioX: i,
        ratioY: r,
        offsetX: s,
        offsetY: o
    }
}
class Ja extends na {
    constructor(t, n) {
        super(t, n),
        this.enableOptionSharing = !0,
        this.innerRadius = void 0,
        this.outerRadius = void 0,
        this.offsetX = void 0,
        this.offsetY = void 0
    }
    linkScales() {}
    parse(t, n) {
        const i = this.getDataset().data
          , r = this._cachedMeta;
        if (this._parsing === !1)
            r._parsed = i;
        else {
            let s = l=>+i[l];
            if (Xe(i[t])) {
                const {key: l="value"} = this._parsing;
                s = c=>+ec(i[c], l)
            }
            let o, a;
            for (o = t,
            a = t + n; o < a; ++o)
                r._parsed[o] = s(o)
        }
    }
    _getRotation() {
        return Ni(this.options.rotation - 90)
    }
    _getCircumference() {
        return Ni(this.options.circumference)
    }
    _getRotationExtents() {
        let t = mt
          , n = -mt;
        for (let i = 0; i < this.chart.data.datasets.length; ++i)
            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
                const r = this.chart.getDatasetMeta(i).controller
                  , s = r._getRotation()
                  , o = r._getCircumference();
                t = Math.min(t, s),
                n = Math.max(n, s + o)
            }
        return {
            rotation: t,
            circumference: n - t
        }
    }
    update(t) {
        const n = this.chart
          , {chartArea: i} = n
          , r = this._cachedMeta
          , s = r.data
          , o = this.getMaxBorderWidth() + this.getMaxOffset(s) + this.options.spacing
          , a = Math.max((Math.min(i.width, i.height) - o) / 2, 0)
          , l = Math.min(lW(this.options.cutout, a), 1)
          , c = this._getRingWeight(this.index)
          , {circumference: u, rotation: h} = this._getRotationExtents()
          , {ratioX: d, ratioY: m, offsetX: f, offsetY: x} = WH(h, u, l)
          , S = (i.width - o) / d
          , v = (i.height - o) / m
          , p = Math.max(Math.min(S, v) / 2, 0)
          , g = jk(this.options.radius, p)
          , C = Math.max(g * l, 0)
          , E = (g - C) / this._getVisibleDatasetWeightTotal();
        this.offsetX = f * g,
        this.offsetY = x * g,
        r.total = this.calculateTotal(),
        this.outerRadius = g - E * this._getRingWeightOffset(this.index),
        this.innerRadius = Math.max(this.outerRadius - E * c, 0),
        this.updateElements(s, 0, s.length, t)
    }
    _circumference(t, n) {
        const i = this.options
          , r = this._cachedMeta
          , s = this._getCircumference();
        return n && i.animation.animateRotate || !this.chart.getDataVisibility(t) || r._parsed[t] === null || r.data[t].hidden ? 0 : this.calculateCircumference(r._parsed[t] * s / mt)
    }
    updateElements(t, n, i, r) {
        const s = r === "reset"
          , o = this.chart
          , a = o.chartArea
          , c = o.options.animation
          , u = (a.left + a.right) / 2
          , h = (a.top + a.bottom) / 2
          , d = s && c.animateScale
          , m = d ? 0 : this.innerRadius
          , f = d ? 0 : this.outerRadius
          , {sharedOptions: x, includeOptions: S} = this._getSharedOptions(n, r);
        let v = this._getRotation(), p;
        for (p = 0; p < n; ++p)
            v += this._circumference(p, s);
        for (p = n; p < n + i; ++p) {
            const g = this._circumference(p, s)
              , C = t[p]
              , E = {
                x: u + this.offsetX,
                y: h + this.offsetY,
                startAngle: v,
                endAngle: v + g,
                circumference: g,
                outerRadius: f,
                innerRadius: m
            };
            S && (E.options = x || this.resolveDataElementOptions(p, C.active ? "active" : r)),
            v += g,
            this.updateElement(C, p, E, r)
        }
    }
    calculateTotal() {
        const t = this._cachedMeta
          , n = t.data;
        let i = 0, r;
        for (r = 0; r < n.length; r++) {
            const s = t._parsed[r];
            s !== null && !isNaN(s) && this.chart.getDataVisibility(r) && !n[r].hidden && (i += Math.abs(s))
        }
        return i
    }
    calculateCircumference(t) {
        const n = this._cachedMeta.total;
        return n > 0 && !isNaN(t) ? mt * (Math.abs(t) / n) : 0
    }
    getLabelAndValue(t) {
        const n = this._cachedMeta
          , i = this.chart
          , r = i.data.labels || []
          , s = sf(n._parsed[t], i.options.locale);
        return {
            label: r[t] || "",
            value: s
        }
    }
    getMaxBorderWidth(t) {
        let n = 0;
        const i = this.chart;
        let r, s, o, a, l;
        if (!t) {
            for (r = 0,
            s = i.data.datasets.length; r < s; ++r)
                if (i.isDatasetVisible(r)) {
                    o = i.getDatasetMeta(r),
                    t = o.data,
                    a = o.controller;
                    break
                }
        }
        if (!t)
            return 0;
        for (r = 0,
        s = t.length; r < s; ++r)
            l = a.resolveDataElementOptions(r),
            l.borderAlign !== "inner" && (n = Math.max(n, l.borderWidth || 0, l.hoverBorderWidth || 0));
        return n
    }
    getMaxOffset(t) {
        let n = 0;
        for (let i = 0, r = t.length; i < r; ++i) {
            const s = this.resolveDataElementOptions(i);
            n = Math.max(n, s.offset || 0, s.hoverOffset || 0)
        }
        return n
    }
    _getRingWeightOffset(t) {
        let n = 0;
        for (let i = 0; i < t; ++i)
            this.chart.isDatasetVisible(i) && (n += this._getRingWeight(i));
        return n
    }
    _getRingWeight(t) {
        return Math.max(He(this.chart.data.datasets[t].weight, 1), 0)
    }
    _getVisibleDatasetWeightTotal() {
        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
    }
}
je(Ja, "id", "doughnut"),
je(Ja, "defaults", {
    datasetElementType: !1,
    dataElementType: "arc",
    animation: {
        animateRotate: !0,
        animateScale: !1
    },
    animations: {
        numbers: {
            type: "number",
            properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
        }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
}),
je(Ja, "descriptors", {
    _scriptable: t=>t !== "spacing",
    _indexable: t=>t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
}),
je(Ja, "overrides", {
    aspectRatio: 1,
    plugins: {
        legend: {
            labels: {
                generateLabels(t) {
                    const n = t.data;
                    if (n.labels.length && n.datasets.length) {
                        const {labels: {pointStyle: i, color: r}} = t.legend.options;
                        return n.labels.map((s,o)=>{
                            const l = t.getDatasetMeta(0).controller.getStyle(o);
                            return {
                                text: s,
                                fillStyle: l.backgroundColor,
                                strokeStyle: l.borderColor,
                                fontColor: r,
                                lineWidth: l.borderWidth,
                                pointStyle: i,
                                hidden: !t.getDataVisibility(o),
                                index: o
                            }
                        }
                        )
                    }
                    return []
                }
            },
            onClick(t, n, i) {
                i.chart.toggleDataVisibility(n.index),
                i.chart.update()
            }
        }
    }
});
class ih extends na {
    initialize() {
        this.enableOptionSharing = !0,
        this.supportsDecimation = !0,
        super.initialize()
    }
    update(t) {
        const n = this._cachedMeta
          , {dataset: i, data: r=[], _dataset: s} = n
          , o = this.chart._animationsDisabled;
        let {start: a, count: l} = MW(n, r, o);
        this._drawStart = a,
        this._drawCount = l,
        EW(n) && (a = 0,
        l = r.length),
        i._chart = this.chart,
        i._datasetIndex = this.index,
        i._decimated = !!s._decimated,
        i.points = r;
        const c = this.resolveDatasetElementOptions(t);
        this.options.showLine || (c.borderWidth = 0),
        c.segment = this.options.segment,
        this.updateElement(i, void 0, {
            animated: !o,
            options: c
        }, t),
        this.updateElements(r, a, l, t)
    }
    updateElements(t, n, i, r) {
        const s = r === "reset"
          , {iScale: o, vScale: a, _stacked: l, _dataset: c} = this._cachedMeta
          , {sharedOptions: u, includeOptions: h} = this._getSharedOptions(n, r)
          , d = o.axis
          , m = a.axis
          , {spanGaps: f, segment: x} = this.options
          , S = tc(f) ? f : Number.POSITIVE_INFINITY
          , v = this.chart._animationsDisabled || s || r === "none"
          , p = n + i
          , g = t.length;
        let C = n > 0 && this.getParsed(n - 1);
        for (let E = 0; E < g; ++E) {
            const O = t[E]
              , R = v ? O : {};
            if (E < n || E >= p) {
                R.skip = !0;
                continue
            }
            const F = this.getParsed(E)
              , P = ft(F[m])
              , _ = R[d] = o.getPixelForValue(F[d], E)
              , T = R[m] = s || P ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, F, l) : F[m], E);
            R.skip = isNaN(_) || isNaN(T) || P,
            R.stop = E > 0 && Math.abs(F[d] - C[d]) > S,
            x && (R.parsed = F,
            R.raw = c.data[E]),
            h && (R.options = u || this.resolveDataElementOptions(E, O.active ? "active" : r)),
            v || this.updateElement(O, E, R, r),
            C = F
        }
    }
    getMaxOverflow() {
        const t = this._cachedMeta
          , n = t.dataset
          , i = n.options && n.options.borderWidth || 0
          , r = t.data || [];
        if (!r.length)
            return i;
        const s = r[0].size(this.resolveDataElementOptions(0))
          , o = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1));
        return Math.max(i, s, o) / 2
    }
    draw() {
        const t = this._cachedMeta;
        t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis),
        super.draw()
    }
}
je(ih, "id", "line"),
je(ih, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
}),
je(ih, "overrides", {
    scales: {
        _index_: {
            type: "category"
        },
        _value_: {
            type: "linear"
        }
    }
});
function ys() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
}
class uv {
    constructor(t) {
        je(this, "options");
        this.options = t || {}
    }
    static override(t) {
        Object.assign(uv.prototype, t)
    }
    init() {}
    formats() {
        return ys()
    }
    parse() {
        return ys()
    }
    format() {
        return ys()
    }
    add() {
        return ys()
    }
    diff() {
        return ys()
    }
    startOf() {
        return ys()
    }
    endOf() {
        return ys()
    }
}
var HH = {
    _date: uv
};
function UH(e, t, n, i) {
    const {controller: r, data: s, _sorted: o} = e
      , a = r._cachedMeta.iScale;
    if (a && t === a.axis && t !== "r" && o && s.length) {
        const l = a._reversePixels ? bW : Bs;
        if (i) {
            if (r._sharedOptions) {
                const c = s[0]
                  , u = typeof c.getRange == "function" && c.getRange(t);
                if (u) {
                    const h = l(s, t, n - u)
                      , d = l(s, t, n + u);
                    return {
                        lo: h.lo,
                        hi: d.hi
                    }
                }
            }
        } else
            return l(s, t, n)
    }
    return {
        lo: 0,
        hi: s.length - 1
    }
}
function Mc(e, t, n, i, r) {
    const s = e.getSortedVisibleDatasetMetas()
      , o = n[t];
    for (let a = 0, l = s.length; a < l; ++a) {
        const {index: c, data: u} = s[a]
          , {lo: h, hi: d} = UH(s[a], t, o, r);
        for (let m = h; m <= d; ++m) {
            const f = u[m];
            f.skip || i(f, c, m)
        }
    }
}
function GH(e) {
    const t = e.indexOf("x") !== -1
      , n = e.indexOf("y") !== -1;
    return function(i, r) {
        const s = t ? Math.abs(i.x - r.x) : 0
          , o = n ? Math.abs(i.y - r.y) : 0;
        return Math.sqrt(Math.pow(s, 2) + Math.pow(o, 2))
    }
}
function D0(e, t, n, i, r) {
    const s = [];
    return !r && !e.isPointInArea(t) || Mc(e, n, t, function(a, l, c) {
        !r && !rr(a, e.chartArea, 0) || a.inRange(t.x, t.y, i) && s.push({
            element: a,
            datasetIndex: l,
            index: c
        })
    }, !0),
    s
}
function XH(e, t, n, i) {
    let r = [];
    function s(o, a, l) {
        const {startAngle: c, endAngle: u} = o.getProps(["startAngle", "endAngle"], i)
          , {angle: h} = Rk(o, {
            x: t.x,
            y: t.y
        });
        nc(h, c, u) && r.push({
            element: o,
            datasetIndex: a,
            index: l
        })
    }
    return Mc(e, n, t, s),
    r
}
function YH(e, t, n, i, r, s) {
    let o = [];
    const a = GH(n);
    let l = Number.POSITIVE_INFINITY;
    function c(u, h, d) {
        const m = u.inRange(t.x, t.y, r);
        if (i && !m)
            return;
        const f = u.getCenterPoint(r);
        if (!(!!s || e.isPointInArea(f)) && !m)
            return;
        const S = a(t, f);
        S < l ? (o = [{
            element: u,
            datasetIndex: h,
            index: d
        }],
        l = S) : S === l && o.push({
            element: u,
            datasetIndex: h,
            index: d
        })
    }
    return Mc(e, n, t, c),
    o
}
function N0(e, t, n, i, r, s) {
    return !s && !e.isPointInArea(t) ? [] : n === "r" && !i ? XH(e, t, n, r) : YH(e, t, n, i, r, s)
}
function z6(e, t, n, i, r) {
    const s = []
      , o = n === "x" ? "inXRange" : "inYRange";
    let a = !1;
    return Mc(e, n, t, (l,c,u)=>{
        l[o](t[n], r) && (s.push({
            element: l,
            datasetIndex: c,
            index: u
        }),
        a = a || l.inRange(t.x, t.y, r))
    }
    ),
    i && !a ? [] : s
}
var $H = {
    evaluateInteractionItems: Mc,
    modes: {
        index(e, t, n, i) {
            const r = Es(t, e)
              , s = n.axis || "x"
              , o = n.includeInvisible || !1
              , a = n.intersect ? D0(e, r, s, i, o) : N0(e, r, s, !1, i, o)
              , l = [];
            return a.length ? (e.getSortedVisibleDatasetMetas().forEach(c=>{
                const u = a[0].index
                  , h = c.data[u];
                h && !h.skip && l.push({
                    element: h,
                    datasetIndex: c.index,
                    index: u
                })
            }
            ),
            l) : []
        },
        dataset(e, t, n, i) {
            const r = Es(t, e)
              , s = n.axis || "xy"
              , o = n.includeInvisible || !1;
            let a = n.intersect ? D0(e, r, s, i, o) : N0(e, r, s, !1, i, o);
            if (a.length > 0) {
                const l = a[0].datasetIndex
                  , c = e.getDatasetMeta(l).data;
                a = [];
                for (let u = 0; u < c.length; ++u)
                    a.push({
                        element: c[u],
                        datasetIndex: l,
                        index: u
                    })
            }
            return a
        },
        point(e, t, n, i) {
            const r = Es(t, e)
              , s = n.axis || "xy"
              , o = n.includeInvisible || !1;
            return D0(e, r, s, i, o)
        },
        nearest(e, t, n, i) {
            const r = Es(t, e)
              , s = n.axis || "xy"
              , o = n.includeInvisible || !1;
            return N0(e, r, s, n.intersect, i, o)
        },
        x(e, t, n, i) {
            const r = Es(t, e);
            return z6(e, r, "x", n.intersect, i)
        },
        y(e, t, n, i) {
            const r = Es(t, e);
            return z6(e, r, "y", n.intersect, i)
        }
    }
};
const Zk = ["left", "top", "right", "bottom"];
function Wa(e, t) {
    return e.filter(n=>n.pos === t)
}
function V6(e, t) {
    return e.filter(n=>Zk.indexOf(n.pos) === -1 && n.box.axis === t)
}
function Ha(e, t) {
    return e.sort((n,i)=>{
        const r = t ? i : n
          , s = t ? n : i;
        return r.weight === s.weight ? r.index - s.index : r.weight - s.weight
    }
    )
}
function KH(e) {
    const t = [];
    let n, i, r, s, o, a;
    for (n = 0,
    i = (e || []).length; n < i; ++n)
        r = e[n],
        {position: s, options: {stack: o, stackWeight: a=1}} = r,
        t.push({
            index: n,
            box: r,
            pos: s,
            horizontal: r.isHorizontal(),
            weight: r.weight,
            stack: o && s + o,
            stackWeight: a
        });
    return t
}
function QH(e) {
    const t = {};
    for (const n of e) {
        const {stack: i, pos: r, stackWeight: s} = n;
        if (!i || !Zk.includes(r))
            continue;
        const o = t[i] || (t[i] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
        });
        o.count++,
        o.weight += s
    }
    return t
}
function qH(e, t) {
    const n = QH(e)
      , {vBoxMaxWidth: i, hBoxMaxHeight: r} = t;
    let s, o, a;
    for (s = 0,
    o = e.length; s < o; ++s) {
        a = e[s];
        const {fullSize: l} = a.box
          , c = n[a.stack]
          , u = c && a.stackWeight / c.weight;
        a.horizontal ? (a.width = u ? u * i : l && t.availableWidth,
        a.height = r) : (a.width = i,
        a.height = u ? u * r : l && t.availableHeight)
    }
    return n
}
function ZH(e) {
    const t = KH(e)
      , n = Ha(t.filter(c=>c.box.fullSize), !0)
      , i = Ha(Wa(t, "left"), !0)
      , r = Ha(Wa(t, "right"))
      , s = Ha(Wa(t, "top"), !0)
      , o = Ha(Wa(t, "bottom"))
      , a = V6(t, "x")
      , l = V6(t, "y");
    return {
        fullSize: n,
        leftAndTop: i.concat(s),
        rightAndBottom: r.concat(l).concat(o).concat(a),
        chartArea: Wa(t, "chartArea"),
        vertical: i.concat(r).concat(l),
        horizontal: s.concat(o).concat(a)
    }
}
function W6(e, t, n, i) {
    return Math.max(e[n], t[n]) + Math.max(e[i], t[i])
}
function Jk(e, t) {
    e.top = Math.max(e.top, t.top),
    e.left = Math.max(e.left, t.left),
    e.bottom = Math.max(e.bottom, t.bottom),
    e.right = Math.max(e.right, t.right)
}
function JH(e, t, n, i) {
    const {pos: r, box: s} = n
      , o = e.maxPadding;
    if (!Xe(r)) {
        n.size && (e[r] -= n.size);
        const h = i[n.stack] || {
            size: 0,
            count: 1
        };
        h.size = Math.max(h.size, n.horizontal ? s.height : s.width),
        n.size = h.size / h.count,
        e[r] += n.size
    }
    s.getPadding && Jk(o, s.getPadding());
    const a = Math.max(0, t.outerWidth - W6(o, e, "left", "right"))
      , l = Math.max(0, t.outerHeight - W6(o, e, "top", "bottom"))
      , c = a !== e.w
      , u = l !== e.h;
    return e.w = a,
    e.h = l,
    n.horizontal ? {
        same: c,
        other: u
    } : {
        same: u,
        other: c
    }
}
function eU(e) {
    const t = e.maxPadding;
    function n(i) {
        const r = Math.max(t[i] - e[i], 0);
        return e[i] += r,
        r
    }
    e.y += n("top"),
    e.x += n("left"),
    n("right"),
    n("bottom")
}
function tU(e, t) {
    const n = t.maxPadding;
    function i(r) {
        const s = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
        return r.forEach(o=>{
            s[o] = Math.max(t[o], n[o])
        }
        ),
        s
    }
    return i(e ? ["left", "right"] : ["top", "bottom"])
}
function el(e, t, n, i) {
    const r = [];
    let s, o, a, l, c, u;
    for (s = 0,
    o = e.length,
    c = 0; s < o; ++s) {
        a = e[s],
        l = a.box,
        l.update(a.width || t.w, a.height || t.h, tU(a.horizontal, t));
        const {same: h, other: d} = JH(t, n, a, i);
        c |= h && r.length,
        u = u || d,
        l.fullSize || r.push(a)
    }
    return c && el(r, t, n, i) || u
}
function Mu(e, t, n, i, r) {
    e.top = n,
    e.left = t,
    e.right = t + i,
    e.bottom = n + r,
    e.width = i,
    e.height = r
}
function H6(e, t, n, i) {
    const r = n.padding;
    let {x: s, y: o} = t;
    for (const a of e) {
        const l = a.box
          , c = i[a.stack] || {
            count: 1,
            placed: 0,
            weight: 1
        }
          , u = a.stackWeight / c.weight || 1;
        if (a.horizontal) {
            const h = t.w * u
              , d = c.size || l.height;
            td(c.start) && (o = c.start),
            l.fullSize ? Mu(l, r.left, o, n.outerWidth - r.right - r.left, d) : Mu(l, t.left + c.placed, o, h, d),
            c.start = o,
            c.placed += h,
            o = l.bottom
        } else {
            const h = t.h * u
              , d = c.size || l.width;
            td(c.start) && (s = c.start),
            l.fullSize ? Mu(l, s, r.top, d, n.outerHeight - r.bottom - r.top) : Mu(l, s, t.top + c.placed, d, h),
            c.start = s,
            c.placed += h,
            s = l.right
        }
    }
    t.x = s,
    t.y = o
}
var ti = {
    addBox(e, t) {
        e.boxes || (e.boxes = []),
        t.fullSize = t.fullSize || !1,
        t.position = t.position || "top",
        t.weight = t.weight || 0,
        t._layers = t._layers || function() {
            return [{
                z: 0,
                draw(n) {
                    t.draw(n)
                }
            }]
        }
        ,
        e.boxes.push(t)
    },
    removeBox(e, t) {
        const n = e.boxes ? e.boxes.indexOf(t) : -1;
        n !== -1 && e.boxes.splice(n, 1)
    },
    configure(e, t, n) {
        t.fullSize = n.fullSize,
        t.position = n.position,
        t.weight = n.weight
    },
    update(e, t, n, i) {
        if (!e)
            return;
        const r = cn(e.options.layout.padding)
          , s = Math.max(t - r.width, 0)
          , o = Math.max(n - r.height, 0)
          , a = ZH(e.boxes)
          , l = a.vertical
          , c = a.horizontal;
        Ze(e.boxes, x=>{
            typeof x.beforeLayout == "function" && x.beforeLayout()
        }
        );
        const u = l.reduce((x,S)=>S.box.options && S.box.options.display === !1 ? x : x + 1, 0) || 1
          , h = Object.freeze({
            outerWidth: t,
            outerHeight: n,
            padding: r,
            availableWidth: s,
            availableHeight: o,
            vBoxMaxWidth: s / 2 / u,
            hBoxMaxHeight: o / 2
        })
          , d = Object.assign({}, r);
        Jk(d, cn(i));
        const m = Object.assign({
            maxPadding: d,
            w: s,
            h: o,
            x: r.left,
            y: r.top
        }, r)
          , f = qH(l.concat(c), h);
        el(a.fullSize, m, h, f),
        el(l, m, h, f),
        el(c, m, h, f) && el(l, m, h, f),
        eU(m),
        H6(a.leftAndTop, m, h, f),
        m.x += m.w,
        m.y += m.h,
        H6(a.rightAndBottom, m, h, f),
        e.chartArea = {
            left: m.left,
            top: m.top,
            right: m.left + m.w,
            bottom: m.top + m.h,
            height: m.h,
            width: m.w
        },
        Ze(a.chartArea, x=>{
            const S = x.box;
            Object.assign(S, e.chartArea),
            S.update(m.w, m.h, {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            })
        }
        )
    }
};
class eA {
    acquireContext(t, n) {}
    releaseContext(t) {
        return !1
    }
    addEventListener(t, n, i) {}
    removeEventListener(t, n, i) {}
    getDevicePixelRatio() {
        return 1
    }
    getMaximumSize(t, n, i, r) {
        return n = Math.max(0, n || t.width),
        i = i || t.height,
        {
            width: n,
            height: Math.max(0, r ? Math.floor(n / r) : i)
        }
    }
    isAttached(t) {
        return !0
    }
    updateConfig(t) {}
}
class nU extends eA {
    acquireContext(t) {
        return t && t.getContext && t.getContext("2d") || null
    }
    updateConfig(t) {
        t.options.animation = !1
    }
}
const rh = "$chartjs"
  , iU = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
}
  , U6 = e=>e === null || e === "";
function rU(e, t) {
    const n = e.style
      , i = e.getAttribute("height")
      , r = e.getAttribute("width");
    if (e[rh] = {
        initial: {
            height: i,
            width: r,
            style: {
                display: n.display,
                height: n.height,
                width: n.width
            }
        }
    },
    n.display = n.display || "block",
    n.boxSizing = n.boxSizing || "border-box",
    U6(r)) {
        const s = T6(e, "width");
        s !== void 0 && (e.width = s)
    }
    if (U6(i))
        if (e.style.height === "")
            e.height = e.width / (t || 2);
        else {
            const s = T6(e, "height");
            s !== void 0 && (e.height = s)
        }
    return e
}
const tA = vH ? {
    passive: !0
} : !1;
function sU(e, t, n) {
    e.addEventListener(t, n, tA)
}
function oU(e, t, n) {
    e.canvas.removeEventListener(t, n, tA)
}
function aU(e, t) {
    const n = iU[e.type] || e.type
      , {x: i, y: r} = Es(e, t);
    return {
        type: n,
        chart: t,
        native: e,
        x: i !== void 0 ? i : null,
        y: r !== void 0 ? r : null
    }
}
function od(e, t) {
    for (const n of e)
        if (n === t || n.contains(t))
            return !0
}
function lU(e, t, n) {
    const i = e.canvas
      , r = new MutationObserver(s=>{
        let o = !1;
        for (const a of s)
            o = o || od(a.addedNodes, i),
            o = o && !od(a.removedNodes, i);
        o && n()
    }
    );
    return r.observe(document, {
        childList: !0,
        subtree: !0
    }),
    r
}
function cU(e, t, n) {
    const i = e.canvas
      , r = new MutationObserver(s=>{
        let o = !1;
        for (const a of s)
            o = o || od(a.removedNodes, i),
            o = o && !od(a.addedNodes, i);
        o && n()
    }
    );
    return r.observe(document, {
        childList: !0,
        subtree: !0
    }),
    r
}
const ic = new Map;
let G6 = 0;
function nA() {
    const e = window.devicePixelRatio;
    e !== G6 && (G6 = e,
    ic.forEach((t,n)=>{
        n.currentDevicePixelRatio !== e && t()
    }
    ))
}
function uU(e, t) {
    ic.size || window.addEventListener("resize", nA),
    ic.set(e, t)
}
function hU(e) {
    ic.delete(e),
    ic.size || window.removeEventListener("resize", nA)
}
function dU(e, t, n) {
    const i = e.canvas
      , r = i && cv(i);
    if (!r)
        return;
    const s = Nk((a,l)=>{
        const c = r.clientWidth;
        n(a, l),
        c < r.clientWidth && n()
    }
    , window)
      , o = new ResizeObserver(a=>{
        const l = a[0]
          , c = l.contentRect.width
          , u = l.contentRect.height;
        c === 0 && u === 0 || s(c, u)
    }
    );
    return o.observe(r),
    uU(e, s),
    o
}
function F0(e, t, n) {
    n && n.disconnect(),
    t === "resize" && hU(e)
}
function fU(e, t, n) {
    const i = e.canvas
      , r = Nk(s=>{
        e.ctx !== null && n(aU(s, e))
    }
    , e);
    return sU(i, t, r),
    r
}
class pU extends eA {
    acquireContext(t, n) {
        const i = t && t.getContext && t.getContext("2d");
        return i && i.canvas === t ? (rU(t, n),
        i) : null
    }
    releaseContext(t) {
        const n = t.canvas;
        if (!n[rh])
            return !1;
        const i = n[rh].initial;
        ["height", "width"].forEach(s=>{
            const o = i[s];
            ft(o) ? n.removeAttribute(s) : n.setAttribute(s, o)
        }
        );
        const r = i.style || {};
        return Object.keys(r).forEach(s=>{
            n.style[s] = r[s]
        }
        ),
        n.width = n.width,
        delete n[rh],
        !0
    }
    addEventListener(t, n, i) {
        this.removeEventListener(t, n);
        const r = t.$proxies || (t.$proxies = {})
          , o = {
            attach: lU,
            detach: cU,
            resize: dU
        }[n] || fU;
        r[n] = o(t, n, i)
    }
    removeEventListener(t, n) {
        const i = t.$proxies || (t.$proxies = {})
          , r = i[n];
        if (!r)
            return;
        ({
            attach: F0,
            detach: F0,
            resize: F0
        }[n] || oU)(t, n, r),
        i[n] = void 0
    }
    getDevicePixelRatio() {
        return window.devicePixelRatio
    }
    getMaximumSize(t, n, i, r) {
        return mH(t, n, i, r)
    }
    isAttached(t) {
        const n = cv(t);
        return !!(n && n.isConnected)
    }
}
function gU(e) {
    return !Uk() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? nU : pU
}
var Nu;
let as = (Nu = class {
    constructor() {
        je(this, "x");
        je(this, "y");
        je(this, "active", !1);
        je(this, "options");
        je(this, "$animations")
    }
    tooltipPosition(t) {
        const {x: n, y: i} = this.getProps(["x", "y"], t);
        return {
            x: n,
            y: i
        }
    }
    hasValue() {
        return tc(this.x) && tc(this.y)
    }
    getProps(t, n) {
        const i = this.$animations;
        if (!n || !i)
            return this;
        const r = {};
        return t.forEach(s=>{
            r[s] = i[s] && i[s].active() ? i[s]._to : this[s]
        }
        ),
        r
    }
}
,
je(Nu, "defaults", {}),
je(Nu, "defaultRoutes"),
Nu);
function mU(e, t) {
    const n = e.options.ticks
      , i = vU(e)
      , r = Math.min(n.maxTicksLimit || i, i)
      , s = n.major.enabled ? xU(t) : []
      , o = s.length
      , a = s[0]
      , l = s[o - 1]
      , c = [];
    if (o > r)
        return bU(t, c, s, o / r),
        c;
    const u = yU(s, t, r);
    if (o > 0) {
        let h, d;
        const m = o > 1 ? Math.round((l - a) / (o - 1)) : null;
        for (Eu(t, c, u, ft(m) ? 0 : a - m, a),
        h = 0,
        d = o - 1; h < d; h++)
            Eu(t, c, u, s[h], s[h + 1]);
        return Eu(t, c, u, l, ft(m) ? t.length : l + m),
        c
    }
    return Eu(t, c, u),
    c
}
function vU(e) {
    const t = e.options.offset
      , n = e._tickSize()
      , i = e._length / n + (t ? 0 : 1)
      , r = e._maxLength / n;
    return Math.floor(Math.min(i, r))
}
function yU(e, t, n) {
    const i = wU(e)
      , r = t.length / n;
    if (!i)
        return Math.max(r, 1);
    const s = mW(i);
    for (let o = 0, a = s.length - 1; o < a; o++) {
        const l = s[o];
        if (l > r)
            return l
    }
    return Math.max(r, 1)
}
function xU(e) {
    const t = [];
    let n, i;
    for (n = 0,
    i = e.length; n < i; n++)
        e[n].major && t.push(n);
    return t
}
function bU(e, t, n, i) {
    let r = 0, s = n[0], o;
    for (i = Math.ceil(i),
    o = 0; o < e.length; o++)
        o === s && (t.push(e[o]),
        r++,
        s = n[r * i])
}
function Eu(e, t, n, i, r) {
    const s = He(i, 0)
      , o = Math.min(He(r, e.length), e.length);
    let a = 0, l, c, u;
    for (n = Math.ceil(n),
    r && (l = r - i,
    n = l / Math.floor(l / n)),
    u = s; u < 0; )
        a++,
        u = Math.round(s + a * n);
    for (c = Math.max(s, 0); c < o; c++)
        c === u && (t.push(e[c]),
        a++,
        u = Math.round(s + a * n))
}
function wU(e) {
    const t = e.length;
    let n, i;
    if (t < 2)
        return !1;
    for (i = e[0],
    n = 1; n < t; ++n)
        if (e[n] - e[n - 1] !== i)
            return !1;
    return i
}
const SU = e=>e === "left" ? "right" : e === "right" ? "left" : e
  , X6 = (e,t,n)=>t === "top" || t === "left" ? e[t] + n : e[t] - n
  , Y6 = (e,t)=>Math.min(t || e, e);
function $6(e, t) {
    const n = []
      , i = e.length / t
      , r = e.length;
    let s = 0;
    for (; s < r; s += i)
        n.push(e[Math.floor(s)]);
    return n
}
function CU(e, t, n) {
    const i = e.ticks.length
      , r = Math.min(t, i - 1)
      , s = e._startPixel
      , o = e._endPixel
      , a = 1e-6;
    let l = e.getPixelForTick(r), c;
    if (!(n && (i === 1 ? c = Math.max(l - s, o - l) : t === 0 ? c = (e.getPixelForTick(1) - l) / 2 : c = (l - e.getPixelForTick(r - 1)) / 2,
    l += r < t ? c : -c,
    l < s - a || l > o + a)))
        return l
}
function kU(e, t) {
    Ze(e, n=>{
        const i = n.gc
          , r = i.length / 2;
        let s;
        if (r > t) {
            for (s = 0; s < r; ++s)
                delete n.data[i[s]];
            i.splice(0, r)
        }
    }
    )
}
function Ua(e) {
    return e.drawTicks ? e.tickLength : 0
}
function K6(e, t) {
    if (!e.display)
        return 0;
    const n = Ht(e.font, t)
      , i = cn(e.padding);
    return (yt(e.text) ? e.text.length : 1) * n.lineHeight + i.height
}
function AU(e, t) {
    return os(e, {
        scale: t,
        type: "scale"
    })
}
function MU(e, t, n) {
    return os(e, {
        tick: n,
        index: t,
        type: "tick"
    })
}
function EU(e, t, n) {
    let i = iv(e);
    return (n && t !== "right" || !n && t === "right") && (i = SU(i)),
    i
}
function PU(e, t, n, i) {
    const {top: r, left: s, bottom: o, right: a, chart: l} = e
      , {chartArea: c, scales: u} = l;
    let h = 0, d, m, f;
    const x = o - r
      , S = a - s;
    if (e.isHorizontal()) {
        if (m = on(i, s, a),
        Xe(n)) {
            const v = Object.keys(n)[0]
              , p = n[v];
            f = u[v].getPixelForValue(p) + x - t
        } else
            n === "center" ? f = (c.bottom + c.top) / 2 + x - t : f = X6(e, n, t);
        d = a - s
    } else {
        if (Xe(n)) {
            const v = Object.keys(n)[0]
              , p = n[v];
            m = u[v].getPixelForValue(p) - S + t
        } else
            n === "center" ? m = (c.left + c.right) / 2 - S + t : m = X6(e, n, t);
        f = on(i, o, r),
        h = n === "left" ? -Rt : Rt
    }
    return {
        titleX: m,
        titleY: f,
        maxWidth: d,
        rotation: h
    }
}
class ao extends as {
    constructor(t) {
        super(),
        this.id = t.id,
        this.type = t.type,
        this.options = void 0,
        this.ctx = t.ctx,
        this.chart = t.chart,
        this.top = void 0,
        this.bottom = void 0,
        this.left = void 0,
        this.right = void 0,
        this.width = void 0,
        this.height = void 0,
        this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        },
        this.maxWidth = void 0,
        this.maxHeight = void 0,
        this.paddingTop = void 0,
        this.paddingBottom = void 0,
        this.paddingLeft = void 0,
        this.paddingRight = void 0,
        this.axis = void 0,
        this.labelRotation = void 0,
        this.min = void 0,
        this.max = void 0,
        this._range = void 0,
        this.ticks = [],
        this._gridLineItems = null,
        this._labelItems = null,
        this._labelSizes = null,
        this._length = 0,
        this._maxLength = 0,
        this._longestTextCache = {},
        this._startPixel = void 0,
        this._endPixel = void 0,
        this._reversePixels = !1,
        this._userMax = void 0,
        this._userMin = void 0,
        this._suggestedMax = void 0,
        this._suggestedMin = void 0,
        this._ticksLength = 0,
        this._borderValue = 0,
        this._cache = {},
        this._dataLimitsCached = !1,
        this.$context = void 0
    }
    init(t) {
        this.options = t.setContext(this.getContext()),
        this.axis = t.axis,
        this._userMin = this.parse(t.min),
        this._userMax = this.parse(t.max),
        this._suggestedMin = this.parse(t.suggestedMin),
        this._suggestedMax = this.parse(t.suggestedMax)
    }
    parse(t, n) {
        return t
    }
    getUserBounds() {
        let {_userMin: t, _userMax: n, _suggestedMin: i, _suggestedMax: r} = this;
        return t = _n(t, Number.POSITIVE_INFINITY),
        n = _n(n, Number.NEGATIVE_INFINITY),
        i = _n(i, Number.POSITIVE_INFINITY),
        r = _n(r, Number.NEGATIVE_INFINITY),
        {
            min: _n(t, i),
            max: _n(n, r),
            minDefined: Pt(t),
            maxDefined: Pt(n)
        }
    }
    getMinMax(t) {
        let {min: n, max: i, minDefined: r, maxDefined: s} = this.getUserBounds(), o;
        if (r && s)
            return {
                min: n,
                max: i
            };
        const a = this.getMatchingVisibleMetas();
        for (let l = 0, c = a.length; l < c; ++l)
            o = a[l].controller.getMinMax(this, t),
            r || (n = Math.min(n, o.min)),
            s || (i = Math.max(i, o.max));
        return n = s && n > i ? i : n,
        i = r && n > i ? n : i,
        {
            min: _n(n, _n(i, n)),
            max: _n(i, _n(n, i))
        }
    }
    getPadding() {
        return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0
        }
    }
    getTicks() {
        return this.ticks
    }
    getLabels() {
        const t = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
    }
    getLabelItems(t=this.chart.chartArea) {
        return this._labelItems || (this._labelItems = this._computeLabelItems(t))
    }
    beforeLayout() {
        this._cache = {},
        this._dataLimitsCached = !1
    }
    beforeUpdate() {
        at(this.options.beforeUpdate, [this])
    }
    update(t, n, i) {
        const {beginAtZero: r, grace: s, ticks: o} = this.options
          , a = o.sampleSize;
        this.beforeUpdate(),
        this.maxWidth = t,
        this.maxHeight = n,
        this._margins = i = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, i),
        this.ticks = null,
        this._labelSizes = null,
        this._gridLineItems = null,
        this._labelItems = null,
        this.beforeSetDimensions(),
        this.setDimensions(),
        this.afterSetDimensions(),
        this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom,
        this._dataLimitsCached || (this.beforeDataLimits(),
        this.determineDataLimits(),
        this.afterDataLimits(),
        this._range = $W(this, s, r),
        this._dataLimitsCached = !0),
        this.beforeBuildTicks(),
        this.ticks = this.buildTicks() || [],
        this.afterBuildTicks();
        const l = a < this.ticks.length;
        this._convertTicksToLabels(l ? $6(this.ticks, a) : this.ticks),
        this.configure(),
        this.beforeCalculateLabelRotation(),
        this.calculateLabelRotation(),
        this.afterCalculateLabelRotation(),
        o.display && (o.autoSkip || o.source === "auto") && (this.ticks = mU(this, this.ticks),
        this._labelSizes = null,
        this.afterAutoSkip()),
        l && this._convertTicksToLabels(this.ticks),
        this.beforeFit(),
        this.fit(),
        this.afterFit(),
        this.afterUpdate()
    }
    configure() {
        let t = this.options.reverse, n, i;
        this.isHorizontal() ? (n = this.left,
        i = this.right) : (n = this.top,
        i = this.bottom,
        t = !t),
        this._startPixel = n,
        this._endPixel = i,
        this._reversePixels = t,
        this._length = i - n,
        this._alignToPixels = this.options.alignToPixels
    }
    afterUpdate() {
        at(this.options.afterUpdate, [this])
    }
    beforeSetDimensions() {
        at(this.options.beforeSetDimensions, [this])
    }
    setDimensions() {
        this.isHorizontal() ? (this.width = this.maxWidth,
        this.left = 0,
        this.right = this.width) : (this.height = this.maxHeight,
        this.top = 0,
        this.bottom = this.height),
        this.paddingLeft = 0,
        this.paddingTop = 0,
        this.paddingRight = 0,
        this.paddingBottom = 0
    }
    afterSetDimensions() {
        at(this.options.afterSetDimensions, [this])
    }
    _callHooks(t) {
        this.chart.notifyPlugins(t, this.getContext()),
        at(this.options[t], [this])
    }
    beforeDataLimits() {
        this._callHooks("beforeDataLimits")
    }
    determineDataLimits() {}
    afterDataLimits() {
        this._callHooks("afterDataLimits")
    }
    beforeBuildTicks() {
        this._callHooks("beforeBuildTicks")
    }
    buildTicks() {
        return []
    }
    afterBuildTicks() {
        this._callHooks("afterBuildTicks")
    }
    beforeTickToLabelConversion() {
        at(this.options.beforeTickToLabelConversion, [this])
    }
    generateTickLabels(t) {
        const n = this.options.ticks;
        let i, r, s;
        for (i = 0,
        r = t.length; i < r; i++)
            s = t[i],
            s.label = at(n.callback, [s.value, i, t], this)
    }
    afterTickToLabelConversion() {
        at(this.options.afterTickToLabelConversion, [this])
    }
    beforeCalculateLabelRotation() {
        at(this.options.beforeCalculateLabelRotation, [this])
    }
    calculateLabelRotation() {
        const t = this.options
          , n = t.ticks
          , i = Y6(this.ticks.length, t.ticks.maxTicksLimit)
          , r = n.minRotation || 0
          , s = n.maxRotation;
        let o = r, a, l, c;
        if (!this._isVisible() || !n.display || r >= s || i <= 1 || !this.isHorizontal()) {
            this.labelRotation = r;
            return
        }
        const u = this._getLabelSizes()
          , h = u.widest.width
          , d = u.highest.height
          , m = gn(this.chart.width - h, 0, this.maxWidth);
        a = t.offset ? this.maxWidth / i : m / (i - 1),
        h + 6 > a && (a = m / (i - (t.offset ? .5 : 1)),
        l = this.maxHeight - Ua(t.grid) - n.padding - K6(t.title, this.chart.options.font),
        c = Math.sqrt(h * h + d * d),
        o = tv(Math.min(Math.asin(gn((u.highest.height + 6) / a, -1, 1)), Math.asin(gn(l / c, -1, 1)) - Math.asin(gn(d / c, -1, 1)))),
        o = Math.max(r, Math.min(s, o))),
        this.labelRotation = o
    }
    afterCalculateLabelRotation() {
        at(this.options.afterCalculateLabelRotation, [this])
    }
    afterAutoSkip() {}
    beforeFit() {
        at(this.options.beforeFit, [this])
    }
    fit() {
        const t = {
            width: 0,
            height: 0
        }
          , {chart: n, options: {ticks: i, title: r, grid: s}} = this
          , o = this._isVisible()
          , a = this.isHorizontal();
        if (o) {
            const l = K6(r, n.options.font);
            if (a ? (t.width = this.maxWidth,
            t.height = Ua(s) + l) : (t.height = this.maxHeight,
            t.width = Ua(s) + l),
            i.display && this.ticks.length) {
                const {first: c, last: u, widest: h, highest: d} = this._getLabelSizes()
                  , m = i.padding * 2
                  , f = Ni(this.labelRotation)
                  , x = Math.cos(f)
                  , S = Math.sin(f);
                if (a) {
                    const v = i.mirror ? 0 : S * h.width + x * d.height;
                    t.height = Math.min(this.maxHeight, t.height + v + m)
                } else {
                    const v = i.mirror ? 0 : x * h.width + S * d.height;
                    t.width = Math.min(this.maxWidth, t.width + v + m)
                }
                this._calculatePadding(c, u, S, x)
            }
        }
        this._handleMargins(),
        a ? (this.width = this._length = n.width - this._margins.left - this._margins.right,
        this.height = t.height) : (this.width = t.width,
        this.height = this._length = n.height - this._margins.top - this._margins.bottom)
    }
    _calculatePadding(t, n, i, r) {
        const {ticks: {align: s, padding: o}, position: a} = this.options
          , l = this.labelRotation !== 0
          , c = a !== "top" && this.axis === "x";
        if (this.isHorizontal()) {
            const u = this.getPixelForTick(0) - this.left
              , h = this.right - this.getPixelForTick(this.ticks.length - 1);
            let d = 0
              , m = 0;
            l ? c ? (d = r * t.width,
            m = i * n.height) : (d = i * t.height,
            m = r * n.width) : s === "start" ? m = n.width : s === "end" ? d = t.width : s !== "inner" && (d = t.width / 2,
            m = n.width / 2),
            this.paddingLeft = Math.max((d - u + o) * this.width / (this.width - u), 0),
            this.paddingRight = Math.max((m - h + o) * this.width / (this.width - h), 0)
        } else {
            let u = n.height / 2
              , h = t.height / 2;
            s === "start" ? (u = 0,
            h = t.height) : s === "end" && (u = n.height,
            h = 0),
            this.paddingTop = u + o,
            this.paddingBottom = h + o
        }
    }
    _handleMargins() {
        this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left),
        this._margins.top = Math.max(this.paddingTop, this._margins.top),
        this._margins.right = Math.max(this.paddingRight, this._margins.right),
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
    }
    afterFit() {
        at(this.options.afterFit, [this])
    }
    isHorizontal() {
        const {axis: t, position: n} = this.options;
        return n === "top" || n === "bottom" || t === "x"
    }
    isFullSize() {
        return this.options.fullSize
    }
    _convertTicksToLabels(t) {
        this.beforeTickToLabelConversion(),
        this.generateTickLabels(t);
        let n, i;
        for (n = 0,
        i = t.length; n < i; n++)
            ft(t[n].label) && (t.splice(n, 1),
            i--,
            n--);
        this.afterTickToLabelConversion()
    }
    _getLabelSizes() {
        let t = this._labelSizes;
        if (!t) {
            const n = this.options.ticks.sampleSize;
            let i = this.ticks;
            n < i.length && (i = $6(i, n)),
            this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit)
        }
        return t
    }
    _computeLabelSizes(t, n, i) {
        const {ctx: r, _longestTextCache: s} = this
          , o = []
          , a = []
          , l = Math.floor(n / Y6(n, i));
        let c = 0, u = 0, h, d, m, f, x, S, v, p, g, C, E;
        for (h = 0; h < n; h += l) {
            if (f = t[h].label,
            x = this._resolveTickFontOptions(h),
            r.font = S = x.string,
            v = s[S] = s[S] || {
                data: {},
                gc: []
            },
            p = x.lineHeight,
            g = C = 0,
            !ft(f) && !yt(f))
                g = id(r, v.data, v.gc, g, f),
                C = p;
            else if (yt(f))
                for (d = 0,
                m = f.length; d < m; ++d)
                    E = f[d],
                    !ft(E) && !yt(E) && (g = id(r, v.data, v.gc, g, E),
                    C += p);
            o.push(g),
            a.push(C),
            c = Math.max(g, c),
            u = Math.max(C, u)
        }
        kU(s, n);
        const O = o.indexOf(c)
          , R = a.indexOf(u)
          , F = P=>({
            width: o[P] || 0,
            height: a[P] || 0
        });
        return {
            first: F(0),
            last: F(n - 1),
            widest: F(O),
            highest: F(R),
            widths: o,
            heights: a
        }
    }
    getLabelForValue(t) {
        return t
    }
    getPixelForValue(t, n) {
        return NaN
    }
    getValueForPixel(t) {}
    getPixelForTick(t) {
        const n = this.ticks;
        return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value)
    }
    getPixelForDecimal(t) {
        this._reversePixels && (t = 1 - t);
        const n = this._startPixel + t * this._length;
        return xW(this._alignToPixels ? vs(this.chart, n, 0) : n)
    }
    getDecimalForPixel(t) {
        const n = (t - this._startPixel) / this._length;
        return this._reversePixels ? 1 - n : n
    }
    getBasePixel() {
        return this.getPixelForValue(this.getBaseValue())
    }
    getBaseValue() {
        const {min: t, max: n} = this;
        return t < 0 && n < 0 ? n : t > 0 && n > 0 ? t : 0
    }
    getContext(t) {
        const n = this.ticks || [];
        if (t >= 0 && t < n.length) {
            const i = n[t];
            return i.$context || (i.$context = MU(this.getContext(), t, i))
        }
        return this.$context || (this.$context = AU(this.chart.getContext(), this))
    }
    _tickSize() {
        const t = this.options.ticks
          , n = Ni(this.labelRotation)
          , i = Math.abs(Math.cos(n))
          , r = Math.abs(Math.sin(n))
          , s = this._getLabelSizes()
          , o = t.autoSkipPadding || 0
          , a = s ? s.widest.width + o : 0
          , l = s ? s.highest.height + o : 0;
        return this.isHorizontal() ? l * i > a * r ? a / i : l / r : l * r < a * i ? l / i : a / r
    }
    _isVisible() {
        const t = this.options.display;
        return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0
    }
    _computeGridLineItems(t) {
        const n = this.axis
          , i = this.chart
          , r = this.options
          , {grid: s, position: o, border: a} = r
          , l = s.offset
          , c = this.isHorizontal()
          , h = this.ticks.length + (l ? 1 : 0)
          , d = Ua(s)
          , m = []
          , f = a.setContext(this.getContext())
          , x = f.display ? f.width : 0
          , S = x / 2
          , v = function(b) {
            return vs(i, b, x)
        };
        let p, g, C, E, O, R, F, P, _, T, L, I;
        if (o === "top")
            p = v(this.bottom),
            R = this.bottom - d,
            P = p - S,
            T = v(t.top) + S,
            I = t.bottom;
        else if (o === "bottom")
            p = v(this.top),
            T = t.top,
            I = v(t.bottom) - S,
            R = p + S,
            P = this.top + d;
        else if (o === "left")
            p = v(this.right),
            O = this.right - d,
            F = p - S,
            _ = v(t.left) + S,
            L = t.right;
        else if (o === "right")
            p = v(this.left),
            _ = t.left,
            L = v(t.right) - S,
            O = p + S,
            F = this.left + d;
        else if (n === "x") {
            if (o === "center")
                p = v((t.top + t.bottom) / 2 + .5);
            else if (Xe(o)) {
                const b = Object.keys(o)[0]
                  , A = o[b];
                p = v(this.chart.scales[b].getPixelForValue(A))
            }
            T = t.top,
            I = t.bottom,
            R = p + S,
            P = R + d
        } else if (n === "y") {
            if (o === "center")
                p = v((t.left + t.right) / 2);
            else if (Xe(o)) {
                const b = Object.keys(o)[0]
                  , A = o[b];
                p = v(this.chart.scales[b].getPixelForValue(A))
            }
            O = p - S,
            F = O - d,
            _ = t.left,
            L = t.right
        }
        const k = He(r.ticks.maxTicksLimit, h)
          , w = Math.max(1, Math.ceil(h / k));
        for (g = 0; g < h; g += w) {
            const b = this.getContext(g)
              , A = s.setContext(b)
              , j = a.setContext(b)
              , B = A.lineWidth
              , W = A.color
              , N = j.dash || []
              , H = j.dashOffset
              , X = A.tickWidth
              , ie = A.tickColor
              , K = A.tickBorderDash || []
              , D = A.tickBorderDashOffset;
            C = CU(this, g, l),
            C !== void 0 && (E = vs(i, C, B),
            c ? O = F = _ = L = E : R = P = T = I = E,
            m.push({
                tx1: O,
                ty1: R,
                tx2: F,
                ty2: P,
                x1: _,
                y1: T,
                x2: L,
                y2: I,
                width: B,
                color: W,
                borderDash: N,
                borderDashOffset: H,
                tickWidth: X,
                tickColor: ie,
                tickBorderDash: K,
                tickBorderDashOffset: D
            }))
        }
        return this._ticksLength = h,
        this._borderValue = p,
        m
    }
    _computeLabelItems(t) {
        const n = this.axis
          , i = this.options
          , {position: r, ticks: s} = i
          , o = this.isHorizontal()
          , a = this.ticks
          , {align: l, crossAlign: c, padding: u, mirror: h} = s
          , d = Ua(i.grid)
          , m = d + u
          , f = h ? -u : m
          , x = -Ni(this.labelRotation)
          , S = [];
        let v, p, g, C, E, O, R, F, P, _, T, L, I = "middle";
        if (r === "top")
            O = this.bottom - f,
            R = this._getXAxisLabelAlignment();
        else if (r === "bottom")
            O = this.top + f,
            R = this._getXAxisLabelAlignment();
        else if (r === "left") {
            const w = this._getYAxisLabelAlignment(d);
            R = w.textAlign,
            E = w.x
        } else if (r === "right") {
            const w = this._getYAxisLabelAlignment(d);
            R = w.textAlign,
            E = w.x
        } else if (n === "x") {
            if (r === "center")
                O = (t.top + t.bottom) / 2 + m;
            else if (Xe(r)) {
                const w = Object.keys(r)[0]
                  , b = r[w];
                O = this.chart.scales[w].getPixelForValue(b) + m
            }
            R = this._getXAxisLabelAlignment()
        } else if (n === "y") {
            if (r === "center")
                E = (t.left + t.right) / 2 - m;
            else if (Xe(r)) {
                const w = Object.keys(r)[0]
                  , b = r[w];
                E = this.chart.scales[w].getPixelForValue(b)
            }
            R = this._getYAxisLabelAlignment(d).textAlign
        }
        n === "y" && (l === "start" ? I = "top" : l === "end" && (I = "bottom"));
        const k = this._getLabelSizes();
        for (v = 0,
        p = a.length; v < p; ++v) {
            g = a[v],
            C = g.label;
            const w = s.setContext(this.getContext(v));
            F = this.getPixelForTick(v) + s.labelOffset,
            P = this._resolveTickFontOptions(v),
            _ = P.lineHeight,
            T = yt(C) ? C.length : 1;
            const b = T / 2
              , A = w.color
              , j = w.textStrokeColor
              , B = w.textStrokeWidth;
            let W = R;
            o ? (E = F,
            R === "inner" && (v === p - 1 ? W = this.options.reverse ? "left" : "right" : v === 0 ? W = this.options.reverse ? "right" : "left" : W = "center"),
            r === "top" ? c === "near" || x !== 0 ? L = -T * _ + _ / 2 : c === "center" ? L = -k.highest.height / 2 - b * _ + _ : L = -k.highest.height + _ / 2 : c === "near" || x !== 0 ? L = _ / 2 : c === "center" ? L = k.highest.height / 2 - b * _ : L = k.highest.height - T * _,
            h && (L *= -1),
            x !== 0 && !w.showLabelBackdrop && (E += _ / 2 * Math.sin(x))) : (O = F,
            L = (1 - T) * _ / 2);
            let N;
            if (w.showLabelBackdrop) {
                const H = cn(w.backdropPadding)
                  , X = k.heights[v]
                  , ie = k.widths[v];
                let K = L - H.top
                  , D = 0 - H.left;
                switch (I) {
                case "middle":
                    K -= X / 2;
                    break;
                case "bottom":
                    K -= X;
                    break
                }
                switch (R) {
                case "center":
                    D -= ie / 2;
                    break;
                case "right":
                    D -= ie;
                    break
                }
                N = {
                    left: D,
                    top: K,
                    width: ie + H.width,
                    height: X + H.height,
                    color: w.backdropColor
                }
            }
            S.push({
                label: C,
                font: P,
                textOffset: L,
                options: {
                    rotation: x,
                    color: A,
                    strokeColor: j,
                    strokeWidth: B,
                    textAlign: W,
                    textBaseline: I,
                    translation: [E, O],
                    backdrop: N
                }
            })
        }
        return S
    }
    _getXAxisLabelAlignment() {
        const {position: t, ticks: n} = this.options;
        if (-Ni(this.labelRotation))
            return t === "top" ? "left" : "right";
        let r = "center";
        return n.align === "start" ? r = "left" : n.align === "end" ? r = "right" : n.align === "inner" && (r = "inner"),
        r
    }
    _getYAxisLabelAlignment(t) {
        const {position: n, ticks: {crossAlign: i, mirror: r, padding: s}} = this.options
          , o = this._getLabelSizes()
          , a = t + s
          , l = o.widest.width;
        let c, u;
        return n === "left" ? r ? (u = this.right + s,
        i === "near" ? c = "left" : i === "center" ? (c = "center",
        u += l / 2) : (c = "right",
        u += l)) : (u = this.right - a,
        i === "near" ? c = "right" : i === "center" ? (c = "center",
        u -= l / 2) : (c = "left",
        u = this.left)) : n === "right" ? r ? (u = this.left + s,
        i === "near" ? c = "right" : i === "center" ? (c = "center",
        u -= l / 2) : (c = "left",
        u -= l)) : (u = this.left + a,
        i === "near" ? c = "left" : i === "center" ? (c = "center",
        u += l / 2) : (c = "right",
        u = this.right)) : c = "right",
        {
            textAlign: c,
            x: u
        }
    }
    _computeLabelArea() {
        if (this.options.ticks.mirror)
            return;
        const t = this.chart
          , n = this.options.position;
        if (n === "left" || n === "right")
            return {
                top: 0,
                left: this.left,
                bottom: t.height,
                right: this.right
            };
        if (n === "top" || n === "bottom")
            return {
                top: this.top,
                left: 0,
                bottom: this.bottom,
                right: t.width
            }
    }
    drawBackground() {
        const {ctx: t, options: {backgroundColor: n}, left: i, top: r, width: s, height: o} = this;
        n && (t.save(),
        t.fillStyle = n,
        t.fillRect(i, r, s, o),
        t.restore())
    }
    getLineWidthForValue(t) {
        const n = this.options.grid;
        if (!this._isVisible() || !n.display)
            return 0;
        const r = this.ticks.findIndex(s=>s.value === t);
        return r >= 0 ? n.setContext(this.getContext(r)).lineWidth : 0
    }
    drawGrid(t) {
        const n = this.options.grid
          , i = this.ctx
          , r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
        let s, o;
        const a = (l,c,u)=>{
            !u.width || !u.color || (i.save(),
            i.lineWidth = u.width,
            i.strokeStyle = u.color,
            i.setLineDash(u.borderDash || []),
            i.lineDashOffset = u.borderDashOffset,
            i.beginPath(),
            i.moveTo(l.x, l.y),
            i.lineTo(c.x, c.y),
            i.stroke(),
            i.restore())
        }
        ;
        if (n.display)
            for (s = 0,
            o = r.length; s < o; ++s) {
                const l = r[s];
                n.drawOnChartArea && a({
                    x: l.x1,
                    y: l.y1
                }, {
                    x: l.x2,
                    y: l.y2
                }, l),
                n.drawTicks && a({
                    x: l.tx1,
                    y: l.ty1
                }, {
                    x: l.tx2,
                    y: l.ty2
                }, {
                    color: l.tickColor,
                    width: l.tickWidth,
                    borderDash: l.tickBorderDash,
                    borderDashOffset: l.tickBorderDashOffset
                })
            }
    }
    drawBorder() {
        const {chart: t, ctx: n, options: {border: i, grid: r}} = this
          , s = i.setContext(this.getContext())
          , o = i.display ? s.width : 0;
        if (!o)
            return;
        const a = r.setContext(this.getContext(0)).lineWidth
          , l = this._borderValue;
        let c, u, h, d;
        this.isHorizontal() ? (c = vs(t, this.left, o) - o / 2,
        u = vs(t, this.right, a) + a / 2,
        h = d = l) : (h = vs(t, this.top, o) - o / 2,
        d = vs(t, this.bottom, a) + a / 2,
        c = u = l),
        n.save(),
        n.lineWidth = s.width,
        n.strokeStyle = s.color,
        n.beginPath(),
        n.moveTo(c, h),
        n.lineTo(u, d),
        n.stroke(),
        n.restore()
    }
    drawLabels(t) {
        if (!this.options.ticks.display)
            return;
        const i = this.ctx
          , r = this._computeLabelArea();
        r && af(i, r);
        const s = this.getLabelItems(t);
        for (const o of s) {
            const a = o.options
              , l = o.font
              , c = o.label
              , u = o.textOffset;
            Js(i, c, 0, u, l, a)
        }
        r && lf(i)
    }
    drawTitle() {
        const {ctx: t, options: {position: n, title: i, reverse: r}} = this;
        if (!i.display)
            return;
        const s = Ht(i.font)
          , o = cn(i.padding)
          , a = i.align;
        let l = s.lineHeight / 2;
        n === "bottom" || n === "center" || Xe(n) ? (l += o.bottom,
        yt(i.text) && (l += s.lineHeight * (i.text.length - 1))) : l += o.top;
        const {titleX: c, titleY: u, maxWidth: h, rotation: d} = PU(this, l, n, a);
        Js(t, i.text, 0, 0, s, {
            color: i.color,
            maxWidth: h,
            rotation: d,
            textAlign: EU(a, n, r),
            textBaseline: "middle",
            translation: [c, u]
        })
    }
    draw(t) {
        this._isVisible() && (this.drawBackground(),
        this.drawGrid(t),
        this.drawBorder(),
        this.drawTitle(),
        this.drawLabels(t))
    }
    _layers() {
        const t = this.options
          , n = t.ticks && t.ticks.z || 0
          , i = He(t.grid && t.grid.z, -1)
          , r = He(t.border && t.border.z, 0);
        return !this._isVisible() || this.draw !== ao.prototype.draw ? [{
            z: n,
            draw: s=>{
                this.draw(s)
            }
        }] : [{
            z: i,
            draw: s=>{
                this.drawBackground(),
                this.drawGrid(s),
                this.drawTitle()
            }
        }, {
            z: r,
            draw: ()=>{
                this.drawBorder()
            }
        }, {
            z: n,
            draw: s=>{
                this.drawLabels(s)
            }
        }]
    }
    getMatchingVisibleMetas(t) {
        const n = this.chart.getSortedVisibleDatasetMetas()
          , i = this.axis + "AxisID"
          , r = [];
        let s, o;
        for (s = 0,
        o = n.length; s < o; ++s) {
            const a = n[s];
            a[i] === this.id && (!t || a.type === t) && r.push(a)
        }
        return r
    }
    _resolveTickFontOptions(t) {
        const n = this.options.ticks.setContext(this.getContext(t));
        return Ht(n.font)
    }
    _maxDigits() {
        const t = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / t
    }
}
class Pu {
    constructor(t, n, i) {
        this.type = t,
        this.scope = n,
        this.override = i,
        this.items = Object.create(null)
    }
    isForType(t) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
    }
    register(t) {
        const n = Object.getPrototypeOf(t);
        let i;
        OU(n) && (i = this.register(n));
        const r = this.items
          , s = t.id
          , o = this.scope + "." + s;
        if (!s)
            throw new Error("class does not have id: " + t);
        return s in r || (r[s] = t,
        TU(t, o, i),
        this.override && Tt.override(t.id, t.overrides)),
        o
    }
    get(t) {
        return this.items[t]
    }
    unregister(t) {
        const n = this.items
          , i = t.id
          , r = this.scope;
        i in n && delete n[i],
        r && i in Tt[r] && (delete Tt[r][i],
        this.override && delete Zs[i])
    }
}
function TU(e, t, n) {
    const i = Jl(Object.create(null), [n ? Tt.get(n) : {}, Tt.get(t), e.defaults]);
    Tt.set(t, i),
    e.defaultRoutes && jU(t, e.defaultRoutes),
    e.descriptors && Tt.describe(t, e.descriptors)
}
function jU(e, t) {
    Object.keys(t).forEach(n=>{
        const i = n.split(".")
          , r = i.pop()
          , s = [e].concat(i).join(".")
          , o = t[n].split(".")
          , a = o.pop()
          , l = o.join(".");
        Tt.route(s, r, l, a)
    }
    )
}
function OU(e) {
    return "id"in e && "defaults"in e
}
class LU {
    constructor() {
        this.controllers = new Pu(na,"datasets",!0),
        this.elements = new Pu(as,"elements"),
        this.plugins = new Pu(Object,"plugins"),
        this.scales = new Pu(ao,"scales"),
        this._typedRegistries = [this.controllers, this.scales, this.elements]
    }
    add(...t) {
        this._each("register", t)
    }
    remove(...t) {
        this._each("unregister", t)
    }
    addControllers(...t) {
        this._each("register", t, this.controllers)
    }
    addElements(...t) {
        this._each("register", t, this.elements)
    }
    addPlugins(...t) {
        this._each("register", t, this.plugins)
    }
    addScales(...t) {
        this._each("register", t, this.scales)
    }
    getController(t) {
        return this._get(t, this.controllers, "controller")
    }
    getElement(t) {
        return this._get(t, this.elements, "element")
    }
    getPlugin(t) {
        return this._get(t, this.plugins, "plugin")
    }
    getScale(t) {
        return this._get(t, this.scales, "scale")
    }
    removeControllers(...t) {
        this._each("unregister", t, this.controllers)
    }
    removeElements(...t) {
        this._each("unregister", t, this.elements)
    }
    removePlugins(...t) {
        this._each("unregister", t, this.plugins)
    }
    removeScales(...t) {
        this._each("unregister", t, this.scales)
    }
    _each(t, n, i) {
        [...n].forEach(r=>{
            const s = i || this._getRegistryForType(r);
            i || s.isForType(r) || s === this.plugins && r.id ? this._exec(t, s, r) : Ze(r, o=>{
                const a = i || this._getRegistryForType(o);
                this._exec(t, a, o)
            }
            )
        }
        )
    }
    _exec(t, n, i) {
        const r = ev(t);
        at(i["before" + r], [], i),
        n[t](i),
        at(i["after" + r], [], i)
    }
    _getRegistryForType(t) {
        for (let n = 0; n < this._typedRegistries.length; n++) {
            const i = this._typedRegistries[n];
            if (i.isForType(t))
                return i
        }
        return this.plugins
    }
    _get(t, n, i) {
        const r = n.get(t);
        if (r === void 0)
            throw new Error('"' + t + '" is not a registered ' + i + ".");
        return r
    }
}
var Li = new LU;
class RU {
    constructor() {
        this._init = []
    }
    notify(t, n, i, r) {
        n === "beforeInit" && (this._init = this._createDescriptors(t, !0),
        this._notify(this._init, t, "install"));
        const s = r ? this._descriptors(t).filter(r) : this._descriptors(t)
          , o = this._notify(s, t, n, i);
        return n === "afterDestroy" && (this._notify(s, t, "stop"),
        this._notify(this._init, t, "uninstall")),
        o
    }
    _notify(t, n, i, r) {
        r = r || {};
        for (const s of t) {
            const o = s.plugin
              , a = o[i]
              , l = [n, r, s.options];
            if (at(a, l, o) === !1 && r.cancelable)
                return !1
        }
        return !0
    }
    invalidate() {
        ft(this._cache) || (this._oldCache = this._cache,
        this._cache = void 0)
    }
    _descriptors(t) {
        if (this._cache)
            return this._cache;
        const n = this._cache = this._createDescriptors(t);
        return this._notifyStateChanges(t),
        n
    }
    _createDescriptors(t, n) {
        const i = t && t.config
          , r = He(i.options && i.options.plugins, {})
          , s = _U(i);
        return r === !1 && !n ? [] : NU(t, s, r, n)
    }
    _notifyStateChanges(t) {
        const n = this._oldCache || []
          , i = this._cache
          , r = (s,o)=>s.filter(a=>!o.some(l=>a.plugin.id === l.plugin.id));
        this._notify(r(n, i), t, "stop"),
        this._notify(r(i, n), t, "start")
    }
}
function _U(e) {
    const t = {}
      , n = []
      , i = Object.keys(Li.plugins.items);
    for (let s = 0; s < i.length; s++)
        n.push(Li.getPlugin(i[s]));
    const r = e.plugins || [];
    for (let s = 0; s < r.length; s++) {
        const o = r[s];
        n.indexOf(o) === -1 && (n.push(o),
        t[o.id] = !0)
    }
    return {
        plugins: n,
        localIds: t
    }
}
function DU(e, t) {
    return !t && e === !1 ? null : e === !0 ? {} : e
}
function NU(e, {plugins: t, localIds: n}, i, r) {
    const s = []
      , o = e.getContext();
    for (const a of t) {
        const l = a.id
          , c = DU(i[l], r);
        c !== null && s.push({
            plugin: a,
            options: FU(e.config, {
                plugin: a,
                local: n[l]
            }, c, o)
        })
    }
    return s
}
function FU(e, {plugin: t, local: n}, i, r) {
    const s = e.pluginScopeKeys(t)
      , o = e.getOptionScopes(i, s);
    return n && t.defaults && o.push(t.defaults),
    e.createResolver(o, r, [""], {
        scriptable: !1,
        indexable: !1,
        allKeys: !0
    })
}
function Ng(e, t) {
    const n = Tt.datasets[e] || {};
    return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || n.indexAxis || "x"
}
function IU(e, t) {
    let n = e;
    return e === "_index_" ? n = t : e === "_value_" && (n = t === "x" ? "y" : "x"),
    n
}
function BU(e, t) {
    return e === t ? "_index_" : "_value_"
}
function Q6(e) {
    if (e === "x" || e === "y" || e === "r")
        return e
}
function zU(e) {
    if (e === "top" || e === "bottom")
        return "x";
    if (e === "left" || e === "right")
        return "y"
}
function Fg(e, ...t) {
    if (Q6(e))
        return e;
    for (const n of t) {
        const i = n.axis || zU(n.position) || e.length > 1 && Q6(e[0].toLowerCase());
        if (i)
            return i
    }
    throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`)
}
function q6(e, t, n) {
    if (n[t + "AxisID"] === e)
        return {
            axis: t
        }
}
function VU(e, t) {
    if (t.data && t.data.datasets) {
        const n = t.data.datasets.filter(i=>i.xAxisID === e || i.yAxisID === e);
        if (n.length)
            return q6(e, "x", n[0]) || q6(e, "y", n[0])
    }
    return {}
}
function WU(e, t) {
    const n = Zs[e.type] || {
        scales: {}
    }
      , i = t.scales || {}
      , r = Ng(e.type, t)
      , s = Object.create(null);
    return Object.keys(i).forEach(o=>{
        const a = i[o];
        if (!Xe(a))
            return console.error(`Invalid scale configuration for scale: ${o}`);
        if (a._proxy)
            return console.warn(`Ignoring resolver passed as options for scale: ${o}`);
        const l = Fg(o, a, VU(o, e), Tt.scales[a.type])
          , c = BU(l, r)
          , u = n.scales || {};
        s[o] = xl(Object.create(null), [{
            axis: l
        }, a, u[l], u[c]])
    }
    ),
    e.data.datasets.forEach(o=>{
        const a = o.type || e.type
          , l = o.indexAxis || Ng(a, t)
          , u = (Zs[a] || {}).scales || {};
        Object.keys(u).forEach(h=>{
            const d = IU(h, l)
              , m = o[d + "AxisID"] || d;
            s[m] = s[m] || Object.create(null),
            xl(s[m], [{
                axis: d
            }, i[m], u[h]])
        }
        )
    }
    ),
    Object.keys(s).forEach(o=>{
        const a = s[o];
        xl(a, [Tt.scales[a.type], Tt.scale])
    }
    ),
    s
}
function iA(e) {
    const t = e.options || (e.options = {});
    t.plugins = He(t.plugins, {}),
    t.scales = WU(e, t)
}
function rA(e) {
    return e = e || {},
    e.datasets = e.datasets || [],
    e.labels = e.labels || [],
    e
}
function HU(e) {
    return e = e || {},
    e.data = rA(e.data),
    iA(e),
    e
}
const Z6 = new Map
  , sA = new Set;
function Tu(e, t) {
    let n = Z6.get(e);
    return n || (n = t(),
    Z6.set(e, n),
    sA.add(n)),
    n
}
const Ga = (e,t,n)=>{
    const i = ec(t, n);
    i !== void 0 && e.add(i)
}
;
class UU {
    constructor(t) {
        this._config = HU(t),
        this._scopeCache = new Map,
        this._resolverCache = new Map
    }
    get platform() {
        return this._config.platform
    }
    get type() {
        return this._config.type
    }
    set type(t) {
        this._config.type = t
    }
    get data() {
        return this._config.data
    }
    set data(t) {
        this._config.data = rA(t)
    }
    get options() {
        return this._config.options
    }
    set options(t) {
        this._config.options = t
    }
    get plugins() {
        return this._config.plugins
    }
    update() {
        const t = this._config;
        this.clearCache(),
        iA(t)
    }
    clearCache() {
        this._scopeCache.clear(),
        this._resolverCache.clear()
    }
    datasetScopeKeys(t) {
        return Tu(t, ()=>[[`datasets.${t}`, ""]])
    }
    datasetAnimationScopeKeys(t, n) {
        return Tu(`${t}.transition.${n}`, ()=>[[`datasets.${t}.transitions.${n}`, `transitions.${n}`], [`datasets.${t}`, ""]])
    }
    datasetElementScopeKeys(t, n) {
        return Tu(`${t}-${n}`, ()=>[[`datasets.${t}.elements.${n}`, `datasets.${t}`, `elements.${n}`, ""]])
    }
    pluginScopeKeys(t) {
        const n = t.id
          , i = this.type;
        return Tu(`${i}-plugin-${n}`, ()=>[[`plugins.${n}`, ...t.additionalOptionScopes || []]])
    }
    _cachedScopes(t, n) {
        const i = this._scopeCache;
        let r = i.get(t);
        return (!r || n) && (r = new Map,
        i.set(t, r)),
        r
    }
    getOptionScopes(t, n, i) {
        const {options: r, type: s} = this
          , o = this._cachedScopes(t, i)
          , a = o.get(n);
        if (a)
            return a;
        const l = new Set;
        n.forEach(u=>{
            t && (l.add(t),
            u.forEach(h=>Ga(l, t, h))),
            u.forEach(h=>Ga(l, r, h)),
            u.forEach(h=>Ga(l, Zs[s] || {}, h)),
            u.forEach(h=>Ga(l, Tt, h)),
            u.forEach(h=>Ga(l, _g, h))
        }
        );
        const c = Array.from(l);
        return c.length === 0 && c.push(Object.create(null)),
        sA.has(n) && o.set(n, c),
        c
    }
    chartOptionScopes() {
        const {options: t, type: n} = this;
        return [t, Zs[n] || {}, Tt.datasets[n] || {}, {
            type: n
        }, Tt, _g]
    }
    resolveNamedOptions(t, n, i, r=[""]) {
        const s = {
            $shared: !0
        }
          , {resolver: o, subPrefixes: a} = J6(this._resolverCache, t, r);
        let l = o;
        if (XU(o, n)) {
            s.$shared = !1,
            i = Zr(i) ? i() : i;
            const c = this.createResolver(t, i, a);
            l = va(o, i, c)
        }
        for (const c of n)
            s[c] = l[c];
        return s
    }
    createResolver(t, n, i=[""], r) {
        const {resolver: s} = J6(this._resolverCache, t, i);
        return Xe(n) ? va(s, n, void 0, r) : s
    }
}
function J6(e, t, n) {
    let i = e.get(t);
    i || (i = new Map,
    e.set(t, i));
    const r = n.join();
    let s = i.get(r);
    return s || (s = {
        resolver: ov(t, n),
        subPrefixes: n.filter(a=>!a.toLowerCase().includes("hover"))
    },
    i.set(r, s)),
    s
}
const GU = e=>Xe(e) && Object.getOwnPropertyNames(e).reduce((t,n)=>t || Zr(e[n]), !1);
function XU(e, t) {
    const {isScriptable: n, isIndexable: i} = Bk(e);
    for (const r of t) {
        const s = n(r)
          , o = i(r)
          , a = (o || s) && e[r];
        if (s && (Zr(a) || GU(a)) || o && yt(a))
            return !0
    }
    return !1
}
var YU = "4.4.0";
const $U = ["top", "bottom", "left", "right", "chartArea"];
function e7(e, t) {
    return e === "top" || e === "bottom" || $U.indexOf(e) === -1 && t === "x"
}
function t7(e, t) {
    return function(n, i) {
        return n[e] === i[e] ? n[t] - i[t] : n[e] - i[e]
    }
}
function n7(e) {
    const t = e.chart
      , n = t.options.animation;
    t.notifyPlugins("afterRender"),
    at(n && n.onComplete, [e], t)
}
function KU(e) {
    const t = e.chart
      , n = t.options.animation;
    at(n && n.onProgress, [e], t)
}
function oA(e) {
    return Uk() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]),
    e && e.canvas && (e = e.canvas),
    e
}
const sh = {}
  , i7 = e=>{
    const t = oA(e);
    return Object.values(sh).filter(n=>n.canvas === t).pop()
}
;
function QU(e, t, n) {
    const i = Object.keys(e);
    for (const r of i) {
        const s = +r;
        if (s >= t) {
            const o = e[r];
            delete e[r],
            (n > 0 || s > t) && (e[s + n] = o)
        }
    }
}
function qU(e, t, n, i) {
    return !n || e.type === "mouseout" ? null : i ? t : e
}
function ju(e, t, n) {
    return e.options.clip ? e[n] : t[n]
}
function ZU(e, t) {
    const {xScale: n, yScale: i} = e;
    return n && i ? {
        left: ju(n, t, "left"),
        right: ju(n, t, "right"),
        top: ju(i, t, "top"),
        bottom: ju(i, t, "bottom")
    } : t
}
var yr;
let Ec = (yr = class {
    static register(...t) {
        Li.add(...t),
        r7()
    }
    static unregister(...t) {
        Li.remove(...t),
        r7()
    }
    constructor(t, n) {
        const i = this.config = new UU(n)
          , r = oA(t)
          , s = i7(r);
        if (s)
            throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas with ID '" + s.canvas.id + "' can be reused.");
        const o = i.createResolver(i.chartOptionScopes(), this.getContext());
        this.platform = new (i.platform || gU(r)),
        this.platform.updateConfig(i);
        const a = this.platform.acquireContext(r, o.aspectRatio)
          , l = a && a.canvas
          , c = l && l.height
          , u = l && l.width;
        if (this.id = aW(),
        this.ctx = a,
        this.canvas = l,
        this.width = u,
        this.height = c,
        this._options = o,
        this._aspectRatio = this.aspectRatio,
        this._layers = [],
        this._metasets = [],
        this._stacks = void 0,
        this.boxes = [],
        this.currentDevicePixelRatio = void 0,
        this.chartArea = void 0,
        this._active = [],
        this._lastEvent = void 0,
        this._listeners = {},
        this._responsiveListeners = void 0,
        this._sortedMetasets = [],
        this.scales = {},
        this._plugins = new RU,
        this.$proxies = {},
        this._hiddenIndices = {},
        this.attached = !1,
        this._animationsDisabled = void 0,
        this.$context = void 0,
        this._doResize = kW(h=>this.update(h), o.resizeDelay || 0),
        this._dataChanges = [],
        sh[this.id] = this,
        !a || !l) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return
        }
        Ki.listen(this, "complete", n7),
        Ki.listen(this, "progress", KU),
        this._initialize(),
        this.attached && this.update()
    }
    get aspectRatio() {
        const {options: {aspectRatio: t, maintainAspectRatio: n}, width: i, height: r, _aspectRatio: s} = this;
        return ft(t) ? n && s ? s : r ? i / r : null : t
    }
    get data() {
        return this.config.data
    }
    set data(t) {
        this.config.data = t
    }
    get options() {
        return this._options
    }
    set options(t) {
        this.config.options = t
    }
    get registry() {
        return Li
    }
    _initialize() {
        return this.notifyPlugins("beforeInit"),
        this.options.responsive ? this.resize() : P6(this, this.options.devicePixelRatio),
        this.bindEvents(),
        this.notifyPlugins("afterInit"),
        this
    }
    clear() {
        return A6(this.canvas, this.ctx),
        this
    }
    stop() {
        return Ki.stop(this),
        this
    }
    resize(t, n) {
        Ki.running(this) ? this._resizeBeforeDraw = {
            width: t,
            height: n
        } : this._resize(t, n)
    }
    _resize(t, n) {
        const i = this.options
          , r = this.canvas
          , s = i.maintainAspectRatio && this.aspectRatio
          , o = this.platform.getMaximumSize(r, t, n, s)
          , a = i.devicePixelRatio || this.platform.getDevicePixelRatio()
          , l = this.width ? "resize" : "attach";
        this.width = o.width,
        this.height = o.height,
        this._aspectRatio = this.aspectRatio,
        P6(this, a, !0) && (this.notifyPlugins("resize", {
            size: o
        }),
        at(i.onResize, [this, o], this),
        this.attached && this._doResize(l) && this.render())
    }
    ensureScalesHaveIDs() {
        const n = this.options.scales || {};
        Ze(n, (i,r)=>{
            i.id = r
        }
        )
    }
    buildOrUpdateScales() {
        const t = this.options
          , n = t.scales
          , i = this.scales
          , r = Object.keys(i).reduce((o,a)=>(o[a] = !1,
        o), {});
        let s = [];
        n && (s = s.concat(Object.keys(n).map(o=>{
            const a = n[o]
              , l = Fg(o, a)
              , c = l === "r"
              , u = l === "x";
            return {
                options: a,
                dposition: c ? "chartArea" : u ? "bottom" : "left",
                dtype: c ? "radialLinear" : u ? "category" : "linear"
            }
        }
        ))),
        Ze(s, o=>{
            const a = o.options
              , l = a.id
              , c = Fg(l, a)
              , u = He(a.type, o.dtype);
            (a.position === void 0 || e7(a.position, c) !== e7(o.dposition)) && (a.position = o.dposition),
            r[l] = !0;
            let h = null;
            if (l in i && i[l].type === u)
                h = i[l];
            else {
                const d = Li.getScale(u);
                h = new d({
                    id: l,
                    type: u,
                    ctx: this.ctx,
                    chart: this
                }),
                i[h.id] = h
            }
            h.init(a, t)
        }
        ),
        Ze(r, (o,a)=>{
            o || delete i[a]
        }
        ),
        Ze(i, o=>{
            ti.configure(this, o, o.options),
            ti.addBox(this, o)
        }
        )
    }
    _updateMetasets() {
        const t = this._metasets
          , n = this.data.datasets.length
          , i = t.length;
        if (t.sort((r,s)=>r.index - s.index),
        i > n) {
            for (let r = n; r < i; ++r)
                this._destroyDatasetMeta(r);
            t.splice(n, i - n)
        }
        this._sortedMetasets = t.slice(0).sort(t7("order", "index"))
    }
    _removeUnreferencedMetasets() {
        const {_metasets: t, data: {datasets: n}} = this;
        t.length > n.length && delete this._stacks,
        t.forEach((i,r)=>{
            n.filter(s=>s === i._dataset).length === 0 && this._destroyDatasetMeta(r)
        }
        )
    }
    buildOrUpdateControllers() {
        const t = []
          , n = this.data.datasets;
        let i, r;
        for (this._removeUnreferencedMetasets(),
        i = 0,
        r = n.length; i < r; i++) {
            const s = n[i];
            let o = this.getDatasetMeta(i);
            const a = s.type || this.config.type;
            if (o.type && o.type !== a && (this._destroyDatasetMeta(i),
            o = this.getDatasetMeta(i)),
            o.type = a,
            o.indexAxis = s.indexAxis || Ng(a, this.options),
            o.order = s.order || 0,
            o.index = i,
            o.label = "" + s.label,
            o.visible = this.isDatasetVisible(i),
            o.controller)
                o.controller.updateIndex(i),
                o.controller.linkScales();
            else {
                const l = Li.getController(a)
                  , {datasetElementType: c, dataElementType: u} = Tt.datasets[a];
                Object.assign(l, {
                    dataElementType: Li.getElement(u),
                    datasetElementType: c && Li.getElement(c)
                }),
                o.controller = new l(this,i),
                t.push(o.controller)
            }
        }
        return this._updateMetasets(),
        t
    }
    _resetElements() {
        Ze(this.data.datasets, (t,n)=>{
            this.getDatasetMeta(n).controller.reset()
        }
        , this)
    }
    reset() {
        this._resetElements(),
        this.notifyPlugins("reset")
    }
    update(t) {
        const n = this.config;
        n.update();
        const i = this._options = n.createResolver(n.chartOptionScopes(), this.getContext())
          , r = this._animationsDisabled = !i.animation;
        if (this._updateScales(),
        this._checkEventBindings(),
        this._updateHiddenIndices(),
        this._plugins.invalidate(),
        this.notifyPlugins("beforeUpdate", {
            mode: t,
            cancelable: !0
        }) === !1)
            return;
        const s = this.buildOrUpdateControllers();
        this.notifyPlugins("beforeElementsUpdate");
        let o = 0;
        for (let c = 0, u = this.data.datasets.length; c < u; c++) {
            const {controller: h} = this.getDatasetMeta(c)
              , d = !r && s.indexOf(h) === -1;
            h.buildOrUpdateElements(d),
            o = Math.max(+h.getMaxOverflow(), o)
        }
        o = this._minPadding = i.layout.autoPadding ? o : 0,
        this._updateLayout(o),
        r || Ze(s, c=>{
            c.reset()
        }
        ),
        this._updateDatasets(t),
        this.notifyPlugins("afterUpdate", {
            mode: t
        }),
        this._layers.sort(t7("z", "_idx"));
        const {_active: a, _lastEvent: l} = this;
        l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0),
        this.render()
    }
    _updateScales() {
        Ze(this.scales, t=>{
            ti.removeBox(this, t)
        }
        ),
        this.ensureScalesHaveIDs(),
        this.buildOrUpdateScales()
    }
    _checkEventBindings() {
        const t = this.options
          , n = new Set(Object.keys(this._listeners))
          , i = new Set(t.events);
        (!m6(n, i) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(),
        this.bindEvents())
    }
    _updateHiddenIndices() {
        const {_hiddenIndices: t} = this
          , n = this._getUniformDataChanges() || [];
        for (const {method: i, start: r, count: s} of n) {
            const o = i === "_removeElements" ? -s : s;
            QU(t, r, o)
        }
    }
    _getUniformDataChanges() {
        const t = this._dataChanges;
        if (!t || !t.length)
            return;
        this._dataChanges = [];
        const n = this.data.datasets.length
          , i = s=>new Set(t.filter(o=>o[0] === s).map((o,a)=>a + "," + o.splice(1).join(",")))
          , r = i(0);
        for (let s = 1; s < n; s++)
            if (!m6(r, i(s)))
                return;
        return Array.from(r).map(s=>s.split(",")).map(s=>({
            method: s[1],
            start: +s[2],
            count: +s[3]
        }))
    }
    _updateLayout(t) {
        if (this.notifyPlugins("beforeLayout", {
            cancelable: !0
        }) === !1)
            return;
        ti.update(this, this.width, this.height, t);
        const n = this.chartArea
          , i = n.width <= 0 || n.height <= 0;
        this._layers = [],
        Ze(this.boxes, r=>{
            i && r.position === "chartArea" || (r.configure && r.configure(),
            this._layers.push(...r._layers()))
        }
        , this),
        this._layers.forEach((r,s)=>{
            r._idx = s
        }
        ),
        this.notifyPlugins("afterLayout")
    }
    _updateDatasets(t) {
        if (this.notifyPlugins("beforeDatasetsUpdate", {
            mode: t,
            cancelable: !0
        }) !== !1) {
            for (let n = 0, i = this.data.datasets.length; n < i; ++n)
                this.getDatasetMeta(n).controller.configure();
            for (let n = 0, i = this.data.datasets.length; n < i; ++n)
                this._updateDataset(n, Zr(t) ? t({
                    datasetIndex: n
                }) : t);
            this.notifyPlugins("afterDatasetsUpdate", {
                mode: t
            })
        }
    }
    _updateDataset(t, n) {
        const i = this.getDatasetMeta(t)
          , r = {
            meta: i,
            index: t,
            mode: n,
            cancelable: !0
        };
        this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (i.controller._update(n),
        r.cancelable = !1,
        this.notifyPlugins("afterDatasetUpdate", r))
    }
    render() {
        this.notifyPlugins("beforeRender", {
            cancelable: !0
        }) !== !1 && (Ki.has(this) ? this.attached && !Ki.running(this) && Ki.start(this) : (this.draw(),
        n7({
            chart: this
        })))
    }
    draw() {
        let t;
        if (this._resizeBeforeDraw) {
            const {width: i, height: r} = this._resizeBeforeDraw;
            this._resize(i, r),
            this._resizeBeforeDraw = null
        }
        if (this.clear(),
        this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
            cancelable: !0
        }) === !1)
            return;
        const n = this._layers;
        for (t = 0; t < n.length && n[t].z <= 0; ++t)
            n[t].draw(this.chartArea);
        for (this._drawDatasets(); t < n.length; ++t)
            n[t].draw(this.chartArea);
        this.notifyPlugins("afterDraw")
    }
    _getSortedDatasetMetas(t) {
        const n = this._sortedMetasets
          , i = [];
        let r, s;
        for (r = 0,
        s = n.length; r < s; ++r) {
            const o = n[r];
            (!t || o.visible) && i.push(o)
        }
        return i
    }
    getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(!0)
    }
    _drawDatasets() {
        if (this.notifyPlugins("beforeDatasetsDraw", {
            cancelable: !0
        }) === !1)
            return;
        const t = this.getSortedVisibleDatasetMetas();
        for (let n = t.length - 1; n >= 0; --n)
            this._drawDataset(t[n]);
        this.notifyPlugins("afterDatasetsDraw")
    }
    _drawDataset(t) {
        const n = this.ctx
          , i = t._clip
          , r = !i.disabled
          , s = ZU(t, this.chartArea)
          , o = {
            meta: t,
            index: t.index,
            cancelable: !0
        };
        this.notifyPlugins("beforeDatasetDraw", o) !== !1 && (r && af(n, {
            left: i.left === !1 ? 0 : s.left - i.left,
            right: i.right === !1 ? this.width : s.right + i.right,
            top: i.top === !1 ? 0 : s.top - i.top,
            bottom: i.bottom === !1 ? this.height : s.bottom + i.bottom
        }),
        t.controller.draw(),
        r && lf(n),
        o.cancelable = !1,
        this.notifyPlugins("afterDatasetDraw", o))
    }
    isPointInArea(t) {
        return rr(t, this.chartArea, this._minPadding)
    }
    getElementsAtEventForMode(t, n, i, r) {
        const s = $H.modes[n];
        return typeof s == "function" ? s(this, t, i, r) : []
    }
    getDatasetMeta(t) {
        const n = this.data.datasets[t]
          , i = this._metasets;
        let r = i.filter(s=>s && s._dataset === n).pop();
        return r || (r = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: n && n.order || 0,
            index: t,
            _dataset: n,
            _parsed: [],
            _sorted: !1
        },
        i.push(r)),
        r
    }
    getContext() {
        return this.$context || (this.$context = os(null, {
            chart: this,
            type: "chart"
        }))
    }
    getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length
    }
    isDatasetVisible(t) {
        const n = this.data.datasets[t];
        if (!n)
            return !1;
        const i = this.getDatasetMeta(t);
        return typeof i.hidden == "boolean" ? !i.hidden : !n.hidden
    }
    setDatasetVisibility(t, n) {
        const i = this.getDatasetMeta(t);
        i.hidden = !n
    }
    toggleDataVisibility(t) {
        this._hiddenIndices[t] = !this._hiddenIndices[t]
    }
    getDataVisibility(t) {
        return !this._hiddenIndices[t]
    }
    _updateVisibility(t, n, i) {
        const r = i ? "show" : "hide"
          , s = this.getDatasetMeta(t)
          , o = s.controller._resolveAnimations(void 0, r);
        td(n) ? (s.data[n].hidden = !i,
        this.update()) : (this.setDatasetVisibility(t, i),
        o.update(s, {
            visible: i
        }),
        this.update(a=>a.datasetIndex === t ? r : void 0))
    }
    hide(t, n) {
        this._updateVisibility(t, n, !1)
    }
    show(t, n) {
        this._updateVisibility(t, n, !0)
    }
    _destroyDatasetMeta(t) {
        const n = this._metasets[t];
        n && n.controller && n.controller._destroy(),
        delete this._metasets[t]
    }
    _stop() {
        let t, n;
        for (this.stop(),
        Ki.remove(this),
        t = 0,
        n = this.data.datasets.length; t < n; ++t)
            this._destroyDatasetMeta(t)
    }
    destroy() {
        this.notifyPlugins("beforeDestroy");
        const {canvas: t, ctx: n} = this;
        this._stop(),
        this.config.clearCache(),
        t && (this.unbindEvents(),
        A6(t, n),
        this.platform.releaseContext(n),
        this.canvas = null,
        this.ctx = null),
        delete sh[this.id],
        this.notifyPlugins("afterDestroy")
    }
    toBase64Image(...t) {
        return this.canvas.toDataURL(...t)
    }
    bindEvents() {
        this.bindUserEvents(),
        this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
    }
    bindUserEvents() {
        const t = this._listeners
          , n = this.platform
          , i = (s,o)=>{
            n.addEventListener(this, s, o),
            t[s] = o
        }
          , r = (s,o,a)=>{
            s.offsetX = o,
            s.offsetY = a,
            this._eventHandler(s)
        }
        ;
        Ze(this.options.events, s=>i(s, r))
    }
    bindResponsiveEvents() {
        this._responsiveListeners || (this._responsiveListeners = {});
        const t = this._responsiveListeners
          , n = this.platform
          , i = (l,c)=>{
            n.addEventListener(this, l, c),
            t[l] = c
        }
          , r = (l,c)=>{
            t[l] && (n.removeEventListener(this, l, c),
            delete t[l])
        }
          , s = (l,c)=>{
            this.canvas && this.resize(l, c)
        }
        ;
        let o;
        const a = ()=>{
            r("attach", a),
            this.attached = !0,
            this.resize(),
            i("resize", s),
            i("detach", o)
        }
        ;
        o = ()=>{
            this.attached = !1,
            r("resize", s),
            this._stop(),
            this._resize(0, 0),
            i("attach", a)
        }
        ,
        n.isAttached(this.canvas) ? a() : o()
    }
    unbindEvents() {
        Ze(this._listeners, (t,n)=>{
            this.platform.removeEventListener(this, n, t)
        }
        ),
        this._listeners = {},
        Ze(this._responsiveListeners, (t,n)=>{
            this.platform.removeEventListener(this, n, t)
        }
        ),
        this._responsiveListeners = void 0
    }
    updateHoverStyle(t, n, i) {
        const r = i ? "set" : "remove";
        let s, o, a, l;
        for (n === "dataset" && (s = this.getDatasetMeta(t[0].datasetIndex),
        s.controller["_" + r + "DatasetHoverStyle"]()),
        a = 0,
        l = t.length; a < l; ++a) {
            o = t[a];
            const c = o && this.getDatasetMeta(o.datasetIndex).controller;
            c && c[r + "HoverStyle"](o.element, o.datasetIndex, o.index)
        }
    }
    getActiveElements() {
        return this._active || []
    }
    setActiveElements(t) {
        const n = this._active || []
          , i = t.map(({datasetIndex: s, index: o})=>{
            const a = this.getDatasetMeta(s);
            if (!a)
                throw new Error("No dataset found at index " + s);
            return {
                datasetIndex: s,
                element: a.data[o],
                index: o
            }
        }
        );
        !Jh(i, n) && (this._active = i,
        this._lastEvent = null,
        this._updateHoverStyles(i, n))
    }
    notifyPlugins(t, n, i) {
        return this._plugins.notify(this, t, n, i)
    }
    isPluginEnabled(t) {
        return this._plugins._cache.filter(n=>n.plugin.id === t).length === 1
    }
    _updateHoverStyles(t, n, i) {
        const r = this.options.hover
          , s = (l,c)=>l.filter(u=>!c.some(h=>u.datasetIndex === h.datasetIndex && u.index === h.index))
          , o = s(n, t)
          , a = i ? t : s(t, n);
        o.length && this.updateHoverStyle(o, r.mode, !1),
        a.length && r.mode && this.updateHoverStyle(a, r.mode, !0)
    }
    _eventHandler(t, n) {
        const i = {
            event: t,
            replay: n,
            cancelable: !0,
            inChartArea: this.isPointInArea(t)
        }
          , r = o=>(o.options.events || this.options.events).includes(t.native.type);
        if (this.notifyPlugins("beforeEvent", i, r) === !1)
            return;
        const s = this._handleEvent(t, n, i.inChartArea);
        return i.cancelable = !1,
        this.notifyPlugins("afterEvent", i, r),
        (s || i.changed) && this.render(),
        this
    }
    _handleEvent(t, n, i) {
        const {_active: r=[], options: s} = this
          , o = n
          , a = this._getActiveElements(t, r, i, o)
          , l = fW(t)
          , c = qU(t, this._lastEvent, i, l);
        i && (this._lastEvent = null,
        at(s.onHover, [t, a, this], this),
        l && at(s.onClick, [t, a, this], this));
        const u = !Jh(a, r);
        return (u || n) && (this._active = a,
        this._updateHoverStyles(a, r, n)),
        this._lastEvent = c,
        u
    }
    _getActiveElements(t, n, i, r) {
        if (t.type === "mouseout")
            return [];
        if (!i)
            return n;
        const s = this.options.hover;
        return this.getElementsAtEventForMode(t, s.mode, s, r)
    }
}
,
je(yr, "defaults", Tt),
je(yr, "instances", sh),
je(yr, "overrides", Zs),
je(yr, "registry", Li),
je(yr, "version", YU),
je(yr, "getChart", i7),
yr);
function r7() {
    return Ze(Ec.instances, e=>e._plugins.invalidate())
}
function JU(e, t, n) {
    const {startAngle: i, pixelMargin: r, x: s, y: o, outerRadius: a, innerRadius: l} = t;
    let c = r / a;
    e.beginPath(),
    e.arc(s, o, a, i - c, n + c),
    l > r ? (c = r / l,
    e.arc(s, o, l, n + c, i - c, !0)) : e.arc(s, o, r, n + Rt, i - Rt),
    e.closePath(),
    e.clip()
}
function eG(e) {
    return sv(e, ["outerStart", "outerEnd", "innerStart", "innerEnd"])
}
function tG(e, t, n, i) {
    const r = eG(e.options.borderRadius)
      , s = (n - t) / 2
      , o = Math.min(s, i * t / 2)
      , a = l=>{
        const c = (n - Math.min(s, l)) * i / 2;
        return gn(l, 0, Math.min(s, c))
    }
    ;
    return {
        outerStart: a(r.outerStart),
        outerEnd: a(r.outerEnd),
        innerStart: gn(r.innerStart, 0, o),
        innerEnd: gn(r.innerEnd, 0, o)
    }
}
function Co(e, t, n, i) {
    return {
        x: n + e * Math.cos(t),
        y: i + e * Math.sin(t)
    }
}
function ad(e, t, n, i, r, s) {
    const {x: o, y: a, startAngle: l, pixelMargin: c, innerRadius: u} = t
      , h = Math.max(t.outerRadius + i + n - c, 0)
      , d = u > 0 ? u + i + n + c : 0;
    let m = 0;
    const f = r - l;
    if (i) {
        const w = u > 0 ? u - i : 0
          , b = h > 0 ? h - i : 0
          , A = (w + b) / 2
          , j = A !== 0 ? f * A / (A + i) : f;
        m = (f - j) / 2
    }
    const x = Math.max(.001, f * h - n / xt) / h
      , S = (f - x) / 2
      , v = l + S + m
      , p = r - S - m
      , {outerStart: g, outerEnd: C, innerStart: E, innerEnd: O} = tG(t, d, h, p - v)
      , R = h - g
      , F = h - C
      , P = v + g / R
      , _ = p - C / F
      , T = d + E
      , L = d + O
      , I = v + E / T
      , k = p - O / L;
    if (e.beginPath(),
    s) {
        const w = (P + _) / 2;
        if (e.arc(o, a, h, P, w),
        e.arc(o, a, h, w, _),
        C > 0) {
            const B = Co(F, _, o, a);
            e.arc(B.x, B.y, C, _, p + Rt)
        }
        const b = Co(L, p, o, a);
        if (e.lineTo(b.x, b.y),
        O > 0) {
            const B = Co(L, k, o, a);
            e.arc(B.x, B.y, O, p + Rt, k + Math.PI)
        }
        const A = (p - O / d + (v + E / d)) / 2;
        if (e.arc(o, a, d, p - O / d, A, !0),
        e.arc(o, a, d, A, v + E / d, !0),
        E > 0) {
            const B = Co(T, I, o, a);
            e.arc(B.x, B.y, E, I + Math.PI, v - Rt)
        }
        const j = Co(R, v, o, a);
        if (e.lineTo(j.x, j.y),
        g > 0) {
            const B = Co(R, P, o, a);
            e.arc(B.x, B.y, g, v - Rt, P)
        }
    } else {
        e.moveTo(o, a);
        const w = Math.cos(P) * h + o
          , b = Math.sin(P) * h + a;
        e.lineTo(w, b);
        const A = Math.cos(_) * h + o
          , j = Math.sin(_) * h + a;
        e.lineTo(A, j)
    }
    e.closePath()
}
function nG(e, t, n, i, r) {
    const {fullCircles: s, startAngle: o, circumference: a} = t;
    let l = t.endAngle;
    if (s) {
        ad(e, t, n, i, l, r);
        for (let c = 0; c < s; ++c)
            e.fill();
        isNaN(a) || (l = o + (a % mt || mt))
    }
    return ad(e, t, n, i, l, r),
    e.fill(),
    l
}
function iG(e, t, n, i, r) {
    const {fullCircles: s, startAngle: o, circumference: a, options: l} = t
      , {borderWidth: c, borderJoinStyle: u, borderDash: h, borderDashOffset: d} = l
      , m = l.borderAlign === "inner";
    if (!c)
        return;
    e.setLineDash(h || []),
    e.lineDashOffset = d,
    m ? (e.lineWidth = c * 2,
    e.lineJoin = u || "round") : (e.lineWidth = c,
    e.lineJoin = u || "bevel");
    let f = t.endAngle;
    if (s) {
        ad(e, t, n, i, f, r);
        for (let x = 0; x < s; ++x)
            e.stroke();
        isNaN(a) || (f = o + (a % mt || mt))
    }
    m && JU(e, t, f),
    s || (ad(e, t, n, i, f, r),
    e.stroke())
}
class tl extends as {
    constructor(n) {
        super();
        je(this, "circumference");
        je(this, "endAngle");
        je(this, "fullCircles");
        je(this, "innerRadius");
        je(this, "outerRadius");
        je(this, "pixelMargin");
        je(this, "startAngle");
        this.options = void 0,
        this.circumference = void 0,
        this.startAngle = void 0,
        this.endAngle = void 0,
        this.innerRadius = void 0,
        this.outerRadius = void 0,
        this.pixelMargin = 0,
        this.fullCircles = 0,
        n && Object.assign(this, n)
    }
    inRange(n, i, r) {
        const s = this.getProps(["x", "y"], r)
          , {angle: o, distance: a} = Rk(s, {
            x: n,
            y: i
        })
          , {startAngle: l, endAngle: c, innerRadius: u, outerRadius: h, circumference: d} = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], r)
          , m = (this.options.spacing + this.options.borderWidth) / 2
          , x = He(d, c - l) >= mt || nc(o, l, c)
          , S = Is(a, u + m, h + m);
        return x && S
    }
    getCenterPoint(n) {
        const {x: i, y: r, startAngle: s, endAngle: o, innerRadius: a, outerRadius: l} = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], n)
          , {offset: c, spacing: u} = this.options
          , h = (s + o) / 2
          , d = (a + l + u + c) / 2;
        return {
            x: i + Math.cos(h) * d,
            y: r + Math.sin(h) * d
        }
    }
    tooltipPosition(n) {
        return this.getCenterPoint(n)
    }
    draw(n) {
        const {options: i, circumference: r} = this
          , s = (i.offset || 0) / 4
          , o = (i.spacing || 0) / 2
          , a = i.circular;
        if (this.pixelMargin = i.borderAlign === "inner" ? .33 : 0,
        this.fullCircles = r > mt ? Math.floor(r / mt) : 0,
        r === 0 || this.innerRadius < 0 || this.outerRadius < 0)
            return;
        n.save();
        const l = (this.startAngle + this.endAngle) / 2;
        n.translate(Math.cos(l) * s, Math.sin(l) * s);
        const c = 1 - Math.sin(Math.min(xt, r || 0))
          , u = s * c;
        n.fillStyle = i.backgroundColor,
        n.strokeStyle = i.borderColor,
        nG(n, this, u, o, a),
        iG(n, this, u, o, a),
        n.restore()
    }
}
je(tl, "id", "arc"),
je(tl, "defaults", {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: !0
}),
je(tl, "defaultRoutes", {
    backgroundColor: "backgroundColor"
}),
je(tl, "descriptors", {
    _scriptable: !0,
    _indexable: n=>n !== "borderDash"
});
function aA(e, t, n=t) {
    e.lineCap = He(n.borderCapStyle, t.borderCapStyle),
    e.setLineDash(He(n.borderDash, t.borderDash)),
    e.lineDashOffset = He(n.borderDashOffset, t.borderDashOffset),
    e.lineJoin = He(n.borderJoinStyle, t.borderJoinStyle),
    e.lineWidth = He(n.borderWidth, t.borderWidth),
    e.strokeStyle = He(n.borderColor, t.borderColor)
}
function rG(e, t, n) {
    e.lineTo(n.x, n.y)
}
function sG(e) {
    return e.stepped ? IW : e.tension || e.cubicInterpolationMode === "monotone" ? BW : rG
}
function lA(e, t, n={}) {
    const i = e.length
      , {start: r=0, end: s=i - 1} = n
      , {start: o, end: a} = t
      , l = Math.max(r, o)
      , c = Math.min(s, a)
      , u = r < o && s < o || r > a && s > a;
    return {
        count: i,
        start: l,
        loop: t.loop,
        ilen: c < l && !u ? i + c - l : c - l
    }
}
function oG(e, t, n, i) {
    const {points: r, options: s} = t
      , {count: o, start: a, loop: l, ilen: c} = lA(r, n, i)
      , u = sG(s);
    let {move: h=!0, reverse: d} = i || {}, m, f, x;
    for (m = 0; m <= c; ++m)
        f = r[(a + (d ? c - m : m)) % o],
        !f.skip && (h ? (e.moveTo(f.x, f.y),
        h = !1) : u(e, x, f, d, s.stepped),
        x = f);
    return l && (f = r[(a + (d ? c : 0)) % o],
    u(e, x, f, d, s.stepped)),
    !!l
}
function aG(e, t, n, i) {
    const r = t.points
      , {count: s, start: o, ilen: a} = lA(r, n, i)
      , {move: l=!0, reverse: c} = i || {};
    let u = 0, h = 0, d, m, f, x, S, v;
    const p = C=>(o + (c ? a - C : C)) % s
      , g = ()=>{
        x !== S && (e.lineTo(u, S),
        e.lineTo(u, x),
        e.lineTo(u, v))
    }
    ;
    for (l && (m = r[p(0)],
    e.moveTo(m.x, m.y)),
    d = 0; d <= a; ++d) {
        if (m = r[p(d)],
        m.skip)
            continue;
        const C = m.x
          , E = m.y
          , O = C | 0;
        O === f ? (E < x ? x = E : E > S && (S = E),
        u = (h * u + C) / ++h) : (g(),
        e.lineTo(C, E),
        f = O,
        h = 0,
        x = S = E),
        v = E
    }
    g()
}
function Ig(e) {
    const t = e.options
      , n = t.borderDash && t.borderDash.length;
    return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !n ? aG : oG
}
function lG(e) {
    return e.stepped ? yH : e.tension || e.cubicInterpolationMode === "monotone" ? xH : Ps
}
function cG(e, t, n, i) {
    let r = t._path;
    r || (r = t._path = new Path2D,
    t.path(r, n, i) && r.closePath()),
    aA(e, t.options),
    e.stroke(r)
}
function uG(e, t, n, i) {
    const {segments: r, options: s} = t
      , o = Ig(t);
    for (const a of r)
        aA(e, s, a.style),
        e.beginPath(),
        o(e, t, a, {
            start: n,
            end: n + i - 1
        }) && e.closePath(),
        e.stroke()
}
const hG = typeof Path2D == "function";
function dG(e, t, n, i) {
    hG && !t.options.segment ? cG(e, t, n, i) : uG(e, t, n, i)
}
class Rr extends as {
    constructor(t) {
        super(),
        this.animated = !0,
        this.options = void 0,
        this._chart = void 0,
        this._loop = void 0,
        this._fullLoop = void 0,
        this._path = void 0,
        this._points = void 0,
        this._segments = void 0,
        this._decimated = !1,
        this._pointsUpdated = !1,
        this._datasetIndex = void 0,
        t && Object.assign(this, t)
    }
    updateControlPoints(t, n) {
        const i = this.options;
        if ((i.tension || i.cubicInterpolationMode === "monotone") && !i.stepped && !this._pointsUpdated) {
            const r = i.spanGaps ? this._loop : this._fullLoop;
            uH(this._points, i, t, r, n),
            this._pointsUpdated = !0
        }
    }
    set points(t) {
        this._points = t,
        delete this._segments,
        delete this._path,
        this._pointsUpdated = !1
    }
    get points() {
        return this._points
    }
    get segments() {
        return this._segments || (this._segments = AH(this, this.options.segment))
    }
    first() {
        const t = this.segments
          , n = this.points;
        return t.length && n[t[0].start]
    }
    last() {
        const t = this.segments
          , n = this.points
          , i = t.length;
        return i && n[t[i - 1].end]
    }
    interpolate(t, n) {
        const i = this.options
          , r = t[n]
          , s = this.points
          , o = Kk(this, {
            property: n,
            start: r,
            end: r
        });
        if (!o.length)
            return;
        const a = []
          , l = lG(i);
        let c, u;
        for (c = 0,
        u = o.length; c < u; ++c) {
            const {start: h, end: d} = o[c]
              , m = s[h]
              , f = s[d];
            if (m === f) {
                a.push(m);
                continue
            }
            const x = Math.abs((r - m[n]) / (f[n] - m[n]))
              , S = l(m, f, x, i.stepped);
            S[n] = t[n],
            a.push(S)
        }
        return a.length === 1 ? a[0] : a
    }
    pathSegment(t, n, i) {
        return Ig(this)(t, this, n, i)
    }
    path(t, n, i) {
        const r = this.segments
          , s = Ig(this);
        let o = this._loop;
        n = n || 0,
        i = i || this.points.length - n;
        for (const a of r)
            o &= s(t, this, a, {
                start: n,
                end: n + i - 1
            });
        return !!o
    }
    draw(t, n, i, r) {
        const s = this.options || {};
        (this.points || []).length && s.borderWidth && (t.save(),
        dG(t, this, i, r),
        t.restore()),
        this.animated && (this._pointsUpdated = !1,
        this._path = void 0)
    }
}
je(Rr, "id", "line"),
je(Rr, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
}),
je(Rr, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
}),
je(Rr, "descriptors", {
    _scriptable: !0,
    _indexable: t=>t !== "borderDash" && t !== "fill"
});
function s7(e, t, n, i) {
    const r = e.options
      , {[n]: s} = e.getProps([n], i);
    return Math.abs(t - s) < r.radius + r.hitRadius
}
class oh extends as {
    constructor(n) {
        super();
        je(this, "parsed");
        je(this, "skip");
        je(this, "stop");
        this.options = void 0,
        this.parsed = void 0,
        this.skip = void 0,
        this.stop = void 0,
        n && Object.assign(this, n)
    }
    inRange(n, i, r) {
        const s = this.options
          , {x: o, y: a} = this.getProps(["x", "y"], r);
        return Math.pow(n - o, 2) + Math.pow(i - a, 2) < Math.pow(s.hitRadius + s.radius, 2)
    }
    inXRange(n, i) {
        return s7(this, n, "x", i)
    }
    inYRange(n, i) {
        return s7(this, n, "y", i)
    }
    getCenterPoint(n) {
        const {x: i, y: r} = this.getProps(["x", "y"], n);
        return {
            x: i,
            y: r
        }
    }
    size(n) {
        n = n || this.options || {};
        let i = n.radius || 0;
        i = Math.max(i, i && n.hoverRadius || 0);
        const r = i && n.borderWidth || 0;
        return (i + r) * 2
    }
    draw(n, i) {
        const r = this.options;
        this.skip || r.radius < .1 || !rr(this, i, this.size(r) / 2) || (n.strokeStyle = r.borderColor,
        n.lineWidth = r.borderWidth,
        n.fillStyle = r.backgroundColor,
        Dg(n, r, this.x, this.y))
    }
    getRange() {
        const n = this.options || {};
        return n.radius + n.hitRadius
    }
}
je(oh, "id", "point"),
je(oh, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
}),
je(oh, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
});
function fG(e, t, n) {
    const i = e.segments
      , r = e.points
      , s = t.points
      , o = [];
    for (const a of i) {
        let {start: l, end: c} = a;
        c = hv(l, c, r);
        const u = Bg(n, r[l], r[c], a.loop);
        if (!t.segments) {
            o.push({
                source: a,
                target: u,
                start: r[l],
                end: r[c]
            });
            continue
        }
        const h = Kk(t, u);
        for (const d of h) {
            const m = Bg(n, s[d.start], s[d.end], d.loop)
              , f = $k(a, r, m);
            for (const x of f)
                o.push({
                    source: x,
                    target: d,
                    start: {
                        [n]: o7(u, m, "start", Math.max)
                    },
                    end: {
                        [n]: o7(u, m, "end", Math.min)
                    }
                })
        }
    }
    return o
}
function Bg(e, t, n, i) {
    if (i)
        return;
    let r = t[e]
      , s = n[e];
    return e === "angle" && (r = Nn(r),
    s = Nn(s)),
    {
        property: e,
        start: r,
        end: s
    }
}
function pG(e, t) {
    const {x: n=null, y: i=null} = e || {}
      , r = t.points
      , s = [];
    return t.segments.forEach(({start: o, end: a})=>{
        a = hv(o, a, r);
        const l = r[o]
          , c = r[a];
        i !== null ? (s.push({
            x: l.x,
            y: i
        }),
        s.push({
            x: c.x,
            y: i
        })) : n !== null && (s.push({
            x: n,
            y: l.y
        }),
        s.push({
            x: n,
            y: c.y
        }))
    }
    ),
    s
}
function hv(e, t, n) {
    for (; t > e; t--) {
        const i = n[t];
        if (!isNaN(i.x) && !isNaN(i.y))
            break
    }
    return t
}
function o7(e, t, n, i) {
    return e && t ? i(e[n], t[n]) : e ? e[n] : t ? t[n] : 0
}
function cA(e, t) {
    let n = []
      , i = !1;
    return yt(e) ? (i = !0,
    n = e) : n = pG(e, t),
    n.length ? new Rr({
        points: n,
        options: {
            tension: 0
        },
        _loop: i,
        _fullLoop: i
    }) : null
}
function a7(e) {
    return e && e.fill !== !1
}
function gG(e, t, n) {
    let r = e[t].fill;
    const s = [t];
    let o;
    if (!n)
        return r;
    for (; r !== !1 && s.indexOf(r) === -1; ) {
        if (!Pt(r))
            return r;
        if (o = e[r],
        !o)
            return !1;
        if (o.visible)
            return r;
        s.push(r),
        r = o.fill
    }
    return !1
}
function mG(e, t, n) {
    const i = bG(e);
    if (Xe(i))
        return isNaN(i.value) ? !1 : i;
    let r = parseFloat(i);
    return Pt(r) && Math.floor(r) === r ? vG(i[0], t, r, n) : ["origin", "start", "end", "stack", "shape"].indexOf(i) >= 0 && i
}
function vG(e, t, n, i) {
    return (e === "-" || e === "+") && (n = t + n),
    n === t || n < 0 || n >= i ? !1 : n
}
function yG(e, t) {
    let n = null;
    return e === "start" ? n = t.bottom : e === "end" ? n = t.top : Xe(e) ? n = t.getPixelForValue(e.value) : t.getBasePixel && (n = t.getBasePixel()),
    n
}
function xG(e, t, n) {
    let i;
    return e === "start" ? i = n : e === "end" ? i = t.options.reverse ? t.min : t.max : Xe(e) ? i = e.value : i = t.getBaseValue(),
    i
}
function bG(e) {
    const t = e.options
      , n = t.fill;
    let i = He(n && n.target, n);
    return i === void 0 && (i = !!t.backgroundColor),
    i === !1 || i === null ? !1 : i === !0 ? "origin" : i
}
function wG(e) {
    const {scale: t, index: n, line: i} = e
      , r = []
      , s = i.segments
      , o = i.points
      , a = SG(t, n);
    a.push(cA({
        x: null,
        y: t.bottom
    }, i));
    for (let l = 0; l < s.length; l++) {
        const c = s[l];
        for (let u = c.start; u <= c.end; u++)
            CG(r, o[u], a)
    }
    return new Rr({
        points: r,
        options: {}
    })
}
function SG(e, t) {
    const n = []
      , i = e.getMatchingVisibleMetas("line");
    for (let r = 0; r < i.length; r++) {
        const s = i[r];
        if (s.index === t)
            break;
        s.hidden || n.unshift(s.dataset)
    }
    return n
}
function CG(e, t, n) {
    const i = [];
    for (let r = 0; r < n.length; r++) {
        const s = n[r]
          , {first: o, last: a, point: l} = kG(s, t, "x");
        if (!(!l || o && a)) {
            if (o)
                i.unshift(l);
            else if (e.push(l),
            !a)
                break
        }
    }
    e.push(...i)
}
function kG(e, t, n) {
    const i = e.interpolate(t, n);
    if (!i)
        return {};
    const r = i[n]
      , s = e.segments
      , o = e.points;
    let a = !1
      , l = !1;
    for (let c = 0; c < s.length; c++) {
        const u = s[c]
          , h = o[u.start][n]
          , d = o[u.end][n];
        if (Is(r, h, d)) {
            a = r === h,
            l = r === d;
            break
        }
    }
    return {
        first: a,
        last: l,
        point: i
    }
}
class uA {
    constructor(t) {
        this.x = t.x,
        this.y = t.y,
        this.radius = t.radius
    }
    pathSegment(t, n, i) {
        const {x: r, y: s, radius: o} = this;
        return n = n || {
            start: 0,
            end: mt
        },
        t.arc(r, s, o, n.end, n.start, !0),
        !i.bounds
    }
    interpolate(t) {
        const {x: n, y: i, radius: r} = this
          , s = t.angle;
        return {
            x: n + Math.cos(s) * r,
            y: i + Math.sin(s) * r,
            angle: s
        }
    }
}
function AG(e) {
    const {chart: t, fill: n, line: i} = e;
    if (Pt(n))
        return MG(t, n);
    if (n === "stack")
        return wG(e);
    if (n === "shape")
        return !0;
    const r = EG(e);
    return r instanceof uA ? r : cA(r, i)
}
function MG(e, t) {
    const n = e.getDatasetMeta(t);
    return n && e.isDatasetVisible(t) ? n.dataset : null
}
function EG(e) {
    return (e.scale || {}).getPointPositionForValue ? TG(e) : PG(e)
}
function PG(e) {
    const {scale: t={}, fill: n} = e
      , i = yG(n, t);
    if (Pt(i)) {
        const r = t.isHorizontal();
        return {
            x: r ? i : null,
            y: r ? null : i
        }
    }
    return null
}
function TG(e) {
    const {scale: t, fill: n} = e
      , i = t.options
      , r = t.getLabels().length
      , s = i.reverse ? t.max : t.min
      , o = xG(n, t, s)
      , a = [];
    if (i.grid.circular) {
        const l = t.getPointPositionForValue(0, s);
        return new uA({
            x: l.x,
            y: l.y,
            radius: t.getDistanceFromCenterForValue(o)
        })
    }
    for (let l = 0; l < r; ++l)
        a.push(t.getPointPositionForValue(l, o));
    return a
}
function I0(e, t, n) {
    const i = AG(t)
      , {line: r, scale: s, axis: o} = t
      , a = r.options
      , l = a.fill
      , c = a.backgroundColor
      , {above: u=c, below: h=c} = l || {};
    i && r.points.length && (af(e, n),
    jG(e, {
        line: r,
        target: i,
        above: u,
        below: h,
        area: n,
        scale: s,
        axis: o
    }),
    lf(e))
}
function jG(e, t) {
    const {line: n, target: i, above: r, below: s, area: o, scale: a} = t
      , l = n._loop ? "angle" : t.axis;
    e.save(),
    l === "x" && s !== r && (l7(e, i, o.top),
    c7(e, {
        line: n,
        target: i,
        color: r,
        scale: a,
        property: l
    }),
    e.restore(),
    e.save(),
    l7(e, i, o.bottom)),
    c7(e, {
        line: n,
        target: i,
        color: s,
        scale: a,
        property: l
    }),
    e.restore()
}
function l7(e, t, n) {
    const {segments: i, points: r} = t;
    let s = !0
      , o = !1;
    e.beginPath();
    for (const a of i) {
        const {start: l, end: c} = a
          , u = r[l]
          , h = r[hv(l, c, r)];
        s ? (e.moveTo(u.x, u.y),
        s = !1) : (e.lineTo(u.x, n),
        e.lineTo(u.x, u.y)),
        o = !!t.pathSegment(e, a, {
            move: o
        }),
        o ? e.closePath() : e.lineTo(h.x, n)
    }
    e.lineTo(t.first().x, n),
    e.closePath(),
    e.clip()
}
function c7(e, t) {
    const {line: n, target: i, property: r, color: s, scale: o} = t
      , a = fG(n, i, r);
    for (const {source: l, target: c, start: u, end: h} of a) {
        const {style: {backgroundColor: d=s}={}} = l
          , m = i !== !0;
        e.save(),
        e.fillStyle = d,
        OG(e, o, m && Bg(r, u, h)),
        e.beginPath();
        const f = !!n.pathSegment(e, l);
        let x;
        if (m) {
            f ? e.closePath() : u7(e, i, h, r);
            const S = !!i.pathSegment(e, c, {
                move: f,
                reverse: !0
            });
            x = f && S,
            x || u7(e, i, u, r)
        }
        e.closePath(),
        e.fill(x ? "evenodd" : "nonzero"),
        e.restore()
    }
}
function OG(e, t, n) {
    const {top: i, bottom: r} = t.chart.chartArea
      , {property: s, start: o, end: a} = n || {};
    s === "x" && (e.beginPath(),
    e.rect(o, i, a - o, r - i),
    e.clip())
}
function u7(e, t, n, i) {
    const r = t.interpolate(n, i);
    r && e.lineTo(r.x, r.y)
}
var hA = {
    id: "filler",
    afterDatasetsUpdate(e, t, n) {
        const i = (e.data.datasets || []).length
          , r = [];
        let s, o, a, l;
        for (o = 0; o < i; ++o)
            s = e.getDatasetMeta(o),
            a = s.dataset,
            l = null,
            a && a.options && a instanceof Rr && (l = {
                visible: e.isDatasetVisible(o),
                index: o,
                fill: mG(a, o, i),
                chart: e,
                axis: s.controller.options.indexAxis,
                scale: s.vScale,
                line: a
            }),
            s.$filler = l,
            r.push(l);
        for (o = 0; o < i; ++o)
            l = r[o],
            !(!l || l.fill === !1) && (l.fill = gG(r, o, n.propagate))
    },
    beforeDraw(e, t, n) {
        const i = n.drawTime === "beforeDraw"
          , r = e.getSortedVisibleDatasetMetas()
          , s = e.chartArea;
        for (let o = r.length - 1; o >= 0; --o) {
            const a = r[o].$filler;
            a && (a.line.updateControlPoints(s, a.axis),
            i && a.fill && I0(e.ctx, a, s))
        }
    },
    beforeDatasetsDraw(e, t, n) {
        if (n.drawTime !== "beforeDatasetsDraw")
            return;
        const i = e.getSortedVisibleDatasetMetas();
        for (let r = i.length - 1; r >= 0; --r) {
            const s = i[r].$filler;
            a7(s) && I0(e.ctx, s, e.chartArea)
        }
    },
    beforeDatasetDraw(e, t, n) {
        const i = t.meta.$filler;
        !a7(i) || n.drawTime !== "beforeDatasetDraw" || I0(e.ctx, i, e.chartArea)
    },
    defaults: {
        propagate: !0,
        drawTime: "beforeDatasetDraw"
    }
};
const h7 = (e,t)=>{
    let {boxHeight: n=t, boxWidth: i=t} = e;
    return e.usePointStyle && (n = Math.min(n, t),
    i = e.pointStyleWidth || Math.min(i, t)),
    {
        boxWidth: i,
        boxHeight: n,
        itemHeight: Math.max(t, n)
    }
}
  , LG = (e,t)=>e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index;
class d7 extends as {
    constructor(t) {
        super(),
        this._added = !1,
        this.legendHitBoxes = [],
        this._hoveredItem = null,
        this.doughnutMode = !1,
        this.chart = t.chart,
        this.options = t.options,
        this.ctx = t.ctx,
        this.legendItems = void 0,
        this.columnSizes = void 0,
        this.lineWidths = void 0,
        this.maxHeight = void 0,
        this.maxWidth = void 0,
        this.top = void 0,
        this.bottom = void 0,
        this.left = void 0,
        this.right = void 0,
        this.height = void 0,
        this.width = void 0,
        this._margins = void 0,
        this.position = void 0,
        this.weight = void 0,
        this.fullSize = void 0
    }
    update(t, n, i) {
        this.maxWidth = t,
        this.maxHeight = n,
        this._margins = i,
        this.setDimensions(),
        this.buildLabels(),
        this.fit()
    }
    setDimensions() {
        this.isHorizontal() ? (this.width = this.maxWidth,
        this.left = this._margins.left,
        this.right = this.width) : (this.height = this.maxHeight,
        this.top = this._margins.top,
        this.bottom = this.height)
    }
    buildLabels() {
        const t = this.options.labels || {};
        let n = at(t.generateLabels, [this.chart], this) || [];
        t.filter && (n = n.filter(i=>t.filter(i, this.chart.data))),
        t.sort && (n = n.sort((i,r)=>t.sort(i, r, this.chart.data))),
        this.options.reverse && n.reverse(),
        this.legendItems = n
    }
    fit() {
        const {options: t, ctx: n} = this;
        if (!t.display) {
            this.width = this.height = 0;
            return
        }
        const i = t.labels
          , r = Ht(i.font)
          , s = r.size
          , o = this._computeTitleHeight()
          , {boxWidth: a, itemHeight: l} = h7(i, s);
        let c, u;
        n.font = r.string,
        this.isHorizontal() ? (c = this.maxWidth,
        u = this._fitRows(o, s, a, l) + 10) : (u = this.maxHeight,
        c = this._fitCols(o, r, a, l) + 10),
        this.width = Math.min(c, t.maxWidth || this.maxWidth),
        this.height = Math.min(u, t.maxHeight || this.maxHeight)
    }
    _fitRows(t, n, i, r) {
        const {ctx: s, maxWidth: o, options: {labels: {padding: a}}} = this
          , l = this.legendHitBoxes = []
          , c = this.lineWidths = [0]
          , u = r + a;
        let h = t;
        s.textAlign = "left",
        s.textBaseline = "middle";
        let d = -1
          , m = -u;
        return this.legendItems.forEach((f,x)=>{
            const S = i + n / 2 + s.measureText(f.text).width;
            (x === 0 || c[c.length - 1] + S + 2 * a > o) && (h += u,
            c[c.length - (x > 0 ? 0 : 1)] = 0,
            m += u,
            d++),
            l[x] = {
                left: 0,
                top: m,
                row: d,
                width: S,
                height: r
            },
            c[c.length - 1] += S + a
        }
        ),
        h
    }
    _fitCols(t, n, i, r) {
        const {ctx: s, maxHeight: o, options: {labels: {padding: a}}} = this
          , l = this.legendHitBoxes = []
          , c = this.columnSizes = []
          , u = o - t;
        let h = a
          , d = 0
          , m = 0
          , f = 0
          , x = 0;
        return this.legendItems.forEach((S,v)=>{
            const {itemWidth: p, itemHeight: g} = RG(i, n, s, S, r);
            v > 0 && m + g + 2 * a > u && (h += d + a,
            c.push({
                width: d,
                height: m
            }),
            f += d + a,
            x++,
            d = m = 0),
            l[v] = {
                left: f,
                top: m,
                col: x,
                width: p,
                height: g
            },
            d = Math.max(d, p),
            m += g + a
        }
        ),
        h += d,
        c.push({
            width: d,
            height: m
        }),
        h
    }
    adjustHitBoxes() {
        if (!this.options.display)
            return;
        const t = this._computeTitleHeight()
          , {legendHitBoxes: n, options: {align: i, labels: {padding: r}, rtl: s}} = this
          , o = ta(s, this.left, this.width);
        if (this.isHorizontal()) {
            let a = 0
              , l = on(i, this.left + r, this.right - this.lineWidths[a]);
            for (const c of n)
                a !== c.row && (a = c.row,
                l = on(i, this.left + r, this.right - this.lineWidths[a])),
                c.top += this.top + t + r,
                c.left = o.leftForLtr(o.x(l), c.width),
                l += c.width + r
        } else {
            let a = 0
              , l = on(i, this.top + t + r, this.bottom - this.columnSizes[a].height);
            for (const c of n)
                c.col !== a && (a = c.col,
                l = on(i, this.top + t + r, this.bottom - this.columnSizes[a].height)),
                c.top = l,
                c.left += this.left + r,
                c.left = o.leftForLtr(o.x(c.left), c.width),
                l += c.height + r
        }
    }
    isHorizontal() {
        return this.options.position === "top" || this.options.position === "bottom"
    }
    draw() {
        if (this.options.display) {
            const t = this.ctx;
            af(t, this),
            this._draw(),
            lf(t)
        }
    }
    _draw() {
        const {options: t, columnSizes: n, lineWidths: i, ctx: r} = this
          , {align: s, labels: o} = t
          , a = Tt.color
          , l = ta(t.rtl, this.left, this.width)
          , c = Ht(o.font)
          , {padding: u} = o
          , h = c.size
          , d = h / 2;
        let m;
        this.drawTitle(),
        r.textAlign = l.textAlign("left"),
        r.textBaseline = "middle",
        r.lineWidth = .5,
        r.font = c.string;
        const {boxWidth: f, boxHeight: x, itemHeight: S} = h7(o, h)
          , v = function(O, R, F) {
            if (isNaN(f) || f <= 0 || isNaN(x) || x < 0)
                return;
            r.save();
            const P = He(F.lineWidth, 1);
            if (r.fillStyle = He(F.fillStyle, a),
            r.lineCap = He(F.lineCap, "butt"),
            r.lineDashOffset = He(F.lineDashOffset, 0),
            r.lineJoin = He(F.lineJoin, "miter"),
            r.lineWidth = P,
            r.strokeStyle = He(F.strokeStyle, a),
            r.setLineDash(He(F.lineDash, [])),
            o.usePointStyle) {
                const _ = {
                    radius: x * Math.SQRT2 / 2,
                    pointStyle: F.pointStyle,
                    rotation: F.rotation,
                    borderWidth: P
                }
                  , T = l.xPlus(O, f / 2)
                  , L = R + d;
                Ik(r, _, T, L, o.pointStyleWidth && f)
            } else {
                const _ = R + Math.max((h - x) / 2, 0)
                  , T = l.leftForLtr(O, f)
                  , L = ea(F.borderRadius);
                r.beginPath(),
                Object.values(L).some(I=>I !== 0) ? rd(r, {
                    x: T,
                    y: _,
                    w: f,
                    h: x,
                    radius: L
                }) : r.rect(T, _, f, x),
                r.fill(),
                P !== 0 && r.stroke()
            }
            r.restore()
        }
          , p = function(O, R, F) {
            Js(r, F.text, O, R + S / 2, c, {
                strikethrough: F.hidden,
                textAlign: l.textAlign(F.textAlign)
            })
        }
          , g = this.isHorizontal()
          , C = this._computeTitleHeight();
        g ? m = {
            x: on(s, this.left + u, this.right - i[0]),
            y: this.top + u + C,
            line: 0
        } : m = {
            x: this.left + u,
            y: on(s, this.top + C + u, this.bottom - n[0].height),
            line: 0
        },
        Gk(this.ctx, t.textDirection);
        const E = S + u;
        this.legendItems.forEach((O,R)=>{
            r.strokeStyle = O.fontColor,
            r.fillStyle = O.fontColor;
            const F = r.measureText(O.text).width
              , P = l.textAlign(O.textAlign || (O.textAlign = o.textAlign))
              , _ = f + d + F;
            let T = m.x
              , L = m.y;
            l.setWidth(this.width),
            g ? R > 0 && T + _ + u > this.right && (L = m.y += E,
            m.line++,
            T = m.x = on(s, this.left + u, this.right - i[m.line])) : R > 0 && L + E > this.bottom && (T = m.x = T + n[m.line].width + u,
            m.line++,
            L = m.y = on(s, this.top + C + u, this.bottom - n[m.line].height));
            const I = l.x(T);
            if (v(I, L, O),
            T = AW(P, T + f + d, g ? T + _ : this.right, t.rtl),
            p(l.x(T), L, O),
            g)
                m.x += _ + u;
            else if (typeof O.text != "string") {
                const k = c.lineHeight;
                m.y += dA(O, k) + u
            } else
                m.y += E
        }
        ),
        Xk(this.ctx, t.textDirection)
    }
    drawTitle() {
        const t = this.options
          , n = t.title
          , i = Ht(n.font)
          , r = cn(n.padding);
        if (!n.display)
            return;
        const s = ta(t.rtl, this.left, this.width)
          , o = this.ctx
          , a = n.position
          , l = i.size / 2
          , c = r.top + l;
        let u, h = this.left, d = this.width;
        if (this.isHorizontal())
            d = Math.max(...this.lineWidths),
            u = this.top + c,
            h = on(t.align, h, this.right - d);
        else {
            const f = this.columnSizes.reduce((x,S)=>Math.max(x, S.height), 0);
            u = c + on(t.align, this.top, this.bottom - f - t.labels.padding - this._computeTitleHeight())
        }
        const m = on(a, h, h + d);
        o.textAlign = s.textAlign(iv(a)),
        o.textBaseline = "middle",
        o.strokeStyle = n.color,
        o.fillStyle = n.color,
        o.font = i.string,
        Js(o, n.text, m, u, i)
    }
    _computeTitleHeight() {
        const t = this.options.title
          , n = Ht(t.font)
          , i = cn(t.padding);
        return t.display ? n.lineHeight + i.height : 0
    }
    _getLegendItemAt(t, n) {
        let i, r, s;
        if (Is(t, this.left, this.right) && Is(n, this.top, this.bottom)) {
            for (s = this.legendHitBoxes,
            i = 0; i < s.length; ++i)
                if (r = s[i],
                Is(t, r.left, r.left + r.width) && Is(n, r.top, r.top + r.height))
                    return this.legendItems[i]
        }
        return null
    }
    handleEvent(t) {
        const n = this.options;
        if (!NG(t.type, n))
            return;
        const i = this._getLegendItemAt(t.x, t.y);
        if (t.type === "mousemove" || t.type === "mouseout") {
            const r = this._hoveredItem
              , s = LG(r, i);
            r && !s && at(n.onLeave, [t, r, this], this),
            this._hoveredItem = i,
            i && !s && at(n.onHover, [t, i, this], this)
        } else
            i && at(n.onClick, [t, i, this], this)
    }
}
function RG(e, t, n, i, r) {
    const s = _G(i, e, t, n)
      , o = DG(r, i, t.lineHeight);
    return {
        itemWidth: s,
        itemHeight: o
    }
}
function _G(e, t, n, i) {
    let r = e.text;
    return r && typeof r != "string" && (r = r.reduce((s,o)=>s.length > o.length ? s : o)),
    t + n.size / 2 + i.measureText(r).width
}
function DG(e, t, n) {
    let i = e;
    return typeof t.text != "string" && (i = dA(t, n)),
    i
}
function dA(e, t) {
    const n = e.text ? e.text.length : 0;
    return t * n
}
function NG(e, t) {
    return !!((e === "mousemove" || e === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (e === "click" || e === "mouseup"))
}
var fA = {
    id: "legend",
    _element: d7,
    start(e, t, n) {
        const i = e.legend = new d7({
            ctx: e.ctx,
            options: n,
            chart: e
        });
        ti.configure(e, i, n),
        ti.addBox(e, i)
    },
    stop(e) {
        ti.removeBox(e, e.legend),
        delete e.legend
    },
    beforeUpdate(e, t, n) {
        const i = e.legend;
        ti.configure(e, i, n),
        i.options = n
    },
    afterUpdate(e) {
        const t = e.legend;
        t.buildLabels(),
        t.adjustHitBoxes()
    },
    afterEvent(e, t) {
        t.replay || e.legend.handleEvent(t.event)
    },
    defaults: {
        display: !0,
        position: "top",
        align: "center",
        fullSize: !0,
        reverse: !1,
        weight: 1e3,
        onClick(e, t, n) {
            const i = t.datasetIndex
              , r = n.chart;
            r.isDatasetVisible(i) ? (r.hide(i),
            t.hidden = !0) : (r.show(i),
            t.hidden = !1)
        },
        onHover: null,
        onLeave: null,
        labels: {
            color: e=>e.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels(e) {
                const t = e.data.datasets
                  , {labels: {usePointStyle: n, pointStyle: i, textAlign: r, color: s, useBorderRadius: o, borderRadius: a}} = e.legend.options;
                return e._getSortedDatasetMetas().map(l=>{
                    const c = l.controller.getStyle(n ? 0 : void 0)
                      , u = cn(c.borderWidth);
                    return {
                        text: t[l.index].label,
                        fillStyle: c.backgroundColor,
                        fontColor: s,
                        hidden: !l.visible,
                        lineCap: c.borderCapStyle,
                        lineDash: c.borderDash,
                        lineDashOffset: c.borderDashOffset,
                        lineJoin: c.borderJoinStyle,
                        lineWidth: (u.width + u.height) / 4,
                        strokeStyle: c.borderColor,
                        pointStyle: i || c.pointStyle,
                        rotation: c.rotation,
                        textAlign: r || c.textAlign,
                        borderRadius: o && (a || c.borderRadius),
                        datasetIndex: l.index
                    }
                }
                , this)
            }
        },
        title: {
            color: e=>e.chart.options.color,
            display: !1,
            position: "center",
            text: ""
        }
    },
    descriptors: {
        _scriptable: e=>!e.startsWith("on"),
        labels: {
            _scriptable: e=>!["generateLabels", "filter", "sort"].includes(e)
        }
    }
};
class pA extends as {
    constructor(t) {
        super(),
        this.chart = t.chart,
        this.options = t.options,
        this.ctx = t.ctx,
        this._padding = void 0,
        this.top = void 0,
        this.bottom = void 0,
        this.left = void 0,
        this.right = void 0,
        this.width = void 0,
        this.height = void 0,
        this.position = void 0,
        this.weight = void 0,
        this.fullSize = void 0
    }
    update(t, n) {
        const i = this.options;
        if (this.left = 0,
        this.top = 0,
        !i.display) {
            this.width = this.height = this.right = this.bottom = 0;
            return
        }
        this.width = this.right = t,
        this.height = this.bottom = n;
        const r = yt(i.text) ? i.text.length : 1;
        this._padding = cn(i.padding);
        const s = r * Ht(i.font).lineHeight + this._padding.height;
        this.isHorizontal() ? this.height = s : this.width = s
    }
    isHorizontal() {
        const t = this.options.position;
        return t === "top" || t === "bottom"
    }
    _drawArgs(t) {
        const {top: n, left: i, bottom: r, right: s, options: o} = this
          , a = o.align;
        let l = 0, c, u, h;
        return this.isHorizontal() ? (u = on(a, i, s),
        h = n + t,
        c = s - i) : (o.position === "left" ? (u = i + t,
        h = on(a, r, n),
        l = xt * -.5) : (u = s - t,
        h = on(a, n, r),
        l = xt * .5),
        c = r - n),
        {
            titleX: u,
            titleY: h,
            maxWidth: c,
            rotation: l
        }
    }
    draw() {
        const t = this.ctx
          , n = this.options;
        if (!n.display)
            return;
        const i = Ht(n.font)
          , s = i.lineHeight / 2 + this._padding.top
          , {titleX: o, titleY: a, maxWidth: l, rotation: c} = this._drawArgs(s);
        Js(t, n.text, 0, 0, i, {
            color: n.color,
            maxWidth: l,
            rotation: c,
            textAlign: iv(n.align),
            textBaseline: "middle",
            translation: [o, a]
        })
    }
}
function FG(e, t) {
    const n = new pA({
        ctx: e.ctx,
        options: t,
        chart: e
    });
    ti.configure(e, n, t),
    ti.addBox(e, n),
    e.titleBlock = n
}
var IG = {
    id: "title",
    _element: pA,
    start(e, t, n) {
        FG(e, n)
    },
    stop(e) {
        const t = e.titleBlock;
        ti.removeBox(e, t),
        delete e.titleBlock
    },
    beforeUpdate(e, t, n) {
        const i = e.titleBlock;
        ti.configure(e, i, n),
        i.options = n
    },
    defaults: {
        align: "center",
        display: !1,
        font: {
            weight: "bold"
        },
        fullSize: !0,
        padding: 10,
        position: "top",
        text: "",
        weight: 2e3
    },
    defaultRoutes: {
        color: "color"
    },
    descriptors: {
        _scriptable: !0,
        _indexable: !1
    }
};
const nl = {
    average(e) {
        if (!e.length)
            return !1;
        let t, n, i = 0, r = 0, s = 0;
        for (t = 0,
        n = e.length; t < n; ++t) {
            const o = e[t].element;
            if (o && o.hasValue()) {
                const a = o.tooltipPosition();
                i += a.x,
                r += a.y,
                ++s
            }
        }
        return {
            x: i / s,
            y: r / s
        }
    },
    nearest(e, t) {
        if (!e.length)
            return !1;
        let n = t.x, i = t.y, r = Number.POSITIVE_INFINITY, s, o, a;
        for (s = 0,
        o = e.length; s < o; ++s) {
            const l = e[s].element;
            if (l && l.hasValue()) {
                const c = l.getCenterPoint()
                  , u = Rg(t, c);
                u < r && (r = u,
                a = l)
            }
        }
        if (a) {
            const l = a.tooltipPosition();
            n = l.x,
            i = l.y
        }
        return {
            x: n,
            y: i
        }
    }
};
function Ti(e, t) {
    return t && (yt(t) ? Array.prototype.push.apply(e, t) : e.push(t)),
    e
}
function Qi(e) {
    return (typeof e == "string" || e instanceof String) && e.indexOf(`
`) > -1 ? e.split(`
`) : e
}
function BG(e, t) {
    const {element: n, datasetIndex: i, index: r} = t
      , s = e.getDatasetMeta(i).controller
      , {label: o, value: a} = s.getLabelAndValue(r);
    return {
        chart: e,
        label: o,
        parsed: s.getParsed(r),
        raw: e.data.datasets[i].data[r],
        formattedValue: a,
        dataset: s.getDataset(),
        dataIndex: r,
        datasetIndex: i,
        element: n
    }
}
function f7(e, t) {
    const n = e.chart.ctx
      , {body: i, footer: r, title: s} = e
      , {boxWidth: o, boxHeight: a} = t
      , l = Ht(t.bodyFont)
      , c = Ht(t.titleFont)
      , u = Ht(t.footerFont)
      , h = s.length
      , d = r.length
      , m = i.length
      , f = cn(t.padding);
    let x = f.height
      , S = 0
      , v = i.reduce((C,E)=>C + E.before.length + E.lines.length + E.after.length, 0);
    if (v += e.beforeBody.length + e.afterBody.length,
    h && (x += h * c.lineHeight + (h - 1) * t.titleSpacing + t.titleMarginBottom),
    v) {
        const C = t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;
        x += m * C + (v - m) * l.lineHeight + (v - 1) * t.bodySpacing
    }
    d && (x += t.footerMarginTop + d * u.lineHeight + (d - 1) * t.footerSpacing);
    let p = 0;
    const g = function(C) {
        S = Math.max(S, n.measureText(C).width + p)
    };
    return n.save(),
    n.font = c.string,
    Ze(e.title, g),
    n.font = l.string,
    Ze(e.beforeBody.concat(e.afterBody), g),
    p = t.displayColors ? o + 2 + t.boxPadding : 0,
    Ze(i, C=>{
        Ze(C.before, g),
        Ze(C.lines, g),
        Ze(C.after, g)
    }
    ),
    p = 0,
    n.font = u.string,
    Ze(e.footer, g),
    n.restore(),
    S += f.width,
    {
        width: S,
        height: x
    }
}
function zG(e, t) {
    const {y: n, height: i} = t;
    return n < i / 2 ? "top" : n > e.height - i / 2 ? "bottom" : "center"
}
function VG(e, t, n, i) {
    const {x: r, width: s} = i
      , o = n.caretSize + n.caretPadding;
    if (e === "left" && r + s + o > t.width || e === "right" && r - s - o < 0)
        return !0
}
function WG(e, t, n, i) {
    const {x: r, width: s} = n
      , {width: o, chartArea: {left: a, right: l}} = e;
    let c = "center";
    return i === "center" ? c = r <= (a + l) / 2 ? "left" : "right" : r <= s / 2 ? c = "left" : r >= o - s / 2 && (c = "right"),
    VG(c, e, t, n) && (c = "center"),
    c
}
function p7(e, t, n) {
    const i = n.yAlign || t.yAlign || zG(e, n);
    return {
        xAlign: n.xAlign || t.xAlign || WG(e, t, n, i),
        yAlign: i
    }
}
function HG(e, t) {
    let {x: n, width: i} = e;
    return t === "right" ? n -= i : t === "center" && (n -= i / 2),
    n
}
function UG(e, t, n) {
    let {y: i, height: r} = e;
    return t === "top" ? i += n : t === "bottom" ? i -= r + n : i -= r / 2,
    i
}
function g7(e, t, n, i) {
    const {caretSize: r, caretPadding: s, cornerRadius: o} = e
      , {xAlign: a, yAlign: l} = n
      , c = r + s
      , {topLeft: u, topRight: h, bottomLeft: d, bottomRight: m} = ea(o);
    let f = HG(t, a);
    const x = UG(t, l, c);
    return l === "center" ? a === "left" ? f += c : a === "right" && (f -= c) : a === "left" ? f -= Math.max(u, d) + r : a === "right" && (f += Math.max(h, m) + r),
    {
        x: gn(f, 0, i.width - t.width),
        y: gn(x, 0, i.height - t.height)
    }
}
function Ou(e, t, n) {
    const i = cn(n.padding);
    return t === "center" ? e.x + e.width / 2 : t === "right" ? e.x + e.width - i.right : e.x + i.left
}
function m7(e) {
    return Ti([], Qi(e))
}
function GG(e, t, n) {
    return os(e, {
        tooltip: t,
        tooltipItems: n,
        type: "tooltip"
    })
}
function v7(e, t) {
    const n = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
    return n ? e.override(n) : e
}
const gA = {
    beforeTitle: Yi,
    title(e) {
        if (e.length > 0) {
            const t = e[0]
              , n = t.chart.data.labels
              , i = n ? n.length : 0;
            if (this && this.options && this.options.mode === "dataset")
                return t.dataset.label || "";
            if (t.label)
                return t.label;
            if (i > 0 && t.dataIndex < i)
                return n[t.dataIndex]
        }
        return ""
    },
    afterTitle: Yi,
    beforeBody: Yi,
    beforeLabel: Yi,
    label(e) {
        if (this && this.options && this.options.mode === "dataset")
            return e.label + ": " + e.formattedValue || e.formattedValue;
        let t = e.dataset.label || "";
        t && (t += ": ");
        const n = e.formattedValue;
        return ft(n) || (t += n),
        t
    },
    labelColor(e) {
        const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
        return {
            borderColor: n.borderColor,
            backgroundColor: n.backgroundColor,
            borderWidth: n.borderWidth,
            borderDash: n.borderDash,
            borderDashOffset: n.borderDashOffset,
            borderRadius: 0
        }
    },
    labelTextColor() {
        return this.options.bodyColor
    },
    labelPointStyle(e) {
        const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
        return {
            pointStyle: n.pointStyle,
            rotation: n.rotation
        }
    },
    afterLabel: Yi,
    afterBody: Yi,
    beforeFooter: Yi,
    footer: Yi,
    afterFooter: Yi
};
function wn(e, t, n, i) {
    const r = e[t].call(n, i);
    return typeof r > "u" ? gA[t].call(n, i) : r
}
class zg extends as {
    constructor(t) {
        super(),
        this.opacity = 0,
        this._active = [],
        this._eventPosition = void 0,
        this._size = void 0,
        this._cachedAnimations = void 0,
        this._tooltipItems = [],
        this.$animations = void 0,
        this.$context = void 0,
        this.chart = t.chart,
        this.options = t.options,
        this.dataPoints = void 0,
        this.title = void 0,
        this.beforeBody = void 0,
        this.body = void 0,
        this.afterBody = void 0,
        this.footer = void 0,
        this.xAlign = void 0,
        this.yAlign = void 0,
        this.x = void 0,
        this.y = void 0,
        this.height = void 0,
        this.width = void 0,
        this.caretX = void 0,
        this.caretY = void 0,
        this.labelColors = void 0,
        this.labelPointStyles = void 0,
        this.labelTextColors = void 0
    }
    initialize(t) {
        this.options = t,
        this._cachedAnimations = void 0,
        this.$context = void 0
    }
    _resolveAnimations() {
        const t = this._cachedAnimations;
        if (t)
            return t;
        const n = this.chart
          , i = this.options.setContext(this.getContext())
          , r = i.enabled && n.options.animation && i.animations
          , s = new Qk(this.chart,r);
        return r._cacheable && (this._cachedAnimations = Object.freeze(s)),
        s
    }
    getContext() {
        return this.$context || (this.$context = GG(this.chart.getContext(), this, this._tooltipItems))
    }
    getTitle(t, n) {
        const {callbacks: i} = n
          , r = wn(i, "beforeTitle", this, t)
          , s = wn(i, "title", this, t)
          , o = wn(i, "afterTitle", this, t);
        let a = [];
        return a = Ti(a, Qi(r)),
        a = Ti(a, Qi(s)),
        a = Ti(a, Qi(o)),
        a
    }
    getBeforeBody(t, n) {
        return m7(wn(n.callbacks, "beforeBody", this, t))
    }
    getBody(t, n) {
        const {callbacks: i} = n
          , r = [];
        return Ze(t, s=>{
            const o = {
                before: [],
                lines: [],
                after: []
            }
              , a = v7(i, s);
            Ti(o.before, Qi(wn(a, "beforeLabel", this, s))),
            Ti(o.lines, wn(a, "label", this, s)),
            Ti(o.after, Qi(wn(a, "afterLabel", this, s))),
            r.push(o)
        }
        ),
        r
    }
    getAfterBody(t, n) {
        return m7(wn(n.callbacks, "afterBody", this, t))
    }
    getFooter(t, n) {
        const {callbacks: i} = n
          , r = wn(i, "beforeFooter", this, t)
          , s = wn(i, "footer", this, t)
          , o = wn(i, "afterFooter", this, t);
        let a = [];
        return a = Ti(a, Qi(r)),
        a = Ti(a, Qi(s)),
        a = Ti(a, Qi(o)),
        a
    }
    _createItems(t) {
        const n = this._active
          , i = this.chart.data
          , r = []
          , s = []
          , o = [];
        let a = [], l, c;
        for (l = 0,
        c = n.length; l < c; ++l)
            a.push(BG(this.chart, n[l]));
        return t.filter && (a = a.filter((u,h,d)=>t.filter(u, h, d, i))),
        t.itemSort && (a = a.sort((u,h)=>t.itemSort(u, h, i))),
        Ze(a, u=>{
            const h = v7(t.callbacks, u);
            r.push(wn(h, "labelColor", this, u)),
            s.push(wn(h, "labelPointStyle", this, u)),
            o.push(wn(h, "labelTextColor", this, u))
        }
        ),
        this.labelColors = r,
        this.labelPointStyles = s,
        this.labelTextColors = o,
        this.dataPoints = a,
        a
    }
    update(t, n) {
        const i = this.options.setContext(this.getContext())
          , r = this._active;
        let s, o = [];
        if (!r.length)
            this.opacity !== 0 && (s = {
                opacity: 0
            });
        else {
            const a = nl[i.position].call(this, r, this._eventPosition);
            o = this._createItems(i),
            this.title = this.getTitle(o, i),
            this.beforeBody = this.getBeforeBody(o, i),
            this.body = this.getBody(o, i),
            this.afterBody = this.getAfterBody(o, i),
            this.footer = this.getFooter(o, i);
            const l = this._size = f7(this, i)
              , c = Object.assign({}, a, l)
              , u = p7(this.chart, i, c)
              , h = g7(i, c, u, this.chart);
            this.xAlign = u.xAlign,
            this.yAlign = u.yAlign,
            s = {
                opacity: 1,
                x: h.x,
                y: h.y,
                width: l.width,
                height: l.height,
                caretX: a.x,
                caretY: a.y
            }
        }
        this._tooltipItems = o,
        this.$context = void 0,
        s && this._resolveAnimations().update(this, s),
        t && i.external && i.external.call(this, {
            chart: this.chart,
            tooltip: this,
            replay: n
        })
    }
    drawCaret(t, n, i, r) {
        const s = this.getCaretPosition(t, i, r);
        n.lineTo(s.x1, s.y1),
        n.lineTo(s.x2, s.y2),
        n.lineTo(s.x3, s.y3)
    }
    getCaretPosition(t, n, i) {
        const {xAlign: r, yAlign: s} = this
          , {caretSize: o, cornerRadius: a} = i
          , {topLeft: l, topRight: c, bottomLeft: u, bottomRight: h} = ea(a)
          , {x: d, y: m} = t
          , {width: f, height: x} = n;
        let S, v, p, g, C, E;
        return s === "center" ? (C = m + x / 2,
        r === "left" ? (S = d,
        v = S - o,
        g = C + o,
        E = C - o) : (S = d + f,
        v = S + o,
        g = C - o,
        E = C + o),
        p = S) : (r === "left" ? v = d + Math.max(l, u) + o : r === "right" ? v = d + f - Math.max(c, h) - o : v = this.caretX,
        s === "top" ? (g = m,
        C = g - o,
        S = v - o,
        p = v + o) : (g = m + x,
        C = g + o,
        S = v + o,
        p = v - o),
        E = g),
        {
            x1: S,
            x2: v,
            x3: p,
            y1: g,
            y2: C,
            y3: E
        }
    }
    drawTitle(t, n, i) {
        const r = this.title
          , s = r.length;
        let o, a, l;
        if (s) {
            const c = ta(i.rtl, this.x, this.width);
            for (t.x = Ou(this, i.titleAlign, i),
            n.textAlign = c.textAlign(i.titleAlign),
            n.textBaseline = "middle",
            o = Ht(i.titleFont),
            a = i.titleSpacing,
            n.fillStyle = i.titleColor,
            n.font = o.string,
            l = 0; l < s; ++l)
                n.fillText(r[l], c.x(t.x), t.y + o.lineHeight / 2),
                t.y += o.lineHeight + a,
                l + 1 === s && (t.y += i.titleMarginBottom - a)
        }
    }
    _drawColorBox(t, n, i, r, s) {
        const o = this.labelColors[i]
          , a = this.labelPointStyles[i]
          , {boxHeight: l, boxWidth: c} = s
          , u = Ht(s.bodyFont)
          , h = Ou(this, "left", s)
          , d = r.x(h)
          , m = l < u.lineHeight ? (u.lineHeight - l) / 2 : 0
          , f = n.y + m;
        if (s.usePointStyle) {
            const x = {
                radius: Math.min(c, l) / 2,
                pointStyle: a.pointStyle,
                rotation: a.rotation,
                borderWidth: 1
            }
              , S = r.leftForLtr(d, c) + c / 2
              , v = f + l / 2;
            t.strokeStyle = s.multiKeyBackground,
            t.fillStyle = s.multiKeyBackground,
            Dg(t, x, S, v),
            t.strokeStyle = o.borderColor,
            t.fillStyle = o.backgroundColor,
            Dg(t, x, S, v)
        } else {
            t.lineWidth = Xe(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1,
            t.strokeStyle = o.borderColor,
            t.setLineDash(o.borderDash || []),
            t.lineDashOffset = o.borderDashOffset || 0;
            const x = r.leftForLtr(d, c)
              , S = r.leftForLtr(r.xPlus(d, 1), c - 2)
              , v = ea(o.borderRadius);
            Object.values(v).some(p=>p !== 0) ? (t.beginPath(),
            t.fillStyle = s.multiKeyBackground,
            rd(t, {
                x,
                y: f,
                w: c,
                h: l,
                radius: v
            }),
            t.fill(),
            t.stroke(),
            t.fillStyle = o.backgroundColor,
            t.beginPath(),
            rd(t, {
                x: S,
                y: f + 1,
                w: c - 2,
                h: l - 2,
                radius: v
            }),
            t.fill()) : (t.fillStyle = s.multiKeyBackground,
            t.fillRect(x, f, c, l),
            t.strokeRect(x, f, c, l),
            t.fillStyle = o.backgroundColor,
            t.fillRect(S, f + 1, c - 2, l - 2))
        }
        t.fillStyle = this.labelTextColors[i]
    }
    drawBody(t, n, i) {
        const {body: r} = this
          , {bodySpacing: s, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: u} = i
          , h = Ht(i.bodyFont);
        let d = h.lineHeight
          , m = 0;
        const f = ta(i.rtl, this.x, this.width)
          , x = function(F) {
            n.fillText(F, f.x(t.x + m), t.y + d / 2),
            t.y += d + s
        }
          , S = f.textAlign(o);
        let v, p, g, C, E, O, R;
        for (n.textAlign = o,
        n.textBaseline = "middle",
        n.font = h.string,
        t.x = Ou(this, S, i),
        n.fillStyle = i.bodyColor,
        Ze(this.beforeBody, x),
        m = a && S !== "right" ? o === "center" ? c / 2 + u : c + 2 + u : 0,
        C = 0,
        O = r.length; C < O; ++C) {
            for (v = r[C],
            p = this.labelTextColors[C],
            n.fillStyle = p,
            Ze(v.before, x),
            g = v.lines,
            a && g.length && (this._drawColorBox(n, t, C, f, i),
            d = Math.max(h.lineHeight, l)),
            E = 0,
            R = g.length; E < R; ++E)
                x(g[E]),
                d = h.lineHeight;
            Ze(v.after, x)
        }
        m = 0,
        d = h.lineHeight,
        Ze(this.afterBody, x),
        t.y -= s
    }
    drawFooter(t, n, i) {
        const r = this.footer
          , s = r.length;
        let o, a;
        if (s) {
            const l = ta(i.rtl, this.x, this.width);
            for (t.x = Ou(this, i.footerAlign, i),
            t.y += i.footerMarginTop,
            n.textAlign = l.textAlign(i.footerAlign),
            n.textBaseline = "middle",
            o = Ht(i.footerFont),
            n.fillStyle = i.footerColor,
            n.font = o.string,
            a = 0; a < s; ++a)
                n.fillText(r[a], l.x(t.x), t.y + o.lineHeight / 2),
                t.y += o.lineHeight + i.footerSpacing
        }
    }
    drawBackground(t, n, i, r) {
        const {xAlign: s, yAlign: o} = this
          , {x: a, y: l} = t
          , {width: c, height: u} = i
          , {topLeft: h, topRight: d, bottomLeft: m, bottomRight: f} = ea(r.cornerRadius);
        n.fillStyle = r.backgroundColor,
        n.strokeStyle = r.borderColor,
        n.lineWidth = r.borderWidth,
        n.beginPath(),
        n.moveTo(a + h, l),
        o === "top" && this.drawCaret(t, n, i, r),
        n.lineTo(a + c - d, l),
        n.quadraticCurveTo(a + c, l, a + c, l + d),
        o === "center" && s === "right" && this.drawCaret(t, n, i, r),
        n.lineTo(a + c, l + u - f),
        n.quadraticCurveTo(a + c, l + u, a + c - f, l + u),
        o === "bottom" && this.drawCaret(t, n, i, r),
        n.lineTo(a + m, l + u),
        n.quadraticCurveTo(a, l + u, a, l + u - m),
        o === "center" && s === "left" && this.drawCaret(t, n, i, r),
        n.lineTo(a, l + h),
        n.quadraticCurveTo(a, l, a + h, l),
        n.closePath(),
        n.fill(),
        r.borderWidth > 0 && n.stroke()
    }
    _updateAnimationTarget(t) {
        const n = this.chart
          , i = this.$animations
          , r = i && i.x
          , s = i && i.y;
        if (r || s) {
            const o = nl[t.position].call(this, this._active, this._eventPosition);
            if (!o)
                return;
            const a = this._size = f7(this, t)
              , l = Object.assign({}, o, this._size)
              , c = p7(n, t, l)
              , u = g7(t, l, c, n);
            (r._to !== u.x || s._to !== u.y) && (this.xAlign = c.xAlign,
            this.yAlign = c.yAlign,
            this.width = a.width,
            this.height = a.height,
            this.caretX = o.x,
            this.caretY = o.y,
            this._resolveAnimations().update(this, u))
        }
    }
    _willRender() {
        return !!this.opacity
    }
    draw(t) {
        const n = this.options.setContext(this.getContext());
        let i = this.opacity;
        if (!i)
            return;
        this._updateAnimationTarget(n);
        const r = {
            width: this.width,
            height: this.height
        }
          , s = {
            x: this.x,
            y: this.y
        };
        i = Math.abs(i) < .001 ? 0 : i;
        const o = cn(n.padding)
          , a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
        n.enabled && a && (t.save(),
        t.globalAlpha = i,
        this.drawBackground(s, t, r, n),
        Gk(t, n.textDirection),
        s.y += o.top,
        this.drawTitle(s, t, n),
        this.drawBody(s, t, n),
        this.drawFooter(s, t, n),
        Xk(t, n.textDirection),
        t.restore())
    }
    getActiveElements() {
        return this._active || []
    }
    setActiveElements(t, n) {
        const i = this._active
          , r = t.map(({datasetIndex: a, index: l})=>{
            const c = this.chart.getDatasetMeta(a);
            if (!c)
                throw new Error("Cannot find a dataset at index " + a);
            return {
                datasetIndex: a,
                element: c.data[l],
                index: l
            }
        }
        )
          , s = !Jh(i, r)
          , o = this._positionChanged(r, n);
        (s || o) && (this._active = r,
        this._eventPosition = n,
        this._ignoreReplayEvents = !0,
        this.update(!0))
    }
    handleEvent(t, n, i=!0) {
        if (n && this._ignoreReplayEvents)
            return !1;
        this._ignoreReplayEvents = !1;
        const r = this.options
          , s = this._active || []
          , o = this._getActiveElements(t, s, n, i)
          , a = this._positionChanged(o, t)
          , l = n || !Jh(o, s) || a;
        return l && (this._active = o,
        (r.enabled || r.external) && (this._eventPosition = {
            x: t.x,
            y: t.y
        },
        this.update(!0, n))),
        l
    }
    _getActiveElements(t, n, i, r) {
        const s = this.options;
        if (t.type === "mouseout")
            return [];
        if (!r)
            return n;
        const o = this.chart.getElementsAtEventForMode(t, s.mode, s, i);
        return s.reverse && o.reverse(),
        o
    }
    _positionChanged(t, n) {
        const {caretX: i, caretY: r, options: s} = this
          , o = nl[s.position].call(this, t, n);
        return o !== !1 && (i !== o.x || r !== o.y)
    }
}
je(zg, "positioners", nl);
var mA = {
    id: "tooltip",
    _element: zg,
    positioners: nl,
    afterInit(e, t, n) {
        n && (e.tooltip = new zg({
            chart: e,
            options: n
        }))
    },
    beforeUpdate(e, t, n) {
        e.tooltip && e.tooltip.initialize(n)
    },
    reset(e, t, n) {
        e.tooltip && e.tooltip.initialize(n)
    },
    afterDraw(e) {
        const t = e.tooltip;
        if (t && t._willRender()) {
            const n = {
                tooltip: t
            };
            if (e.notifyPlugins("beforeTooltipDraw", {
                ...n,
                cancelable: !0
            }) === !1)
                return;
            t.draw(e.ctx),
            e.notifyPlugins("afterTooltipDraw", n)
        }
    },
    afterEvent(e, t) {
        if (e.tooltip) {
            const n = t.replay;
            e.tooltip.handleEvent(t.event, n, t.inChartArea) && (t.changed = !0)
        }
    },
    defaults: {
        enabled: !0,
        external: null,
        position: "average",
        backgroundColor: "rgba(0,0,0,0.8)",
        titleColor: "#fff",
        titleFont: {
            weight: "bold"
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: "left",
        bodyColor: "#fff",
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: "left",
        footerColor: "#fff",
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
            weight: "bold"
        },
        footerAlign: "left",
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (e,t)=>t.bodyFont.size,
        boxWidth: (e,t)=>t.bodyFont.size,
        multiKeyBackground: "#fff",
        displayColors: !0,
        boxPadding: 0,
        borderColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        animation: {
            duration: 400,
            easing: "easeOutQuart"
        },
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "width", "height", "caretX", "caretY"]
            },
            opacity: {
                easing: "linear",
                duration: 200
            }
        },
        callbacks: gA
    },
    defaultRoutes: {
        bodyFont: "font",
        footerFont: "font",
        titleFont: "font"
    },
    descriptors: {
        _scriptable: e=>e !== "filter" && e !== "itemSort" && e !== "external",
        _indexable: !1,
        callbacks: {
            _scriptable: !1,
            _indexable: !1
        },
        animation: {
            _fallback: !1
        },
        animations: {
            _fallback: "animation"
        }
    },
    additionalOptionScopes: ["interaction"]
};
const XG = (e,t,n,i)=>(typeof t == "string" ? (n = e.push(t) - 1,
i.unshift({
    index: n,
    label: t
})) : isNaN(t) && (n = null),
n);
function YG(e, t, n, i) {
    const r = e.indexOf(t);
    if (r === -1)
        return XG(e, t, n, i);
    const s = e.lastIndexOf(t);
    return r !== s ? n : r
}
const $G = (e,t)=>e === null ? null : gn(Math.round(e), 0, t);
function y7(e) {
    const t = this.getLabels();
    return e >= 0 && e < t.length ? t[e] : e
}
class Vg extends ao {
    constructor(t) {
        super(t),
        this._startValue = void 0,
        this._valueRange = 0,
        this._addedLabels = []
    }
    init(t) {
        const n = this._addedLabels;
        if (n.length) {
            const i = this.getLabels();
            for (const {index: r, label: s} of n)
                i[r] === s && i.splice(r, 1);
            this._addedLabels = []
        }
        super.init(t)
    }
    parse(t, n) {
        if (ft(t))
            return null;
        const i = this.getLabels();
        return n = isFinite(n) && i[n] === t ? n : YG(i, t, He(n, t), this._addedLabels),
        $G(n, i.length - 1)
    }
    determineDataLimits() {
        const {minDefined: t, maxDefined: n} = this.getUserBounds();
        let {min: i, max: r} = this.getMinMax(!0);
        this.options.bounds === "ticks" && (t || (i = 0),
        n || (r = this.getLabels().length - 1)),
        this.min = i,
        this.max = r
    }
    buildTicks() {
        const t = this.min
          , n = this.max
          , i = this.options.offset
          , r = [];
        let s = this.getLabels();
        s = t === 0 && n === s.length - 1 ? s : s.slice(t, n + 1),
        this._valueRange = Math.max(s.length - (i ? 0 : 1), 1),
        this._startValue = this.min - (i ? .5 : 0);
        for (let o = t; o <= n; o++)
            r.push({
                value: o
            });
        return r
    }
    getLabelForValue(t) {
        return y7.call(this, t)
    }
    configure() {
        super.configure(),
        this.isHorizontal() || (this._reversePixels = !this._reversePixels)
    }
    getPixelForValue(t) {
        return typeof t != "number" && (t = this.parse(t)),
        t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
    }
    getPixelForTick(t) {
        const n = this.ticks;
        return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value)
    }
    getValueForPixel(t) {
        return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)
    }
    getBasePixel() {
        return this.bottom
    }
}
je(Vg, "id", "category"),
je(Vg, "defaults", {
    ticks: {
        callback: y7
    }
});
function KG(e, t) {
    const n = []
      , {bounds: r, step: s, min: o, max: a, precision: l, count: c, maxTicks: u, maxDigits: h, includeBounds: d} = e
      , m = s || 1
      , f = u - 1
      , {min: x, max: S} = t
      , v = !ft(o)
      , p = !ft(a)
      , g = !ft(c)
      , C = (S - x) / (h + 1);
    let E = y6((S - x) / f / m) * m, O, R, F, P;
    if (E < 1e-14 && !v && !p)
        return [{
            value: x
        }, {
            value: S
        }];
    P = Math.ceil(S / E) - Math.floor(x / E),
    P > f && (E = y6(P * E / f / m) * m),
    ft(l) || (O = Math.pow(10, l),
    E = Math.ceil(E * O) / O),
    r === "ticks" ? (R = Math.floor(x / E) * E,
    F = Math.ceil(S / E) * E) : (R = x,
    F = S),
    v && p && s && vW((a - o) / s, E / 1e3) ? (P = Math.round(Math.min((a - o) / E, u)),
    E = (a - o) / P,
    R = o,
    F = a) : g ? (R = v ? o : R,
    F = p ? a : F,
    P = c - 1,
    E = (F - R) / P) : (P = (F - R) / E,
    bl(P, Math.round(P), E / 1e3) ? P = Math.round(P) : P = Math.ceil(P));
    const _ = Math.max(x6(E), x6(R));
    O = Math.pow(10, ft(l) ? _ : l),
    R = Math.round(R * O) / O,
    F = Math.round(F * O) / O;
    let T = 0;
    for (v && (d && R !== o ? (n.push({
        value: o
    }),
    R < o && T++,
    bl(Math.round((R + T * E) * O) / O, o, x7(o, C, e)) && T++) : R < o && T++); T < P; ++T) {
        const L = Math.round((R + T * E) * O) / O;
        if (p && L > a)
            break;
        n.push({
            value: L
        })
    }
    return p && d && F !== a ? n.length && bl(n[n.length - 1].value, a, x7(a, C, e)) ? n[n.length - 1].value = a : n.push({
        value: a
    }) : (!p || F === a) && n.push({
        value: F
    }),
    n
}
function x7(e, t, {horizontal: n, minRotation: i}) {
    const r = Ni(i)
      , s = (n ? Math.sin(r) : Math.cos(r)) || .001
      , o = .75 * t * ("" + e).length;
    return Math.min(t / s, o)
}
class ld extends ao {
    constructor(t) {
        super(t),
        this.start = void 0,
        this.end = void 0,
        this._startValue = void 0,
        this._endValue = void 0,
        this._valueRange = 0
    }
    parse(t, n) {
        return ft(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t
    }
    handleTickRangeOptions() {
        const {beginAtZero: t} = this.options
          , {minDefined: n, maxDefined: i} = this.getUserBounds();
        let {min: r, max: s} = this;
        const o = l=>r = n ? r : l
          , a = l=>s = i ? s : l;
        if (t) {
            const l = ma(r)
              , c = ma(s);
            l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && o(0)
        }
        if (r === s) {
            let l = s === 0 ? 1 : Math.abs(s * .05);
            a(s + l),
            t || o(r - l)
        }
        this.min = r,
        this.max = s
    }
    getTickLimit() {
        const t = this.options.ticks;
        let {maxTicksLimit: n, stepSize: i} = t, r;
        return i ? (r = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1,
        r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${r} ticks. Limiting to 1000.`),
        r = 1e3)) : (r = this.computeTickLimit(),
        n = n || 11),
        n && (r = Math.min(n, r)),
        r
    }
    computeTickLimit() {
        return Number.POSITIVE_INFINITY
    }
    buildTicks() {
        const t = this.options
          , n = t.ticks;
        let i = this.getTickLimit();
        i = Math.max(2, i);
        const r = {
            maxTicks: i,
            bounds: t.bounds,
            min: t.min,
            max: t.max,
            precision: n.precision,
            step: n.stepSize,
            count: n.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: n.minRotation || 0,
            includeBounds: n.includeBounds !== !1
        }
          , s = this._range || this
          , o = KG(r, s);
        return t.bounds === "ticks" && Lk(o, this, "value"),
        t.reverse ? (o.reverse(),
        this.start = this.max,
        this.end = this.min) : (this.start = this.min,
        this.end = this.max),
        o
    }
    configure() {
        const t = this.ticks;
        let n = this.min
          , i = this.max;
        if (super.configure(),
        this.options.offset && t.length) {
            const r = (i - n) / Math.max(t.length - 1, 1) / 2;
            n -= r,
            i += r
        }
        this._startValue = n,
        this._endValue = i,
        this._valueRange = i - n
    }
    getLabelForValue(t) {
        return sf(t, this.chart.options.locale, this.options.ticks.format)
    }
}
class Wg extends ld {
    determineDataLimits() {
        const {min: t, max: n} = this.getMinMax(!0);
        this.min = Pt(t) ? t : 0,
        this.max = Pt(n) ? n : 1,
        this.handleTickRangeOptions()
    }
    computeTickLimit() {
        const t = this.isHorizontal()
          , n = t ? this.width : this.height
          , i = Ni(this.options.ticks.minRotation)
          , r = (t ? Math.sin(i) : Math.cos(i)) || .001
          , s = this._resolveTickFontOptions(0);
        return Math.ceil(n / Math.min(40, s.lineHeight / r))
    }
    getPixelForValue(t) {
        return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
    }
    getValueForPixel(t) {
        return this._startValue + this.getDecimalForPixel(t) * this._valueRange
    }
}
je(Wg, "id", "linear"),
je(Wg, "defaults", {
    ticks: {
        callback: of.formatters.numeric
    }
});
const rc = e=>Math.floor(Lr(e))
  , xs = (e,t)=>Math.pow(10, rc(e) + t);
function b7(e) {
    return e / Math.pow(10, rc(e)) === 1
}
function w7(e, t, n) {
    const i = Math.pow(10, n)
      , r = Math.floor(e / i);
    return Math.ceil(t / i) - r
}
function QG(e, t) {
    const n = t - e;
    let i = rc(n);
    for (; w7(e, t, i) > 10; )
        i++;
    for (; w7(e, t, i) < 10; )
        i--;
    return Math.min(i, rc(e))
}
function qG(e, {min: t, max: n}) {
    t = _n(e.min, t);
    const i = []
      , r = rc(t);
    let s = QG(t, n)
      , o = s < 0 ? Math.pow(10, Math.abs(s)) : 1;
    const a = Math.pow(10, s)
      , l = r > s ? Math.pow(10, r) : 0
      , c = Math.round((t - l) * o) / o
      , u = Math.floor((t - l) / a / 10) * a * 10;
    let h = Math.floor((c - u) / Math.pow(10, s))
      , d = _n(e.min, Math.round((l + u + h * Math.pow(10, s)) * o) / o);
    for (; d < n; )
        i.push({
            value: d,
            major: b7(d),
            significand: h
        }),
        h >= 10 ? h = h < 15 ? 15 : 20 : h++,
        h >= 20 && (s++,
        h = 2,
        o = s >= 0 ? 1 : o),
        d = Math.round((l + u + h * Math.pow(10, s)) * o) / o;
    const m = _n(e.max, d);
    return i.push({
        value: m,
        major: b7(m),
        significand: h
    }),
    i
}
class S7 extends ao {
    constructor(t) {
        super(t),
        this.start = void 0,
        this.end = void 0,
        this._startValue = void 0,
        this._valueRange = 0
    }
    parse(t, n) {
        const i = ld.prototype.parse.apply(this, [t, n]);
        if (i === 0) {
            this._zero = !0;
            return
        }
        return Pt(i) && i > 0 ? i : null
    }
    determineDataLimits() {
        const {min: t, max: n} = this.getMinMax(!0);
        this.min = Pt(t) ? Math.max(0, t) : null,
        this.max = Pt(n) ? Math.max(0, n) : null,
        this.options.beginAtZero && (this._zero = !0),
        this._zero && this.min !== this._suggestedMin && !Pt(this._userMin) && (this.min = t === xs(this.min, 0) ? xs(this.min, -1) : xs(this.min, 0)),
        this.handleTickRangeOptions()
    }
    handleTickRangeOptions() {
        const {minDefined: t, maxDefined: n} = this.getUserBounds();
        let i = this.min
          , r = this.max;
        const s = a=>i = t ? i : a
          , o = a=>r = n ? r : a;
        i === r && (i <= 0 ? (s(1),
        o(10)) : (s(xs(i, -1)),
        o(xs(r, 1)))),
        i <= 0 && s(xs(r, -1)),
        r <= 0 && o(xs(i, 1)),
        this.min = i,
        this.max = r
    }
    buildTicks() {
        const t = this.options
          , n = {
            min: this._userMin,
            max: this._userMax
        }
          , i = qG(n, this);
        return t.bounds === "ticks" && Lk(i, this, "value"),
        t.reverse ? (i.reverse(),
        this.start = this.max,
        this.end = this.min) : (this.start = this.min,
        this.end = this.max),
        i
    }
    getLabelForValue(t) {
        return t === void 0 ? "0" : sf(t, this.chart.options.locale, this.options.ticks.format)
    }
    configure() {
        const t = this.min;
        super.configure(),
        this._startValue = Lr(t),
        this._valueRange = Lr(this.max) - Lr(t)
    }
    getPixelForValue(t) {
        return (t === void 0 || t === 0) && (t = this.min),
        t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (Lr(t) - this._startValue) / this._valueRange)
    }
    getValueForPixel(t) {
        const n = this.getDecimalForPixel(t);
        return Math.pow(10, this._startValue + n * this._valueRange)
    }
}
je(S7, "id", "logarithmic"),
je(S7, "defaults", {
    ticks: {
        callback: of.formatters.logarithmic,
        major: {
            enabled: !0
        }
    }
});
function Hg(e) {
    const t = e.ticks;
    if (t.display && e.display) {
        const n = cn(t.backdropPadding);
        return He(t.font && t.font.size, Tt.font.size) + n.height
    }
    return 0
}
function ZG(e, t, n) {
    return n = yt(n) ? n : [n],
    {
        w: FW(e, t.string, n),
        h: n.length * t.lineHeight
    }
}
function C7(e, t, n, i, r) {
    return e === i || e === r ? {
        start: t - n / 2,
        end: t + n / 2
    } : e < i || e > r ? {
        start: t - n,
        end: t
    } : {
        start: t,
        end: t + n
    }
}
function JG(e) {
    const t = {
        l: e.left + e._padding.left,
        r: e.right - e._padding.right,
        t: e.top + e._padding.top,
        b: e.bottom - e._padding.bottom
    }
      , n = Object.assign({}, t)
      , i = []
      , r = []
      , s = e._pointLabels.length
      , o = e.options.pointLabels
      , a = o.centerPointLabels ? xt / s : 0;
    for (let l = 0; l < s; l++) {
        const c = o.setContext(e.getPointLabelContext(l));
        r[l] = c.padding;
        const u = e.getPointPosition(l, e.drawingArea + r[l], a)
          , h = Ht(c.font)
          , d = ZG(e.ctx, h, e._pointLabels[l]);
        i[l] = d;
        const m = Nn(e.getIndexAngle(l) + a)
          , f = Math.round(tv(m))
          , x = C7(f, u.x, d.w, 0, 180)
          , S = C7(f, u.y, d.h, 90, 270);
        eX(n, t, m, x, S)
    }
    e.setCenterPoint(t.l - n.l, n.r - t.r, t.t - n.t, n.b - t.b),
    e._pointLabelItems = iX(e, i, r)
}
function eX(e, t, n, i, r) {
    const s = Math.abs(Math.sin(n))
      , o = Math.abs(Math.cos(n));
    let a = 0
      , l = 0;
    i.start < t.l ? (a = (t.l - i.start) / s,
    e.l = Math.min(e.l, t.l - a)) : i.end > t.r && (a = (i.end - t.r) / s,
    e.r = Math.max(e.r, t.r + a)),
    r.start < t.t ? (l = (t.t - r.start) / o,
    e.t = Math.min(e.t, t.t - l)) : r.end > t.b && (l = (r.end - t.b) / o,
    e.b = Math.max(e.b, t.b + l))
}
function tX(e, t, n) {
    const i = e.drawingArea
      , {extra: r, additionalAngle: s, padding: o, size: a} = n
      , l = e.getPointPosition(t, i + r + o, s)
      , c = Math.round(tv(Nn(l.angle + Rt)))
      , u = oX(l.y, a.h, c)
      , h = rX(c)
      , d = sX(l.x, a.w, h);
    return {
        visible: !0,
        x: l.x,
        y: u,
        textAlign: h,
        left: d,
        top: u,
        right: d + a.w,
        bottom: u + a.h
    }
}
function nX(e, t) {
    if (!t)
        return !0;
    const {left: n, top: i, right: r, bottom: s} = e;
    return !(rr({
        x: n,
        y: i
    }, t) || rr({
        x: n,
        y: s
    }, t) || rr({
        x: r,
        y: i
    }, t) || rr({
        x: r,
        y: s
    }, t))
}
function iX(e, t, n) {
    const i = []
      , r = e._pointLabels.length
      , s = e.options
      , {centerPointLabels: o, display: a} = s.pointLabels
      , l = {
        extra: Hg(s) / 2,
        additionalAngle: o ? xt / r : 0
    };
    let c;
    for (let u = 0; u < r; u++) {
        l.padding = n[u],
        l.size = t[u];
        const h = tX(e, u, l);
        i.push(h),
        a === "auto" && (h.visible = nX(h, c),
        h.visible && (c = h))
    }
    return i
}
function rX(e) {
    return e === 0 || e === 180 ? "center" : e < 180 ? "left" : "right"
}
function sX(e, t, n) {
    return n === "right" ? e -= t : n === "center" && (e -= t / 2),
    e
}
function oX(e, t, n) {
    return n === 90 || n === 270 ? e -= t / 2 : (n > 270 || n < 90) && (e -= t),
    e
}
function aX(e, t, n) {
    const {left: i, top: r, right: s, bottom: o} = n
      , {backdropColor: a} = t;
    if (!ft(a)) {
        const l = ea(t.borderRadius)
          , c = cn(t.backdropPadding);
        e.fillStyle = a;
        const u = i - c.left
          , h = r - c.top
          , d = s - i + c.width
          , m = o - r + c.height;
        Object.values(l).some(f=>f !== 0) ? (e.beginPath(),
        rd(e, {
            x: u,
            y: h,
            w: d,
            h: m,
            radius: l
        }),
        e.fill()) : e.fillRect(u, h, d, m)
    }
}
function lX(e, t) {
    const {ctx: n, options: {pointLabels: i}} = e;
    for (let r = t - 1; r >= 0; r--) {
        const s = e._pointLabelItems[r];
        if (!s.visible)
            continue;
        const o = i.setContext(e.getPointLabelContext(r));
        aX(n, o, s);
        const a = Ht(o.font)
          , {x: l, y: c, textAlign: u} = s;
        Js(n, e._pointLabels[r], l, c + a.lineHeight / 2, a, {
            color: o.color,
            textAlign: u,
            textBaseline: "middle"
        })
    }
}
function vA(e, t, n, i) {
    const {ctx: r} = e;
    if (n)
        r.arc(e.xCenter, e.yCenter, t, 0, mt);
    else {
        let s = e.getPointPosition(0, t);
        r.moveTo(s.x, s.y);
        for (let o = 1; o < i; o++)
            s = e.getPointPosition(o, t),
            r.lineTo(s.x, s.y)
    }
}
function cX(e, t, n, i, r) {
    const s = e.ctx
      , o = t.circular
      , {color: a, lineWidth: l} = t;
    !o && !i || !a || !l || n < 0 || (s.save(),
    s.strokeStyle = a,
    s.lineWidth = l,
    s.setLineDash(r.dash),
    s.lineDashOffset = r.dashOffset,
    s.beginPath(),
    vA(e, n, o, i),
    s.closePath(),
    s.stroke(),
    s.restore())
}
function uX(e, t, n) {
    return os(e, {
        label: n,
        index: t,
        type: "pointLabel"
    })
}
class Lu extends ld {
    constructor(t) {
        super(t),
        this.xCenter = void 0,
        this.yCenter = void 0,
        this.drawingArea = void 0,
        this._pointLabels = [],
        this._pointLabelItems = []
    }
    setDimensions() {
        const t = this._padding = cn(Hg(this.options) / 2)
          , n = this.width = this.maxWidth - t.width
          , i = this.height = this.maxHeight - t.height;
        this.xCenter = Math.floor(this.left + n / 2 + t.left),
        this.yCenter = Math.floor(this.top + i / 2 + t.top),
        this.drawingArea = Math.floor(Math.min(n, i) / 2)
    }
    determineDataLimits() {
        const {min: t, max: n} = this.getMinMax(!1);
        this.min = Pt(t) && !isNaN(t) ? t : 0,
        this.max = Pt(n) && !isNaN(n) ? n : 0,
        this.handleTickRangeOptions()
    }
    computeTickLimit() {
        return Math.ceil(this.drawingArea / Hg(this.options))
    }
    generateTickLabels(t) {
        ld.prototype.generateTickLabels.call(this, t),
        this._pointLabels = this.getLabels().map((n,i)=>{
            const r = at(this.options.pointLabels.callback, [n, i], this);
            return r || r === 0 ? r : ""
        }
        ).filter((n,i)=>this.chart.getDataVisibility(i))
    }
    fit() {
        const t = this.options;
        t.display && t.pointLabels.display ? JG(this) : this.setCenterPoint(0, 0, 0, 0)
    }
    setCenterPoint(t, n, i, r) {
        this.xCenter += Math.floor((t - n) / 2),
        this.yCenter += Math.floor((i - r) / 2),
        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, n, i, r))
    }
    getIndexAngle(t) {
        const n = mt / (this._pointLabels.length || 1)
          , i = this.options.startAngle || 0;
        return Nn(t * n + Ni(i))
    }
    getDistanceFromCenterForValue(t) {
        if (ft(t))
            return NaN;
        const n = this.drawingArea / (this.max - this.min);
        return this.options.reverse ? (this.max - t) * n : (t - this.min) * n
    }
    getValueForDistanceFromCenter(t) {
        if (ft(t))
            return NaN;
        const n = t / (this.drawingArea / (this.max - this.min));
        return this.options.reverse ? this.max - n : this.min + n
    }
    getPointLabelContext(t) {
        const n = this._pointLabels || [];
        if (t >= 0 && t < n.length) {
            const i = n[t];
            return uX(this.getContext(), t, i)
        }
    }
    getPointPosition(t, n, i=0) {
        const r = this.getIndexAngle(t) - Rt + i;
        return {
            x: Math.cos(r) * n + this.xCenter,
            y: Math.sin(r) * n + this.yCenter,
            angle: r
        }
    }
    getPointPositionForValue(t, n) {
        return this.getPointPosition(t, this.getDistanceFromCenterForValue(n))
    }
    getBasePosition(t) {
        return this.getPointPositionForValue(t || 0, this.getBaseValue())
    }
    getPointLabelPosition(t) {
        const {left: n, top: i, right: r, bottom: s} = this._pointLabelItems[t];
        return {
            left: n,
            top: i,
            right: r,
            bottom: s
        }
    }
    drawBackground() {
        const {backgroundColor: t, grid: {circular: n}} = this.options;
        if (t) {
            const i = this.ctx;
            i.save(),
            i.beginPath(),
            vA(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length),
            i.closePath(),
            i.fillStyle = t,
            i.fill(),
            i.restore()
        }
    }
    drawGrid() {
        const t = this.ctx
          , n = this.options
          , {angleLines: i, grid: r, border: s} = n
          , o = this._pointLabels.length;
        let a, l, c;
        if (n.pointLabels.display && lX(this, o),
        r.display && this.ticks.forEach((u,h)=>{
            if (h !== 0) {
                l = this.getDistanceFromCenterForValue(u.value);
                const d = this.getContext(h)
                  , m = r.setContext(d)
                  , f = s.setContext(d);
                cX(this, m, l, o, f)
            }
        }
        ),
        i.display) {
            for (t.save(),
            a = o - 1; a >= 0; a--) {
                const u = i.setContext(this.getPointLabelContext(a))
                  , {color: h, lineWidth: d} = u;
                !d || !h || (t.lineWidth = d,
                t.strokeStyle = h,
                t.setLineDash(u.borderDash),
                t.lineDashOffset = u.borderDashOffset,
                l = this.getDistanceFromCenterForValue(n.ticks.reverse ? this.min : this.max),
                c = this.getPointPosition(a, l),
                t.beginPath(),
                t.moveTo(this.xCenter, this.yCenter),
                t.lineTo(c.x, c.y),
                t.stroke())
            }
            t.restore()
        }
    }
    drawBorder() {}
    drawLabels() {
        const t = this.ctx
          , n = this.options
          , i = n.ticks;
        if (!i.display)
            return;
        const r = this.getIndexAngle(0);
        let s, o;
        t.save(),
        t.translate(this.xCenter, this.yCenter),
        t.rotate(r),
        t.textAlign = "center",
        t.textBaseline = "middle",
        this.ticks.forEach((a,l)=>{
            if (l === 0 && !n.reverse)
                return;
            const c = i.setContext(this.getContext(l))
              , u = Ht(c.font);
            if (s = this.getDistanceFromCenterForValue(this.ticks[l].value),
            c.showLabelBackdrop) {
                t.font = u.string,
                o = t.measureText(a.label).width,
                t.fillStyle = c.backdropColor;
                const h = cn(c.backdropPadding);
                t.fillRect(-o / 2 - h.left, -s - u.size / 2 - h.top, o + h.width, u.size + h.height)
            }
            Js(t, a.label, 0, -s, u, {
                color: c.color,
                strokeColor: c.textStrokeColor,
                strokeWidth: c.textStrokeWidth
            })
        }
        ),
        t.restore()
    }
    drawTitle() {}
}
je(Lu, "id", "radialLinear"),
je(Lu, "defaults", {
    display: !0,
    animate: !0,
    position: "chartArea",
    angleLines: {
        display: !0,
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0
    },
    grid: {
        circular: !1
    },
    startAngle: 0,
    ticks: {
        showLabelBackdrop: !0,
        callback: of.formatters.numeric
    },
    pointLabels: {
        backdropColor: void 0,
        backdropPadding: 2,
        display: !0,
        font: {
            size: 10
        },
        callback(t) {
            return t
        },
        padding: 5,
        centerPointLabels: !1
    }
}),
je(Lu, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
}),
je(Lu, "descriptors", {
    angleLines: {
        _fallback: "grid"
    }
});
const uf = {
    millisecond: {
        common: !0,
        size: 1,
        steps: 1e3
    },
    second: {
        common: !0,
        size: 1e3,
        steps: 60
    },
    minute: {
        common: !0,
        size: 6e4,
        steps: 60
    },
    hour: {
        common: !0,
        size: 36e5,
        steps: 24
    },
    day: {
        common: !0,
        size: 864e5,
        steps: 30
    },
    week: {
        common: !1,
        size: 6048e5,
        steps: 4
    },
    month: {
        common: !0,
        size: 2628e6,
        steps: 12
    },
    quarter: {
        common: !1,
        size: 7884e6,
        steps: 4
    },
    year: {
        common: !0,
        size: 3154e7
    }
}
  , Cn = Object.keys(uf);
function k7(e, t) {
    return e - t
}
function A7(e, t) {
    if (ft(t))
        return null;
    const n = e._adapter
      , {parser: i, round: r, isoWeekday: s} = e._parseOpts;
    let o = t;
    return typeof i == "function" && (o = i(o)),
    Pt(o) || (o = typeof i == "string" ? n.parse(o, i) : n.parse(o)),
    o === null ? null : (r && (o = r === "week" && (tc(s) || s === !0) ? n.startOf(o, "isoWeek", s) : n.startOf(o, r)),
    +o)
}
function M7(e, t, n, i) {
    const r = Cn.length;
    for (let s = Cn.indexOf(e); s < r - 1; ++s) {
        const o = uf[Cn[s]]
          , a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER;
        if (o.common && Math.ceil((n - t) / (a * o.size)) <= i)
            return Cn[s]
    }
    return Cn[r - 1]
}
function hX(e, t, n, i, r) {
    for (let s = Cn.length - 1; s >= Cn.indexOf(n); s--) {
        const o = Cn[s];
        if (uf[o].common && e._adapter.diff(r, i, o) >= t - 1)
            return o
    }
    return Cn[n ? Cn.indexOf(n) : 0]
}
function dX(e) {
    for (let t = Cn.indexOf(e) + 1, n = Cn.length; t < n; ++t)
        if (uf[Cn[t]].common)
            return Cn[t]
}
function E7(e, t, n) {
    if (!n)
        e[t] = !0;
    else if (n.length) {
        const {lo: i, hi: r} = nv(n, t)
          , s = n[i] >= t ? n[i] : n[r];
        e[s] = !0
    }
}
function fX(e, t, n, i) {
    const r = e._adapter
      , s = +r.startOf(t[0].value, i)
      , o = t[t.length - 1].value;
    let a, l;
    for (a = s; a <= o; a = +r.add(a, 1, i))
        l = n[a],
        l >= 0 && (t[l].major = !0);
    return t
}
function P7(e, t, n) {
    const i = []
      , r = {}
      , s = t.length;
    let o, a;
    for (o = 0; o < s; ++o)
        a = t[o],
        r[a] = o,
        i.push({
            value: a,
            major: !1
        });
    return s === 0 || !n ? i : fX(e, i, r, n)
}
class cd extends ao {
    constructor(t) {
        super(t),
        this._cache = {
            data: [],
            labels: [],
            all: []
        },
        this._unit = "day",
        this._majorUnit = void 0,
        this._offsets = {},
        this._normalized = !1,
        this._parseOpts = void 0
    }
    init(t, n={}) {
        const i = t.time || (t.time = {})
          , r = this._adapter = new HH._date(t.adapters.date);
        r.init(n),
        xl(i.displayFormats, r.formats()),
        this._parseOpts = {
            parser: i.parser,
            round: i.round,
            isoWeekday: i.isoWeekday
        },
        super.init(t),
        this._normalized = n.normalized
    }
    parse(t, n) {
        return t === void 0 ? null : A7(this, t)
    }
    beforeLayout() {
        super.beforeLayout(),
        this._cache = {
            data: [],
            labels: [],
            all: []
        }
    }
    determineDataLimits() {
        const t = this.options
          , n = this._adapter
          , i = t.time.unit || "day";
        let {min: r, max: s, minDefined: o, maxDefined: a} = this.getUserBounds();
        function l(c) {
            !o && !isNaN(c.min) && (r = Math.min(r, c.min)),
            !a && !isNaN(c.max) && (s = Math.max(s, c.max))
        }
        (!o || !a) && (l(this._getLabelBounds()),
        (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))),
        r = Pt(r) && !isNaN(r) ? r : +n.startOf(Date.now(), i),
        s = Pt(s) && !isNaN(s) ? s : +n.endOf(Date.now(), i) + 1,
        this.min = Math.min(r, s - 1),
        this.max = Math.max(r + 1, s)
    }
    _getLabelBounds() {
        const t = this.getLabelTimestamps();
        let n = Number.POSITIVE_INFINITY
          , i = Number.NEGATIVE_INFINITY;
        return t.length && (n = t[0],
        i = t[t.length - 1]),
        {
            min: n,
            max: i
        }
    }
    buildTicks() {
        const t = this.options
          , n = t.time
          , i = t.ticks
          , r = i.source === "labels" ? this.getLabelTimestamps() : this._generate();
        t.bounds === "ticks" && r.length && (this.min = this._userMin || r[0],
        this.max = this._userMax || r[r.length - 1]);
        const s = this.min
          , o = this.max
          , a = wW(r, s, o);
        return this._unit = n.unit || (i.autoSkip ? M7(n.minUnit, this.min, this.max, this._getLabelCapacity(s)) : hX(this, a.length, n.minUnit, this.min, this.max)),
        this._majorUnit = !i.major.enabled || this._unit === "year" ? void 0 : dX(this._unit),
        this.initOffsets(r),
        t.reverse && a.reverse(),
        P7(this, a, this._majorUnit)
    }
    afterAutoSkip() {
        this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(t=>+t.value))
    }
    initOffsets(t=[]) {
        let n = 0, i = 0, r, s;
        this.options.offset && t.length && (r = this.getDecimalForValue(t[0]),
        t.length === 1 ? n = 1 - r : n = (this.getDecimalForValue(t[1]) - r) / 2,
        s = this.getDecimalForValue(t[t.length - 1]),
        t.length === 1 ? i = s : i = (s - this.getDecimalForValue(t[t.length - 2])) / 2);
        const o = t.length < 3 ? .5 : .25;
        n = gn(n, 0, o),
        i = gn(i, 0, o),
        this._offsets = {
            start: n,
            end: i,
            factor: 1 / (n + 1 + i)
        }
    }
    _generate() {
        const t = this._adapter
          , n = this.min
          , i = this.max
          , r = this.options
          , s = r.time
          , o = s.unit || M7(s.minUnit, n, i, this._getLabelCapacity(n))
          , a = He(r.ticks.stepSize, 1)
          , l = o === "week" ? s.isoWeekday : !1
          , c = tc(l) || l === !0
          , u = {};
        let h = n, d, m;
        if (c && (h = +t.startOf(h, "isoWeek", l)),
        h = +t.startOf(h, c ? "day" : o),
        t.diff(i, n, o) > 1e5 * a)
            throw new Error(n + " and " + i + " are too far apart with stepSize of " + a + " " + o);
        const f = r.ticks.source === "data" && this.getDataTimestamps();
        for (d = h,
        m = 0; d < i; d = +t.add(d, a, o),
        m++)
            E7(u, d, f);
        return (d === i || r.bounds === "ticks" || m === 1) && E7(u, d, f),
        Object.keys(u).sort(k7).map(x=>+x)
    }
    getLabelForValue(t) {
        const n = this._adapter
          , i = this.options.time;
        return i.tooltipFormat ? n.format(t, i.tooltipFormat) : n.format(t, i.displayFormats.datetime)
    }
    format(t, n) {
        const r = this.options.time.displayFormats
          , s = this._unit
          , o = n || r[s];
        return this._adapter.format(t, o)
    }
    _tickFormatFunction(t, n, i, r) {
        const s = this.options
          , o = s.ticks.callback;
        if (o)
            return at(o, [t, n, i], this);
        const a = s.time.displayFormats
          , l = this._unit
          , c = this._majorUnit
          , u = l && a[l]
          , h = c && a[c]
          , d = i[n]
          , m = c && h && d && d.major;
        return this._adapter.format(t, r || (m ? h : u))
    }
    generateTickLabels(t) {
        let n, i, r;
        for (n = 0,
        i = t.length; n < i; ++n)
            r = t[n],
            r.label = this._tickFormatFunction(r.value, n, t)
    }
    getDecimalForValue(t) {
        return t === null ? NaN : (t - this.min) / (this.max - this.min)
    }
    getPixelForValue(t) {
        const n = this._offsets
          , i = this.getDecimalForValue(t);
        return this.getPixelForDecimal((n.start + i) * n.factor)
    }
    getValueForPixel(t) {
        const n = this._offsets
          , i = this.getDecimalForPixel(t) / n.factor - n.end;
        return this.min + i * (this.max - this.min)
    }
    _getLabelSize(t) {
        const n = this.options.ticks
          , i = this.ctx.measureText(t).width
          , r = Ni(this.isHorizontal() ? n.maxRotation : n.minRotation)
          , s = Math.cos(r)
          , o = Math.sin(r)
          , a = this._resolveTickFontOptions(0).size;
        return {
            w: i * s + a * o,
            h: i * o + a * s
        }
    }
    _getLabelCapacity(t) {
        const n = this.options.time
          , i = n.displayFormats
          , r = i[n.unit] || i.millisecond
          , s = this._tickFormatFunction(t, 0, P7(this, [t], this._majorUnit), r)
          , o = this._getLabelSize(s)
          , a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
        return a > 0 ? a : 1
    }
    getDataTimestamps() {
        let t = this._cache.data || [], n, i;
        if (t.length)
            return t;
        const r = this.getMatchingVisibleMetas();
        if (this._normalized && r.length)
            return this._cache.data = r[0].controller.getAllParsedValues(this);
        for (n = 0,
        i = r.length; n < i; ++n)
            t = t.concat(r[n].controller.getAllParsedValues(this));
        return this._cache.data = this.normalize(t)
    }
    getLabelTimestamps() {
        const t = this._cache.labels || [];
        let n, i;
        if (t.length)
            return t;
        const r = this.getLabels();
        for (n = 0,
        i = r.length; n < i; ++n)
            t.push(A7(this, r[n]));
        return this._cache.labels = this._normalized ? t : this.normalize(t)
    }
    normalize(t) {
        return CW(t.sort(k7))
    }
}
je(cd, "id", "time"),
je(cd, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
        parser: !1,
        unit: !1,
        round: !1,
        isoWeekday: !1,
        minUnit: "millisecond",
        displayFormats: {}
    },
    ticks: {
        source: "auto",
        callback: !1,
        major: {
            enabled: !1
        }
    }
});
function Ru(e, t, n) {
    let i = 0, r = e.length - 1, s, o, a, l;
    n ? (t >= e[i].pos && t <= e[r].pos && ({lo: i, hi: r} = Bs(e, "pos", t)),
    {pos: s, time: a} = e[i],
    {pos: o, time: l} = e[r]) : (t >= e[i].time && t <= e[r].time && ({lo: i, hi: r} = Bs(e, "time", t)),
    {time: s, pos: a} = e[i],
    {time: o, pos: l} = e[r]);
    const c = o - s;
    return c ? a + (l - a) * (t - s) / c : a
}
class T7 extends cd {
    constructor(t) {
        super(t),
        this._table = [],
        this._minPos = void 0,
        this._tableRange = void 0
    }
    initOffsets() {
        const t = this._getTimestampsForTable()
          , n = this._table = this.buildLookupTable(t);
        this._minPos = Ru(n, this.min),
        this._tableRange = Ru(n, this.max) - this._minPos,
        super.initOffsets(t)
    }
    buildLookupTable(t) {
        const {min: n, max: i} = this
          , r = []
          , s = [];
        let o, a, l, c, u;
        for (o = 0,
        a = t.length; o < a; ++o)
            c = t[o],
            c >= n && c <= i && r.push(c);
        if (r.length < 2)
            return [{
                time: n,
                pos: 0
            }, {
                time: i,
                pos: 1
            }];
        for (o = 0,
        a = r.length; o < a; ++o)
            u = r[o + 1],
            l = r[o - 1],
            c = r[o],
            Math.round((u + l) / 2) !== c && s.push({
                time: c,
                pos: o / (a - 1)
            });
        return s
    }
    _generate() {
        const t = this.min
          , n = this.max;
        let i = super.getDataTimestamps();
        return (!i.includes(t) || !i.length) && i.splice(0, 0, t),
        (!i.includes(n) || i.length === 1) && i.push(n),
        i.sort((r,s)=>r - s)
    }
    _getTimestampsForTable() {
        let t = this._cache.all || [];
        if (t.length)
            return t;
        const n = this.getDataTimestamps()
          , i = this.getLabelTimestamps();
        return n.length && i.length ? t = this.normalize(n.concat(i)) : t = n.length ? n : i,
        t = this._cache.all = t,
        t
    }
    getDecimalForValue(t) {
        return (Ru(this._table, t) - this._minPos) / this._tableRange
    }
    getValueForPixel(t) {
        const n = this._offsets
          , i = this.getDecimalForPixel(t) / n.factor - n.end;
        return Ru(this._table, i * this._tableRange + this._minPos, !0)
    }
}
je(T7, "id", "timeseries"),
je(T7, "defaults", cd.defaults);
const yA = "label";
function j7(e, t) {
    typeof e == "function" ? e(t) : e && (e.current = t)
}
function pX(e, t) {
    const n = e.options;
    n && t && Object.assign(n, t)
}
function xA(e, t) {
    e.labels = t
}
function bA(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : yA;
    const i = [];
    e.datasets = t.map(r=>{
        const s = e.datasets.find(o=>o[n] === r[n]);
        return !s || !r.data || i.includes(s) ? {
            ...r
        } : (i.push(s),
        Object.assign(s, r),
        s)
    }
    )
}
function gX(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : yA;
    const n = {
        labels: [],
        datasets: []
    };
    return xA(n, e.labels),
    bA(n, e.datasets, t),
    n
}
function mX(e, t) {
    const {height: n=150, width: i=300, redraw: r=!1, datasetIdKey: s, type: o, data: a, options: l, plugins: c=[], fallbackContent: u, updateMode: h, ...d} = e
      , m = M.useRef(null)
      , f = M.useRef()
      , x = ()=>{
        m.current && (f.current = new Ec(m.current,{
            type: o,
            data: gX(a, s),
            options: l && {
                ...l
            },
            plugins: c
        }),
        j7(t, f.current))
    }
      , S = ()=>{
        j7(t, null),
        f.current && (f.current.destroy(),
        f.current = null)
    }
    ;
    return M.useEffect(()=>{
        !r && f.current && l && pX(f.current, l)
    }
    , [r, l]),
    M.useEffect(()=>{
        !r && f.current && xA(f.current.config.data, a.labels)
    }
    , [r, a.labels]),
    M.useEffect(()=>{
        !r && f.current && a.datasets && bA(f.current.config.data, a.datasets, s)
    }
    , [r, a.datasets]),
    M.useEffect(()=>{
        f.current && (r ? (S(),
        setTimeout(x)) : f.current.update(h))
    }
    , [r, l, a.labels, a.datasets, h]),
    M.useEffect(()=>{
        f.current && (S(),
        setTimeout(x))
    }
    , [o]),
    M.useEffect(()=>(x(),
    ()=>S()), []),
    Ce.createElement("canvas", Object.assign({
        ref: m,
        role: "img",
        height: n,
        width: i
    }, d), u)
}
const vX = M.forwardRef(mX);
function wA(e, t) {
    return Ec.register(t),
    M.forwardRef((n,i)=>Ce.createElement(vX, Object.assign({}, n, {
        ref: i,
        type: e
    })))
}
const yX = wA("line", ih)
  , xX = wA("doughnut", Ja);
Ec.register(Vg, Wg, oh, Rr, IG, mA, fA, hA);
const SA = e=>{
    const [t,n] = Ce.useState([0, 0, 0, 0, 0]);
    Ce.useEffect(()=>{
        n(e.data)
    }
    , [e.data]);
    const i = {
        labels: e.data,
        datasets: [{
            type: "line",
            label: "Line",
            data: t,
            backgroundColor: s=>{
                if (!s.chart.chartArea)
                    return;
                const {ctx: o, chartArea: {top: a, bottom: l}} = s.chart
                  , c = o.createLinearGradient(0, a, 0, l);
                return c.addColorStop(0, "rgba(96, 175, 255, 0.6)"),
                c.addColorStop(1, "rgba(96, 175, 255, 0)"),
                c
            }
            ,
            borderColor: "#2B7AFF",
            borderWidth: 1.5,
            tension: .4,
            order: 1,
            radius: 0,
            fill: !0
        }]
    }
      , r = {
        maintainAspectRatio: !1,
        responsive: !0,
        categoryPercentage: .4,
        scales: {
            y: {
                beginAtZero: !0,
                ticks: {
                    display: !1
                },
                grid: {
                    display: !1
                },
                border: {
                    display: !1
                }
            },
            x: {
                beginAtZero: !0,
                ticks: {
                    display: !1
                },
                grid: {
                    display: !1
                },
                border: {
                    display: !1
                }
            }
        },
        plugins: {
            legend: {
                display: !1
            }
        }
    };
    return y.jsx(yX, {
        data: i,
        options: r
    })
}
  , ud = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAhCAYAAABX5MJvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAY4SURBVHgBtVcLbFRFFD0z720XKIXtB/qBlgXKH0oRNEGx0oL8CggYBUNLQJMiBYWIJEaMGowxKAaUj4YQIykIsSYigUCVfqmBBKHdUqCEUlooUPtdWrbdtvveeN/rh912l36kJ3nvzZu5c++ZO3dm7jD0ECsSzgb3l41RTHCz4CKEAT5UXcMgaoTK8xoNTbnJ3796tyc6WXeElm1JNw1sYu+R9BL6fb4reQFcp2efqogzx3+MLu5K/qkkEhL+GVAv27aBiS30a0LPUUl9dybtnf0tY0ygpyTiNmSPA3ecomI4/ifIerGiiGhPXuFwSyAtFsyR+ywIaKCRmiWO3DWbshd6aHfFmk0ZC1XByAOC45mDqVCVpUd+iDntkcSqd9PNBonliN7Nf3dhV5obpx07OL+greLJaIVgksTS+5iAhn6SwetUfHyKd1uF1FZYXTF7K0Xwm+56jR8zGAtihuONxWEY1K8C1wtKIHuZ4O9rxIABMvobZdgbFfTvz7Ey1oQ5UcMwYYw/GpsUVFY3utHI/OAlNeddOpyh/2kvbRpkiV2iYkBH4ysWmdFkr0bGeQsMsoxJE0dg/NgwBA7t7LB/K2wovV+NCxct8PMbhJhXIqDCgCPJt3C14FFHcatsECN/3hNtlXV3cLGI+LgSCB+M7ZsjkWspBKfQ3py4HF0hcIi3/kyPDNX/75VWweAFbNsYiR27/kZhicNZ3OTQNkDgi5aYYDyxo8J1q1pWZ+TUcERMHoXeIHS4P4LIY4z8vXxRGBoeP3AVYFiqfXh8wvkwkpnk3DZmlA9CggbiWSJiUijCzQY01Fc4V8+IS8gK5kJSIzt2iH4xBH2Bl2eOg91WBrsTESErUZxxNaKj8LQpfugLzJ41FgYKksaGKnqq9TrGuJkLIVwsTqAVMdDby60Sy9UiHD6airSsPLftuXklSDqeTUu41G27t7cRE8cFazGIRnsNrTornSsiRBZgvs7bZsREX7cKcvJuY+tHh6gTI/YMNdV1eH3ZS+3tJ89cxv6DKdrIcDT5Ar7e8RbFwfBOel6YbkZ+QQU4l9DcVEd7pBjE6aitcxYKNw92S+LP1Jx2AhpSs/Jd2lMz8nUCYJL+Tcu84VbPaHOAToCRHJcMUFWlmkMwl3Uzfoz7XXtYsH87Ac1I4BBXOV9fn3YCmoGw0AC3esaPDSTjsk5Ak5MkqUbbh+60CQQN6QdPWLZkJqKjpuhGIqeMwvp35ru0b3h7DsaODqZRyvpynBcz0a0eWaYBBAzWCTCunRrMwuK2ZAWjWdW9oQXlx5sj0dfY/mU6bt15BE5EVI4R/MieqIdC4LKnDucyLMi+cB29Qf6NMtwsLO9UbzQadAKMydeSDy6927JtC/Wk9rlbasO1m5UuHebOnorRI4Oxc/fvOHX2Msorap9q2PqoHr/9kYNDSRfJ9Qzjwoe6tF/JK0PxvcctU8HFPq1Oj7S1lE07mpkWGyahNmPJXBNWrpjRycDZcxbs3n8aQYG+dIr6wdfkDaOXkWKbcv6aejwsq0NFlQ3r181C7DyXkwANdgdS0orw68lbWupCJORiAZXyzoXF7VtEXGLmZ7RcP9fKKhGR1SJMnxqCOeSJcAo4q9WGbZ8cRXllrcsqaPk+KWsb0RAKvK8+jYXPQCOKSmpgyS/HX5nFaGhQdQ8QAXoMH/xyIGZ3uyc0xH+Y4i0ajBYqjm4jUlWWA8VR3xrJ3GUf8ERAX/9O+0DbKuBMbiWg1xUfPRAzqu0a0J7eJe2abyPLsdq06g0k7B/0HLz6mXpJQG4lIDsRkLV2qyp4tPM9xCWjpiz4JhGJ07NinYgM34DJdOj49MIDcqsHpHYPUFnlClvd8f7h9vITl5i+gLQcQ2vSK1QFtdZCOJrru+kBudUD0hMPMNlK4RjXMd33SELDWso7lZbs26wTEQrqam5DURp7GAP0hXRbqNLiYwejC9zZ6uJCLFj8pswtdHK9r5HRiNhq71Gw2vU40ZL1pxHgzGClyu8km/pNUhLFnAd061auecUhsYV09m+kuZlkq7tPF6lmjwTA5Cs0JSfsA2x7T+xZbu1Kf7dIOGNdYmaoXbFH2uofTpWE5Ec3JhPN/WMuGe/TnJdQzGcd/+m1Bz3R+R8jXBZgDKx0ZQAAAABJRU5ErkJggg=="
  , hd = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAhCAYAAABX5MJvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAQASURBVHgBvZdfaFNXHMe/597bJG2SNv1jim0S65gwBtuUoeuYFbuBNPokwz3sZT50D3sYOtnbBtr3TS2MDbaH/WGwp+HYkBRh61gL61pmVfAPiFjTtNG0mjaJNc2fe/yd3FpMmnvvibb9QLgnl+8993t+53fO71yGGgj8Ed8PTe0GlD0c2MWARg7eTNc0OItyFOMkG1EZG46G/aOy/TI7ge/cbZ/H5TlGL/kQjHdCEg42BV0fmDnk/8FOa2kicD7RxxXlGwbehWdExkxVE2L03nrPSc5xHOsE1/UzM4faT0DGhDDgdrqHGWM7sf5MZLLagYXDzQtP31QqVTT/FzbIgGC321X4SwzU1EQwMvelEGIDodDvctNUV9wz6IwkjjKw77FZcH4wdtAfEc2nIqGcxHOyrUHFVqcipeUMX/vOJX2rJowoVF+GrQ5mu5nsa3VgsrcFo/uaMU7XX3Y34QW3iu6WOhzpdFZ9hnrt8jhyx412ycT8bTMTn7/khkqygRuZqp0F6hX809OMOmWt1dgjHf0XU5ima6qgV3t8Nhbe0qmEfk/stdqMWuoU9He5cPZVLzpca0N94sWGqgYEYmbeD7nMDAg6ApH4fqWosV5YsLjSwbsdTvz6RtOa8IYoD8y4ni7gs6sZWKN2a7Qn7BWbqxmRuzn0b6svtQP1Kk6/4sWnOxpwebFQ+jVp5hnzW3wZ9ih7NDJgWZREgo3M59DT5li91+FSS79wu9PqUcznOOwQ1VhMctBKtMOjlhmohURWt9VQPjYKE14r0U/RLArcfkSVzC3ruEo5IYGPTLCkleLOUhEfX86Ullst/DmXk5WmFQ49ZafK6RzXUlKjWmXw1iM5IePTCuPskp1uLJnHy40aZPl5OkuRK8qJdcwq5OQ/O10qz3FkfLG05OzyQ0zbFzeXIAtjGBE5MSYjFiP7ikI8kSxYGhBm7+fk84dxPlzaaQKRxCz93Vop8NM2/c4WB0K0Sb3u0/AmFSQz/n2Qx7EracSzNRig8+d0uG27UQx09m01kVjno/N5tFMReK1pbU5QvpZe/sH/KbxHEajFgNGBPmCYIbqorudd+UlRXq2e2UlGvFTQRLmYodBHl3Sr4mTJkygY7RUCQ/f76EgcwSZBK+JoNNz2o9FeIdbXOkTHnUFsArQ3nXlioMyEQFtOnyLJJDaWiZlw+fdHmYmpw9sXtGzd2zRL49gAKI8ntWzmQOV908NA8Py90/QJ+AnWywDngw+XH55aoIFC1oRAHIAVOoXz5/gWpVI9RSfrj2J9/iFzjQRBMoNazTDMUvy/o/Cfnaoy+nJpDYQu3HurWGS9jKOHNn1xIgvSPHupkySFO0Vr/5JRi9gYnaL/lu33MTrZeCbmx9kgAAAAAElFTkSuQmCC";
var O7;
function Ug() {
    return Ug = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Ug.apply(this, arguments)
}
const CA = e=>M.createElement("svg", Ug({
    xmlns: "http://www.w3.org/2000/svg",
    width: 17,
    height: 17,
    fill: "none"
}, e), O7 || (O7 = M.createElement("path", {
    stroke: "#2B7AFF",
    strokeWidth: 1.5,
    d: "m7.71 2.002-1.439 4.43H1.613c-.804 0-1.138 1.03-.488 1.502l.441-.607-.44.607 3.768 2.738-1.44 4.43c-.248.764.627 1.4 1.278.928L8.5 13.292l3.768 2.738c.65.472 1.526-.164 1.278-.928l-.714.232.714-.232-1.44-4.43 3.769-2.738c.65-.473.316-1.502-.488-1.502h-4.658l-1.44-4.43c-.248-.764-1.33-.764-1.578 0Zm-2.422 8.956.393-.542-.393.542Zm6.668-.75v.001Zm-1.077-3.313-.637.207.637-.207Z"
})));
var L7;
function Gg() {
    return Gg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Gg.apply(this, arguments)
}
const kA = e=>M.createElement("svg", Gg({
    xmlns: "http://www.w3.org/2000/svg",
    width: 14,
    height: 17,
    fill: "none"
}, e), L7 || (L7 = M.createElement("path", {
    stroke: "#2B7AFF",
    strokeWidth: 1.5,
    d: "M4.333 8.5h5m-5 3.333h5M11 16H2.667A1.667 1.667 0 0 1 1 14.333V2.667A1.667 1.667 0 0 1 2.667 1h4.655c.22 0 .433.088.589.244l4.512 4.512a.834.834 0 0 1 .244.589v7.988A1.666 1.666 0 0 1 11 16Z"
})))
  , bX = ({data: e, hendleFavoredValue: t, isFavored: n})=>{
    const i = o=>{
        let a = {};
        return typeof o == "string" && (a = Di(o)),
        a
    }
      , r = {
        hidden: {
            opacity: 1,
            scale: 0
        },
        visible: {
            opacity: 1,
            scale: 1,
            transition: {
                delayChildren: .3,
                staggerChildren: .2
            }
        }
    }
      , s = {
        hidden: {
            y: 20,
            opacity: 0
        },
        visible: {
            y: 0,
            opacity: 1
        }
    };
    return y.jsx("div", {
        className: "all-tokens-table",
        children: y.jsx("table", {
            children: y.jsx(u6.tbody, {
                variants: r,
                initial: "hidden",
                animate: "visible",
                children: e.map(({id: o, token: a, price: l, marketCap: c, volume: u, socialFollowing: h, socialInteractions: d, circulatingSuppy: m, tFhCurve: f},x)=>y.jsxs(u6.tr, {
                    variants: s,
                    initial: "hidden",
                    animate: "visible",
                    children: [y.jsx("td", {
                        children: y.jsx("div", {
                            className: "row-1",
                            onClick: ()=>t(x),
                            children: n[x] ? y.jsx(j2, {}) : y.jsx(CA, {})
                        })
                    }), y.jsx("td", {
                        children: y.jsx(Vn, {
                            to: `market/${o}`,
                            children: y.jsx(kA, {})
                        })
                    }), y.jsx("td", {
                        children: y.jsx(Vn, {
                            to: `market/${o}`,
                            children: y.jsxs("div", {
                                className: "row-2",
                                children: [y.jsx(tn, {
                                    name: a[2],
                                    className: "svg-37px"
                                }), y.jsxs("div", {
                                    children: [y.jsx("h5", {
                                        children: a[0]
                                    }), y.jsx("h5", {
                                        style: {
                                            color: "#A6B2CD"
                                        },
                                        children: a[1]
                                    })]
                                })]
                            })
                        })
                    }), y.jsx("td", {
                        children: y.jsxs("div", {
                            className: "row-4",
                            children: [y.jsxs("h5", {
                                children: ["$", l[0]]
                            }), y.jsxs("div", {
                                children: [y.jsx("h6", {
                                    className: "bg-transpatent-blue",
                                    children: "24h"
                                }), y.jsx("h6", {
                                    style: i(l[1]),
                                    children: l[1]
                                }), y.jsx("h6", {
                                    className: "bg-transpatent-blue",
                                    children: "7h"
                                }), y.jsx("h6", {
                                    style: i(l[2]),
                                    children: l[2]
                                })]
                            })]
                        })
                    }), y.jsx("td", {
                        children: y.jsx("div", {
                            className: "row-5",
                            children: y.jsxs("h5", {
                                children: ["$", c, "B"]
                            })
                        })
                    }), y.jsx("td", {
                        children: y.jsxs("div", {
                            className: "row-6",
                            children: [y.jsxs("h5", {
                                children: ["$", u[0], "B"]
                            }), y.jsxs("div", {
                                children: [y.jsx("h6", {
                                    className: "bg-transpatent-blue",
                                    children: "24h"
                                }), y.jsxs("h6", {
                                    style: i(u[1]),
                                    children: [u[1], "%"]
                                })]
                            })]
                        })
                    }), y.jsx("td", {
                        children: y.jsxs("div", {
                            className: "row-7",
                            children: [y.jsx("img", {
                                src: ud,
                                alt: "discord"
                            }), y.jsxs("div", {
                                children: [y.jsxs("h5", {
                                    children: [h[2], "K"]
                                }), y.jsxs("div", {
                                    children: [y.jsx("h6", {
                                        className: "bg-transpatent-blue",
                                        children: "24h"
                                    }), y.jsx("h6", {
                                        style: i(h[0]),
                                        children: h[0]
                                    })]
                                })]
                            }), y.jsx("img", {
                                src: hd,
                                alt: "twitter"
                            }), y.jsxs("div", {
                                children: [y.jsxs("h5", {
                                    children: [h[3], "K"]
                                }), y.jsxs("div", {
                                    children: [y.jsx("h6", {
                                        className: "bg-transpatent-blue",
                                        children: "24h"
                                    }), y.jsx("h6", {
                                        style: i(h[1]),
                                        children: h[1]
                                    })]
                                })]
                            })]
                        })
                    }), y.jsx("td", {
                        children: y.jsxs("div", {
                            className: "row-9",
                            children: [y.jsx("img", {
                                src: ud,
                                alt: "discord"
                            }), y.jsxs("div", {
                                children: [y.jsxs("h5", {
                                    children: [d[2], "K"]
                                }), y.jsxs("div", {
                                    children: [y.jsx("h6", {
                                        className: "bg-transpatent-blue",
                                        children: "24h"
                                    }), y.jsx("h6", {
                                        style: i(d[0]),
                                        children: d[0]
                                    })]
                                })]
                            }), y.jsx("img", {
                                src: hd,
                                alt: "twitter"
                            }), y.jsxs("div", {
                                children: [y.jsxs("h5", {
                                    children: [d[3], "K"]
                                }), y.jsxs("div", {
                                    children: [y.jsx("h6", {
                                        className: "bg-transpatent-blue",
                                        children: "24h"
                                    }), y.jsx("h6", {
                                        style: i(d[1]),
                                        children: d[1]
                                    })]
                                })]
                            })]
                        })
                    }), y.jsx("td", {
                        children: y.jsxs("div", {
                            className: "row-11",
                            children: [y.jsxs("div", {
                                children: [y.jsxs("h5", {
                                    children: [m[0], "M BTC"]
                                }), " ", y.jsxs("h6", {
                                    children: [m[1], "%"]
                                })]
                            }), y.jsx("div", {
                                className: "range-slider",
                                children: y.jsx("div", {
                                    style: {
                                        width: `${m[1]}%`
                                    }
                                })
                            })]
                        })
                    }), y.jsx("td", {
                        children: y.jsx("div", {
                            className: "line-small-chart",
                            children: y.jsx(SA, {
                                data: f
                            })
                        })
                    })]
                }, x))
            })
        })
    })
}
  , wX = ({data: e, isFavored: t, hendleFavoredValue: n})=>{
    const i = r=>{
        let s = {};
        return typeof r == "string" && (s = Di(r)),
        s
    }
    ;
    return y.jsx("section", {
        className: "table-of-columns",
        children: e.map(({id: r, token: s, price: o, marketCap: a, volume: l, socialFollowing: c, socialInteractions: u, circulatingSuppy: h, tFhCurve: d, sentiment: m},f)=>y.jsx("div", {
            children: y.jsx("table", {
                children: y.jsx("tbody", {
                    children: y.jsxs("tr", {
                        children: [y.jsx("td", {
                            children: y.jsxs("div", {
                                children: [y.jsx("div", {
                                    onClick: ()=>n(f),
                                    children: t[f] ? y.jsx(j2, {}) : y.jsx(CA, {})
                                }), y.jsx("div", {
                                    children: y.jsx(Vn, {
                                        to: `market/${r}`,
                                        children: y.jsx(kA, {})
                                    })
                                })]
                            })
                        }), y.jsx("td", {
                            children: y.jsx(Vn, {
                                to: `market/${r}`,
                                children: y.jsxs("div", {
                                    children: [y.jsxs("div", {
                                        children: [y.jsxs("div", {
                                            children: [y.jsx(tn, {
                                                name: s[2],
                                                className: "svg-37px"
                                            }), y.jsx("h4", {
                                                children: s[0]
                                            }), y.jsx("h6", {
                                                className: "grey-text",
                                                children: s[1]
                                            })]
                                        }), y.jsxs("h4", {
                                            children: ["$", h[0] * 1e3]
                                        })]
                                    }), y.jsxs("div", {
                                        children: [y.jsx("h6", {
                                            className: "bg-transpatent-blue",
                                            children: "Rank #1"
                                        }), y.jsx("h6", {
                                            className: "bg-transpatent-blue",
                                            children: "Coin"
                                        }), y.jsx("h6", {
                                            className: "bg-transpatent-blue",
                                            children: "On 3,994,278 watchlists"
                                        }), y.jsx("h6", {
                                            className: "bg-transpatent-blue",
                                            children: "24h"
                                        }), y.jsx("h6", {
                                            style: i(o[1]),
                                            children: o[1]
                                        })]
                                    }), y.jsxs("div", {
                                        children: [y.jsx("h6", {
                                            className: "grey-text",
                                            children: "Low: "
                                        }), " ", y.jsx("h5", {
                                            children: "$26,910.20"
                                        }), y.jsx("div", {
                                            className: "range-slider",
                                            style: {
                                                margin: "0 6px"
                                            },
                                            children: y.jsx("div", {
                                                style: {
                                                    width: `${h[1]}%`
                                                }
                                            })
                                        }), y.jsx("h6", {
                                            className: "grey-text",
                                            children: "High: "
                                        }), " ", y.jsx("h5", {
                                            children: "$31,481.60"
                                        })]
                                    })]
                                })
                            })
                        }), y.jsx("td", {
                            children: y.jsxs("div", {
                                children: [y.jsx("h5", {
                                    className: "grey-text",
                                    style: {
                                        fontSize: "13px"
                                    },
                                    children: "Market Cap"
                                }), y.jsxs("div", {
                                    children: [y.jsxs("h5", {
                                        style: {
                                            fontSize: "14px"
                                        },
                                        children: ["$", a, "B"]
                                    }), y.jsxs("div", {
                                        children: [y.jsx("h6", {
                                            className: "bg-transpatent-blue",
                                            children: "24h"
                                        }), y.jsx("h6", {
                                            style: i(c[0]),
                                            children: c[0]
                                        })]
                                    })]
                                }), y.jsxs("div", {
                                    children: [y.jsx("h6", {
                                        className: "grey-text",
                                        children: "24H Volume/Market Cap:"
                                    }), y.jsx("h5", {
                                        children: "$30.92B"
                                    })]
                                })]
                            })
                        }), y.jsx("td", {
                            children: y.jsxs("div", {
                                children: [y.jsx("h5", {
                                    className: "grey-text",
                                    style: {
                                        fontSize: "13px"
                                    },
                                    children: "Volume"
                                }), y.jsxs("div", {
                                    children: [y.jsxs("h5", {
                                        style: {
                                            fontSize: "14px"
                                        },
                                        children: ["$", l[0], "B"]
                                    }), y.jsxs("div", {
                                        children: [y.jsx("h6", {
                                            className: "bg-transpatent-blue",
                                            children: "24h"
                                        }), y.jsx("h6", {
                                            style: i(l[1]),
                                            children: l[1]
                                        })]
                                    })]
                                }), y.jsxs("div", {
                                    children: [y.jsx("h6", {
                                        className: "grey-text",
                                        children: "CEX Vol: "
                                    }), y.jsx("h5", {
                                        children: "$30.92B"
                                    })]
                                }), y.jsxs("div", {
                                    children: [y.jsx("h6", {
                                        className: "grey-text",
                                        children: "DEX Vol: "
                                    }), y.jsx("h5", {
                                        children: "$21.79M"
                                    })]
                                })]
                            })
                        }), y.jsx("td", {
                            children: y.jsxs("div", {
                                children: [y.jsx("h5", {
                                    className: "grey-text",
                                    style: {
                                        fontSize: "13px"
                                    },
                                    children: "Circulating Supply"
                                }), y.jsxs("div", {
                                    children: [y.jsxs("div", {
                                        children: [y.jsxs("h5", {
                                            children: [h[0], "BTC"]
                                        }), " ", y.jsxs("h6", {
                                            children: [h[1], "%"]
                                        })]
                                    }), y.jsx("div", {
                                        className: "range-slider",
                                        children: y.jsx("div", {
                                            style: {
                                                width: `${h[1]}%`
                                            }
                                        })
                                    })]
                                }), y.jsxs("div", {
                                    children: [y.jsx("h6", {
                                        className: "grey-text",
                                        children: "Max Supply: "
                                    }), y.jsx("h5", {
                                        children: "31.48M"
                                    })]
                                }), y.jsxs("div", {
                                    children: [y.jsx("h6", {
                                        className: "grey-text",
                                        children: "Total Supply: "
                                    }), y.jsx("h5", {
                                        children: "19.36M"
                                    })]
                                })]
                            })
                        }), y.jsx("td", {
                            children: y.jsxs("div", {
                                children: [y.jsx("h5", {
                                    className: "grey-text",
                                    style: {
                                        fontSize: "13px"
                                    },
                                    children: "Social Following"
                                }), y.jsxs("div", {
                                    children: [y.jsxs("div", {
                                        children: [y.jsx("img", {
                                            src: ud,
                                            alt: "discord"
                                        }), y.jsxs("h5", {
                                            children: [c[2], "K"]
                                        }), y.jsx("h6", {
                                            style: i(c[0]),
                                            children: c[0]
                                        })]
                                    }), y.jsxs("div", {
                                        children: [y.jsx("img", {
                                            src: hd,
                                            alt: "twitter"
                                        }), y.jsxs("h5", {
                                            children: [c[3], "K"]
                                        }), y.jsx("h6", {
                                            style: i(c[1]),
                                            children: c[1]
                                        })]
                                    })]
                                })]
                            })
                        }), y.jsx("td", {
                            children: y.jsxs("div", {
                                children: [y.jsx("h5", {
                                    className: "grey-text",
                                    style: {
                                        fontSize: "13px"
                                    },
                                    children: "Social Interactions"
                                }), y.jsxs("div", {
                                    children: [y.jsxs("div", {
                                        children: [y.jsx("img", {
                                            src: ud,
                                            alt: "discord"
                                        }), y.jsxs("h5", {
                                            children: [u[2], "K"]
                                        }), y.jsx("h6", {
                                            style: i(u[0]),
                                            children: u[0]
                                        })]
                                    }), y.jsxs("div", {
                                        children: [y.jsx("img", {
                                            src: hd,
                                            alt: "twitter"
                                        }), y.jsxs("h5", {
                                            children: [u[3], "K"]
                                        }), y.jsx("h6", {
                                            style: i(u[1]),
                                            children: u[1]
                                        })]
                                    })]
                                })]
                            })
                        }), y.jsx("td", {
                            children: y.jsxs("div", {
                                children: [y.jsx("h5", {
                                    className: "grey-text",
                                    style: {
                                        fontSize: "13px"
                                    },
                                    children: "Holders"
                                }), y.jsxs("div", {
                                    children: [y.jsx("h5", {
                                        style: {
                                            fontSize: "14px"
                                        },
                                        children: a * 100
                                    }), y.jsx("h6", {
                                        style: i(l[1]),
                                        children: o[0]
                                    })]
                                }), y.jsx("div", {
                                    children: y.jsx(SA, {
                                        data: d
                                    })
                                })]
                            })
                        }), y.jsx("td", {
                            children: y.jsxs("div", {
                                children: [y.jsx("h5", {
                                    className: "grey-text",
                                    style: {
                                        fontSize: "13px"
                                    },
                                    children: "Sentiment"
                                }), y.jsxs("div", {
                                    children: [y.jsx("div", {
                                        children: y.jsx("h5", {
                                            style: {
                                                color: `${m[3]}`
                                            },
                                            children: m[2]
                                        })
                                    }), y.jsx("div", {
                                        className: "range-slider",
                                        children: y.jsx("div", {
                                            style: {
                                                width: `${m[1]}%`
                                            }
                                        })
                                    })]
                                }), y.jsx("h6", {
                                    className: "grey-text",
                                    children: "Based on data from May 17, 2023 at 13:41"
                                })]
                            })
                        })]
                    })
                })
            })
        }, r))
    })
}
  , dd = ({options: e, hendleSelected: t, className: n, style: i})=>{
    var u;
    const [r,s] = M.useState("")
      , [o,a] = M.useState(!1)
      , l = h=>{
        s(h),
        a(!1)
    }
      , c = ()=>{
        a(!o)
    }
    ;
    return y.jsxs("div", {
        onClick: c,
        className: `custom-select ${n}`,
        style: i,
        children: [y.jsx("div", {
            className: "custom-select__selected",
            children: r ? (u = e.find(h=>h.label === r)) == null ? void 0 : u.label : e[0].label
        }), y.jsx("div", {
            children: y.jsx(Kr, {
                className: o ? "arrow-up" : "arrow-down"
            })
        }), o && y.jsx("ul", {
            className: "custom-select__options",
            children: e.map(h=>y.jsx("li", {
                className: "custom-select__option",
                onClick: ()=>{
                    l(h.label),
                    t && t(h.value)
                }
                ,
                children: h.label
            }, h.value))
        })]
    })
}
  , SX = ({options: e, hendleSelected: t, className: n, style: i})=>{
    const {activeBlackout: r, setActiveBlackout: s} = M.useContext(Tw)
      , [o,a] = M.useState([])
      , l = f=>{
        a(x=>x.includes(f) ? x.filter(S=>S !== f) : [...x, f])
    }
      , c = e.map((f,x)=>({
        id: x + 1,
        data: [...f],
        checked: !1
    }))
      , u = c.filter(f=>o.find(x=>f.id === x)).map(f=>f.data[1]);
    Ce.useEffect(()=>{
        u && t(u)
    }
    , [o]);
    const h = f=>typeof f == "string" ? f : ""
      , d = Ce.useRef(null)
      , m = f=>{
        var x;
        r || s(!0),
        r && ((x = d == null ? void 0 : d.current) == null ? void 0 : x.contains(f.target)) === !1 && s(!1)
    }
    ;
    return y.jsxs("div", {
        onClick: m,
        className: `custom-select-with-icon ${n}`,
        style: i,
        children: [y.jsx("div", {
            className: "custom-select-with-icon__selected",
            children: "Сhoose values"
        }), y.jsx("div", {
            children: y.jsx(Kr, {
                className: r ? "arrow-up" : "arrow-down"
            })
        }), r && y.jsx("ul", {
            ref: d,
            className: "custom-select-with-icon__options",
            children: c.map((f,x)=>y.jsx("li", {
                children: y.jsxs(pN, {
                    checked: o.includes(f.id),
                    className: "custom-select-with-icon__option",
                    onClick: ()=>l(f.id),
                    children: [y.jsx(tn, {
                        name: h(f.data[2]),
                        className: "svg-27px"
                    }), f.data[0], "(", f.data[1], ")"]
                })
            }, x))
        })]
    })
}
  , bs = (e,t,n,i)=>{
    if (!t && !n && i)
        return e;
    let r = e;
    switch (i) {
    case 1:
        r = e.filter(s=>t && n ? +s.price[0] >= +t && +s.price[0] <= +n : t ? +s.price[0] >= +t : n ? +s.price[0] <= +n : !1).sort((s,o)=>+s.price[0] - +o.price[0]);
        break;
    case 2:
        r = e.filter(s=>t && n ? +s.marketCap >= +t && +s.marketCap <= +n : t ? +s.marketCap >= +t : n ? +s.marketCap <= +n : !1).sort((s,o)=>+s.marketCap - +o.marketCap);
        break;
    case 3:
        r = e.filter(s=>t && n ? +s.volume[0] >= +t && +s.volume[0] <= +n : t ? +s.volume[0] >= +t : n ? +s.volume[0] <= +n : !1).sort((s,o)=>+s.volume[0] - +o.volume[0]);
        break;
    case 4:
        r = e.filter(s=>{
            const o = +s.socialFollowing[2] + +s.socialFollowing[3];
            return t && n ? o >= +t && o <= +n : t ? o >= +t : n ? o <= +n : !1
        }
        ).sort((s,o)=>+s.socialFollowing[2] + +s.socialFollowing[3] - +o.socialFollowing[2] + +o.socialFollowing[3]);
        break;
    case 5:
        r = e.filter(s=>{
            const o = +s.socialInteractions[2] + +s.socialInteractions[3];
            return t && n ? o >= +t && o <= +n : t ? o >= +t : n ? o <= +n : !1
        }
        ).sort((s,o)=>+s.socialInteractions[2] + +s.socialInteractions[3] - +o.socialInteractions[2] + +o.socialInteractions[3]);
        break;
    case 6:
        r = e.filter(s=>t && n ? +s.circulatingSuppy[0] >= +t && +s.circulatingSuppy[0] <= +n : t ? +s.circulatingSuppy[0] >= +t : n ? +s.circulatingSuppy[0] <= +n : !1).sort((s,o)=>+s.circulatingSuppy[0] - +o.circulatingSuppy[0]);
        break;
    case 7:
        r = e.filter(s=>t && n ? +s.sentiment[0] >= +t && +s.sentiment[0] <= +n : t ? +s.sentiment[0] >= +t : n ? +s.sentiment[0] <= +n : !1).sort((s,o)=>+s.sentiment[0] - +o.sentiment[0]);
        break;
    default:
        r = e
    }
    return r
}
  , CX = Ns.map(e=>e.token)
  , kX = ()=>{
    const [e,t] = Ce.useState([])
      , [n,i] = Ce.useState(!0)
      , [r,s] = Ce.useState("")
      , [o,a] = Ce.useState([])
      , [l,c] = Ce.useState(Array(12).fill(""))
      , [u,h] = Ce.useState("")
      , [d,m] = Ce.useState("")
      , [f,x] = Ce.useState(!1)
      , [S,v] = Ce.useState(!1)
      , [p,g] = Ce.useState(!1)
      , [C,E] = Ce.useState(Array(Ns.length).fill(!1));
    Ce.useEffect(()=>{
        E(p ? Array(Ns.length).fill(!0) : Array(Ns.length).fill(!1))
    }
    , [p]);
    const O = b=>{
        const A = [...C];
        A[b] = !C[b],
        E(A)
    }
    ;
    Ce.useEffect(()=>{
        let b = R(Ns)
          , A = F(b)
          , j = bs(A, l[0], l[6], 1)
          , B = bs(j, l[1], l[7], 2)
          , W = bs(B, l[2], l[8], 3)
          , N = bs(W, l[3], l[9], 4)
          , H = bs(N, l[4], l[10], 5)
          , X = bs(H, l[5], l[11], 6);
        const K = [...bs(X, u, d, 7)];
        x(P()),
        t(K)
    }
    , [o, l, u, d, r]);
    const R = b=>o.length === 0 ? b : b.filter(A=>o.find(j=>j === A.token[1]));
    function F(b) {
        return b.filter(A=>String(A.token[0]).toLocaleLowerCase().includes(r))
    }
    const P = ()=>{
        let b = !1;
        return o.some(A=>!!A) && (b = !0),
        l.some(A=>!!A) && (b = !0),
        (u || d || r) && (b = !0),
        b
    }
      , _ = ()=>{
        a([]),
        c(Array(12).fill("")),
        h(""),
        m(""),
        s("")
    }
      , T = b=>{
        s(b.target.value)
    }
      , L = b=>{
        a(b)
    }
      , I = (b,A)=>{
        const j = [...l];
        j[b] = A,
        c(j)
    }
      , k = b=>{
        h(b)
    }
      , w = b=>{
        m(b)
    }
    ;
    return y.jsxs("section", {
        className: S ? "all-tokens" : "all-tokens theme-box",
        children: [y.jsxs("div", {
            className: "all-tokens__title",
            children: [y.jsx("h2", {
                children: "All Tokens"
            }), y.jsxs("div", {
                className: "buttons",
                children: [y.jsx("button", {
                    className: f ? "buttons__active" : "buttons__unactive",
                    onClick: _,
                    children: "Clear"
                }), y.jsx("div", {
                    children: y.jsxs("label", {
                        children: [y.jsx("div", {
                            children: y.jsx(Ew, {
                                className: "search-input"
                            })
                        }), y.jsx("input", {
                            type: "text",
                            placeholder: "Search by token name",
                            onChange: T,
                            value: r
                        })]
                    })
                }), y.jsxs("button", {
                    className: S ? "buttons__active" : "buttons__unactive",
                    onClick: ()=>v(!S),
                    children: ["Columns ", y.jsx(PF, {
                        className: "btn-svg"
                    })]
                }), y.jsxs("button", {
                    className: n ? "buttons__active" : "buttons__unactive",
                    onClick: ()=>i(!n),
                    children: ["Filters ", y.jsx(oC, {
                        className: "btn-svg"
                    })]
                })]
            })]
        }), y.jsxs("div", {
            className: S ? "" : "all-tokens__content",
            children: [y.jsxs("div", {
                className: S ? "all-tokens__title-filter_hidden" : "all-tokens__title-filter",
                children: [y.jsx("div", {
                    className: "like",
                    onClick: ()=>g(!p),
                    children: y.jsx(j2, {})
                }), TF.map((b,A)=>{
                    const j = !(A === 0 || A === 7);
                    return y.jsxs("div", {
                        children: [y.jsxs("h5", {
                            children: [b, " ", y.jsx(Kr, {})]
                        }), n && y.jsxs(y.Fragment, {
                            children: [j && y.jsxs("div", {
                                className: "inputs",
                                children: [y.jsx("input", {
                                    type: "number",
                                    placeholder: "from",
                                    value: l[A - 1],
                                    onChange: B=>I(A - 1, B.target.value)
                                }), y.jsx("input", {
                                    type: "number",
                                    placeholder: "to",
                                    value: l[A + 5],
                                    onChange: B=>I(A + 5, B.target.value)
                                })]
                            }), A === 7 && y.jsxs(y.Fragment, {
                                children: [y.jsx(dd, {
                                    options: sb,
                                    hendleSelected: w
                                }), y.jsx(dd, {
                                    options: sb,
                                    style: {
                                        marginTop: "5px"
                                    },
                                    hendleSelected: k
                                })]
                            }), A === 0 && y.jsx(SX, {
                                options: CX,
                                hendleSelected: L
                            })]
                        })]
                    }, A)
                }
                )]
            }), y.jsx("div", {
                className: "all-tokens__table",
                children: S ? y.jsx(wX, {
                    data: e,
                    isFavored: C,
                    hendleFavoredValue: O
                }) : y.jsx(bX, {
                    data: e,
                    isFavored: C,
                    hendleFavoredValue: O
                })
            })]
        })]
    })
}
  , AX = ()=>y.jsxs("main", {
    children: [y.jsx(qN, {}), y.jsxs(Hr, {
        gutter: [32, 32],
        style: {
            marginTop: "40px"
        },
        children: [y.jsx(Ot, {
            className: "gutter-row",
            xs: 24,
            md: 12,
            lg: 12,
            xl: 12,
            xxl: 6,
            children: y.jsx(fu, {
                dataTop: pu[0],
                numberTitle: 0
            })
        }), y.jsx(Ot, {
            className: "gutter-row",
            xs: 24,
            md: 12,
            lg: 12,
            xl: 12,
            xxl: 6,
            children: y.jsx(fu, {
                dataTop: pu[1],
                numberTitle: 1
            })
        }), y.jsx(Ot, {
            className: "gutter-row",
            xs: 24,
            md: 12,
            lg: 12,
            xl: 12,
            xxl: 6,
            children: y.jsx(fu, {
                dataTop: pu[2],
                numberTitle: 2
            })
        }), y.jsx(Ot, {
            className: "gutter-row",
            xs: 24,
            md: 12,
            lg: 12,
            xl: 12,
            xxl: 6,
            children: y.jsx(fu, {
                dataTop: pu[3],
                numberTitle: 3
            })
        }), y.jsx(Ot, {
            xs: 24,
            children: y.jsx(kX, {})
        })]
    })]
})
  , MX = ()=>y.jsx("main", {
    style: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        height: "90vh"
    },
    children: y.jsxs("div", {
        style: {
            textAlign: "center"
        },
        children: [y.jsx("h2", {
            children: "404"
        }), y.jsx("h3", {
            children: "This page doesn't exist"
        })]
    })
})
  , R7 = [[{
    period: "24h:",
    info: "-2.39%"
}, {
    period: "7d:",
    info: "+1.15%"
}, {
    period: "30d:",
    info: "-6.94%"
}], [{
    period: "180d:",
    info: "+60.8%"
}, {
    period: "ATH:",
    info: "$64,400.12"
}, {
    period: "ATL:",
    info: "$327.00"
}]]
  , _7 = [[{
    title: "Circulating market cap",
    amount: "N/A",
    procent: "N/A"
}, {
    title: "Fully diluted market cap",
    amount: "$5.12b",
    procent: "-16.70%"
}, {
    title: "Total value locked",
    amount: "$3.99b",
    procent: "-1.21%"
}, {
    title: "Trading volume (annualized)",
    amount: "$519.30b",
    procent: "-38.30%"
}, {
    title: "Fees (30d)",
    amount: "$66.31m",
    procent: "+13.43%"
}, {
    title: "Fees (annualized)",
    amount: "$806.77m",
    procent: "-22.05%"
}, {
    title: "Core developers (30d average)",
    amount: "26.27",
    procent: "-26.6%"
}], [{
    title: "Revenue (30d)",
    amount: "$0",
    procent: "N/A"
}, {
    title: "Revenue (annualized)",
    amount: "$0",
    procent: "N/A"
}, {
    title: "P/F ratio (fully diluted)",
    amount: "6.21x",
    procent: "-28.7%"
}, {
    title: "P/S ratio (fully diluted)",
    amount: "N/A",
    procent: "N/A"
}, {
    title: "Treasury",
    amount: "$2.12b",
    procent: "-16.70%"
}, {
    title: "Daily active users (30d average)",
    amount: "77.95k",
    procent: "+50.8%"
}, {
    title: "Code commits (30d sum)",
    amount: "327",
    procent: "-6.3%"
}]]
  , EX = ()=>{
    const e = rs().pathname.slice(8)
      , t = Ns[+e].token;
    return Ce.useEffect(()=>{
        window.scrollTo({
            top: 0,
            behavior: "smooth"
        })
    }
    , []),
    y.jsxs("section", {
        children: [y.jsx("h2", {
            children: "Token Info"
        }), y.jsxs("div", {
            className: "token-info",
            children: [y.jsxs("div", {
                className: "token-info__title",
                children: [y.jsx(tn, {
                    name: t[2],
                    className: "svg-45px"
                }), y.jsxs("div", {
                    children: [y.jsxs("h3", {
                        children: [t[0], " ", y.jsxs("span", {
                            children: ["(", t[1], ")"]
                        })]
                    }), y.jsxs("div", {
                        children: [y.jsx("div", {
                            children: ["eth", "usdt", "bnb", "xrp", "usd", "ada"].map((n,i)=>y.jsx(tn, {
                                name: n,
                                className: "svg-16px token-info__svg"
                            }, i))
                        }), y.jsx("h3", {
                            children: "$29,025.99"
                        })]
                    })]
                })]
            }), y.jsx("div", {
                className: "token-info__content",
                children: y.jsxs("div", {
                    className: "period",
                    children: [y.jsx("div", {
                        className: "period__left",
                        children: R7[0].map(({period: n, info: i},r)=>y.jsxs("div", {
                            children: [y.jsx("h4", {
                                children: n
                            }), y.jsx("h4", {
                                style: Di(i),
                                children: i
                            })]
                        }, r))
                    }), y.jsx("div", {
                        className: "period__right",
                        children: R7[1].map(({period: n, info: i},r)=>y.jsxs("div", {
                            children: [y.jsx("h4", {
                                children: n
                            }), y.jsx("h4", {
                                style: r === 0 ? Di(i) : {},
                                children: i
                            })]
                        }, r))
                    })]
                })
            }), y.jsxs("div", {
                className: "main-info",
                children: [y.jsx("div", {
                    className: "main-info__left",
                    children: y.jsx("table", {
                        children: y.jsx("tbody", {
                            children: _7[0].map(({title: n, amount: i, procent: r},s)=>y.jsxs("tr", {
                                children: [y.jsx("td", {
                                    children: y.jsx("h4", {
                                        children: n
                                    })
                                }), y.jsx("td", {
                                    children: y.jsx("h4", {
                                        children: i
                                    })
                                }), y.jsx("td", {
                                    children: y.jsx("h4", {
                                        style: Di(r),
                                        children: r
                                    })
                                })]
                            }, s))
                        })
                    })
                }), y.jsx("div", {
                    className: "main-info__right",
                    children: y.jsx("table", {
                        children: y.jsx("tbody", {
                            children: _7[1].map(({title: n, amount: i, procent: r},s)=>y.jsxs("tr", {
                                children: [y.jsx("td", {
                                    children: y.jsx("h4", {
                                        children: n
                                    })
                                }), y.jsx("td", {
                                    children: y.jsx("h4", {
                                        children: i
                                    })
                                }), y.jsx("td", {
                                    children: y.jsx("h4", {
                                        style: Di(r),
                                        children: r
                                    })
                                })]
                            }, s))
                        })
                    })
                })]
            }), y.jsxs("div", {
                className: "main-info__footer",
                children: [y.jsxs("div", {
                    children: [y.jsx("button", {
                        children: "View data sourses"
                    }), y.jsx("button", {
                        children: "Business model"
                    })]
                }), y.jsx("p", {
                    children: "Last column in the tables shows 30d change"
                })]
            })]
        })]
    })
}
;
var Xg = new Map
  , _u = new WeakMap
  , D7 = 0
  , PX = void 0;
function TX(e) {
    return e ? (_u.has(e) || (D7 += 1,
    _u.set(e, D7.toString())),
    _u.get(e)) : "0"
}
function jX(e) {
    return Object.keys(e).sort().filter(t=>e[t] !== void 0).map(t=>`${t}_${t === "root" ? TX(e.root) : e[t]}`).toString()
}
function OX(e) {
    let t = jX(e)
      , n = Xg.get(t);
    if (!n) {
        const i = new Map;
        let r;
        const s = new IntersectionObserver(o=>{
            o.forEach(a=>{
                var l;
                const c = a.isIntersecting && r.some(u=>a.intersectionRatio >= u);
                e.trackVisibility && typeof a.isVisible > "u" && (a.isVisible = c),
                (l = i.get(a.target)) == null || l.forEach(u=>{
                    u(c, a)
                }
                )
            }
            )
        }
        ,e);
        r = s.thresholds || (Array.isArray(e.threshold) ? e.threshold : [e.threshold || 0]),
        n = {
            id: t,
            observer: s,
            elements: i
        },
        Xg.set(t, n)
    }
    return n
}
function LX(e, t, n={}, i=PX) {
    if (typeof window.IntersectionObserver > "u" && i !== void 0) {
        const l = e.getBoundingClientRect();
        return t(i, {
            isIntersecting: i,
            target: e,
            intersectionRatio: typeof n.threshold == "number" ? n.threshold : 0,
            time: 0,
            boundingClientRect: l,
            intersectionRect: l,
            rootBounds: l
        }),
        ()=>{}
    }
    const {id: r, observer: s, elements: o} = OX(n);
    let a = o.get(e) || [];
    return o.has(e) || o.set(e, a),
    a.push(t),
    s.observe(e),
    function() {
        a.splice(a.indexOf(t), 1),
        a.length === 0 && (o.delete(e),
        s.unobserve(e)),
        o.size === 0 && (s.disconnect(),
        Xg.delete(r))
    }
}
function AA({threshold: e, delay: t, trackVisibility: n, rootMargin: i, root: r, triggerOnce: s, skip: o, initialInView: a, fallbackInView: l, onChange: c}={}) {
    var u;
    const [h,d] = M.useState(null)
      , m = M.useRef()
      , [f,x] = M.useState({
        inView: !!a,
        entry: void 0
    });
    m.current = c,
    M.useEffect(()=>{
        if (o || !h)
            return;
        let g;
        return g = LX(h, (C,E)=>{
            x({
                inView: C,
                entry: E
            }),
            m.current && m.current(C, E),
            E.isIntersecting && s && g && (g(),
            g = void 0)
        }
        , {
            root: r,
            rootMargin: i,
            threshold: e,
            trackVisibility: n,
            delay: t
        }, l),
        ()=>{
            g && g()
        }
    }
    , [Array.isArray(e) ? e.toString() : e, h, r, i, s, o, n, l, t]);
    const S = (u = f.entry) == null ? void 0 : u.target
      , v = M.useRef();
    !h && S && !s && !o && v.current !== S && (v.current = S,
    x({
        inView: !!a,
        entry: void 0
    }));
    const p = [d, f.inView, f.entry];
    return p.ref = p[0],
    p.inView = p[1],
    p.entry = p[2],
    p
}
var N7, F7;
function Yg() {
    return Yg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Yg.apply(this, arguments)
}
const RX = e=>M.createElement("svg", Yg({
    xmlns: "http://www.w3.org/2000/svg",
    width: 120,
    height: 64,
    fill: "none"
}, e), N7 || (N7 = M.createElement("path", {
    fill: "#2C406E",
    d: "M119.536.307 9.833 62.982 3.048 49.228 119.536.307Z"
})), F7 || (F7 = M.createElement("path", {
    fill: "#2C406E",
    d: "M12.619 62.35a8.333 8.333 0 1 1-7.375-14.947 8.333 8.333 0 0 1 7.375 14.946"
})))
  , _X = ({value: e})=>{
    const {ref: t, inView: n} = AA({
        threshold: 0
    })
      , i = r=>{
        switch (r) {
        case "sell":
            return {
                transform: "rotate(234deg)"
            };
        case "neutral":
            return {
                transform: "rotate(297deg)"
            };
        case "buy":
            return {
                transform: "rotate(360deg)"
            };
        default:
            return {}
        }
    }
    ;
    return y.jsx("div", {
        className: "speedometer-chart",
        ref: t,
        children: y.jsx("div", {
            className: "speedometer-chart__wrapper",
            children: y.jsxs("div", {
                className: "speedometer",
                children: [y.jsx("div", {
                    className: "pointer",
                    style: i(n ? e : "sell"),
                    children: y.jsx("div", {
                        className: "pointer__wrapper",
                        children: y.jsx(RX, {})
                    })
                }), y.jsx("h4", {
                    className: "speedometer__sell",
                    children: "SELL"
                }), y.jsx("h4", {
                    className: "speedometer__neutral",
                    children: "NEUTRAL"
                }), y.jsx("h4", {
                    className: "speedometer__buy",
                    children: "BUY"
                })]
            })
        })
    })
}
  , B0 = [{
    ctypto: "ETH/USDT",
    time: "1 minute",
    data: {
        sell: 13,
        neutral: 6,
        buy: 22
    }
}, {
    ctypto: "ETH/USDT",
    time: "1 hour",
    data: {
        sell: 9,
        neutral: 6,
        buy: 15
    }
}, {
    ctypto: "ETH/USDT",
    time: "1 day",
    data: {
        sell: 9,
        neutral: 17,
        buy: 12
    }
}, {
    ctypto: "ETH/USDT",
    time: "1 week",
    data: {
        sell: 3,
        neutral: 5,
        buy: 3
    }
}, {
    ctypto: "ETH/USDT",
    time: "1 month",
    data: {
        sell: 12,
        neutral: 3,
        buy: 7
    }
}, {
    ctypto: "Tether/BNB",
    time: "1 minute",
    data: {
        sell: 11,
        neutral: 3,
        buy: 12
    }
}, {
    ctypto: "Tether/BNB",
    time: "1 hour",
    data: {
        sell: 10,
        neutral: 9,
        buy: 7
    }
}, {
    ctypto: "Tether/BNB",
    time: "1 day",
    data: {
        sell: 12,
        neutral: 11,
        buy: 14
    }
}, {
    ctypto: "Tether/BNB",
    time: "1 week",
    data: {
        sell: 4,
        neutral: 4,
        buy: 6
    }
}, {
    ctypto: "Tether/BNB",
    time: "1 month",
    data: {
        sell: 17,
        neutral: 2,
        buy: 19
    }
}, {
    ctypto: "XRP/Cardano",
    time: "1 minute",
    data: {
        sell: 1,
        neutral: 2,
        buy: 12
    }
}, {
    ctypto: "XRP/Cardano",
    time: "1 hour",
    data: {
        sell: 13,
        neutral: 14,
        buy: 12
    }
}, {
    ctypto: "XRP/Cardano",
    time: "1 day",
    data: {
        sell: 14,
        neutral: 12,
        buy: 5
    }
}, {
    ctypto: "XRP/Cardano",
    time: "1 week",
    data: {
        sell: 4,
        neutral: 3,
        buy: 7
    }
}, {
    ctypto: "XRP/Cardano",
    time: "1 month",
    data: {
        sell: 11,
        neutral: 12,
        buy: 6
    }
}]
  , DX = [{
    value: "ETH/USDT",
    label: "ETH/USDT"
}, {
    value: "Tether/BNB",
    label: "Tether/BNB"
}, {
    value: "XRP/Cardano",
    label: "XRP/Cardano"
}]
  , NX = [{
    value: "1 minute",
    label: "1 minute"
}, {
    value: "1 hour",
    label: "1 hour"
}, {
    value: "1 day",
    label: "1 day"
}, {
    value: "1 week",
    label: "1 week"
}, {
    value: "1 month",
    label: "1 month"
}]
  , dv = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='6'%20height='11'%20viewBox='0%200%206%2011'%20fill='none'%3e%3cpath%20d='M1%2010L5%205.5L1%201'%20stroke='%23A6B2CD'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e"
  , FX = ()=>{
    const [e,t] = Ce.useState([B0[0]])
      , [n,i] = Ce.useState("ETH/USDT")
      , [r,s] = Ce.useState("1 minute")
      , o = u=>{
        i(u),
        t(c(B0, u, r))
    }
      , a = u=>{
        s(u),
        t(c(B0, n, u))
    }
      , l = u=>{
        const h = Math.max(...Object.values(u.data));
        return Object.keys(u.data).find(m=>u.data[m] === h) || ""
    }
      , c = (u,h,d)=>u.filter(m=>m.ctypto === h && m.time === d);
    return y.jsxs("section", {
        className: "technical-analysis",
        children: [y.jsx("h2", {
            children: "Technical Analysis"
        }), y.jsxs("div", {
            className: "technical-analysis__contaner",
            children: [y.jsxs("div", {
                className: "technical-analysis__dropdowns",
                children: [y.jsx(dd, {
                    options: DX,
                    style: {
                        width: "115px"
                    },
                    hendleSelected: o
                }), y.jsx(dd, {
                    options: NX,
                    style: {
                        width: "90px"
                    },
                    hendleSelected: a
                })]
            }), y.jsx("div", {
                className: "technical-analysis__chart",
                children: y.jsx(_X, {
                    value: l(e[0])
                })
            }), y.jsxs("div", {
                className: "technical-analysis__info",
                children: [y.jsx("h3", {
                    children: l(e[0]).toLocaleUpperCase()
                }), y.jsxs("div", {
                    children: [y.jsxs("div", {
                        children: [y.jsx("h4", {
                            style: {
                                color: " #CF304A"
                            },
                            children: e[0].data.sell
                        }), y.jsx("h4", {
                            children: "Sell"
                        })]
                    }), y.jsxs("div", {
                        children: [y.jsx("h4", {
                            style: {
                                color: "#A6B2CD"
                            },
                            children: e[0].data.neutral
                        }), y.jsx("h4", {
                            children: "Neutral"
                        })]
                    }), y.jsxs("div", {
                        children: [y.jsx("h4", {
                            style: {
                                color: "#03A66D"
                            },
                            children: e[0].data.buy
                        }), y.jsx("h4", {
                            children: "Buy"
                        })]
                    })]
                })]
            }), y.jsxs("div", {
                className: "technical-analysis__footer",
                children: [y.jsxs("div", {
                    children: [y.jsx("button", {
                        children: "More info"
                    }), y.jsx("button", {
                        children: "Copy link"
                    })]
                }), y.jsxs("div", {
                    children: [y.jsx("p", {
                        children: "Last update 28.08.2023 12:00 PM"
                    }), y.jsxs("div", {
                        children: [["atlas", "avax", "ok", "usd", "xrp", "btc"].map((u,h)=>y.jsx(tn, {
                            name: u,
                            className: "svg-21px token-info__svg"
                        }, h)), y.jsx("img", {
                            src: dv,
                            alt: "Arrow Right"
                        })]
                    })]
                })]
            })]
        })]
    })
}
  , IX = "data:image/svg+xml,%3csvg%20width='15'%20height='15'%20viewBox='0%200%2015%2015'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20id='Vector'%20d='M7.5%204.61111V7.5M7.5%2010.3889H7.50722M14%207.5C14%208.35359%2013.8319%209.19883%2013.5052%209.98744C13.1786%2010.7761%2012.6998%2011.4926%2012.0962%2012.0962C11.4926%2012.6998%2010.7761%2013.1786%209.98744%2013.5052C9.19883%2013.8319%208.35359%2014%207.5%2014C6.64641%2014%205.80117%2013.8319%205.01256%2013.5052C4.22394%2013.1786%203.50739%2012.6998%202.90381%2012.0962C2.30022%2011.4926%201.82144%2010.7761%201.49478%209.98744C1.16813%209.19883%201%208.35359%201%207.5C1%205.77609%201.68482%204.12279%202.90381%202.90381C4.12279%201.68482%205.77609%201%207.5%201C9.22391%201%2010.8772%201.68482%2012.0962%202.90381C13.3152%204.12279%2014%205.77609%2014%207.5Z'%20stroke='%232C406E'%20stroke-width='1.5'%20strokeLinecap='round'%20strokeLinejoin='round'/%3e%3c/svg%3e"
  , BX = "data:image/svg+xml,%3csvg%20width='10'%20height='13'%20viewBox='0%200%2010%2013'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20id='Vector'%20d='M9.79547%205.22624C9.99983%203.86025%208.95977%203.12593%207.53764%202.63606L7.99896%200.785653L6.87262%200.504948L6.42349%202.30659C6.12738%202.23281%205.82326%202.16319%205.52106%202.09422L5.9734%200.280705L4.84769%200L4.38605%201.84976C4.14096%201.79394%203.90035%201.73877%203.66681%201.6807L3.66809%201.67493L2.11475%201.28707L1.81512%202.49009C1.81512%202.49009%202.65082%202.68161%202.63317%202.69348C3.08936%202.80737%203.1718%203.10925%203.15801%203.34857L2.63253%205.45658C2.66397%205.4646%202.70471%205.47615%202.74962%205.49411C2.71209%205.48481%202.67199%205.47455%202.6306%205.4646L1.89404%208.41761C1.83822%208.5562%201.69674%208.76409%201.37786%208.68517C1.38909%208.70153%200.559164%208.48081%200.559164%208.48081L0%209.77013L1.46576%2010.1355C1.73844%2010.2039%202.00568%2010.2754%202.26874%2010.3428L1.80261%2012.2143L2.92767%2012.4951L3.38931%2010.6434C3.69664%2010.7268%203.99499%2010.8038%204.28692%2010.8763L3.82689%2012.7193L4.95324%2013L5.41937%2011.132C7.34003%2011.4954%208.7843%2011.3488%209.39222%209.61165C9.88209%208.21294%209.36784%207.40612%208.3573%206.87999C9.09323%206.71029%209.64758%206.22619%209.79547%205.22624ZM7.22197%208.83498C6.8739%2010.2337%204.51887%209.47756%203.75535%209.28796L4.37386%206.80845C5.13738%206.99901%207.58577%207.37628%207.22197%208.83498ZM7.57037%205.20603C7.25277%206.47835%205.29265%205.83192%204.65681%205.67344L5.21758%203.4246C5.85342%203.58308%207.90112%203.87886%207.57037%205.20603Z'%20fill='%232C406E'/%3e%3c/svg%3e"
  , zX = "data:image/svg+xml,%3csvg%20width='15'%20height='15'%20viewBox='0%200%2015%2015'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20id='Vector'%20d='M4.61111%208.94444V11.1111M7.5%208.94444V11.1111M10.3889%208.94444V11.1111M1%2014H14M1%206.05556H14M1%203.88889L7.5%201L14%203.88889H1ZM1.72222%206.05556H13.2778V14H1.72222V6.05556Z'%20stroke='%232C406E'%20stroke-width='1.5'%20strokeLinecap='round'%20strokeLinejoin='round'/%3e%3c/svg%3e"
  , VX = "data:image/svg+xml,%3csvg%20width='15'%20height='15'%20viewBox='0%200%2015%2015'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20id='Vector'%20d='M8.85572%206.14428C8.31397%205.6027%207.57931%205.29845%206.81328%205.29845C6.04725%205.29845%205.31258%205.6027%204.77083%206.14428L1.88194%209.03317C1.60603%209.29966%201.38594%209.61843%201.23454%209.97089C1.08314%2010.3233%201.00344%2010.7024%201.00011%2011.086C0.996776%2011.4696%201.06987%2011.85%201.21513%2012.205C1.36038%2012.5601%201.57489%2012.8826%201.84614%2013.1539C2.11738%2013.4251%202.43993%2013.6396%202.79497%2013.7849C3.15%2013.9301%203.53041%2014.0032%203.91399%2013.9999C4.29758%2013.9966%204.67666%2013.9169%205.02911%2013.7655C5.38157%2013.6141%205.70034%2013.394%205.96683%2013.1181L6.76272%2012.3229M6.21528%208.78472C6.75702%209.32631%207.49169%209.63055%208.25772%209.63055C9.02375%209.63055%209.75842%209.32631%2010.3002%208.78472L13.1891%205.89583C13.7153%205.35098%2014.0065%204.62124%2013.9999%203.86379C13.9933%203.10633%2013.6895%202.38176%2013.1539%201.84614C12.6182%201.31051%2011.8937%201.00669%2011.1362%201.00011C10.3788%200.993527%209.64902%201.28471%209.10417%201.81095L8.30972%202.60539'%20stroke='%232C406E'%20stroke-width='1.5'%20strokeLinecap='round'%20strokeLinejoin='round'/%3e%3c/svg%3e";
var I7;
function $g() {
    return $g = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    $g.apply(this, arguments)
}
const WX = e=>M.createElement("svg", $g({
    xmlns: "http://www.w3.org/2000/svg",
    width: 33,
    height: 25,
    fill: "none"
}, e), I7 || (I7 = M.createElement("path", {
    fill: "#2C406E",
    d: "M27.6 2.06A26.886 26.886 0 0 0 20.962.002a.1.1 0 0 0-.107.05c-.286.51-.604 1.175-.826 1.697a24.82 24.82 0 0 0-7.453 0 17.16 17.16 0 0 0-.84-1.697.105.105 0 0 0-.106-.05A26.81 26.81 0 0 0 4.995 2.06a.095.095 0 0 0-.044.037C.725 8.412-.433 14.571.135 20.654c.002.03.019.058.042.076a27.036 27.036 0 0 0 8.141 4.116.106.106 0 0 0 .114-.038 19.324 19.324 0 0 0 1.666-2.709.103.103 0 0 0-.057-.144 17.787 17.787 0 0 1-2.543-1.212.105.105 0 0 1-.01-.173c.17-.128.342-.262.505-.396a.1.1 0 0 1 .105-.014c5.336 2.436 11.112 2.436 16.385 0a.1.1 0 0 1 .106.013c.164.134.335.269.507.397a.104.104 0 0 1-.01.173 16.7 16.7 0 0 1-2.544 1.211.104.104 0 0 0-.055.145c.49.948 1.049 1.851 1.664 2.708a.104.104 0 0 0 .115.039 26.947 26.947 0 0 0 8.153-4.116.105.105 0 0 0 .043-.075c.68-7.032-1.139-13.14-4.82-18.556a.083.083 0 0 0-.043-.04M10.894 16.95c-1.607 0-2.93-1.475-2.93-3.286 0-1.81 1.298-3.286 2.93-3.286 1.644 0 2.955 1.488 2.93 3.286 0 1.811-1.298 3.286-2.93 3.286m10.833 0c-1.607 0-2.93-1.475-2.93-3.286 0-1.81 1.298-3.286 2.93-3.286 1.644 0 2.955 1.488 2.93 3.286 0 1.811-1.286 3.286-2.93 3.286"
})));
var B7;
function Kg() {
    return Kg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Kg.apply(this, arguments)
}
const HX = e=>M.createElement("svg", Kg({
    xmlns: "http://www.w3.org/2000/svg",
    width: 25,
    height: 25,
    fill: "none"
}, e), B7 || (B7 = M.createElement("path", {
    fill: "#2C406E",
    d: "M25 12.5C25 5.596 19.404 0 12.5 0S0 5.596 0 12.5c0 6.239 4.571 11.41 10.547 12.348v-8.735H7.373V12.5h3.174V9.746c0-3.133 1.866-4.863 4.721-4.863 1.367 0 2.798.244 2.798.244v3.076H16.49c-1.552 0-2.037.964-2.037 1.953V12.5h3.467l-.554 3.613h-2.913v8.735C20.43 23.91 25 18.74 25 12.5"
})));
var z7, V7;
function Qg() {
    return Qg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    Qg.apply(this, arguments)
}
const UX = e=>M.createElement("svg", Qg({
    xmlns: "http://www.w3.org/2000/svg",
    width: 25,
    height: 25,
    fill: "none"
}, e), z7 || (z7 = M.createElement("g", {
    fill: "#2C406E",
    clipPath: "url(#instagram_svg__a)"
}, M.createElement("path", {
    d: "M12.425 2.237c3.32 0 3.713.015 5.018.073 1.214.054 1.87.258 2.306.427.578.224.995.495 1.427.927.437.437.704.85.927 1.427.17.437.374 1.097.427 2.306.058 1.31.073 1.703.073 5.018 0 3.32-.015 3.713-.073 5.019-.053 1.213-.257 1.868-.427 2.305a3.842 3.842 0 0 1-.927 1.427c-.437.437-.85.704-1.427.927-.437.17-1.097.374-2.305.427-1.31.059-1.704.073-5.019.073-3.32 0-3.713-.014-5.019-.073-1.213-.053-1.868-.257-2.305-.427a3.844 3.844 0 0 1-1.427-.927 3.822 3.822 0 0 1-.927-1.427c-.17-.437-.374-1.097-.427-2.305-.058-1.31-.073-1.704-.073-5.019 0-3.32.015-3.713.073-5.018.053-1.214.257-1.869.427-2.306.223-.577.495-.995.927-1.427.437-.436.85-.703 1.427-.927.437-.17 1.097-.373 2.305-.427 1.306-.058 1.7-.073 5.019-.073m0-2.237C9.052 0 8.63.015 7.305.073 5.985.13 5.077.345 4.29.65c-.82.32-1.515.743-2.204 1.437A6.088 6.088 0 0 0 .65 4.286C.345 5.076.131 5.98.073 7.3.015 8.63 0 9.052 0 12.425s.015 3.795.073 5.12c.058 1.32.272 2.228.577 3.014.32.82.743 1.515 1.437 2.204a6.074 6.074 0 0 0 2.199 1.432c.79.305 1.694.52 3.014.577 1.325.059 1.747.073 5.12.073s3.796-.014 5.12-.073c1.32-.058 2.228-.271 3.015-.577a6.074 6.074 0 0 0 2.198-1.432 6.074 6.074 0 0 0 1.432-2.199c.306-.79.52-1.694.578-3.014.058-1.325.072-1.747.072-5.12s-.014-3.796-.072-5.12c-.059-1.32-.272-2.228-.578-3.015a5.82 5.82 0 0 0-1.422-2.208A6.074 6.074 0 0 0 20.564.655C19.774.35 18.87.135 17.55.078 16.22.015 15.798 0 12.425 0"
}), M.createElement("path", {
    d: "M12.425 6.043a6.384 6.384 0 0 0-6.382 6.382 6.384 6.384 0 0 0 6.382 6.383 6.384 6.384 0 0 0 6.383-6.383 6.384 6.384 0 0 0-6.383-6.382m0 10.522a4.14 4.14 0 1 1 .001-8.281 4.14 4.14 0 0 1 0 8.281M20.55 5.79a1.49 1.49 0 1 1-2.98 0 1.49 1.49 0 0 1 2.98 0"
}))), V7 || (V7 = M.createElement("defs", null, M.createElement("clipPath", {
    id: "instagram_svg__a"
}, M.createElement("path", {
    fill: "#fff",
    d: "M0 0h24.85v24.85H0z"
})))));
var W7;
function qg() {
    return qg = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    qg.apply(this, arguments)
}
const GX = e=>M.createElement("svg", qg({
    xmlns: "http://www.w3.org/2000/svg",
    width: 31,
    height: 25,
    fill: "none"
}, e), W7 || (W7 = M.createElement("path", {
    fill: "#2C406E",
    d: "M9.621 24.85c11.538 0 17.851-9.561 17.851-17.85 0-.27-.006-.544-.018-.813a12.743 12.743 0 0 0 3.13-3.248 12.371 12.371 0 0 1-3.602.985 6.308 6.308 0 0 0 2.76-3.47 12.612 12.612 0 0 1-3.984 1.523 6.283 6.283 0 0 0-10.696 5.721 17.82 17.82 0 0 1-12.93-6.55A6.282 6.282 0 0 0 4.073 9.52a6.282 6.282 0 0 1-2.842-.782v.077a6.272 6.272 0 0 0 5.034 6.153 6.236 6.236 0 0 1-2.83.107 6.287 6.287 0 0 0 5.858 4.36A12.585 12.585 0 0 1 0 22.033a17.8 17.8 0 0 0 9.621 2.818"
})))
  , XX = ()=>y.jsxs(y.Fragment, {
    children: [y.jsx("h2", {
        children: "About"
    }), y.jsxs("article", {
        className: "ad-about",
        style: {
            backgroundImage: `url(${sC})`
        },
        children: [y.jsxs("div", {
            children: [y.jsxs("div", {
                children: [y.jsx("h3", {
                    children: "What is Bitcoin"
                }), y.jsx("img", {
                    src: BX,
                    alt: "What is Bitcoin"
                })]
            }), y.jsx("p", {
                children: "Bitcoin (BTC) is a cryptocurrency, a virtual currency designed to act as money and a form of payment outside the control of any one person, group, or entity, thus removing the need for third-party involvement in financial transactions."
            })]
        }), y.jsxs("div", {
            children: [y.jsxs("div", {
                children: [y.jsx("h3", {
                    children: "How does Bitcoin work"
                }), y.jsx("img", {
                    src: IX,
                    alt: "How does Bitcoin work"
                })]
            }), y.jsx("p", {
                children: "Bitcoin is a form of digital currency that aims to eliminate the need for central authorities such as banks or governments. Instead, Bitcoin uses blockchain technology to support peer-to-peer transactions between users on a decentralized network."
            })]
        }), y.jsxs("div", {
            children: [y.jsxs("div", {
                children: [y.jsx("h3", {
                    children: "Who Governs Bitcoin"
                }), y.jsx("img", {
                    src: zX,
                    alt: "Who Governs Bitcoin"
                })]
            }), y.jsx("p", {
                children: "Bitcoin is a system of rules without rulers. There's no president or CEO, no oversight board or ruling council. No one person or group can unilaterally make changes to the software that runs the network. Therefore, no one can be said to be in control."
            })]
        }), y.jsxs("div", {
            children: [y.jsxs("div", {
                children: [y.jsx("h3", {
                    children: "Bitcoin community channels"
                }), y.jsx("img", {
                    src: VX,
                    alt: "community"
                })]
            }), y.jsxs("div", {
                children: [" ", y.jsxs("div", {
                    children: [y.jsx("a", {
                        href: "http://www.extej.com/",
                        children: y.jsx(HX, {})
                    }), y.jsx("a", {
                        href: "http://www.extej.com/",
                        children: y.jsx(GX, {})
                    }), y.jsx("a", {
                        href: "http://www.extej.com/",
                        children: y.jsx(UX, {})
                    }), y.jsx("a", {
                        href: "http://www.extej.com/",
                        children: y.jsx(WX, {})
                    })]
                })]
            })]
        })]
    })]
});
var MA = {
    exports: {}
};
(function(e) {
    (function(t, n) {
        e.exports ? (n.default = n,
        e.exports = t.document ? n(t) : n) : (t.Highcharts && t.Highcharts.error(16, !0),
        t.Highcharts = n(t))
    }
    )(typeof window < "u" ? window : n8, function(t) {
        var n = {};
        function i(r, s, o, a) {
            r.hasOwnProperty(s) || (r[s] = a.apply(null, o),
            typeof CustomEvent == "function" && t.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{
                detail: {
                    path: s,
                    module: r[s]
                }
            })))
        }
        return i(n, "Core/Globals.js", [], function() {
            var r, s;
            return (s = r || (r = {})).SVG_NS = "http://www.w3.org/2000/svg",
            s.product = "Highcharts",
            s.version = "11.2.0",
            s.win = t !== void 0 ? t : {},
            s.doc = s.win.document,
            s.svg = s.doc && s.doc.createElementNS && !!s.doc.createElementNS(s.SVG_NS, "svg").createSVGRect,
            s.userAgent = s.win.navigator && s.win.navigator.userAgent || "",
            s.isChrome = s.userAgent.indexOf("Chrome") !== -1,
            s.isFirefox = s.userAgent.indexOf("Firefox") !== -1,
            s.isMS = /(edge|msie|trident)/i.test(s.userAgent) && !s.win.opera,
            s.isSafari = !s.isChrome && s.userAgent.indexOf("Safari") !== -1,
            s.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(s.userAgent),
            s.isWebKit = s.userAgent.indexOf("AppleWebKit") !== -1,
            s.deg2rad = 2 * Math.PI / 360,
            s.hasBidiBug = s.isFirefox && 4 > parseInt(s.userAgent.split("Firefox/")[1], 10),
            s.hasTouch = !!s.win.TouchEvent,
            s.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"],
            s.noop = function() {}
            ,
            s.supportsPassiveEvents = function() {
                let o = !1;
                if (!s.isMS) {
                    let a = Object.defineProperty({}, "passive", {
                        get: function() {
                            o = !0
                        }
                    });
                    s.win.addEventListener && s.win.removeEventListener && (s.win.addEventListener("testPassive", s.noop, a),
                    s.win.removeEventListener("testPassive", s.noop, a))
                }
                return o
            }(),
            s.charts = [],
            s.dateFormats = {},
            s.seriesTypes = {},
            s.symbolSizes = {},
            s.chartCount = 0,
            r
        }),
        i(n, "Core/Utilities.js", [n["Core/Globals.js"]], function(r) {
            let s, {charts: o, doc: a, win: l} = r;
            function c(w, b, A, j) {
                let B = b ? "Highcharts error" : "Highcharts warning";
                w === 32 && (w = `${B}: Deprecated member`);
                let W = S(w)
                  , N = W ? `${B} #${w}: www.highcharts.com/errors/${w}/` : w.toString();
                if (j !== void 0) {
                    let H = "";
                    W && (N += "?"),
                    _(j, function(X, ie) {
                        H += `
 - ${ie}: ${X}`,
                        W && (N += encodeURI(ie) + "=" + encodeURI(X))
                    }),
                    N += H
                }
                L(r, "displayError", {
                    chart: A,
                    code: w,
                    message: N,
                    params: j
                }, function() {
                    if (b)
                        throw Error(N);
                    l.console && c.messages.indexOf(N) === -1 && console.warn(N)
                }),
                c.messages.push(N)
            }
            function u(w, b) {
                return parseInt(w, b || 10)
            }
            function h(w) {
                return typeof w == "string"
            }
            function d(w) {
                let b = Object.prototype.toString.call(w);
                return b === "[object Array]" || b === "[object Array Iterator]"
            }
            function m(w, b) {
                return !!w && typeof w == "object" && (!b || !d(w))
            }
            function f(w) {
                return m(w) && typeof w.nodeType == "number"
            }
            function x(w) {
                let b = w && w.constructor;
                return !!(m(w, !0) && !f(w) && b && b.name && b.name !== "Object")
            }
            function S(w) {
                return typeof w == "number" && !isNaN(w) && w < 1 / 0 && w > -1 / 0
            }
            function v(w) {
                return w != null
            }
            function p(w, b, A) {
                let j, B = h(b) && !v(A), W = (N,H)=>{
                    v(N) ? w.setAttribute(H, N) : B ? (j = w.getAttribute(H)) || H !== "class" || (j = w.getAttribute(H + "Name")) : w.removeAttribute(H)
                }
                ;
                return h(b) ? W(A, b) : _(b, W),
                j
            }
            function g(w) {
                return d(w) ? w : [w]
            }
            function C(w, b) {
                let A;
                for (A in w || (w = {}),
                b)
                    w[A] = b[A];
                return w
            }
            function E() {
                let w = arguments
                  , b = w.length;
                for (let A = 0; A < b; A++) {
                    let j = w[A];
                    if (j != null)
                        return j
                }
            }
            function O(w, b) {
                r.isMS && !r.svg && b && v(b.opacity) && (b.filter = `alpha(opacity=${100 * b.opacity})`),
                C(w.style, b)
            }
            function R(w) {
                return Math.pow(10, Math.floor(Math.log(w) / Math.LN10))
            }
            function F(w, b) {
                return w > 1e14 ? w : parseFloat(w.toPrecision(b || 14))
            }
            (c || (c = {})).messages = [],
            Math.easeInOutSine = function(w) {
                return -.5 * (Math.cos(Math.PI * w) - 1)
            }
            ;
            let P = Array.prototype.find ? function(w, b) {
                return w.find(b)
            }
            : function(w, b) {
                let A, j = w.length;
                for (A = 0; A < j; A++)
                    if (b(w[A], A))
                        return w[A]
            }
            ;
            function _(w, b, A) {
                for (let j in w)
                    Object.hasOwnProperty.call(w, j) && b.call(A || w[j], w[j], j, w)
            }
            function T(w, b, A) {
                function j(N, H) {
                    let X = w.removeEventListener;
                    X && X.call(w, N, H, !1)
                }
                function B(N) {
                    let H, X;
                    w.nodeName && (b ? (H = {})[b] = !0 : H = N,
                    _(H, function(ie, K) {
                        if (N[K])
                            for (X = N[K].length; X--; )
                                j(K, N[K][X].fn)
                    }))
                }
                let W = typeof w == "function" && w.prototype || w;
                if (Object.hasOwnProperty.call(W, "hcEvents")) {
                    let N = W.hcEvents;
                    if (b) {
                        let H = N[b] || [];
                        A ? (N[b] = H.filter(function(X) {
                            return A !== X.fn
                        }),
                        j(b, A)) : (B(N),
                        N[b] = [])
                    } else
                        B(N),
                        delete W.hcEvents
                }
            }
            function L(w, b, A, j) {
                let B;
                if (A = A || {},
                a.createEvent && (w.dispatchEvent || w.fireEvent && w !== r))
                    (B = a.createEvent("Events")).initEvent(b, !0, !0),
                    A = C(B, A),
                    w.dispatchEvent ? w.dispatchEvent(A) : w.fireEvent(b, A);
                else if (w.hcEvents) {
                    A.target || C(A, {
                        preventDefault: function() {
                            A.defaultPrevented = !0
                        },
                        target: w,
                        type: b
                    });
                    let W = []
                      , N = w
                      , H = !1;
                    for (; N.hcEvents; )
                        Object.hasOwnProperty.call(N, "hcEvents") && N.hcEvents[b] && (W.length && (H = !0),
                        W.unshift.apply(W, N.hcEvents[b])),
                        N = Object.getPrototypeOf(N);
                    H && W.sort((X,ie)=>X.order - ie.order),
                    W.forEach(X=>{
                        X.fn.call(w, A) === !1 && A.preventDefault()
                    }
                    )
                }
                j && !A.defaultPrevented && j.call(w, A)
            }
            _({
                map: "map",
                each: "forEach",
                grep: "filter",
                reduce: "reduce",
                some: "some"
            }, function(w, b) {
                r[b] = function(A) {
                    return c(32, !1, void 0, {
                        [`Highcharts.${b}`]: `use Array.${w}`
                    }),
                    Array.prototype[w].apply(A, [].slice.call(arguments, 1))
                }
            });
            let I = function() {
                let w = Math.random().toString(36).substring(2, 9) + "-"
                  , b = 0;
                return function() {
                    return "highcharts-" + (s ? "" : w) + b++
                }
            }();
            return l.jQuery && (l.jQuery.fn.highcharts = function() {
                let w = [].slice.call(arguments);
                if (this[0])
                    return w[0] ? (new r[h(w[0]) ? w.shift() : "Chart"](this[0],w[0],w[1]),
                    this) : o[p(this[0], "data-highcharts-chart")]
            }
            ),
            {
                addEvent: function(w, b, A, j={}) {
                    let B = typeof w == "function" && w.prototype || w;
                    Object.hasOwnProperty.call(B, "hcEvents") || (B.hcEvents = {});
                    let W = B.hcEvents;
                    r.Point && w instanceof r.Point && w.series && w.series.chart && (w.series.chart.runTrackerClick = !0);
                    let N = w.addEventListener;
                    N && N.call(w, b, A, !!r.supportsPassiveEvents && {
                        passive: j.passive === void 0 ? b.indexOf("touch") !== -1 : j.passive,
                        capture: !1
                    }),
                    W[b] || (W[b] = []);
                    let H = {
                        fn: A,
                        order: typeof j.order == "number" ? j.order : 1 / 0
                    };
                    return W[b].push(H),
                    W[b].sort((X,ie)=>X.order - ie.order),
                    function() {
                        T(w, b, A)
                    }
                },
                arrayMax: function(w) {
                    let b = w.length
                      , A = w[0];
                    for (; b--; )
                        w[b] > A && (A = w[b]);
                    return A
                },
                arrayMin: function(w) {
                    let b = w.length
                      , A = w[0];
                    for (; b--; )
                        w[b] < A && (A = w[b]);
                    return A
                },
                attr: p,
                clamp: function(w, b, A) {
                    return w > b ? w < A ? w : A : b
                },
                clearTimeout: function(w) {
                    v(w) && clearTimeout(w)
                },
                correctFloat: F,
                createElement: function(w, b, A, j, B) {
                    let W = a.createElement(w);
                    return b && C(W, b),
                    B && O(W, {
                        padding: "0",
                        border: "none",
                        margin: "0"
                    }),
                    A && O(W, A),
                    j && j.appendChild(W),
                    W
                },
                css: O,
                defined: v,
                destroyObjectProperties: function(w, b) {
                    _(w, function(A, j) {
                        A && A !== b && A.destroy && A.destroy(),
                        delete w[j]
                    })
                },
                diffObjects: function(w, b, A, j) {
                    let B = {};
                    return function W(N, H, X, ie) {
                        let K = A ? H : N;
                        _(N, function(D, V) {
                            if (!ie && j && j.indexOf(V) > -1 && H[V]) {
                                D = g(D),
                                X[V] = [];
                                for (let G = 0; G < Math.max(D.length, H[V].length); G++)
                                    H[V][G] && (D[G] === void 0 ? X[V][G] = H[V][G] : (X[V][G] = {},
                                    W(D[G], H[V][G], X[V][G], ie + 1)))
                            } else
                                m(D, !0) && !D.nodeType ? (X[V] = d(D) ? [] : {},
                                W(D, H[V] || {}, X[V], ie + 1),
                                Object.keys(X[V]).length !== 0 || V === "colorAxis" && ie === 0 || delete X[V]) : (N[V] !== H[V] || V in N && !(V in H)) && (X[V] = K[V])
                        })
                    }(w, b, B, 0),
                    B
                },
                discardElement: function(w) {
                    w && w.parentElement && w.parentElement.removeChild(w)
                },
                erase: function(w, b) {
                    let A = w.length;
                    for (; A--; )
                        if (w[A] === b) {
                            w.splice(A, 1);
                            break
                        }
                },
                error: c,
                extend: C,
                extendClass: function(w, b) {
                    let A = function() {};
                    return A.prototype = new w,
                    C(A.prototype, b),
                    A
                },
                find: P,
                fireEvent: L,
                getClosestDistance: function(w, b) {
                    let A, j, B, W = !b;
                    return w.forEach(N=>{
                        if (N.length > 1)
                            for (B = N.length - 1; B > 0; B--)
                                (j = N[B] - N[B - 1]) < 0 && !W ? (b == null || b(),
                                b = void 0) : j && (A === void 0 || j < A) && (A = j)
                    }
                    ),
                    A
                },
                getMagnitude: R,
                getNestedProperty: function(w, b) {
                    let A = w.split(".");
                    for (; A.length && v(b); ) {
                        let j = A.shift();
                        if (j === void 0 || j === "__proto__")
                            return;
                        if (j === "this") {
                            let W;
                            return m(b) && (W = b["@this"]),
                            W ?? b
                        }
                        let B = b[j];
                        if (!v(B) || typeof B == "function" || typeof B.nodeType == "number" || B === l)
                            return;
                        b = B
                    }
                    return b
                },
                getStyle: function w(b, A, j) {
                    let B;
                    if (A === "width") {
                        let N = Math.min(b.offsetWidth, b.scrollWidth)
                          , H = b.getBoundingClientRect && b.getBoundingClientRect().width;
                        return H < N && H >= N - 1 && (N = Math.floor(H)),
                        Math.max(0, N - (w(b, "padding-left", !0) || 0) - (w(b, "padding-right", !0) || 0))
                    }
                    if (A === "height")
                        return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - (w(b, "padding-top", !0) || 0) - (w(b, "padding-bottom", !0) || 0));
                    let W = l.getComputedStyle(b, void 0);
                    return W && (B = W.getPropertyValue(A),
                    E(j, A !== "opacity") && (B = u(B))),
                    B
                },
                inArray: function(w, b, A) {
                    return c(32, !1, void 0, {
                        "Highcharts.inArray": "use Array.indexOf"
                    }),
                    b.indexOf(w, A)
                },
                insertItem: function(w, b) {
                    let A, j = w.options.index, B = b.length;
                    for (A = w.options.isInternal ? B : 0; A < B + 1; A++)
                        if (!b[A] || S(j) && j < E(b[A].options.index, b[A]._i) || b[A].options.isInternal) {
                            b.splice(A, 0, w);
                            break
                        }
                    return A
                },
                isArray: d,
                isClass: x,
                isDOMElement: f,
                isFunction: function(w) {
                    return typeof w == "function"
                },
                isNumber: S,
                isObject: m,
                isString: h,
                keys: function(w) {
                    return c(32, !1, void 0, {
                        "Highcharts.keys": "use Object.keys"
                    }),
                    Object.keys(w)
                },
                merge: function() {
                    let w, b = arguments, A = {}, j = function(W, N) {
                        return typeof W != "object" && (W = {}),
                        _(N, function(H, X) {
                            X !== "__proto__" && X !== "constructor" && (!m(H, !0) || x(H) || f(H) ? W[X] = N[X] : W[X] = j(W[X] || {}, H))
                        }),
                        W
                    };
                    b[0] === !0 && (A = b[1],
                    b = Array.prototype.slice.call(b, 2));
                    let B = b.length;
                    for (w = 0; w < B; w++)
                        A = j(A, b[w]);
                    return A
                },
                normalizeTickInterval: function(w, b, A, j, B) {
                    let W, N = w;
                    A = E(A, R(w));
                    let H = w / A;
                    for (!b && (b = B ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10],
                    j === !1 && (A === 1 ? b = b.filter(function(X) {
                        return X % 1 == 0
                    }) : A <= .1 && (b = [1 / A]))),
                    W = 0; W < b.length && (N = b[W],
                    (!B || !(N * A >= w)) && (B || !(H <= (b[W] + (b[W + 1] || b[W])) / 2))); W++)
                        ;
                    return F(N * A, -Math.round(Math.log(.001) / Math.LN10))
                },
                objectEach: _,
                offset: function(w) {
                    let b = a.documentElement
                      , A = w.parentElement || w.parentNode ? w.getBoundingClientRect() : {
                        top: 0,
                        left: 0,
                        width: 0,
                        height: 0
                    };
                    return {
                        top: A.top + (l.pageYOffset || b.scrollTop) - (b.clientTop || 0),
                        left: A.left + (l.pageXOffset || b.scrollLeft) - (b.clientLeft || 0),
                        width: A.width,
                        height: A.height
                    }
                },
                pad: function(w, b, A) {
                    return Array((b || 2) + 1 - String(w).replace("-", "").length).join(A || "0") + w
                },
                pick: E,
                pInt: u,
                pushUnique: function(w, b) {
                    return 0 > w.indexOf(b) && !!w.push(b)
                },
                relativeLength: function(w, b, A) {
                    return /%$/.test(w) ? b * parseFloat(w) / 100 + (A || 0) : parseFloat(w)
                },
                removeEvent: T,
                splat: g,
                stableSort: function(w, b) {
                    let A, j, B = w.length;
                    for (j = 0; j < B; j++)
                        w[j].safeI = j;
                    for (w.sort(function(W, N) {
                        return (A = b(W, N)) === 0 ? W.safeI - N.safeI : A
                    }),
                    j = 0; j < B; j++)
                        delete w[j].safeI
                },
                syncTimeout: function(w, b, A) {
                    return b > 0 ? setTimeout(w, b, A) : (w.call(0, A),
                    -1)
                },
                timeUnits: {
                    millisecond: 1,
                    second: 1e3,
                    minute: 6e4,
                    hour: 36e5,
                    day: 864e5,
                    week: 6048e5,
                    month: 24192e5,
                    year: 314496e5
                },
                uniqueKey: I,
                useSerialIds: function(w) {
                    return s = E(w, s)
                },
                wrap: function(w, b, A) {
                    let j = w[b];
                    w[b] = function() {
                        let B = arguments
                          , W = this;
                        return A.apply(this, [function() {
                            return j.apply(W, arguments.length ? arguments : B)
                        }
                        ].concat([].slice.call(arguments)))
                    }
                }
            }
        }),
        i(n, "Core/Chart/ChartDefaults.js", [], function() {
            return {
                alignThresholds: !1,
                panning: {
                    enabled: !1,
                    type: "x"
                },
                styledMode: !1,
                borderRadius: 0,
                colorCount: 10,
                allowMutatingData: !0,
                ignoreHiddenSeries: !0,
                spacing: [10, 10, 15, 10],
                resetZoomButton: {
                    theme: {},
                    position: {}
                },
                reflow: !0,
                type: "line",
                zooming: {
                    singleTouch: !1,
                    resetButton: {
                        theme: {
                            zIndex: 6
                        },
                        position: {
                            align: "right",
                            x: -10,
                            y: 10
                        }
                    }
                },
                width: null,
                height: null,
                borderColor: "#334eff",
                backgroundColor: "#ffffff",
                plotBorderColor: "#cccccc"
            }
        }),
        i(n, "Core/Color/Palettes.js", [], function() {
            return {
                colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"]
            }
        }),
        i(n, "Core/Time.js", [n["Core/Globals.js"], n["Core/Utilities.js"]], function(r, s) {
            let {win: o} = r
              , {defined: a, error: l, extend: c, isObject: u, merge: h, objectEach: d, pad: m, pick: f, splat: x, timeUnits: S} = s
              , v = r.isSafari && o.Intl && o.Intl.DateTimeFormat.prototype.formatRange
              , p = r.isSafari && o.Intl && !o.Intl.DateTimeFormat.prototype.formatRange;
            return class {
                constructor(g) {
                    this.options = {},
                    this.useUTC = !1,
                    this.variableTimezone = !1,
                    this.Date = o.Date,
                    this.getTimezoneOffset = this.timezoneOffsetFunction(),
                    this.update(g)
                }
                get(g, C) {
                    if (this.variableTimezone || this.timezoneOffset) {
                        let E = C.getTime()
                          , O = E - this.getTimezoneOffset(C);
                        C.setTime(O);
                        let R = C["getUTC" + g]();
                        return C.setTime(E),
                        R
                    }
                    return this.useUTC ? C["getUTC" + g]() : C["get" + g]()
                }
                set(g, C, E) {
                    if (this.variableTimezone || this.timezoneOffset) {
                        if (g === "Milliseconds" || g === "Seconds" || g === "Minutes" && this.getTimezoneOffset(C) % 36e5 == 0)
                            return C["setUTC" + g](E);
                        let O = this.getTimezoneOffset(C)
                          , R = C.getTime() - O;
                        C.setTime(R),
                        C["setUTC" + g](E);
                        let F = this.getTimezoneOffset(C);
                        return R = C.getTime() + F,
                        C.setTime(R)
                    }
                    return this.useUTC || v && g === "FullYear" ? C["setUTC" + g](E) : C["set" + g](E)
                }
                update(g={}) {
                    let C = f(g.useUTC, !0);
                    this.options = g = h(!0, this.options, g),
                    this.Date = g.Date || o.Date || Date,
                    this.useUTC = C,
                    this.timezoneOffset = C && g.timezoneOffset || void 0,
                    this.getTimezoneOffset = this.timezoneOffsetFunction(),
                    this.variableTimezone = C && !!(g.getTimezoneOffset || g.timezone)
                }
                makeTime(g, C, E, O, R, F) {
                    let P, _, T;
                    return this.useUTC ? (P = this.Date.UTC.apply(0, arguments),
                    _ = this.getTimezoneOffset(P),
                    P += _,
                    _ !== (T = this.getTimezoneOffset(P)) ? P += T - _ : _ - 36e5 !== this.getTimezoneOffset(P - 36e5) || p || (P -= 36e5)) : P = new this.Date(g,C,f(E, 1),f(O, 0),f(R, 0),f(F, 0)).getTime(),
                    P
                }
                timezoneOffsetFunction() {
                    let g = this
                      , C = this.options
                      , E = C.getTimezoneOffset
                      , O = C.moment || o.moment;
                    if (!this.useUTC)
                        return function(R) {
                            return 6e4 * new Date(R.toString()).getTimezoneOffset()
                        }
                        ;
                    if (C.timezone) {
                        if (O)
                            return function(R) {
                                return -(6e4 * O.tz(R, C.timezone).utcOffset())
                            }
                            ;
                        l(25)
                    }
                    return this.useUTC && E ? function(R) {
                        return 6e4 * E(R.valueOf())
                    }
                    : function() {
                        return 6e4 * (g.timezoneOffset || 0)
                    }
                }
                dateFormat(g, C, E) {
                    if (!a(C) || isNaN(C))
                        return r.defaultOptions.lang && r.defaultOptions.lang.invalidDate || "";
                    g = f(g, "%Y-%m-%d %H:%M:%S");
                    let O = this
                      , R = new this.Date(C)
                      , F = this.get("Hours", R)
                      , P = this.get("Day", R)
                      , _ = this.get("Date", R)
                      , T = this.get("Month", R)
                      , L = this.get("FullYear", R)
                      , I = r.defaultOptions.lang
                      , k = I && I.weekdays
                      , w = I && I.shortWeekdays
                      , b = c({
                        a: w ? w[P] : k[P].substr(0, 3),
                        A: k[P],
                        d: m(_),
                        e: m(_, 2, " "),
                        w: P,
                        b: I.shortMonths[T],
                        B: I.months[T],
                        m: m(T + 1),
                        o: T + 1,
                        y: L.toString().substr(2, 2),
                        Y: L,
                        H: m(F),
                        k: F,
                        I: m(F % 12 || 12),
                        l: F % 12 || 12,
                        M: m(this.get("Minutes", R)),
                        p: F < 12 ? "AM" : "PM",
                        P: F < 12 ? "am" : "pm",
                        S: m(this.get("Seconds", R)),
                        L: m(Math.floor(C % 1e3), 3)
                    }, r.dateFormats);
                    return d(b, function(A, j) {
                        for (; g.indexOf("%" + j) !== -1; )
                            g = g.replace("%" + j, typeof A == "function" ? A.call(O, C) : A)
                    }),
                    E ? g.substr(0, 1).toUpperCase() + g.substr(1) : g
                }
                resolveDTLFormat(g) {
                    return u(g, !0) ? g : {
                        main: (g = x(g))[0],
                        from: g[1],
                        to: g[2]
                    }
                }
                getTimeTicks(g, C, E, O) {
                    let R, F, P, _, T = this, L = T.Date, I = [], k = {}, w = new L(C), b = g.unitRange, A = g.count || 1;
                    if (O = f(O, 1),
                    a(C)) {
                        T.set("Milliseconds", w, b >= S.second ? 0 : A * Math.floor(T.get("Milliseconds", w) / A)),
                        b >= S.second && T.set("Seconds", w, b >= S.minute ? 0 : A * Math.floor(T.get("Seconds", w) / A)),
                        b >= S.minute && T.set("Minutes", w, b >= S.hour ? 0 : A * Math.floor(T.get("Minutes", w) / A)),
                        b >= S.hour && T.set("Hours", w, b >= S.day ? 0 : A * Math.floor(T.get("Hours", w) / A)),
                        b >= S.day && T.set("Date", w, b >= S.month ? 1 : Math.max(1, A * Math.floor(T.get("Date", w) / A))),
                        b >= S.month && (T.set("Month", w, b >= S.year ? 0 : A * Math.floor(T.get("Month", w) / A)),
                        F = T.get("FullYear", w)),
                        b >= S.year && (F -= F % A,
                        T.set("FullYear", w, F)),
                        b === S.week && (_ = T.get("Day", w),
                        T.set("Date", w, T.get("Date", w) - _ + O + (_ < O ? -7 : 0))),
                        F = T.get("FullYear", w);
                        let j = T.get("Month", w)
                          , B = T.get("Date", w)
                          , W = T.get("Hours", w);
                        C = w.getTime(),
                        (T.variableTimezone || !T.useUTC) && a(E) && (P = E - C > 4 * S.month || T.getTimezoneOffset(C) !== T.getTimezoneOffset(E));
                        let N = w.getTime();
                        for (R = 1; N < E; )
                            I.push(N),
                            b === S.year ? N = T.makeTime(F + R * A, 0) : b === S.month ? N = T.makeTime(F, j + R * A) : P && (b === S.day || b === S.week) ? N = T.makeTime(F, j, B + R * A * (b === S.day ? 1 : 7)) : P && b === S.hour && A > 1 ? N = T.makeTime(F, j, B, W + R * A) : N += b * A,
                            R++;
                        I.push(N),
                        b <= S.hour && I.length < 1e4 && I.forEach(function(H) {
                            H % 18e5 == 0 && T.dateFormat("%H%M%S%L", H) === "000000000" && (k[H] = "day")
                        })
                    }
                    return I.info = c(g, {
                        higherRanks: k,
                        totalRange: b * A
                    }),
                    I
                }
                getDateFormat(g, C, E, O) {
                    let R = this.dateFormat("%m-%d %H:%M:%S.%L", C)
                      , F = "01-01 00:00:00.000"
                      , P = {
                        millisecond: 15,
                        second: 12,
                        minute: 9,
                        hour: 6,
                        day: 3
                    }
                      , _ = "millisecond"
                      , T = _;
                    for (_ in S) {
                        if (g === S.week && +this.dateFormat("%w", C) === E && R.substr(6) === F.substr(6)) {
                            _ = "week";
                            break
                        }
                        if (S[_] > g) {
                            _ = T;
                            break
                        }
                        if (P[_] && R.substr(P[_]) !== F.substr(P[_]))
                            break;
                        _ !== "week" && (T = _)
                    }
                    return this.resolveDTLFormat(O[_]).main
                }
            }
        }),
        i(n, "Core/Defaults.js", [n["Core/Chart/ChartDefaults.js"], n["Core/Globals.js"], n["Core/Color/Palettes.js"], n["Core/Time.js"], n["Core/Utilities.js"]], function(r, s, o, a, l) {
            let {isTouchDevice: c, svg: u} = s
              , {merge: h} = l
              , d = {
                colors: o.colors,
                symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
                lang: {
                    loading: "Loading...",
                    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                    weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    decimalPoint: ".",
                    numericSymbols: ["k", "M", "G", "T", "P", "E"],
                    resetZoom: "Reset zoom",
                    resetZoomTitle: "Reset zoom level 1:1",
                    thousandsSep: " "
                },
                global: {},
                time: {
                    Date: void 0,
                    getTimezoneOffset: void 0,
                    timezone: void 0,
                    timezoneOffset: 0,
                    useUTC: !0
                },
                chart: r,
                title: {
                    style: {
                        color: "#333333",
                        fontWeight: "bold"
                    },
                    text: "Chart title",
                    align: "center",
                    margin: 15,
                    widthAdjust: -44
                },
                subtitle: {
                    style: {
                        color: "#666666",
                        fontSize: "0.8em"
                    },
                    text: "",
                    align: "center",
                    widthAdjust: -44
                },
                caption: {
                    margin: 15,
                    style: {
                        color: "#666666",
                        fontSize: "0.8em"
                    },
                    text: "",
                    align: "left",
                    verticalAlign: "bottom"
                },
                plotOptions: {},
                legend: {
                    enabled: !0,
                    align: "center",
                    alignColumns: !0,
                    className: "highcharts-no-tooltip",
                    layout: "horizontal",
                    itemMarginBottom: 2,
                    itemMarginTop: 2,
                    labelFormatter: function() {
                        return this.name
                    },
                    borderColor: "#999999",
                    borderRadius: 0,
                    navigation: {
                        style: {
                            fontSize: "0.8em"
                        },
                        activeColor: "#0022ff",
                        inactiveColor: "#cccccc"
                    },
                    itemStyle: {
                        color: "#333333",
                        cursor: "pointer",
                        fontSize: "0.8em",
                        textDecoration: "none",
                        textOverflow: "ellipsis"
                    },
                    itemHoverStyle: {
                        color: "#000000"
                    },
                    itemHiddenStyle: {
                        color: "#666666",
                        textDecoration: "line-through"
                    },
                    shadow: !1,
                    itemCheckboxStyle: {
                        position: "absolute",
                        width: "13px",
                        height: "13px"
                    },
                    squareSymbol: !0,
                    symbolPadding: 5,
                    verticalAlign: "bottom",
                    x: 0,
                    y: 0,
                    title: {
                        style: {
                            fontSize: "0.8em",
                            fontWeight: "bold"
                        }
                    }
                },
                loading: {
                    labelStyle: {
                        fontWeight: "bold",
                        position: "relative",
                        top: "45%"
                    },
                    style: {
                        position: "absolute",
                        backgroundColor: "#ffffff",
                        opacity: .5,
                        textAlign: "center"
                    }
                },
                tooltip: {
                    enabled: !0,
                    animation: u,
                    borderRadius: 3,
                    dateTimeLabelFormats: {
                        millisecond: "%A, %e %b, %H:%M:%S.%L",
                        second: "%A, %e %b, %H:%M:%S",
                        minute: "%A, %e %b, %H:%M",
                        hour: "%A, %e %b, %H:%M",
                        day: "%A, %e %b %Y",
                        week: "Week from %A, %e %b %Y",
                        month: "%B %Y",
                        year: "%Y"
                    },
                    footerFormat: "",
                    headerShape: "callout",
                    hideDelay: 500,
                    padding: 8,
                    shape: "callout",
                    shared: !1,
                    snap: c ? 25 : 10,
                    headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>',
                    pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',
                    backgroundColor: "#ffffff",
                    borderWidth: void 0,
                    shadow: !0,
                    stickOnContact: !1,
                    style: {
                        color: "#333333",
                        cursor: "default",
                        fontSize: "0.8em"
                    },
                    useHTML: !1
                },
                credits: {
                    enabled: !0,
                    href: "https://www.highcharts.com?credits",
                    position: {
                        align: "right",
                        x: -10,
                        verticalAlign: "bottom",
                        y: -5
                    },
                    style: {
                        cursor: "pointer",
                        color: "#999999",
                        fontSize: "0.6em"
                    },
                    text: "Highcharts.com"
                }
            };
            d.chart.styledMode = !1;
            let m = new a(d.time);
            return {
                defaultOptions: d,
                defaultTime: m,
                getOptions: function() {
                    return d
                },
                setOptions: function(f) {
                    return h(!0, d, f),
                    (f.time || f.global) && (s.time ? s.time.update(h(d.global, d.time, f.global, f.time)) : s.time = m),
                    d
                }
            }
        }),
        i(n, "Core/Color/Color.js", [n["Core/Globals.js"], n["Core/Utilities.js"]], function(r, s) {
            let {isNumber: o, merge: a, pInt: l} = s;
            class c {
                static parse(h) {
                    return h ? new c(h) : c.None
                }
                constructor(h) {
                    this.rgba = [NaN, NaN, NaN, NaN],
                    this.input = h;
                    let d = r.Color;
                    if (d && d !== c)
                        return new d(h);
                    this.init(h)
                }
                init(h) {
                    let d, m, f, x;
                    if (typeof h == "object" && h.stops !== void 0)
                        this.stops = h.stops.map(S=>new c(S[1]));
                    else if (typeof h == "string") {
                        if (this.input = h = c.names[h.toLowerCase()] || h,
                        h.charAt(0) === "#") {
                            let S = h.length
                              , v = parseInt(h.substr(1), 16);
                            S === 7 ? m = [(16711680 & v) >> 16, (65280 & v) >> 8, 255 & v, 1] : S === 4 && (m = [(3840 & v) >> 4 | (3840 & v) >> 8, (240 & v) >> 4 | 240 & v, (15 & v) << 4 | 15 & v, 1])
                        }
                        if (!m)
                            for (f = c.parsers.length; f-- && !m; )
                                (d = (x = c.parsers[f]).regex.exec(h)) && (m = x.parse(d))
                    }
                    m && (this.rgba = m)
                }
                get(h) {
                    let d = this.input
                      , m = this.rgba;
                    if (typeof d == "object" && this.stops !== void 0) {
                        let f = a(d);
                        return f.stops = [].slice.call(f.stops),
                        this.stops.forEach((x,S)=>{
                            f.stops[S] = [f.stops[S][0], x.get(h)]
                        }
                        ),
                        f
                    }
                    return m && o(m[0]) ? h !== "rgb" && (h || m[3] !== 1) ? h === "a" ? `${m[3]}` : "rgba(" + m.join(",") + ")" : "rgb(" + m[0] + "," + m[1] + "," + m[2] + ")" : d
                }
                brighten(h) {
                    let d = this.rgba;
                    if (this.stops)
                        this.stops.forEach(function(m) {
                            m.brighten(h)
                        });
                    else if (o(h) && h !== 0)
                        for (let m = 0; m < 3; m++)
                            d[m] += l(255 * h),
                            d[m] < 0 && (d[m] = 0),
                            d[m] > 255 && (d[m] = 255);
                    return this
                }
                setOpacity(h) {
                    return this.rgba[3] = h,
                    this
                }
                tweenTo(h, d) {
                    let m = this.rgba
                      , f = h.rgba;
                    if (!o(m[0]) || !o(f[0]))
                        return h.input || "none";
                    let x = f[3] !== 1 || m[3] !== 1;
                    return (x ? "rgba(" : "rgb(") + Math.round(f[0] + (m[0] - f[0]) * (1 - d)) + "," + Math.round(f[1] + (m[1] - f[1]) * (1 - d)) + "," + Math.round(f[2] + (m[2] - f[2]) * (1 - d)) + (x ? "," + (f[3] + (m[3] - f[3]) * (1 - d)) : "") + ")"
                }
            }
            return c.names = {
                white: "#ffffff",
                black: "#000000"
            },
            c.parsers = [{
                regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
                parse: function(u) {
                    return [l(u[1]), l(u[2]), l(u[3]), parseFloat(u[4], 10)]
                }
            }, {
                regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
                parse: function(u) {
                    return [l(u[1]), l(u[2]), l(u[3]), 1]
                }
            }],
            c.None = new c(""),
            c
        }),
        i(n, "Core/Animation/Fx.js", [n["Core/Color/Color.js"], n["Core/Globals.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {parse: a} = r
              , {win: l} = s
              , {isNumber: c, objectEach: u} = o;
            class h {
                constructor(m, f, x) {
                    this.pos = NaN,
                    this.options = f,
                    this.elem = m,
                    this.prop = x
                }
                dSetter() {
                    let m = this.paths
                      , f = m && m[0]
                      , x = m && m[1]
                      , S = this.now || 0
                      , v = [];
                    if (S !== 1 && f && x)
                        if (f.length === x.length && S < 1)
                            for (let p = 0; p < x.length; p++) {
                                let g = f[p]
                                  , C = x[p]
                                  , E = [];
                                for (let O = 0; O < C.length; O++) {
                                    let R = g[O]
                                      , F = C[O];
                                    c(R) && c(F) && !(C[0] === "A" && (O === 4 || O === 5)) ? E[O] = R + S * (F - R) : E[O] = F
                                }
                                v.push(E)
                            }
                        else
                            v = x;
                    else
                        v = this.toD || [];
                    this.elem.attr("d", v, void 0, !0)
                }
                update() {
                    let m = this.elem
                      , f = this.prop
                      , x = this.now
                      , S = this.options.step;
                    this[f + "Setter"] ? this[f + "Setter"]() : m.attr ? m.element && m.attr(f, x, null, !0) : m.style[f] = x + this.unit,
                    S && S.call(m, x, this)
                }
                run(m, f, x) {
                    let S = this
                      , v = S.options
                      , p = function(E) {
                        return !p.stopped && S.step(E)
                    }
                      , g = l.requestAnimationFrame || function(E) {
                        setTimeout(E, 13)
                    }
                      , C = function() {
                        for (let E = 0; E < h.timers.length; E++)
                            h.timers[E]() || h.timers.splice(E--, 1);
                        h.timers.length && g(C)
                    };
                    m !== f || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date,
                    this.start = m,
                    this.end = f,
                    this.unit = x,
                    this.now = this.start,
                    this.pos = 0,
                    p.elem = this.elem,
                    p.prop = this.prop,
                    p() && h.timers.push(p) === 1 && g(C)) : (delete v.curAnim[this.prop],
                    v.complete && Object.keys(v.curAnim).length === 0 && v.complete.call(this.elem))
                }
                step(m) {
                    let f, x, S = +new Date, v = this.options, p = this.elem, g = v.complete, C = v.duration, E = v.curAnim;
                    return p.attr && !p.element ? f = !1 : m || S >= C + this.startTime ? (this.now = this.end,
                    this.pos = 1,
                    this.update(),
                    E[this.prop] = !0,
                    x = !0,
                    u(E, function(O) {
                        O !== !0 && (x = !1)
                    }),
                    x && g && g.call(p),
                    f = !1) : (this.pos = v.easing((S - this.startTime) / C),
                    this.now = this.start + (this.end - this.start) * this.pos,
                    this.update(),
                    f = !0),
                    f
                }
                initPath(m, f, x) {
                    let S = m.startX, v = m.endX, p = x.slice(), g = m.isArea, C = g ? 2 : 1, E, O, R, F, P = f && f.slice();
                    if (!P)
                        return [p, p];
                    function _(L, I) {
                        for (; L.length < O; ) {
                            let k = L[0]
                              , w = I[O - L.length];
                            if (w && k[0] === "M" && (w[0] === "C" ? L[0] = ["C", k[1], k[2], k[1], k[2], k[1], k[2]] : L[0] = ["L", k[1], k[2]]),
                            L.unshift(k),
                            g) {
                                let b = L.pop();
                                L.push(L[L.length - 1], b)
                            }
                        }
                    }
                    function T(L, I) {
                        for (; L.length < O; ) {
                            let k = L[Math.floor(L.length / C) - 1].slice();
                            if (k[0] === "C" && (k[1] = k[5],
                            k[2] = k[6]),
                            g) {
                                let w = L[Math.floor(L.length / C)].slice();
                                L.splice(L.length / 2, 0, k, w)
                            } else
                                L.push(k)
                        }
                    }
                    if (S && v && v.length) {
                        for (R = 0; R < S.length; R++) {
                            if (S[R] === v[0]) {
                                E = R;
                                break
                            }
                            if (S[0] === v[v.length - S.length + R]) {
                                E = R,
                                F = !0;
                                break
                            }
                            if (S[S.length - 1] === v[v.length - S.length + R]) {
                                E = S.length - R;
                                break
                            }
                        }
                        E === void 0 && (P = [])
                    }
                    return P.length && c(E) && (O = p.length + E * C,
                    F ? (_(P, p),
                    T(p)) : (_(p, P),
                    T(P))),
                    [P, p]
                }
                fillSetter() {
                    h.prototype.strokeSetter.apply(this, arguments)
                }
                strokeSetter() {
                    this.elem.attr(this.prop, a(this.start).tweenTo(a(this.end), this.pos), void 0, !0)
                }
            }
            return h.timers = [],
            h
        }),
        i(n, "Core/Animation/AnimationUtilities.js", [n["Core/Animation/Fx.js"], n["Core/Utilities.js"]], function(r, s) {
            let {defined: o, getStyle: a, isArray: l, isNumber: c, isObject: u, merge: h, objectEach: d, pick: m} = s;
            function f(S) {
                return u(S) ? h({
                    duration: 500,
                    defer: 0
                }, S) : {
                    duration: S ? 500 : 0,
                    defer: 0
                }
            }
            function x(S, v) {
                let p = r.timers.length;
                for (; p--; )
                    r.timers[p].elem !== S || v && v !== r.timers[p].prop || (r.timers[p].stopped = !0)
            }
            return {
                animate: function(S, v, p) {
                    let g, C = "", E, O, R;
                    u(p) || (R = arguments,
                    p = {
                        duration: R[2],
                        easing: R[3],
                        complete: R[4]
                    }),
                    c(p.duration) || (p.duration = 400),
                    p.easing = typeof p.easing == "function" ? p.easing : Math[p.easing] || Math.easeInOutSine,
                    p.curAnim = h(v),
                    d(v, function(F, P) {
                        x(S, P),
                        O = new r(S,p,P),
                        E = void 0,
                        P === "d" && l(v.d) ? (O.paths = O.initPath(S, S.pathArray, v.d),
                        O.toD = v.d,
                        g = 0,
                        E = 1) : S.attr ? g = S.attr(P) : (g = parseFloat(a(S, P)) || 0,
                        P !== "opacity" && (C = "px")),
                        E || (E = F),
                        typeof E == "string" && E.match("px") && (E = E.replace(/px/g, "")),
                        O.run(g, E, C)
                    })
                },
                animObject: f,
                getDeferredAnimation: function(S, v, p) {
                    let g = f(v)
                      , C = p ? [p] : S.series
                      , E = 0
                      , O = 0;
                    return C.forEach(F=>{
                        let P = f(F.options.animation);
                        E = v && o(v.defer) ? g.defer : Math.max(E, P.duration + P.defer),
                        O = Math.min(g.duration, P.duration)
                    }
                    ),
                    S.renderer.forExport && (E = 0),
                    {
                        defer: Math.max(0, E - O),
                        duration: Math.min(E, O)
                    }
                },
                setAnimation: function(S, v) {
                    v.renderer.globalAnimation = m(S, v.options.chart.animation, !0)
                },
                stop: x
            }
        }),
        i(n, "Core/Renderer/HTML/AST.js", [n["Core/Globals.js"], n["Core/Utilities.js"]], function(r, s) {
            let {SVG_NS: o, win: a} = r
              , {attr: l, createElement: c, css: u, error: h, isFunction: d, isString: m, objectEach: f, splat: x} = s
              , {trustedTypes: S} = a
              , v = S && d(S.createPolicy) && S.createPolicy("highcharts", {
                createHTML: E=>E
            })
              , p = v ? v.createHTML("") : ""
              , g = function() {
                try {
                    return !!new DOMParser().parseFromString(p, "text/html")
                } catch {
                    return !1
                }
            }();
            class C {
                static filterUserAttributes(O) {
                    return f(O, (R,F)=>{
                        let P = !0;
                        C.allowedAttributes.indexOf(F) === -1 && (P = !1),
                        ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(F) !== -1 && (P = m(R) && C.allowedReferences.some(_=>R.indexOf(_) === 0)),
                        P || (h(33, !1, void 0, {
                            "Invalid attribute in config": `${F}`
                        }),
                        delete O[F]),
                        m(R) && O[F] && (O[F] = R.replace(/</g, "&lt;"))
                    }
                    ),
                    O
                }
                static parseStyle(O) {
                    return O.split(";").reduce((R,F)=>{
                        let P = F.split(":").map(T=>T.trim())
                          , _ = P.shift();
                        return _ && P.length && (R[_.replace(/-([a-z])/g, T=>T[1].toUpperCase())] = P.join(":")),
                        R
                    }
                    , {})
                }
                static setElementHTML(O, R) {
                    O.innerHTML = C.emptyHTML,
                    R && new C(R).addToDOM(O)
                }
                constructor(O) {
                    this.nodes = typeof O == "string" ? this.parseMarkup(O) : O
                }
                addToDOM(O) {
                    return function R(F, P) {
                        let _;
                        return x(F).forEach(function(T) {
                            let L, I = T.tagName, k = T.textContent ? r.doc.createTextNode(T.textContent) : void 0, w = C.bypassHTMLFiltering;
                            if (I)
                                if (I === "#text")
                                    L = k;
                                else if (C.allowedTags.indexOf(I) !== -1 || w) {
                                    let b = I === "svg" ? o : P.namespaceURI || o
                                      , A = r.doc.createElementNS(b, I)
                                      , j = T.attributes || {};
                                    f(T, function(B, W) {
                                        W !== "tagName" && W !== "attributes" && W !== "children" && W !== "style" && W !== "textContent" && (j[W] = B)
                                    }),
                                    l(A, w ? j : C.filterUserAttributes(j)),
                                    T.style && u(A, T.style),
                                    k && A.appendChild(k),
                                    R(T.children || [], A),
                                    L = A
                                } else
                                    h(33, !1, void 0, {
                                        "Invalid tagName in config": I
                                    });
                            L && P.appendChild(L),
                            _ = L
                        }),
                        _
                    }(this.nodes, O)
                }
                parseMarkup(O) {
                    let R, F = [];
                    if (O = O.trim().replace(/ style=(["'])/g, " data-style=$1"),
                    g)
                        R = new DOMParser().parseFromString(v ? v.createHTML(O) : O, "text/html");
                    else {
                        let _ = c("div");
                        _.innerHTML = O,
                        R = {
                            body: _
                        }
                    }
                    let P = (_,T)=>{
                        let L = _.nodeName.toLowerCase()
                          , I = {
                            tagName: L
                        };
                        L === "#text" && (I.textContent = _.textContent || "");
                        let k = _.attributes;
                        if (k) {
                            let w = {};
                            [].forEach.call(k, b=>{
                                b.name === "data-style" ? I.style = C.parseStyle(b.value) : w[b.name] = b.value
                            }
                            ),
                            I.attributes = w
                        }
                        if (_.childNodes.length) {
                            let w = [];
                            [].forEach.call(_.childNodes, b=>{
                                P(b, w)
                            }
                            ),
                            w.length && (I.children = w)
                        }
                        T.push(I)
                    }
                    ;
                    return [].forEach.call(R.body.childNodes, _=>P(_, F)),
                    F
                }
            }
            return C.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "dx", "dy", "disabled", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "markerHeight", "markerWidth", "offset", "opacity", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "refX", "refY", "role", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke", "stroke-linecap", "stroke-width", "style", "tableValues", "result", "rowspan", "summary", "target", "tabindex", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"],
            C.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"],
            C.allowedTags = ["a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feDropShadow", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feOffset", "feMerge", "feMergeNode", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "text", "textPath", "thead", "title", "tbody", "tspan", "td", "th", "tr", "u", "ul", "#text"],
            C.emptyHTML = p,
            C.bypassHTMLFiltering = !1,
            C
        }),
        i(n, "Core/Templating.js", [n["Core/Defaults.js"], n["Core/Utilities.js"]], function(r, s) {
            let {defaultOptions: o, defaultTime: a} = r
              , {extend: l, getNestedProperty: c, isArray: u, isNumber: h, isObject: d, isString: m, pick: f, pInt: x} = s
              , S = {
                add: (g,C)=>g + C,
                divide: (g,C)=>C !== 0 ? g / C : "",
                eq: (g,C)=>g == C,
                each: function(g) {
                    let C = arguments[arguments.length - 1];
                    return !!u(g) && g.map((E,O)=>v(C.body, l(d(E) ? E : {
                        "@this": E
                    }, {
                        "@index": O,
                        "@first": O === 0,
                        "@last": O === g.length - 1
                    }))).join("")
                },
                ge: (g,C)=>g >= C,
                gt: (g,C)=>g > C,
                if: g=>!!g,
                le: (g,C)=>g <= C,
                lt: (g,C)=>g < C,
                multiply: (g,C)=>g * C,
                ne: (g,C)=>g != C,
                subtract: (g,C)=>g - C,
                unless: g=>!g
            };
            function v(g="", C, E) {
                let O = /\{([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= #\(\)]+)\}/g, R = /\(([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= ]+)\)/g, F = [], P = /f$/, _ = /\.([0-9])/, T = o.lang, L = E && E.time || a, I = E && E.numberFormatter || p, k = (B="")=>{
                    let W;
                    return B === "true" || B !== "false" && ((W = Number(B)).toString() === B ? W : c(B, C))
                }
                , w, b, A = 0, j;
                for (; (w = O.exec(g)) !== null; ) {
                    let B = R.exec(w[1]);
                    B && (w = B,
                    j = !0),
                    b && b.isBlock || (b = {
                        ctx: C,
                        expression: w[1],
                        find: w[0],
                        isBlock: w[1].charAt(0) === "#",
                        start: w.index,
                        startInner: w.index + w[0].length,
                        length: w[0].length
                    });
                    let W = w[1].split(" ")[0].replace("#", "");
                    S[W] && (b.isBlock && W === b.fn && A++,
                    b.fn || (b.fn = W));
                    let N = w[1] === "else";
                    if (b.isBlock && b.fn && (w[1] === `/${b.fn}` || N))
                        if (A)
                            !N && A--;
                        else {
                            let H = b.startInner
                              , X = g.substr(H, w.index - H);
                            b.body === void 0 ? (b.body = X,
                            b.startInner = w.index + w[0].length) : b.elseBody = X,
                            b.find += X + w[0],
                            N || (F.push(b),
                            b = void 0)
                        }
                    else
                        b.isBlock || F.push(b);
                    if (B && !(b != null && b.isBlock))
                        break
                }
                return F.forEach(B=>{
                    let W, N, {body: H, elseBody: X, expression: ie, fn: K} = B;
                    if (K) {
                        let D = [B]
                          , V = ie.split(" ");
                        for (N = S[K].length; N--; )
                            D.unshift(k(V[N + 1]));
                        W = S[K].apply(C, D),
                        B.isBlock && typeof W == "boolean" && (W = v(W ? H : X, C))
                    } else {
                        let D = ie.split(":");
                        if (W = k(D.shift() || ""),
                        D.length && typeof W == "number") {
                            let V = D.join(":");
                            if (P.test(V)) {
                                let G = parseInt((V.match(_) || ["", "-1"])[1], 10);
                                W !== null && (W = I(W, G, T.decimalPoint, V.indexOf(",") > -1 ? T.thousandsSep : ""))
                            } else
                                W = L.dateFormat(V, W)
                        }
                    }
                    g = g.replace(B.find, f(W, ""))
                }
                ),
                j ? v(g, C, E) : g
            }
            function p(g, C, E, O) {
                let R, F;
                g = +g || 0,
                C = +C;
                let P = o.lang
                  , _ = (g.toString().split(".")[1] || "").split("e")[0].length
                  , T = g.toString().split("e")
                  , L = C;
                C === -1 ? C = Math.min(_, 20) : h(C) ? C && T[1] && T[1] < 0 && ((F = C + +T[1]) >= 0 ? (T[0] = (+T[0]).toExponential(F).split("e")[0],
                C = F) : (T[0] = T[0].split(".")[0] || 0,
                g = C < 20 ? (T[0] * Math.pow(10, T[1])).toFixed(C) : 0,
                T[1] = 0)) : C = 2;
                let I = (Math.abs(T[1] ? T[0] : g) + Math.pow(10, -Math.max(C, _) - 1)).toFixed(C)
                  , k = String(x(I))
                  , w = k.length > 3 ? k.length % 3 : 0;
                return E = f(E, P.decimalPoint),
                O = f(O, P.thousandsSep),
                R = (g < 0 ? "-" : "") + (w ? k.substr(0, w) + O : ""),
                0 > +T[1] && !L ? R = "0" : R += k.substr(w).replace(/(\d{3})(?=\d)/g, "$1" + O),
                C && (R += E + I.slice(-C)),
                T[1] && +R != 0 && (R += "e" + T[1]),
                R
            }
            return {
                dateFormat: function(g, C, E) {
                    return a.dateFormat(g, C, E)
                },
                format: v,
                helpers: S,
                numberFormat: p
            }
        }),
        i(n, "Core/Renderer/RendererUtilities.js", [n["Core/Utilities.js"]], function(r) {
            var s;
            let {clamp: o, pick: a, pushUnique: l, stableSort: c} = r;
            return (s || (s = {})).distribute = function u(h, d, m) {
                let f = h, x = f.reducedLen || d, S = (I,k)=>I.target - k.target, v = [], p = h.length, g = [], C = v.push, E, O, R, F = !0, P, _, T = 0, L;
                for (E = p; E--; )
                    T += h[E].size;
                if (T > x) {
                    for (c(h, (I,k)=>(k.rank || 0) - (I.rank || 0)),
                    R = (L = h[0].rank === h[h.length - 1].rank) ? p / 2 : -1,
                    O = L ? R : p - 1; R && T > x; )
                        P = h[E = Math.floor(O)],
                        l(g, E) && (T -= P.size),
                        O += R,
                        L && O >= h.length && (R /= 2,
                        O = R);
                    g.sort((I,k)=>k - I).forEach(I=>C.apply(v, h.splice(I, 1)))
                }
                for (c(h, S),
                h = h.map(I=>({
                    size: I.size,
                    targets: [I.target],
                    align: a(I.align, .5)
                })); F; ) {
                    for (E = h.length; E--; )
                        P = h[E],
                        _ = (Math.min.apply(0, P.targets) + Math.max.apply(0, P.targets)) / 2,
                        P.pos = o(_ - P.size * P.align, 0, d - P.size);
                    for (E = h.length,
                    F = !1; E--; )
                        E > 0 && h[E - 1].pos + h[E - 1].size > h[E].pos && (h[E - 1].size += h[E].size,
                        h[E - 1].targets = h[E - 1].targets.concat(h[E].targets),
                        h[E - 1].align = .5,
                        h[E - 1].pos + h[E - 1].size > d && (h[E - 1].pos = d - h[E - 1].size),
                        h.splice(E, 1),
                        F = !0)
                }
                return C.apply(f, v),
                E = 0,
                h.some(I=>{
                    let k = 0;
                    return (I.targets || []).some(()=>(f[E].pos = I.pos + k,
                    m !== void 0 && Math.abs(f[E].pos - f[E].target) > m ? (f.slice(0, E + 1).forEach(w=>delete w.pos),
                    f.reducedLen = (f.reducedLen || d) - .1 * d,
                    f.reducedLen > .1 * d && u(f, d, m),
                    !0) : (k += f[E].size,
                    E++,
                    !1)))
                }
                ),
                c(f, S),
                f
            }
            ,
            s
        }),
        i(n, "Core/Renderer/SVG/SVGElement.js", [n["Core/Animation/AnimationUtilities.js"], n["Core/Color/Color.js"], n["Core/Globals.js"], n["Core/Utilities.js"]], function(r, s, o, a) {
            let {animate: l, animObject: c, stop: u} = r
              , {deg2rad: h, doc: d, noop: m, svg: f, SVG_NS: x, win: S} = o
              , {addEvent: v, attr: p, createElement: g, css: C, defined: E, erase: O, extend: R, fireEvent: F, isArray: P, isFunction: _, isObject: T, isString: L, merge: I, objectEach: k, pick: w, pInt: b, syncTimeout: A, uniqueKey: j} = a;
            class B {
                constructor() {
                    this.element = void 0,
                    this.onEvents = {},
                    this.opacity = 1,
                    this.renderer = void 0,
                    this.SVG_NS = x
                }
                _defaultGetter(N) {
                    let H = w(this[N + "Value"], this[N], this.element ? this.element.getAttribute(N) : null, 0);
                    return /^[\-0-9\.]+$/.test(H) && (H = parseFloat(H)),
                    H
                }
                _defaultSetter(N, H, X) {
                    X.setAttribute(H, N)
                }
                add(N) {
                    let H, X = this.renderer, ie = this.element;
                    return N && (this.parentGroup = N),
                    this.textStr !== void 0 && this.element.nodeName === "text" && X.buildText(this),
                    this.added = !0,
                    (!N || N.handleZ || this.zIndex) && (H = this.zIndexSetter()),
                    H || (N ? N.element : X.box).appendChild(ie),
                    this.onAdd && this.onAdd(),
                    this
                }
                addClass(N, H) {
                    let X = H ? "" : this.attr("class") || "";
                    return (N = (N || "").split(/ /g).reduce(function(ie, K) {
                        return X.indexOf(K) === -1 && ie.push(K),
                        ie
                    }, X ? [X] : []).join(" ")) !== X && this.attr("class", N),
                    this
                }
                afterSetters() {
                    this.doTransform && (this.updateTransform(),
                    this.doTransform = !1)
                }
                align(N, H, X) {
                    let ie, K, D, V, G, ee = {}, J = this.renderer, te = J.alignedObjects;
                    N ? (this.alignOptions = N,
                    this.alignByTranslate = H,
                    (!X || L(X)) && (this.alignTo = D = X || "renderer",
                    O(te, this),
                    te.push(this),
                    X = void 0)) : (N = this.alignOptions,
                    H = this.alignByTranslate,
                    D = this.alignTo),
                    X = w(X, J[D], D === "scrollablePlotBox" ? J.plotBox : void 0, J);
                    let z = N.align
                      , Y = N.verticalAlign;
                    return ie = (X.x || 0) + (N.x || 0),
                    K = (X.y || 0) + (N.y || 0),
                    z === "right" ? V = 1 : z === "center" && (V = 2),
                    V && (ie += (X.width - (N.width || 0)) / V),
                    ee[H ? "translateX" : "x"] = Math.round(ie),
                    Y === "bottom" ? G = 1 : Y === "middle" && (G = 2),
                    G && (K += (X.height - (N.height || 0)) / G),
                    ee[H ? "translateY" : "y"] = Math.round(K),
                    this[this.placed ? "animate" : "attr"](ee),
                    this.placed = !0,
                    this.alignAttr = ee,
                    this
                }
                alignSetter(N) {
                    let H = {
                        left: "start",
                        center: "middle",
                        right: "end"
                    };
                    H[N] && (this.alignValue = N,
                    this.element.setAttribute("text-anchor", H[N]))
                }
                animate(N, H, X) {
                    let ie = c(w(H, this.renderer.globalAnimation, !0))
                      , K = ie.defer;
                    return d.hidden && (ie.duration = 0),
                    ie.duration !== 0 ? (X && (ie.complete = X),
                    A(()=>{
                        this.element && l(this, N, ie)
                    }
                    , K)) : (this.attr(N, void 0, X || ie.complete),
                    k(N, function(D, V) {
                        ie.step && ie.step.call(this, D, {
                            prop: V,
                            pos: 1,
                            elem: this
                        })
                    }, this)),
                    this
                }
                applyTextOutline(N) {
                    let H = this.element;
                    N.indexOf("contrast") !== -1 && (N = N.replace(/contrast/g, this.renderer.getContrast(H.style.fill)));
                    let ie = N.split(" ")
                      , K = ie[ie.length - 1]
                      , D = ie[0];
                    if (D && D !== "none" && o.svg) {
                        this.fakeTS = !0,
                        D = D.replace(/(^[\d\.]+)(.*?)$/g, function(te, z, Y) {
                            return 2 * Number(z) + Y
                        }),
                        this.removeTextOutline();
                        let V = d.createElementNS(x, "tspan");
                        p(V, {
                            class: "highcharts-text-outline",
                            fill: K,
                            stroke: K,
                            "stroke-width": D,
                            "stroke-linejoin": "round"
                        });
                        let G = H.querySelector("textPath") || H;
                        [].forEach.call(G.childNodes, te=>{
                            let z = te.cloneNode(!0);
                            z.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(Y=>z.removeAttribute(Y)),
                            V.appendChild(z)
                        }
                        );
                        let ee = 0;
                        [].forEach.call(G.querySelectorAll("text tspan"), te=>{
                            ee += Number(te.getAttribute("dy"))
                        }
                        );
                        let J = d.createElementNS(x, "tspan");
                        J.textContent = "​",
                        p(J, {
                            x: Number(H.getAttribute("x")),
                            dy: -ee
                        }),
                        V.appendChild(J),
                        G.insertBefore(V, G.firstChild)
                    }
                }
                attr(N, H, X, ie) {
                    let K = this.element, D = B.symbolCustomAttribs, V, G, ee = this, J;
                    return typeof N == "string" && H !== void 0 && (V = N,
                    (N = {})[V] = H),
                    typeof N == "string" ? ee = (this[N + "Getter"] || this._defaultGetter).call(this, N, K) : (k(N, function(te, z) {
                        J = !1,
                        ie || u(this, z),
                        this.symbolName && D.indexOf(z) !== -1 && (G || (this.symbolAttr(N),
                        G = !0),
                        J = !0),
                        this.rotation && (z === "x" || z === "y") && (this.doTransform = !0),
                        J || (this[z + "Setter"] || this._defaultSetter).call(this, te, z, K)
                    }, this),
                    this.afterSetters()),
                    X && X.call(this),
                    ee
                }
                clip(N) {
                    return this.attr("clip-path", N ? "url(" + this.renderer.url + "#" + N.id + ")" : "none")
                }
                crisp(N, H) {
                    H = H || N.strokeWidth || 0;
                    let X = Math.round(H) % 2 / 2;
                    return N.x = Math.floor(N.x || this.x || 0) + X,
                    N.y = Math.floor(N.y || this.y || 0) + X,
                    N.width = Math.floor((N.width || this.width || 0) - 2 * X),
                    N.height = Math.floor((N.height || this.height || 0) - 2 * X),
                    E(N.strokeWidth) && (N.strokeWidth = H),
                    N
                }
                complexColor(N, H, X) {
                    let ie = this.renderer, K, D, V, G, ee, J, te, z, Y, U, Z = [], $;
                    F(this.renderer, "complexColor", {
                        args: arguments
                    }, function() {
                        if (N.radialGradient ? D = "radialGradient" : N.linearGradient && (D = "linearGradient"),
                        D) {
                            if (V = N[D],
                            ee = ie.gradients,
                            J = N.stops,
                            Y = X.radialReference,
                            P(V) && (N[D] = V = {
                                x1: V[0],
                                y1: V[1],
                                x2: V[2],
                                y2: V[3],
                                gradientUnits: "userSpaceOnUse"
                            }),
                            D === "radialGradient" && Y && !E(V.gradientUnits) && (G = V,
                            V = I(V, ie.getRadialAttr(Y, G), {
                                gradientUnits: "userSpaceOnUse"
                            })),
                            k(V, function(ne, oe) {
                                oe !== "id" && Z.push(oe, ne)
                            }),
                            k(J, function(ne) {
                                Z.push(ne)
                            }),
                            ee[Z = Z.join(",")])
                                U = ee[Z].attr("id");
                            else {
                                V.id = U = j();
                                let ne = ee[Z] = ie.createElement(D).attr(V).add(ie.defs);
                                ne.radAttr = G,
                                ne.stops = [],
                                J.forEach(function(oe) {
                                    oe[1].indexOf("rgba") === 0 ? (te = (K = s.parse(oe[1])).get("rgb"),
                                    z = K.get("a")) : (te = oe[1],
                                    z = 1);
                                    let se = ie.createElement("stop").attr({
                                        offset: oe[0],
                                        "stop-color": te,
                                        "stop-opacity": z
                                    }).add(ne);
                                    ne.stops.push(se)
                                })
                            }
                            $ = "url(" + ie.url + "#" + U + ")",
                            X.setAttribute(H, $),
                            X.gradient = Z,
                            N.toString = function() {
                                return $
                            }
                        }
                    })
                }
                css(N) {
                    let H = this.styles, X = {}, ie = this.element, K, D = !H;
                    if (H && k(N, function(V, G) {
                        H && H[G] !== V && (X[G] = V,
                        D = !0)
                    }),
                    D) {
                        H && (N = R(H, X)),
                        N.width === null || N.width === "auto" ? delete this.textWidth : ie.nodeName.toLowerCase() === "text" && N.width && (K = this.textWidth = b(N.width)),
                        this.styles = N,
                        K && !f && this.renderer.forExport && delete N.width;
                        let V = I(N);
                        ie.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "width"].forEach(G=>V && delete V[G]),
                        V.color && (V.fill = V.color)),
                        C(ie, V)
                    }
                    return this.added && (this.element.nodeName === "text" && this.renderer.buildText(this),
                    N.textOutline && this.applyTextOutline(N.textOutline)),
                    this
                }
                dashstyleSetter(N) {
                    let H, X = this["stroke-width"];
                    if (X === "inherit" && (X = 1),
                    N = N && N.toLowerCase()) {
                        let ie = N.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
                        for (H = ie.length; H--; )
                            ie[H] = "" + b(ie[H]) * w(X, NaN);
                        N = ie.join(",").replace(/NaN/g, "none"),
                        this.element.setAttribute("stroke-dasharray", N)
                    }
                }
                destroy() {
                    var G;
                    let N = this, H = N.element || {}, X = N.renderer, ie = H.ownerSVGElement, K = H.nodeName === "SPAN" && N.parentGroup || void 0, D, V;
                    if (H.onclick = H.onmouseout = H.onmouseover = H.onmousemove = H.point = null,
                    u(N),
                    N.clipPath && ie) {
                        let ee = N.clipPath;
                        [].forEach.call(ie.querySelectorAll("[clip-path],[CLIP-PATH]"), function(J) {
                            J.getAttribute("clip-path").indexOf(ee.element.id) > -1 && J.removeAttribute("clip-path")
                        }),
                        N.clipPath = ee.destroy()
                    }
                    if (N.connector = (G = N.connector) == null ? void 0 : G.destroy(),
                    N.stops) {
                        for (V = 0; V < N.stops.length; V++)
                            N.stops[V].destroy();
                        N.stops.length = 0,
                        N.stops = void 0
                    }
                    for (N.safeRemoveChild(H); K && K.div && K.div.childNodes.length === 0; )
                        D = K.parentGroup,
                        N.safeRemoveChild(K.div),
                        delete K.div,
                        K = D;
                    N.alignTo && O(X.alignedObjects, N),
                    k(N, function(ee, J) {
                        N[J] && N[J].parentGroup === N && N[J].destroy && N[J].destroy(),
                        delete N[J]
                    })
                }
                dSetter(N, H, X) {
                    P(N) && (typeof N[0] == "string" && (N = this.renderer.pathToSegments(N)),
                    this.pathArray = N,
                    N = N.reduce((ie,K,D)=>K && K.join ? (D ? ie + " " : "") + K.join(" ") : (K || "").toString(), "")),
                    /(NaN| {2}|^$)/.test(N) && (N = "M 0 0"),
                    this[H] !== N && (X.setAttribute(H, N),
                    this[H] = N)
                }
                fillSetter(N, H, X) {
                    typeof N == "string" ? X.setAttribute(H, N) : N && this.complexColor(N, H, X)
                }
                hrefSetter(N, H, X) {
                    X.setAttributeNS("http://www.w3.org/1999/xlink", H, N)
                }
                getBBox(N, H) {
                    let X, ie, K, D, V, {alignValue: G, element: ee, renderer: J, styles: te, textStr: z} = this, {cache: Y, cacheKeys: U} = J, Z = ee.namespaceURI === this.SVG_NS, $ = w(H, this.rotation, 0), ne = J.styledMode ? ee && B.prototype.getStyle.call(ee, "font-size") : te && te.fontSize;
                    if (E(z) && ((V = z.toString()).indexOf("<") === -1 && (V = V.replace(/[0-9]/g, "0")),
                    V += ["", J.rootFontSize, ne, $, this.textWidth, G, te && te.textOverflow, te && te.fontWeight].join(",")),
                    V && !N && (X = Y[V]),
                    !X) {
                        if (Z || J.forExport) {
                            try {
                                D = this.fakeTS && function(oe) {
                                    let se = ee.querySelector(".highcharts-text-outline");
                                    se && C(se, {
                                        display: oe
                                    })
                                }
                                ,
                                _(D) && D("none"),
                                X = ee.getBBox ? R({}, ee.getBBox()) : {
                                    width: ee.offsetWidth,
                                    height: ee.offsetHeight,
                                    x: 0,
                                    y: 0
                                },
                                _(D) && D("")
                            } catch {}
                            (!X || X.width < 0) && (X = {
                                x: 0,
                                y: 0,
                                width: 0,
                                height: 0
                            })
                        } else
                            X = this.htmlGetBBox();
                        if (ie = X.width,
                        K = X.height,
                        Z && (X.height = K = {
                            "11px,17": 14,
                            "13px,20": 16
                        }[`${ne || ""},${Math.round(K)}`] || K),
                        $) {
                            let oe = Number(ee.getAttribute("y") || 0) - X.y
                              , se = {
                                right: 1,
                                center: .5
                            }[G || 0] || 0
                              , le = $ * h
                              , he = ($ - 90) * h
                              , Q = ie * Math.cos(le)
                              , q = ie * Math.sin(le)
                              , ae = Math.cos(he)
                              , re = Math.sin(he)
                              , ce = X.x + se * (ie - Q)
                              , ue = X.y + oe - se * q
                              , fe = ce + oe * ae
                              , de = fe + Q
                              , ge = de - K * ae
                              , ye = ge - Q
                              , pe = ue + oe * re
                              , xe = pe + q
                              , ke = xe - K * re
                              , Ee = ke - q;
                            X.x = Math.min(fe, de, ge, ye),
                            X.y = Math.min(pe, xe, ke, Ee),
                            X.width = Math.max(fe, de, ge, ye) - X.x,
                            X.height = Math.max(pe, xe, ke, Ee) - X.y
                        }
                    }
                    if (V && (z === "" || X.height > 0)) {
                        for (; U.length > 250; )
                            delete Y[U.shift()];
                        Y[V] || U.push(V),
                        Y[V] = X
                    }
                    return X
                }
                getStyle(N) {
                    return S.getComputedStyle(this.element || this, "").getPropertyValue(N)
                }
                hasClass(N) {
                    return ("" + this.attr("class")).split(" ").indexOf(N) !== -1
                }
                hide() {
                    return this.attr({
                        visibility: "hidden"
                    })
                }
                htmlGetBBox() {
                    return {
                        height: 0,
                        width: 0,
                        x: 0,
                        y: 0
                    }
                }
                init(N, H) {
                    this.element = H === "span" ? g(H) : d.createElementNS(this.SVG_NS, H),
                    this.renderer = N,
                    F(this, "afterInit")
                }
                on(N, H) {
                    let {onEvents: X} = this;
                    return X[N] && X[N](),
                    X[N] = v(this.element, N, H),
                    this
                }
                opacitySetter(N, H, X) {
                    let ie = Number(Number(N).toFixed(3));
                    this.opacity = ie,
                    X.setAttribute(H, ie)
                }
                removeClass(N) {
                    return this.attr("class", ("" + this.attr("class")).replace(L(N) ? RegExp(`(^| )${N}( |$)`) : N, " ").replace(/ +/g, " ").trim())
                }
                removeTextOutline() {
                    let N = this.element.querySelector("tspan.highcharts-text-outline");
                    N && this.safeRemoveChild(N)
                }
                safeRemoveChild(N) {
                    let H = N.parentNode;
                    H && H.removeChild(N)
                }
                setRadialReference(N) {
                    let H = this.element.gradient && this.renderer.gradients[this.element.gradient];
                    return this.element.radialReference = N,
                    H && H.radAttr && H.animate(this.renderer.getRadialAttr(N, H.radAttr)),
                    this
                }
                setTextPath(N, H) {
                    H = I(!0, {
                        enabled: !0,
                        attributes: {
                            dy: -5,
                            startOffset: "50%",
                            textAnchor: "middle"
                        }
                    }, H);
                    let X = this.renderer.url
                      , ie = this.text || this
                      , K = ie.textPath
                      , {attributes: D, enabled: V} = H;
                    if (N = N || K && K.path,
                    K && K.undo(),
                    N && V) {
                        let G = v(ie, "afterModifyTree", ee=>{
                            if (N && V) {
                                let J = N.attr("id");
                                J || N.attr("id", J = j());
                                let te = {
                                    x: 0,
                                    y: 0
                                };
                                E(D.dx) && (te.dx = D.dx,
                                delete D.dx),
                                E(D.dy) && (te.dy = D.dy,
                                delete D.dy),
                                ie.attr(te),
                                this.attr({
                                    transform: ""
                                }),
                                this.box && (this.box = this.box.destroy());
                                let z = ee.nodes.slice(0);
                                ee.nodes.length = 0,
                                ee.nodes[0] = {
                                    tagName: "textPath",
                                    attributes: R(D, {
                                        "text-anchor": D.textAnchor,
                                        href: `${X}#${J}`
                                    }),
                                    children: z
                                }
                            }
                        }
                        );
                        ie.textPath = {
                            path: N,
                            undo: G
                        }
                    } else
                        ie.attr({
                            dx: 0,
                            dy: 0
                        }),
                        delete ie.textPath;
                    return this.added && (ie.textCache = "",
                    this.renderer.buildText(ie)),
                    this
                }
                shadow(N) {
                    var K;
                    let {renderer: H} = this
                      , X = I(((K = this.parentGroup) == null ? void 0 : K.rotation) === 90 ? {
                        offsetX: -1,
                        offsetY: -1
                    } : {}, T(N) ? N : {})
                      , ie = H.shadowDefinition(X);
                    return this.attr({
                        filter: N ? `url(${H.url}#${ie})` : "none"
                    })
                }
                show(N=!0) {
                    return this.attr({
                        visibility: N ? "inherit" : "visible"
                    })
                }
                "stroke-widthSetter"(N, H, X) {
                    this[H] = N,
                    X.setAttribute(H, N)
                }
                strokeWidth() {
                    if (!this.renderer.styledMode)
                        return this["stroke-width"] || 0;
                    let N = this.getStyle("stroke-width"), H = 0, X;
                    return N.indexOf("px") === N.length - 2 ? H = b(N) : N !== "" && (p(X = d.createElementNS(x, "rect"), {
                        width: N,
                        "stroke-width": 0
                    }),
                    this.element.parentNode.appendChild(X),
                    H = X.getBBox().width,
                    X.parentNode.removeChild(X)),
                    H
                }
                symbolAttr(N) {
                    let H = this;
                    B.symbolCustomAttribs.forEach(function(X) {
                        H[X] = w(N[X], H[X])
                    }),
                    H.attr({
                        d: H.renderer.symbols[H.symbolName](H.x, H.y, H.width, H.height, H)
                    })
                }
                textSetter(N) {
                    N !== this.textStr && (delete this.textPxLength,
                    this.textStr = N,
                    this.added && this.renderer.buildText(this))
                }
                titleSetter(N) {
                    let H = this.element
                      , X = H.getElementsByTagName("title")[0] || d.createElementNS(this.SVG_NS, "title");
                    H.insertBefore ? H.insertBefore(X, H.firstChild) : H.appendChild(X),
                    X.textContent = String(w(N, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">")
                }
                toFront() {
                    let N = this.element;
                    return N.parentNode.appendChild(N),
                    this
                }
                translate(N, H) {
                    return this.attr({
                        translateX: N,
                        translateY: H
                    })
                }
                updateTransform() {
                    let {element: N, matrix: H, rotation: X=0, scaleX: ie, scaleY: K, translateX: D=0, translateY: V=0} = this
                      , G = ["translate(" + D + "," + V + ")"];
                    E(H) && G.push("matrix(" + H.join(",") + ")"),
                    X && G.push("rotate(" + X + " " + w(this.rotationOriginX, N.getAttribute("x"), 0) + " " + w(this.rotationOriginY, N.getAttribute("y") || 0) + ")"),
                    (E(ie) || E(K)) && G.push("scale(" + w(ie, 1) + " " + w(K, 1) + ")"),
                    G.length && !(this.text || this).textPath && N.setAttribute("transform", G.join(" "))
                }
                visibilitySetter(N, H, X) {
                    N === "inherit" ? X.removeAttribute(H) : this[H] !== N && X.setAttribute(H, N),
                    this[H] = N
                }
                xGetter(N) {
                    return this.element.nodeName === "circle" && (N === "x" ? N = "cx" : N === "y" && (N = "cy")),
                    this._defaultGetter(N)
                }
                zIndexSetter(N, H) {
                    let X = this.renderer, ie = this.parentGroup, K = ie || X, D = K.element || X.box, V = this.element, G = D === X.box, ee, J, te, z = !1, Y, U = this.added, Z;
                    if (E(N) ? (V.setAttribute("data-z-index", N),
                    N = +N,
                    this[H] === N && (U = !1)) : E(this[H]) && V.removeAttribute("data-z-index"),
                    this[H] = N,
                    U) {
                        for ((N = this.zIndex) && ie && (ie.handleZ = !0),
                        Z = (ee = D.childNodes).length - 1; Z >= 0 && !z; Z--)
                            Y = !E(te = (J = ee[Z]).getAttribute("data-z-index")),
                            J !== V && (N < 0 && Y && !G && !Z ? (D.insertBefore(V, ee[Z]),
                            z = !0) : (b(te) <= N || Y && (!E(N) || N >= 0)) && (D.insertBefore(V, ee[Z + 1]),
                            z = !0));
                        z || (D.insertBefore(V, ee[G ? 3 : 0]),
                        z = !0)
                    }
                    return z
                }
            }
            return B.symbolCustomAttribs = ["anchorX", "anchorY", "clockwise", "end", "height", "innerR", "r", "start", "width", "x", "y"],
            B.prototype.strokeSetter = B.prototype.fillSetter,
            B.prototype.yGetter = B.prototype.xGetter,
            B.prototype.matrixSetter = B.prototype.rotationOriginXSetter = B.prototype.rotationOriginYSetter = B.prototype.rotationSetter = B.prototype.scaleXSetter = B.prototype.scaleYSetter = B.prototype.translateXSetter = B.prototype.translateYSetter = B.prototype.verticalAlignSetter = function(W, N) {
                this[N] = W,
                this.doTransform = !0
            }
            ,
            B
        }),
        i(n, "Core/Renderer/RendererRegistry.js", [n["Core/Globals.js"]], function(r) {
            var s, o;
            let a;
            return (o = s || (s = {})).rendererTypes = {},
            o.getRendererType = function(l=a) {
                return o.rendererTypes[l] || o.rendererTypes[a]
            }
            ,
            o.registerRendererType = function(l, c, u) {
                o.rendererTypes[l] = c,
                (!a || u) && (a = l,
                r.Renderer = c)
            }
            ,
            s
        }),
        i(n, "Core/Renderer/SVG/SVGLabel.js", [n["Core/Renderer/SVG/SVGElement.js"], n["Core/Utilities.js"]], function(r, s) {
            let {defined: o, extend: a, isNumber: l, merge: c, pick: u, removeEvent: h} = s;
            class d extends r {
                constructor(f, x, S, v, p, g, C, E, O, R) {
                    let F;
                    super(),
                    this.paddingLeftSetter = this.paddingSetter,
                    this.paddingRightSetter = this.paddingSetter,
                    this.init(f, "g"),
                    this.textStr = x,
                    this.x = S,
                    this.y = v,
                    this.anchorX = g,
                    this.anchorY = C,
                    this.baseline = O,
                    this.className = R,
                    this.addClass(R === "button" ? "highcharts-no-tooltip" : "highcharts-label"),
                    R && this.addClass("highcharts-" + R),
                    this.text = f.text(void 0, 0, 0, E).attr({
                        zIndex: 1
                    }),
                    typeof p == "string" && ((F = /^url\((.*?)\)$/.test(p)) || this.renderer.symbols[p]) && (this.symbolKey = p),
                    this.bBox = d.emptyBBox,
                    this.padding = 3,
                    this.baselineOffset = 0,
                    this.needsBox = f.styledMode || F,
                    this.deferredAttr = {},
                    this.alignFactor = 0
                }
                alignSetter(f) {
                    let x = {
                        left: 0,
                        center: .5,
                        right: 1
                    }[f];
                    x !== this.alignFactor && (this.alignFactor = x,
                    this.bBox && l(this.xSetting) && this.attr({
                        x: this.xSetting
                    }))
                }
                anchorXSetter(f, x) {
                    this.anchorX = f,
                    this.boxAttr(x, Math.round(f) - this.getCrispAdjust() - this.xSetting)
                }
                anchorYSetter(f, x) {
                    this.anchorY = f,
                    this.boxAttr(x, f - this.ySetting)
                }
                boxAttr(f, x) {
                    this.box ? this.box.attr(f, x) : this.deferredAttr[f] = x
                }
                css(f) {
                    if (f) {
                        let x = {};
                        f = c(f),
                        d.textProps.forEach(S=>{
                            f[S] !== void 0 && (x[S] = f[S],
                            delete f[S])
                        }
                        ),
                        this.text.css(x),
                        "fontSize"in x || "fontWeight"in x ? this.updateTextPadding() : ("width"in x || "textOverflow"in x) && this.updateBoxSize()
                    }
                    return r.prototype.css.call(this, f)
                }
                destroy() {
                    h(this.element, "mouseenter"),
                    h(this.element, "mouseleave"),
                    this.text && this.text.destroy(),
                    this.box && (this.box = this.box.destroy()),
                    r.prototype.destroy.call(this)
                }
                fillSetter(f, x) {
                    f && (this.needsBox = !0),
                    this.fill = f,
                    this.boxAttr(x, f)
                }
                getBBox() {
                    this.textStr && this.bBox.width === 0 && this.bBox.height === 0 && this.updateBoxSize();
                    let f = this.padding
                      , x = u(this.paddingLeft, f);
                    return {
                        width: this.width || 0,
                        height: this.height || 0,
                        x: this.bBox.x - x,
                        y: this.bBox.y - f
                    }
                }
                getCrispAdjust() {
                    return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2
                }
                heightSetter(f) {
                    this.heightSetting = f
                }
                onAdd() {
                    this.text.add(this),
                    this.attr({
                        text: u(this.textStr, ""),
                        x: this.x || 0,
                        y: this.y || 0
                    }),
                    this.box && o(this.anchorX) && this.attr({
                        anchorX: this.anchorX,
                        anchorY: this.anchorY
                    })
                }
                paddingSetter(f, x) {
                    l(f) ? f !== this[x] && (this[x] = f,
                    this.updateTextPadding()) : this[x] = void 0
                }
                rSetter(f, x) {
                    this.boxAttr(x, f)
                }
                strokeSetter(f, x) {
                    this.stroke = f,
                    this.boxAttr(x, f)
                }
                "stroke-widthSetter"(f, x) {
                    f && (this.needsBox = !0),
                    this["stroke-width"] = f,
                    this.boxAttr(x, f)
                }
                "text-alignSetter"(f) {
                    this.textAlign = f
                }
                textSetter(f) {
                    f !== void 0 && this.text.attr({
                        text: f
                    }),
                    this.updateTextPadding()
                }
                updateBoxSize() {
                    let f, x = this.text, S = {}, v = this.padding, p = this.bBox = (!l(this.widthSetting) || !l(this.heightSetting) || this.textAlign) && o(x.textStr) ? x.getBBox() : d.emptyBBox;
                    this.width = this.getPaddedWidth(),
                    this.height = (this.heightSetting || p.height || 0) + 2 * v;
                    let g = this.renderer.fontMetrics(x);
                    if (this.baselineOffset = v + Math.min((this.text.firstLineMetrics || g).b, p.height || 1 / 0),
                    this.heightSetting && (this.baselineOffset += (this.heightSetting - g.h) / 2),
                    this.needsBox && !x.textPath) {
                        if (!this.box) {
                            let C = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
                            C.addClass((this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")),
                            C.add(this)
                        }
                        f = this.getCrispAdjust(),
                        S.x = f,
                        S.y = (this.baseline ? -this.baselineOffset : 0) + f,
                        S.width = Math.round(this.width),
                        S.height = Math.round(this.height),
                        this.box.attr(a(S, this.deferredAttr)),
                        this.deferredAttr = {}
                    }
                }
                updateTextPadding() {
                    let f = this.text;
                    if (!f.textPath) {
                        this.updateBoxSize();
                        let x = this.baseline ? 0 : this.baselineOffset
                          , S = u(this.paddingLeft, this.padding);
                        o(this.widthSetting) && this.bBox && (this.textAlign === "center" || this.textAlign === "right") && (S += {
                            center: .5,
                            right: 1
                        }[this.textAlign] * (this.widthSetting - this.bBox.width)),
                        (S !== f.x || x !== f.y) && (f.attr("x", S),
                        f.hasBoxWidthChanged && (this.bBox = f.getBBox(!0)),
                        x !== void 0 && f.attr("y", x)),
                        f.x = S,
                        f.y = x
                    }
                }
                widthSetter(f) {
                    this.widthSetting = l(f) ? f : void 0
                }
                getPaddedWidth() {
                    let f = this.padding
                      , x = u(this.paddingLeft, f)
                      , S = u(this.paddingRight, f);
                    return (this.widthSetting || this.bBox.width || 0) + x + S
                }
                xSetter(f) {
                    this.x = f,
                    this.alignFactor && (f -= this.alignFactor * this.getPaddedWidth(),
                    this["forceAnimate:x"] = !0),
                    this.xSetting = Math.round(f),
                    this.attr("translateX", this.xSetting)
                }
                ySetter(f) {
                    this.ySetting = this.y = Math.round(f),
                    this.attr("translateY", this.ySetting)
                }
            }
            return d.emptyBBox = {
                width: 0,
                height: 0,
                x: 0,
                y: 0
            },
            d.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"],
            d
        }),
        i(n, "Core/Renderer/SVG/Symbols.js", [n["Core/Utilities.js"]], function(r) {
            let {defined: s, isNumber: o, pick: a} = r;
            function l(h, d, m, f, x) {
                let S = [];
                if (x) {
                    let v = x.start || 0
                      , p = a(x.r, m)
                      , g = a(x.r, f || m)
                      , C = .001 > Math.abs((x.end || 0) - v - 2 * Math.PI)
                      , E = (x.end || 0) - .001
                      , O = x.innerR
                      , R = a(x.open, C)
                      , F = Math.cos(v)
                      , P = Math.sin(v)
                      , _ = Math.cos(E)
                      , T = Math.sin(E)
                      , L = a(x.longArc, E - v - Math.PI < .001 ? 0 : 1)
                      , I = ["A", p, g, 0, L, a(x.clockwise, 1), h + p * _, d + g * T];
                    I.params = {
                        start: v,
                        end: E,
                        cx: h,
                        cy: d
                    },
                    S.push(["M", h + p * F, d + g * P], I),
                    s(O) && ((I = ["A", O, O, 0, L, s(x.clockwise) ? 1 - x.clockwise : 0, h + O * F, d + O * P]).params = {
                        start: E,
                        end: v,
                        cx: h,
                        cy: d
                    },
                    S.push(R ? ["M", h + O * _, d + O * T] : ["L", h + O * _, d + O * T], I)),
                    R || S.push(["Z"])
                }
                return S
            }
            function c(h, d, m, f, x) {
                return x && x.r ? u(h, d, m, f, x) : [["M", h, d], ["L", h + m, d], ["L", h + m, d + f], ["L", h, d + f], ["Z"]]
            }
            function u(h, d, m, f, x) {
                let S = (x == null ? void 0 : x.r) || 0;
                return [["M", h + S, d], ["L", h + m - S, d], ["A", S, S, 0, 0, 1, h + m, d + S], ["L", h + m, d + f - S], ["A", S, S, 0, 0, 1, h + m - S, d + f], ["L", h + S, d + f], ["A", S, S, 0, 0, 1, h, d + f - S], ["L", h, d + S], ["A", S, S, 0, 0, 1, h + S, d], ["Z"]]
            }
            return {
                arc: l,
                callout: function(h, d, m, f, x) {
                    let S = Math.min(x && x.r || 0, m, f)
                      , v = S + 6
                      , p = x && x.anchorX
                      , g = x && x.anchorY || 0
                      , C = u(h, d, m, f, {
                        r: S
                    });
                    if (!o(p) || p < m && p > 0 && g < f && g > 0)
                        return C;
                    if (h + p > m - v)
                        if (g > d + v && g < d + f - v)
                            C.splice(3, 1, ["L", h + m, g - 6], ["L", h + m + 6, g], ["L", h + m, g + 6], ["L", h + m, d + f - S]);
                        else if (p < m) {
                            let E = g < d + v
                              , O = E ? d : d + f;
                            C.splice(E ? 2 : 5, 0, ["L", p, g], ["L", h + m - S, O])
                        } else
                            C.splice(3, 1, ["L", h + m, f / 2], ["L", p, g], ["L", h + m, f / 2], ["L", h + m, d + f - S]);
                    else if (h + p < v)
                        if (g > d + v && g < d + f - v)
                            C.splice(7, 1, ["L", h, g + 6], ["L", h - 6, g], ["L", h, g - 6], ["L", h, d + S]);
                        else if (p > 0) {
                            let E = g < d + v
                              , O = E ? d : d + f;
                            C.splice(E ? 1 : 6, 0, ["L", p, g], ["L", h + S, O])
                        } else
                            C.splice(7, 1, ["L", h, f / 2], ["L", p, g], ["L", h, f / 2], ["L", h, d + S]);
                    else
                        g > f && p < m - v ? C.splice(5, 1, ["L", p + 6, d + f], ["L", p, d + f + 6], ["L", p - 6, d + f], ["L", h + S, d + f]) : g < 0 && p > v && C.splice(1, 1, ["L", p - 6, d], ["L", p, d - 6], ["L", p + 6, d], ["L", m - S, d]);
                    return C
                },
                circle: function(h, d, m, f) {
                    return l(h + m / 2, d + f / 2, m / 2, f / 2, {
                        start: .5 * Math.PI,
                        end: 2.5 * Math.PI,
                        open: !1
                    })
                },
                diamond: function(h, d, m, f) {
                    return [["M", h + m / 2, d], ["L", h + m, d + f / 2], ["L", h + m / 2, d + f], ["L", h, d + f / 2], ["Z"]]
                },
                rect: c,
                roundedRect: u,
                square: c,
                triangle: function(h, d, m, f) {
                    return [["M", h + m / 2, d], ["L", h + m, d + f], ["L", h, d + f], ["Z"]]
                },
                "triangle-down": function(h, d, m, f) {
                    return [["M", h, d], ["L", h + m, d], ["L", h + m / 2, d + f], ["Z"]]
                }
            }
        }),
        i(n, "Core/Renderer/SVG/TextBuilder.js", [n["Core/Renderer/HTML/AST.js"], n["Core/Globals.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {doc: a, SVG_NS: l, win: c} = s
              , {attr: u, extend: h, fireEvent: d, isString: m, objectEach: f, pick: x} = o;
            return class {
                constructor(S) {
                    let v = S.styles;
                    this.renderer = S.renderer,
                    this.svgElement = S,
                    this.width = S.textWidth,
                    this.textLineHeight = v && v.lineHeight,
                    this.textOutline = v && v.textOutline,
                    this.ellipsis = !!(v && v.textOverflow === "ellipsis"),
                    this.noWrap = !!(v && v.whiteSpace === "nowrap")
                }
                buildSVG() {
                    let S = this.svgElement
                      , v = S.element
                      , p = S.renderer
                      , g = x(S.textStr, "").toString()
                      , C = g.indexOf("<") !== -1
                      , E = v.childNodes
                      , O = !S.added && p.box
                      , R = [g, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, S.getStyle("font-size"), this.width].join(",");
                    if (R !== S.textCache) {
                        S.textCache = R,
                        delete S.actualWidth;
                        for (let F = E.length; F--; )
                            v.removeChild(E[F]);
                        if (C || this.ellipsis || this.width || S.textPath || g.indexOf(" ") !== -1 && (!this.noWrap || /<br.*?>/g.test(g))) {
                            if (g !== "") {
                                O && O.appendChild(v);
                                let F = new r(g);
                                this.modifyTree(F.nodes),
                                F.addToDOM(v),
                                this.modifyDOM(),
                                this.ellipsis && (v.textContent || "").indexOf("…") !== -1 && S.attr("title", this.unescapeEntities(S.textStr || "", ["&lt;", "&gt;"])),
                                O && O.removeChild(v)
                            }
                        } else
                            v.appendChild(a.createTextNode(this.unescapeEntities(g)));
                        m(this.textOutline) && S.applyTextOutline && S.applyTextOutline(this.textOutline)
                    }
                }
                modifyDOM() {
                    let S, v = this.svgElement, p = u(v.element, "x");
                    for (v.firstLineMetrics = void 0; (S = v.element.firstChild) && /^[\s\u200B]*$/.test(S.textContent || " "); )
                        v.element.removeChild(S);
                    [].forEach.call(v.element.querySelectorAll("tspan.highcharts-br"), (O,R)=>{
                        O.nextSibling && O.previousSibling && (R === 0 && O.previousSibling.nodeType === 1 && (v.firstLineMetrics = v.renderer.fontMetrics(O.previousSibling)),
                        u(O, {
                            dy: this.getLineHeight(O.nextSibling),
                            x: p
                        }))
                    }
                    );
                    let g = this.width || 0;
                    if (!g)
                        return;
                    let C = (O,R)=>{
                        let F = O.textContent || ""
                          , P = F.replace(/([^\^])-/g, "$1- ").split(" ")
                          , _ = !this.noWrap && (P.length > 1 || v.element.childNodes.length > 1)
                          , T = this.getLineHeight(R)
                          , L = 0
                          , I = v.actualWidth;
                        if (this.ellipsis)
                            F && this.truncate(O, F, void 0, 0, Math.max(0, g - .8 * T), (k,w)=>k.substring(0, w) + "…");
                        else if (_) {
                            let k = []
                              , w = [];
                            for (; R.firstChild && R.firstChild !== O; )
                                w.push(R.firstChild),
                                R.removeChild(R.firstChild);
                            for (; P.length; )
                                P.length && !this.noWrap && L > 0 && (k.push(O.textContent || ""),
                                O.textContent = P.join(" ").replace(/- /g, "-")),
                                this.truncate(O, void 0, P, L === 0 && I || 0, g, (b,A)=>P.slice(0, A).join(" ").replace(/- /g, "-")),
                                I = v.actualWidth,
                                L++;
                            w.forEach(b=>{
                                R.insertBefore(b, O)
                            }
                            ),
                            k.forEach(b=>{
                                R.insertBefore(a.createTextNode(b), O);
                                let A = a.createElementNS(l, "tspan");
                                A.textContent = "​",
                                u(A, {
                                    dy: T,
                                    x: p
                                }),
                                R.insertBefore(A, O)
                            }
                            )
                        }
                    }
                      , E = O=>{
                        [].slice.call(O.childNodes).forEach(F=>{
                            F.nodeType === c.Node.TEXT_NODE ? C(F, O) : (F.className.baseVal.indexOf("highcharts-br") !== -1 && (v.actualWidth = 0),
                            E(F))
                        }
                        )
                    }
                    ;
                    E(v.element)
                }
                getLineHeight(S) {
                    let v = S.nodeType === c.Node.TEXT_NODE ? S.parentElement : S;
                    return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(v || this.svgElement.element).h
                }
                modifyTree(S) {
                    let v = (p,g)=>{
                        let {attributes: C={}, children: E, style: O={}, tagName: R} = p
                          , F = this.renderer.styledMode;
                        if (R === "b" || R === "strong" ? F ? C.class = "highcharts-strong" : O.fontWeight = "bold" : (R === "i" || R === "em") && (F ? C.class = "highcharts-emphasized" : O.fontStyle = "italic"),
                        O && O.color && (O.fill = O.color),
                        R === "br") {
                            C.class = "highcharts-br",
                            p.textContent = "​";
                            let P = S[g + 1];
                            P && P.textContent && (P.textContent = P.textContent.replace(/^ +/gm, ""))
                        } else
                            R === "a" && E && E.some(P=>P.tagName === "#text") && (p.children = [{
                                children: E,
                                tagName: "tspan"
                            }]);
                        R !== "#text" && R !== "a" && (p.tagName = "tspan"),
                        h(p, {
                            attributes: C,
                            style: O
                        }),
                        E && E.filter(P=>P.tagName !== "#text").forEach(v)
                    }
                    ;
                    S.forEach(v),
                    d(this.svgElement, "afterModifyTree", {
                        nodes: S
                    })
                }
                truncate(S, v, p, g, C, E) {
                    let O, R, F = this.svgElement, {renderer: P, rotation: _} = F, T = [], L = p ? 1 : 0, I = (v || p || "").length, k = I, w = function(b, A) {
                        let j = A || b
                          , B = S.parentNode;
                        if (B && T[j] === void 0 && B.getSubStringLength)
                            try {
                                T[j] = g + B.getSubStringLength(0, p ? j + 1 : j)
                            } catch {}
                        return T[j]
                    };
                    if (F.rotation = 0,
                    g + (R = w(S.textContent.length)) > C) {
                        for (; L <= I; )
                            k = Math.ceil((L + I) / 2),
                            p && (O = E(p, k)),
                            R = w(k, O && O.length - 1),
                            L === I ? L = I + 1 : R > C ? I = k - 1 : L = k;
                        I === 0 ? S.textContent = "" : v && I === v.length - 1 || (S.textContent = O || E(v || p, k))
                    }
                    p && p.splice(0, k),
                    F.actualWidth = R,
                    F.rotation = _
                }
                unescapeEntities(S, v) {
                    return f(this.renderer.escapes, function(p, g) {
                        v && v.indexOf(p) !== -1 || (S = S.toString().replace(RegExp(p, "g"), g))
                    }),
                    S
                }
            }
        }),
        i(n, "Core/Renderer/SVG/SVGRenderer.js", [n["Core/Renderer/HTML/AST.js"], n["Core/Color/Color.js"], n["Core/Globals.js"], n["Core/Renderer/RendererRegistry.js"], n["Core/Renderer/SVG/SVGElement.js"], n["Core/Renderer/SVG/SVGLabel.js"], n["Core/Renderer/SVG/Symbols.js"], n["Core/Renderer/SVG/TextBuilder.js"], n["Core/Utilities.js"]], function(r, s, o, a, l, c, u, h, d) {
            let m, {charts: f, deg2rad: x, doc: S, isFirefox: v, isMS: p, isWebKit: g, noop: C, SVG_NS: E, symbolSizes: O, win: R} = o, {addEvent: F, attr: P, createElement: _, css: T, defined: L, destroyObjectProperties: I, extend: k, isArray: w, isNumber: b, isObject: A, isString: j, merge: B, pick: W, pInt: N, uniqueKey: H} = d;
            class X {
                constructor(K, D, V, G, ee, J, te) {
                    this.alignedObjects = void 0,
                    this.box = void 0,
                    this.boxWrapper = void 0,
                    this.cache = void 0,
                    this.cacheKeys = void 0,
                    this.chartIndex = void 0,
                    this.defs = void 0,
                    this.globalAnimation = void 0,
                    this.gradients = void 0,
                    this.height = void 0,
                    this.imgCount = void 0,
                    this.style = void 0,
                    this.url = void 0,
                    this.width = void 0,
                    this.init(K, D, V, G, ee, J, te)
                }
                init(K, D, V, G, ee, J, te) {
                    let z, Y, U = this.createElement("svg").attr({
                        version: "1.1",
                        class: "highcharts-root"
                    }), Z = U.element;
                    te || U.css(this.getStyle(G)),
                    K.appendChild(Z),
                    P(K, "dir", "ltr"),
                    K.innerHTML.indexOf("xmlns") === -1 && P(Z, "xmlns", this.SVG_NS),
                    this.box = Z,
                    this.boxWrapper = U,
                    this.alignedObjects = [],
                    this.url = this.getReferenceURL(),
                    this.createElement("desc").add().element.appendChild(S.createTextNode("Created with Highcharts 11.2.0")),
                    this.defs = this.createElement("defs").add(),
                    this.allowHTML = J,
                    this.forExport = ee,
                    this.styledMode = te,
                    this.gradients = {},
                    this.cache = {},
                    this.cacheKeys = [],
                    this.imgCount = 0,
                    this.rootFontSize = U.getStyle("font-size"),
                    this.setSize(D, V, !1),
                    v && K.getBoundingClientRect && ((z = function() {
                        T(K, {
                            left: 0,
                            top: 0
                        }),
                        Y = K.getBoundingClientRect(),
                        T(K, {
                            left: Math.ceil(Y.left) - Y.left + "px",
                            top: Math.ceil(Y.top) - Y.top + "px"
                        })
                    }
                    )(),
                    this.unSubPixelFix = F(R, "resize", z))
                }
                definition(K) {
                    return new r([K]).addToDOM(this.defs.element)
                }
                getReferenceURL() {
                    if ((v || g) && S.getElementsByTagName("base").length) {
                        if (!L(m)) {
                            let K = H()
                              , D = new r([{
                                tagName: "svg",
                                attributes: {
                                    width: 8,
                                    height: 8
                                },
                                children: [{
                                    tagName: "defs",
                                    children: [{
                                        tagName: "clipPath",
                                        attributes: {
                                            id: K
                                        },
                                        children: [{
                                            tagName: "rect",
                                            attributes: {
                                                width: 4,
                                                height: 4
                                            }
                                        }]
                                    }]
                                }, {
                                    tagName: "rect",
                                    attributes: {
                                        id: "hitme",
                                        width: 8,
                                        height: 8,
                                        "clip-path": `url(#${K})`,
                                        fill: "rgba(0,0,0,0.001)"
                                    }
                                }]
                            }])
                              , V = D.addToDOM(S.body);
                            T(V, {
                                position: "fixed",
                                top: 0,
                                left: 0,
                                zIndex: 9e5
                            });
                            let G = S.elementFromPoint(6, 6);
                            m = (G && G.id) === "hitme",
                            S.body.removeChild(V)
                        }
                        if (m)
                            return R.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20")
                    }
                    return ""
                }
                getStyle(K) {
                    return this.style = k({
                        fontFamily: "Helvetica, Arial, sans-serif",
                        fontSize: "1rem"
                    }, K),
                    this.style
                }
                setStyle(K) {
                    this.boxWrapper.css(this.getStyle(K))
                }
                isHidden() {
                    return !this.boxWrapper.getBBox().width
                }
                destroy() {
                    let K = this.defs;
                    return this.box = null,
                    this.boxWrapper = this.boxWrapper.destroy(),
                    I(this.gradients || {}),
                    this.gradients = null,
                    this.defs = K.destroy(),
                    this.unSubPixelFix && this.unSubPixelFix(),
                    this.alignedObjects = null,
                    null
                }
                createElement(K) {
                    let D = new this.Element;
                    return D.init(this, K),
                    D
                }
                getRadialAttr(K, D) {
                    return {
                        cx: K[0] - K[2] / 2 + (D.cx || 0) * K[2],
                        cy: K[1] - K[2] / 2 + (D.cy || 0) * K[2],
                        r: (D.r || 0) * K[2]
                    }
                }
                shadowDefinition(K) {
                    let D = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(K).map(G=>`${G}-${K[G]}`)].join("-").toLowerCase().replace(/[^a-z0-9\-]/g, "")
                      , V = B({
                        color: "#000000",
                        offsetX: 1,
                        offsetY: 1,
                        opacity: .15,
                        width: 5
                    }, K);
                    return this.defs.element.querySelector(`#${D}`) || this.definition({
                        tagName: "filter",
                        attributes: {
                            id: D,
                            filterUnits: V.filterUnits
                        },
                        children: [{
                            tagName: "feDropShadow",
                            attributes: {
                                dx: V.offsetX,
                                dy: V.offsetY,
                                "flood-color": V.color,
                                "flood-opacity": Math.min(5 * V.opacity, 1),
                                stdDeviation: V.width / 2
                            }
                        }]
                    }),
                    D
                }
                buildText(K) {
                    new h(K).buildSVG()
                }
                getContrast(K) {
                    let D = s.parse(K).rgba.map(G=>{
                        let ee = G / 255;
                        return ee <= .03928 ? ee / 12.92 : Math.pow((ee + .055) / 1.055, 2.4)
                    }
                    )
                      , V = .2126 * D[0] + .7152 * D[1] + .0722 * D[2];
                    return 1.05 / (V + .05) > (V + .05) / .05 ? "#FFFFFF" : "#000000"
                }
                button(K, D, V, G, ee={}, J, te, z, Y, U) {
                    let Z, $, ne, oe = this.label(K, D, V, Y, void 0, void 0, U, void 0, "button"), se = this.styledMode, le = ee.states || {}, he = 0;
                    ee = B(ee),
                    delete ee.states;
                    let Q = B({
                        color: "#333333",
                        cursor: "pointer",
                        fontSize: "0.8em",
                        fontWeight: "normal"
                    }, ee.style);
                    delete ee.style;
                    let q = r.filterUserAttributes(ee);
                    return oe.attr(B({
                        padding: 8,
                        r: 2
                    }, q)),
                    se || (q = B({
                        fill: "#f7f7f7",
                        stroke: "#cccccc",
                        "stroke-width": 1
                    }, q),
                    Z = (J = B(q, {
                        fill: "#e6e6e6"
                    }, r.filterUserAttributes(J || le.hover || {}))).style,
                    delete J.style,
                    $ = (te = B(q, {
                        fill: "#e6e9ff",
                        style: {
                            color: "#000000",
                            fontWeight: "bold"
                        }
                    }, r.filterUserAttributes(te || le.select || {}))).style,
                    delete te.style,
                    ne = (z = B(q, {
                        style: {
                            color: "#cccccc"
                        }
                    }, r.filterUserAttributes(z || le.disabled || {}))).style,
                    delete z.style),
                    F(oe.element, p ? "mouseover" : "mouseenter", function() {
                        he !== 3 && oe.setState(1)
                    }),
                    F(oe.element, p ? "mouseout" : "mouseleave", function() {
                        he !== 3 && oe.setState(he)
                    }),
                    oe.setState = function(ae) {
                        if (ae !== 1 && (oe.state = he = ae),
                        oe.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][ae || 0]),
                        !se) {
                            oe.attr([q, J, te, z][ae || 0]);
                            let re = [Q, Z, $, ne][ae || 0];
                            A(re) && oe.css(re)
                        }
                    }
                    ,
                    !se && (oe.attr(q).css(k({
                        cursor: "default"
                    }, Q)),
                    U && oe.text.css({
                        pointerEvents: "none"
                    })),
                    oe.on("touchstart", ae=>ae.stopPropagation()).on("click", function(ae) {
                        he !== 3 && G.call(oe, ae)
                    })
                }
                crispLine(K, D, V="round") {
                    let G = K[0]
                      , ee = K[1];
                    return L(G[1]) && G[1] === ee[1] && (G[1] = ee[1] = Math[V](G[1]) - D % 2 / 2),
                    L(G[2]) && G[2] === ee[2] && (G[2] = ee[2] = Math[V](G[2]) + D % 2 / 2),
                    K
                }
                path(K) {
                    let D = this.styledMode ? {} : {
                        fill: "none"
                    };
                    return w(K) ? D.d = K : A(K) && k(D, K),
                    this.createElement("path").attr(D)
                }
                circle(K, D, V) {
                    let G = A(K) ? K : K === void 0 ? {} : {
                        x: K,
                        y: D,
                        r: V
                    }
                      , ee = this.createElement("circle");
                    return ee.xSetter = ee.ySetter = function(J, te, z) {
                        z.setAttribute("c" + te, J)
                    }
                    ,
                    ee.attr(G)
                }
                arc(K, D, V, G, ee, J) {
                    let te;
                    A(K) ? (D = (te = K).y,
                    V = te.r,
                    G = te.innerR,
                    ee = te.start,
                    J = te.end,
                    K = te.x) : te = {
                        innerR: G,
                        start: ee,
                        end: J
                    };
                    let z = this.symbol("arc", K, D, V, V, te);
                    return z.r = V,
                    z
                }
                rect(K, D, V, G, ee, J) {
                    let te = A(K) ? K : K === void 0 ? {} : {
                        x: K,
                        y: D,
                        r: ee,
                        width: Math.max(V || 0, 0),
                        height: Math.max(G || 0, 0)
                    }
                      , z = this.createElement("rect");
                    return this.styledMode || (J !== void 0 && (te["stroke-width"] = J,
                    k(te, z.crisp(te))),
                    te.fill = "none"),
                    z.rSetter = function(Y, U, Z) {
                        z.r = Y,
                        P(Z, {
                            rx: Y,
                            ry: Y
                        })
                    }
                    ,
                    z.rGetter = function() {
                        return z.r || 0
                    }
                    ,
                    z.attr(te)
                }
                roundedRect(K) {
                    return this.symbol("roundedRect").attr(K)
                }
                setSize(K, D, V) {
                    this.width = K,
                    this.height = D,
                    this.boxWrapper.animate({
                        width: K,
                        height: D
                    }, {
                        step: function() {
                            this.attr({
                                viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                            })
                        },
                        duration: W(V, !0) ? void 0 : 0
                    }),
                    this.alignElements()
                }
                g(K) {
                    let D = this.createElement("g");
                    return K ? D.attr({
                        class: "highcharts-" + K
                    }) : D
                }
                image(K, D, V, G, ee, J) {
                    let te = {
                        preserveAspectRatio: "none"
                    };
                    b(D) && (te.x = D),
                    b(V) && (te.y = V),
                    b(G) && (te.width = G),
                    b(ee) && (te.height = ee);
                    let z = this.createElement("image").attr(te)
                      , Y = function(U) {
                        z.attr({
                            href: K
                        }),
                        J.call(z, U)
                    };
                    if (J) {
                        z.attr({
                            href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
                        });
                        let U = new R.Image;
                        F(U, "load", Y),
                        U.src = K,
                        U.complete && Y({})
                    } else
                        z.attr({
                            href: K
                        });
                    return z
                }
                symbol(K, D, V, G, ee, J) {
                    let te, z, Y, U, Z = this, $ = /^url\((.*?)\)$/, ne = $.test(K), oe = !ne && (this.symbols[K] ? K : "circle"), se = oe && this.symbols[oe];
                    if (se)
                        typeof D == "number" && (z = se.call(this.symbols, Math.round(D || 0), Math.round(V || 0), G || 0, ee || 0, J)),
                        te = this.path(z),
                        Z.styledMode || te.attr("fill", "none"),
                        k(te, {
                            symbolName: oe || void 0,
                            x: D,
                            y: V,
                            width: G,
                            height: ee
                        }),
                        J && k(te, J);
                    else if (ne) {
                        Y = K.match($)[1];
                        let le = te = this.image(Y);
                        le.imgwidth = W(J && J.width, O[Y] && O[Y].width),
                        le.imgheight = W(J && J.height, O[Y] && O[Y].height),
                        U = he=>he.attr({
                            width: he.width,
                            height: he.height
                        }),
                        ["width", "height"].forEach(he=>{
                            le[`${he}Setter`] = function(Q, q) {
                                this[q] = Q;
                                let {alignByTranslate: ae, element: re, width: ce, height: ue, imgwidth: fe, imgheight: de} = this
                                  , ge = q === "width" ? fe : de
                                  , ye = 1;
                                J && J.backgroundSize === "within" && ce && ue && fe && de ? (ye = Math.min(ce / fe, ue / de),
                                P(re, {
                                    width: Math.round(fe * ye),
                                    height: Math.round(de * ye)
                                })) : re && ge && re.setAttribute(q, ge),
                                !ae && fe && de && this.translate(((ce || 0) - fe * ye) / 2, ((ue || 0) - de * ye) / 2)
                            }
                        }
                        ),
                        L(D) && le.attr({
                            x: D,
                            y: V
                        }),
                        le.isImg = !0,
                        L(le.imgwidth) && L(le.imgheight) ? U(le) : (le.attr({
                            width: 0,
                            height: 0
                        }),
                        _("img", {
                            onload: function() {
                                let he = f[Z.chartIndex];
                                this.width === 0 && (T(this, {
                                    position: "absolute",
                                    top: "-999em"
                                }),
                                S.body.appendChild(this)),
                                O[Y] = {
                                    width: this.width,
                                    height: this.height
                                },
                                le.imgwidth = this.width,
                                le.imgheight = this.height,
                                le.element && U(le),
                                this.parentNode && this.parentNode.removeChild(this),
                                Z.imgCount--,
                                Z.imgCount || !he || he.hasLoaded || he.onload()
                            },
                            src: Y
                        }),
                        this.imgCount++)
                    }
                    return te
                }
                clipRect(K, D, V, G) {
                    let ee = H() + "-"
                      , J = this.createElement("clipPath").attr({
                        id: ee
                    }).add(this.defs)
                      , te = this.rect(K, D, V, G, 0).add(J);
                    return te.id = ee,
                    te.clipPath = J,
                    te.count = 0,
                    te
                }
                text(K, D, V, G) {
                    let ee = {};
                    if (G && (this.allowHTML || !this.forExport))
                        return this.html(K, D, V);
                    ee.x = Math.round(D || 0),
                    V && (ee.y = Math.round(V)),
                    L(K) && (ee.text = K);
                    let J = this.createElement("text").attr(ee);
                    return G && (!this.forExport || this.allowHTML) || (J.xSetter = function(te, z, Y) {
                        let U = Y.getElementsByTagName("tspan")
                          , Z = Y.getAttribute(z);
                        for (let $ = 0, ne; $ < U.length; $++)
                            (ne = U[$]).getAttribute(z) === Z && ne.setAttribute(z, te);
                        Y.setAttribute(z, te)
                    }
                    ),
                    J
                }
                fontMetrics(K) {
                    let D = N(l.prototype.getStyle.call(K, "font-size") || 0)
                      , V = D < 24 ? D + 3 : Math.round(1.2 * D)
                      , G = Math.round(.8 * V);
                    return {
                        h: V,
                        b: G,
                        f: D
                    }
                }
                rotCorr(K, D, V) {
                    let G = K;
                    return D && V && (G = Math.max(G * Math.cos(D * x), 4)),
                    {
                        x: -K / 3 * Math.sin(D * x),
                        y: G
                    }
                }
                pathToSegments(K) {
                    let D = []
                      , V = []
                      , G = {
                        A: 8,
                        C: 7,
                        H: 2,
                        L: 3,
                        M: 3,
                        Q: 5,
                        S: 5,
                        T: 3,
                        V: 2
                    };
                    for (let ee = 0; ee < K.length; ee++)
                        j(V[0]) && b(K[ee]) && V.length === G[V[0].toUpperCase()] && K.splice(ee, 0, V[0].replace("M", "L").replace("m", "l")),
                        typeof K[ee] == "string" && (V.length && D.push(V.slice(0)),
                        V.length = 0),
                        V.push(K[ee]);
                    return D.push(V.slice(0)),
                    D
                }
                label(K, D, V, G, ee, J, te, z, Y) {
                    return new c(this,K,D,V,G,ee,J,te,z,Y)
                }
                alignElements() {
                    this.alignedObjects.forEach(K=>K.align())
                }
            }
            return k(X.prototype, {
                Element: l,
                SVG_NS: E,
                escapes: {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    "'": "&#39;",
                    '"': "&quot;"
                },
                symbols: u,
                draw: C
            }),
            a.registerRendererType("svg", X, !0),
            X
        }),
        i(n, "Core/Renderer/HTML/HTMLElement.js", [n["Core/Globals.js"], n["Core/Renderer/SVG/SVGElement.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {isFirefox: a, isMS: l, isWebKit: c, win: u} = r
              , {css: h, defined: d, extend: m, pick: f, pInt: x} = o
              , S = [];
            class v extends s {
                static compose(g) {
                    if (o.pushUnique(S, g)) {
                        let C = v.prototype
                          , E = g.prototype;
                        E.getSpanCorrection = C.getSpanCorrection,
                        E.htmlCss = C.htmlCss,
                        E.htmlGetBBox = C.htmlGetBBox,
                        E.htmlUpdateTransform = C.htmlUpdateTransform,
                        E.setSpanRotation = C.setSpanRotation
                    }
                    return g
                }
                getSpanCorrection(g, C, E) {
                    this.xCorr = -g * E,
                    this.yCorr = -C
                }
                htmlCss(g) {
                    let C, E = this.element, O = E.tagName === "SPAN" && g && "width"in g, R = f(O && g.width, void 0);
                    return O && (delete g.width,
                    this.textWidth = R,
                    C = !0),
                    g && g.textOverflow === "ellipsis" && (g.whiteSpace = "nowrap",
                    g.overflow = "hidden"),
                    this.styles = m(this.styles, g),
                    h(this.element, g),
                    C && this.htmlUpdateTransform(),
                    this
                }
                htmlGetBBox() {
                    let g = this.element;
                    return {
                        x: g.offsetLeft,
                        y: g.offsetTop,
                        width: g.offsetWidth,
                        height: g.offsetHeight
                    }
                }
                htmlUpdateTransform() {
                    if (!this.added) {
                        this.alignOnAdd = !0;
                        return
                    }
                    let g = this.renderer
                      , C = this.element
                      , E = this.translateX || 0
                      , O = this.translateY || 0
                      , R = this.x || 0
                      , F = this.y || 0
                      , P = this.textAlign || "left"
                      , _ = {
                        left: 0,
                        center: .5,
                        right: 1
                    }[P]
                      , T = this.styles
                      , L = T && T.whiteSpace;
                    if (h(C, {
                        marginLeft: E,
                        marginTop: O
                    }),
                    C.tagName === "SPAN") {
                        let I = this.rotation, k = this.textWidth && x(this.textWidth), w = [I, P, C.innerHTML, this.textWidth, this.textAlign].join(","), b, A = !1;
                        if (k !== this.oldTextWidth) {
                            let j = this.textPxLength ? this.textPxLength : (h(C, {
                                width: "",
                                whiteSpace: L || "nowrap"
                            }),
                            C.offsetWidth);
                            (k > this.oldTextWidth || j > k) && (/[ \-]/.test(C.textContent || C.innerText) || C.style.textOverflow === "ellipsis") && (h(C, {
                                width: j > k || I ? k + "px" : "auto",
                                display: "block",
                                whiteSpace: L || "normal"
                            }),
                            this.oldTextWidth = k,
                            A = !0)
                        }
                        this.hasBoxWidthChanged = A,
                        w !== this.cTT && (b = g.fontMetrics(C).b,
                        d(I) && (I !== (this.oldRotation || 0) || P !== this.oldAlign) && this.setSpanRotation(I, _, b),
                        this.getSpanCorrection(!d(I) && this.textPxLength || C.offsetWidth, b, _, I, P)),
                        h(C, {
                            left: R + (this.xCorr || 0) + "px",
                            top: F + (this.yCorr || 0) + "px"
                        }),
                        this.cTT = w,
                        this.oldRotation = I,
                        this.oldAlign = P
                    }
                }
                setSpanRotation(g, C, E) {
                    let O = {}
                      , R = l && !/Edge/.test(u.navigator.userAgent) ? "-ms-transform" : c ? "-webkit-transform" : a ? "MozTransform" : u.opera ? "-o-transform" : void 0;
                    R && (O[R] = O.transform = "rotate(" + g + "deg)",
                    O[R + (a ? "Origin" : "-origin")] = O.transformOrigin = 100 * C + "% " + E + "px",
                    h(this.element, O))
                }
            }
            return v
        }),
        i(n, "Core/Renderer/HTML/HTMLRenderer.js", [n["Core/Renderer/HTML/AST.js"], n["Core/Renderer/SVG/SVGElement.js"], n["Core/Renderer/SVG/SVGRenderer.js"], n["Core/Utilities.js"]], function(r, s, o, a) {
            let {attr: l, createElement: c, extend: u, pick: h} = a
              , d = [];
            class m extends o {
                static compose(x) {
                    if (a.pushUnique(d, x)) {
                        let S = m.prototype
                          , v = x.prototype;
                        v.html = S.html
                    }
                    return x
                }
                html(x, S, v) {
                    let p = this.createElement("span")
                      , g = p.element
                      , C = p.renderer
                      , E = function(O, R) {
                        ["opacity", "visibility"].forEach(function(F) {
                            O[F + "Setter"] = function(P, _, T) {
                                let L = O.div ? O.div.style : R;
                                s.prototype[F + "Setter"].call(this, P, _, T),
                                L && (L[_] = P)
                            }
                        }),
                        O.addedSetters = !0
                    };
                    return p.textSetter = function(O) {
                        O !== this.textStr && (delete this.bBox,
                        delete this.oldTextWidth,
                        r.setElementHTML(this.element, h(O, "")),
                        this.textStr = O,
                        p.doTransform = !0)
                    }
                    ,
                    E(p, p.element.style),
                    p.xSetter = p.ySetter = p.alignSetter = p.rotationSetter = function(O, R) {
                        R === "align" ? p.alignValue = p.textAlign = O : p[R] = O,
                        p.doTransform = !0
                    }
                    ,
                    p.afterSetters = function() {
                        this.doTransform && (this.htmlUpdateTransform(),
                        this.doTransform = !1)
                    }
                    ,
                    p.attr({
                        text: x,
                        x: Math.round(S),
                        y: Math.round(v)
                    }).css({
                        position: "absolute"
                    }),
                    C.styledMode || p.css({
                        fontFamily: this.style.fontFamily,
                        fontSize: this.style.fontSize
                    }),
                    g.style.whiteSpace = "nowrap",
                    p.css = p.htmlCss,
                    p.add = function(O) {
                        let R, F, P = C.box.parentNode, _ = [];
                        if (this.parentGroup = O,
                        O) {
                            if (!(R = O.div)) {
                                for (F = O; F; )
                                    _.push(F),
                                    F = F.parentGroup;
                                _.reverse().forEach(function(T) {
                                    var L;
                                    let I = l(T.element, "class")
                                      , k = T.css;
                                    function w(j, B) {
                                        T[B] = j,
                                        B === "translateX" ? A.left = j + "px" : A.top = j + "px",
                                        T.doTransform = !0
                                    }
                                    let b = T.styles || {};
                                    R = T.div = T.div || c("div", I ? {
                                        className: I
                                    } : void 0, {
                                        position: "absolute",
                                        left: (T.translateX || 0) + "px",
                                        top: (T.translateY || 0) + "px",
                                        display: T.display,
                                        opacity: T.opacity,
                                        visibility: T.visibility
                                    }, R || P);
                                    let A = R.style;
                                    u(T, {
                                        classSetter: (L = R,
                                        function(j) {
                                            this.element.setAttribute("class", j),
                                            L.className = j
                                        }
                                        ),
                                        css: function(j) {
                                            return k.call(T, j),
                                            ["cursor", "pointerEvents"].forEach(B=>{
                                                j[B] && (A[B] = j[B])
                                            }
                                            ),
                                            T
                                        },
                                        on: function() {
                                            return _[0].div && p.on.apply({
                                                element: _[0].div,
                                                onEvents: T.onEvents
                                            }, arguments),
                                            T
                                        },
                                        translateXSetter: w,
                                        translateYSetter: w
                                    }),
                                    T.addedSetters || E(T),
                                    T.css(b)
                                })
                            }
                        } else
                            R = P;
                        return R.appendChild(g),
                        p.added = !0,
                        p.alignOnAdd && p.htmlUpdateTransform(),
                        p
                    }
                    ,
                    p
                }
            }
            return m
        }),
        i(n, "Core/Axis/AxisDefaults.js", [], function() {
            var r, s;
            return (s = r || (r = {})).defaultXAxisOptions = {
                alignTicks: !0,
                allowDecimals: void 0,
                panningEnabled: !0,
                zIndex: 2,
                zoomEnabled: !0,
                dateTimeLabelFormats: {
                    millisecond: {
                        main: "%H:%M:%S.%L",
                        range: !1
                    },
                    second: {
                        main: "%H:%M:%S",
                        range: !1
                    },
                    minute: {
                        main: "%H:%M",
                        range: !1
                    },
                    hour: {
                        main: "%H:%M",
                        range: !1
                    },
                    day: {
                        main: "%e %b"
                    },
                    week: {
                        main: "%e %b"
                    },
                    month: {
                        main: "%b '%y"
                    },
                    year: {
                        main: "%Y"
                    }
                },
                endOnTick: !1,
                gridLineDashStyle: "Solid",
                gridZIndex: 1,
                labels: {
                    autoRotation: void 0,
                    autoRotationLimit: 80,
                    distance: 15,
                    enabled: !0,
                    indentation: 10,
                    overflow: "justify",
                    padding: 5,
                    reserveSpace: void 0,
                    rotation: void 0,
                    staggerLines: 0,
                    step: 0,
                    useHTML: !1,
                    zIndex: 7,
                    style: {
                        color: "#333333",
                        cursor: "default",
                        fontSize: "0.8em"
                    }
                },
                maxPadding: .01,
                minorGridLineDashStyle: "Solid",
                minorTickLength: 2,
                minorTickPosition: "outside",
                minorTicksPerMajor: 5,
                minPadding: .01,
                offset: void 0,
                opposite: !1,
                reversed: void 0,
                reversedStacks: !1,
                showEmpty: !0,
                showFirstLabel: !0,
                showLastLabel: !0,
                startOfWeek: 1,
                startOnTick: !1,
                tickLength: 10,
                tickPixelInterval: 100,
                tickmarkPlacement: "between",
                tickPosition: "outside",
                title: {
                    align: "middle",
                    rotation: 0,
                    useHTML: !1,
                    x: 0,
                    y: 0,
                    style: {
                        color: "#666666",
                        fontSize: "0.8em"
                    }
                },
                type: "linear",
                uniqueNames: !0,
                visible: !0,
                minorGridLineColor: "#f2f2f2",
                minorGridLineWidth: 1,
                minorTickColor: "#999999",
                lineColor: "#333333",
                lineWidth: 1,
                gridLineColor: "#e6e6e6",
                gridLineWidth: void 0,
                tickColor: "#333333"
            },
            s.defaultYAxisOptions = {
                reversedStacks: !0,
                endOnTick: !0,
                maxPadding: .05,
                minPadding: .05,
                tickPixelInterval: 72,
                showLastLabel: !0,
                labels: {
                    x: void 0
                },
                startOnTick: !0,
                title: {
                    rotation: 270,
                    text: "Values"
                },
                stackLabels: {
                    animation: {},
                    allowOverlap: !1,
                    enabled: !1,
                    crop: !0,
                    overflow: "justify",
                    formatter: function() {
                        let {numberFormatter: o} = this.axis.chart;
                        return o(this.total || 0, -1)
                    },
                    style: {
                        color: "#000000",
                        fontSize: "0.7em",
                        fontWeight: "bold",
                        textOutline: "1px contrast"
                    }
                },
                gridLineWidth: 1,
                lineWidth: 0
            },
            s.defaultLeftAxisOptions = {
                title: {
                    rotation: 270
                }
            },
            s.defaultRightAxisOptions = {
                title: {
                    rotation: 90
                }
            },
            s.defaultBottomAxisOptions = {
                labels: {
                    autoRotation: [-45]
                },
                margin: 15,
                title: {
                    rotation: 0
                }
            },
            s.defaultTopAxisOptions = {
                labels: {
                    autoRotation: [-45]
                },
                margin: 15,
                title: {
                    rotation: 0
                }
            },
            r
        }),
        i(n, "Core/Foundation.js", [n["Core/Utilities.js"]], function(r) {
            var s;
            let {addEvent: o, isFunction: a, objectEach: l, removeEvent: c} = r;
            return (s || (s = {})).registerEventOptions = function(u, h) {
                u.eventOptions = u.eventOptions || {},
                l(h.events, function(d, m) {
                    u.eventOptions[m] !== d && (u.eventOptions[m] && (c(u, m, u.eventOptions[m]),
                    delete u.eventOptions[m]),
                    a(d) && (u.eventOptions[m] = d,
                    o(u, m, d, {
                        order: 0
                    })))
                })
            }
            ,
            s
        }),
        i(n, "Core/Axis/Tick.js", [n["Core/Templating.js"], n["Core/Globals.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {deg2rad: a} = s
              , {clamp: l, correctFloat: c, defined: u, destroyObjectProperties: h, extend: d, fireEvent: m, isNumber: f, merge: x, objectEach: S, pick: v} = o;
            return class {
                constructor(p, g, C, E, O) {
                    this.isNew = !0,
                    this.isNewLabel = !0,
                    this.axis = p,
                    this.pos = g,
                    this.type = C || "",
                    this.parameters = O || {},
                    this.tickmarkOffset = this.parameters.tickmarkOffset,
                    this.options = this.parameters.options,
                    m(this, "init"),
                    C || E || this.addLabel()
                }
                addLabel() {
                    let p = this, g = p.axis, C = g.options, E = g.chart, O = g.categories, R = g.logarithmic, F = g.names, P = p.pos, _ = v(p.options && p.options.labels, C.labels), T = g.tickPositions, L = P === T[0], I = P === T[T.length - 1], k = (!_.step || _.step === 1) && g.tickInterval === 1, w = T.info, b = p.label, A, j, B, W = this.parameters.category || (O ? v(O[P], F[P], P) : P);
                    R && f(W) && (W = c(R.lin2log(W))),
                    g.dateTime && (w ? A = (j = E.time.resolveDTLFormat(C.dateTimeLabelFormats[!C.grid && w.higherRanks[P] || w.unitName])).main : f(W) && (A = g.dateTime.getXDateFormat(W, C.dateTimeLabelFormats || {}))),
                    p.isFirst = L,
                    p.isLast = I;
                    let N = {
                        axis: g,
                        chart: E,
                        dateTimeLabelFormat: A,
                        isFirst: L,
                        isLast: I,
                        pos: P,
                        tick: p,
                        tickPositionInfo: w,
                        value: W
                    };
                    m(this, "labelFormat", N);
                    let H = K=>_.formatter ? _.formatter.call(K, K) : _.format ? (K.text = g.defaultLabelFormatter.call(K, K),
                    r.format(_.format, K, E)) : g.defaultLabelFormatter.call(K, K)
                      , X = H.call(N, N)
                      , ie = j && j.list;
                    ie ? p.shortenLabel = function() {
                        for (B = 0; B < ie.length; B++)
                            if (d(N, {
                                dateTimeLabelFormat: ie[B]
                            }),
                            b.attr({
                                text: H.call(N, N)
                            }),
                            b.getBBox().width < g.getSlotWidth(p) - 2 * _.padding)
                                return;
                        b.attr({
                            text: ""
                        })
                    }
                    : p.shortenLabel = void 0,
                    k && g._addedPlotLB && p.moveLabel(X, _),
                    u(b) || p.movedLabel ? b && b.textStr !== X && !k && (!b.textWidth || _.style.width || b.styles.width || b.css({
                        width: null
                    }),
                    b.attr({
                        text: X
                    }),
                    b.textPxLength = b.getBBox().width) : (p.label = b = p.createLabel({
                        x: 0,
                        y: 0
                    }, X, _),
                    p.rotation = 0)
                }
                createLabel(p, g, C) {
                    let E = this.axis
                      , O = E.chart
                      , R = u(g) && C.enabled ? O.renderer.text(g, p.x, p.y, C.useHTML).add(E.labelGroup) : null;
                    return R && (O.styledMode || R.css(x(C.style)),
                    R.textPxLength = R.getBBox().width),
                    R
                }
                destroy() {
                    h(this, this.axis)
                }
                getPosition(p, g, C, E) {
                    let O = this.axis
                      , R = O.chart
                      , F = E && R.oldChartHeight || R.chartHeight
                      , P = {
                        x: p ? c(O.translate(g + C, void 0, void 0, E) + O.transB) : O.left + O.offset + (O.opposite ? (E && R.oldChartWidth || R.chartWidth) - O.right - O.left : 0),
                        y: p ? F - O.bottom + O.offset - (O.opposite ? O.height : 0) : c(F - O.translate(g + C, void 0, void 0, E) - O.transB)
                    };
                    return P.y = l(P.y, -1e5, 1e5),
                    m(this, "afterGetPosition", {
                        pos: P
                    }),
                    P
                }
                getLabelPosition(p, g, C, E, O, R, F, P) {
                    let _, T, L = this.axis, I = L.transA, k = L.isLinked && L.linkedParent ? L.linkedParent.reversed : L.reversed, w = L.staggerLines, b = L.tickRotCorr || {
                        x: 0,
                        y: 0
                    }, A = E || L.reserveSpaceDefault ? 0 : -L.labelOffset * (L.labelAlign === "center" ? .5 : 1), j = O.distance, B = {};
                    return _ = L.side === 0 ? C.rotation ? -j : -C.getBBox().height : L.side === 2 ? b.y + j : Math.cos(C.rotation * a) * (b.y - C.getBBox(!1, 0).height / 2),
                    u(O.y) && (_ = L.side === 0 && L.horiz ? O.y + _ : O.y),
                    p = p + v(O.x, [0, 1, 0, -1][L.side] * j) + A + b.x - (R && E ? R * I * (k ? -1 : 1) : 0),
                    g = g + _ - (R && !E ? R * I * (k ? 1 : -1) : 0),
                    w && (T = F / (P || 1) % w,
                    L.opposite && (T = w - T - 1),
                    g += T * (L.labelOffset / w)),
                    B.x = p,
                    B.y = Math.round(g),
                    m(this, "afterGetLabelPosition", {
                        pos: B,
                        tickmarkOffset: R,
                        index: F
                    }),
                    B
                }
                getLabelSize() {
                    return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0
                }
                getMarkPath(p, g, C, E, O, R) {
                    return R.crispLine([["M", p, g], ["L", p + (O ? 0 : -C), g + (O ? C : 0)]], E)
                }
                handleOverflow(p) {
                    let g = this.axis, C = g.options.labels, E = p.x, O = g.chart.chartWidth, R = g.chart.spacing, F = v(g.labelLeft, Math.min(g.pos, R[3])), P = v(g.labelRight, Math.max(g.isRadial ? 0 : g.pos + g.len, O - R[1])), _ = this.label, T = this.rotation, L = {
                        left: 0,
                        center: .5,
                        right: 1
                    }[g.labelAlign || _.attr("align")], I = _.getBBox().width, k = g.getSlotWidth(this), w = {}, b = k, A = 1, j;
                    T || C.overflow !== "justify" ? T < 0 && E - L * I < F ? j = Math.round(E / Math.cos(T * a) - F) : T > 0 && E + L * I > P && (j = Math.round((O - E) / Math.cos(T * a))) : (E - L * I < F ? b = p.x + b * (1 - L) - F : E + (1 - L) * I > P && (b = P - p.x + b * L,
                    A = -1),
                    (b = Math.min(k, b)) < k && g.labelAlign === "center" && (p.x += A * (k - b - L * (k - Math.min(I, b)))),
                    (I > b || g.autoRotation && (_.styles || {}).width) && (j = b)),
                    j && (this.shortenLabel ? this.shortenLabel() : (w.width = Math.floor(j) + "px",
                    (C.style || {}).textOverflow || (w.textOverflow = "ellipsis"),
                    _.css(w)))
                }
                moveLabel(p, g) {
                    let C = this, E = C.label, O = C.axis, R = !1, F;
                    E && E.textStr === p ? (C.movedLabel = E,
                    R = !0,
                    delete C.label) : S(O.ticks, function(P) {
                        R || P.isNew || P === C || !P.label || P.label.textStr !== p || (C.movedLabel = P.label,
                        R = !0,
                        P.labelPos = C.movedLabel.xy,
                        delete P.label)
                    }),
                    !R && (C.labelPos || E) && (F = C.labelPos || E.xy,
                    C.movedLabel = C.createLabel(F, p, g),
                    C.movedLabel && C.movedLabel.attr({
                        opacity: 0
                    }))
                }
                render(p, g, C) {
                    let E = this.axis
                      , O = E.horiz
                      , R = this.pos
                      , F = v(this.tickmarkOffset, E.tickmarkOffset)
                      , P = this.getPosition(O, R, F, g)
                      , _ = P.x
                      , T = P.y
                      , L = O && _ === E.pos + E.len || !O && T === E.pos ? -1 : 1
                      , I = v(C, this.label && this.label.newOpacity, 1);
                    C = v(C, 1),
                    this.isActive = !0,
                    this.renderGridLine(g, C, L),
                    this.renderMark(P, C, L),
                    this.renderLabel(P, g, I, p),
                    this.isNew = !1,
                    m(this, "afterRender")
                }
                renderGridLine(p, g, C) {
                    let E = this.axis, O = E.options, R = {}, F = this.pos, P = this.type, _ = v(this.tickmarkOffset, E.tickmarkOffset), T = E.chart.renderer, L = this.gridLine, I, k = O.gridLineWidth, w = O.gridLineColor, b = O.gridLineDashStyle;
                    this.type === "minor" && (k = O.minorGridLineWidth,
                    w = O.minorGridLineColor,
                    b = O.minorGridLineDashStyle),
                    L || (E.chart.styledMode || (R.stroke = w,
                    R["stroke-width"] = k || 0,
                    R.dashstyle = b),
                    P || (R.zIndex = 1),
                    p && (g = 0),
                    this.gridLine = L = T.path().attr(R).addClass("highcharts-" + (P ? P + "-" : "") + "grid-line").add(E.gridGroup)),
                    L && (I = E.getPlotLinePath({
                        value: F + _,
                        lineWidth: L.strokeWidth() * C,
                        force: "pass",
                        old: p,
                        acrossPanes: !1
                    })) && L[p || this.isNew ? "attr" : "animate"]({
                        d: I,
                        opacity: g
                    })
                }
                renderMark(p, g, C) {
                    let E = this.axis
                      , O = E.options
                      , R = E.chart.renderer
                      , F = this.type
                      , P = E.tickSize(F ? F + "Tick" : "tick")
                      , _ = p.x
                      , T = p.y
                      , L = v(O[F !== "minor" ? "tickWidth" : "minorTickWidth"], !F && E.isXAxis ? 1 : 0)
                      , I = O[F !== "minor" ? "tickColor" : "minorTickColor"]
                      , k = this.mark
                      , w = !k;
                    P && (E.opposite && (P[0] = -P[0]),
                    k || (this.mark = k = R.path().addClass("highcharts-" + (F ? F + "-" : "") + "tick").add(E.axisGroup),
                    E.chart.styledMode || k.attr({
                        stroke: I,
                        "stroke-width": L
                    })),
                    k[w ? "attr" : "animate"]({
                        d: this.getMarkPath(_, T, P[0], k.strokeWidth() * C, E.horiz, R),
                        opacity: g
                    }))
                }
                renderLabel(p, g, C, E) {
                    let O = this.axis
                      , R = O.horiz
                      , F = O.options
                      , P = this.label
                      , _ = F.labels
                      , T = _.step
                      , L = v(this.tickmarkOffset, O.tickmarkOffset)
                      , I = p.x
                      , k = p.y
                      , w = !0;
                    P && f(I) && (P.xy = p = this.getLabelPosition(I, k, P, R, _, L, E, T),
                    (!this.isFirst || this.isLast || F.showFirstLabel) && (!this.isLast || this.isFirst || F.showLastLabel) ? !R || _.step || _.rotation || g || C === 0 || this.handleOverflow(p) : w = !1,
                    T && E % T && (w = !1),
                    w && f(p.y) ? (p.opacity = C,
                    P[this.isNewLabel ? "attr" : "animate"](p).show(!0),
                    this.isNewLabel = !1) : (P.hide(),
                    this.isNewLabel = !0))
                }
                replaceMovedLabel() {
                    let p = this.label
                      , g = this.axis;
                    p && !this.isNew && (p.animate({
                        opacity: 0
                    }, void 0, p.destroy),
                    delete this.label),
                    g.isDirty = !0,
                    this.label = this.movedLabel,
                    delete this.movedLabel
                }
            }
        }),
        i(n, "Core/Axis/Axis.js", [n["Core/Animation/AnimationUtilities.js"], n["Core/Axis/AxisDefaults.js"], n["Core/Color/Color.js"], n["Core/Defaults.js"], n["Core/Foundation.js"], n["Core/Globals.js"], n["Core/Axis/Tick.js"], n["Core/Utilities.js"]], function(r, s, o, a, l, c, u, h) {
            let {animObject: d} = r
              , {defaultOptions: m} = a
              , {registerEventOptions: f} = l
              , {deg2rad: x} = c
              , {arrayMax: S, arrayMin: v, clamp: p, correctFloat: g, defined: C, destroyObjectProperties: E, erase: O, error: R, extend: F, fireEvent: P, getClosestDistance: _, insertItem: T, isArray: L, isNumber: I, isString: k, merge: w, normalizeTickInterval: b, objectEach: A, pick: j, relativeLength: B, removeEvent: W, splat: N, syncTimeout: H} = h
              , X = (K,D)=>b(D, void 0, void 0, j(K.options.allowDecimals, D < .5 || K.tickAmount !== void 0), !!K.tickAmount);
            class ie {
                constructor(D, V, G) {
                    this.alternateBands = void 0,
                    this.bottom = void 0,
                    this.chart = void 0,
                    this.closestPointRange = void 0,
                    this.coll = void 0,
                    this.eventOptions = void 0,
                    this.hasNames = void 0,
                    this.hasVisibleSeries = void 0,
                    this.height = void 0,
                    this.index = void 0,
                    this.isLinked = void 0,
                    this.labelEdge = void 0,
                    this.labelFormatter = void 0,
                    this.left = void 0,
                    this.len = void 0,
                    this.max = void 0,
                    this.maxLabelLength = void 0,
                    this.min = void 0,
                    this.minorTickInterval = void 0,
                    this.minorTicks = void 0,
                    this.minPixelPadding = void 0,
                    this.names = void 0,
                    this.offset = void 0,
                    this.options = void 0,
                    this.overlap = void 0,
                    this.paddedTicks = void 0,
                    this.plotLinesAndBands = void 0,
                    this.plotLinesAndBandsGroups = void 0,
                    this.pointRange = void 0,
                    this.pointRangePadding = void 0,
                    this.pos = void 0,
                    this.positiveValuesOnly = void 0,
                    this.right = void 0,
                    this.series = void 0,
                    this.side = void 0,
                    this.tickAmount = void 0,
                    this.tickInterval = void 0,
                    this.tickmarkOffset = void 0,
                    this.tickPositions = void 0,
                    this.tickRotCorr = void 0,
                    this.ticks = void 0,
                    this.top = void 0,
                    this.transA = void 0,
                    this.transB = void 0,
                    this.translationSlope = void 0,
                    this.userOptions = void 0,
                    this.visible = void 0,
                    this.width = void 0,
                    this.zoomEnabled = void 0,
                    this.init(D, V, G)
                }
                init(D, V, G=this.coll) {
                    let ee = G === "xAxis";
                    this.chart = D,
                    this.horiz = this.isZAxis || (D.inverted ? !ee : ee),
                    this.isXAxis = ee,
                    this.coll = G,
                    P(this, "init", {
                        userOptions: V
                    }),
                    this.opposite = j(V.opposite, this.opposite),
                    this.side = j(V.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3),
                    this.setOptions(V);
                    let J = this.options
                      , te = J.labels
                      , z = J.type;
                    this.userOptions = V,
                    this.minPixelPadding = 0,
                    this.reversed = j(J.reversed, this.reversed),
                    this.visible = J.visible,
                    this.zoomEnabled = J.zoomEnabled,
                    this.hasNames = z === "category" || J.categories === !0,
                    this.categories = J.categories || (this.hasNames ? [] : void 0),
                    this.names || (this.names = [],
                    this.names.keys = {}),
                    this.plotLinesAndBandsGroups = {},
                    this.positiveValuesOnly = !!this.logarithmic,
                    this.isLinked = C(J.linkedTo),
                    this.ticks = {},
                    this.labelEdge = [],
                    this.minorTicks = {},
                    this.plotLinesAndBands = [],
                    this.alternateBands = {},
                    this.len = 0,
                    this.minRange = this.userMinRange = J.minRange || J.maxZoom,
                    this.range = J.range,
                    this.offset = J.offset || 0,
                    this.max = null,
                    this.min = null;
                    let Y = j(J.crosshair, N(D.options.tooltip.crosshairs)[ee ? 0 : 1]);
                    this.crosshair = Y === !0 ? {} : Y,
                    D.axes.indexOf(this) === -1 && (ee ? D.axes.splice(D.xAxis.length, 0, this) : D.axes.push(this),
                    T(this, D[this.coll])),
                    D.orderItems(this.coll),
                    this.series = this.series || [],
                    D.inverted && !this.isZAxis && ee && this.reversed === void 0 && (this.reversed = !0),
                    this.labelRotation = I(te.rotation) ? te.rotation : void 0,
                    f(this, J),
                    P(this, "afterInit")
                }
                setOptions(D) {
                    this.options = w(s.defaultXAxisOptions, this.coll === "yAxis" && s.defaultYAxisOptions, [s.defaultTopAxisOptions, s.defaultRightAxisOptions, s.defaultBottomAxisOptions, s.defaultLeftAxisOptions][this.side], w(m[this.coll], D)),
                    P(this, "afterSetOptions", {
                        userOptions: D
                    })
                }
                defaultLabelFormatter(D) {
                    let V = this.axis, G = this.chart, {numberFormatter: ee} = G, J = I(this.value) ? this.value : NaN, te = V.chart.time, z = V.categories, Y = this.dateTimeLabelFormat, U = m.lang, Z = U.numericSymbols, $ = U.numericSymbolMagnitude || 1e3, ne = V.logarithmic ? Math.abs(J) : V.tickInterval, oe = Z && Z.length, se, le;
                    if (z)
                        le = `${this.value}`;
                    else if (Y)
                        le = te.dateFormat(Y, J);
                    else if (oe && ne >= 1e3)
                        for (; oe-- && le === void 0; )
                            ne >= (se = Math.pow($, oe + 1)) && 10 * J % se == 0 && Z[oe] !== null && J !== 0 && (le = ee(J / se, -1) + Z[oe]);
                    return le === void 0 && (le = Math.abs(J) >= 1e4 ? ee(J, -1) : ee(J, -1, void 0, "")),
                    le
                }
                getSeriesExtremes() {
                    let D, V = this;
                    V.chart,
                    P(this, "getSeriesExtremes", null, function() {
                        V.hasVisibleSeries = !1,
                        V.dataMin = V.dataMax = V.threshold = null,
                        V.softThreshold = !V.isXAxis,
                        V.series.forEach(function(G) {
                            if (G.reserveSpace()) {
                                let ee = G.options, J, te = ee.threshold, z, Y;
                                if (V.hasVisibleSeries = !0,
                                V.positiveValuesOnly && te <= 0 && (te = null),
                                V.isXAxis)
                                    (J = G.xData) && J.length && (J = V.logarithmic ? J.filter(U=>U > 0) : J,
                                    z = (D = G.getXExtremes(J)).min,
                                    Y = D.max,
                                    I(z) || z instanceof Date || (J = J.filter(I),
                                    z = (D = G.getXExtremes(J)).min,
                                    Y = D.max),
                                    J.length && (V.dataMin = Math.min(j(V.dataMin, z), z),
                                    V.dataMax = Math.max(j(V.dataMax, Y), Y)));
                                else {
                                    let U = G.applyExtremes();
                                    I(U.dataMin) && (z = U.dataMin,
                                    V.dataMin = Math.min(j(V.dataMin, z), z)),
                                    I(U.dataMax) && (Y = U.dataMax,
                                    V.dataMax = Math.max(j(V.dataMax, Y), Y)),
                                    C(te) && (V.threshold = te),
                                    (!ee.softThreshold || V.positiveValuesOnly) && (V.softThreshold = !1)
                                }
                            }
                        })
                    }),
                    P(this, "afterGetSeriesExtremes")
                }
                translate(D, V, G, ee, J, te) {
                    let z = this.linkedParent || this
                      , Y = ee && z.old ? z.old.min : z.min;
                    if (!I(Y))
                        return NaN;
                    let U = z.minPixelPadding
                      , Z = (z.isOrdinal || z.brokenAxis && z.brokenAxis.hasBreaks || z.logarithmic && J) && z.lin2val
                      , $ = 1
                      , ne = 0
                      , oe = ee && z.old ? z.old.transA : z.transA
                      , se = 0;
                    if (oe || (oe = z.transA),
                    G && ($ *= -1,
                    ne = z.len),
                    z.reversed && ($ *= -1,
                    ne -= $ * (z.sector || z.len)),
                    V)
                        se = (D = D * $ + ne - U) / oe + Y,
                        Z && (se = z.lin2val(se));
                    else {
                        Z && (D = z.val2lin(D));
                        let le = $ * (D - Y) * oe;
                        se = (z.isRadial ? le : g(le)) + ne + $ * U + (I(te) ? oe * te : 0)
                    }
                    return se
                }
                toPixels(D, V) {
                    return this.translate(D, !1, !this.horiz, void 0, !0) + (V ? 0 : this.pos)
                }
                toValue(D, V) {
                    return this.translate(D - (V ? 0 : this.pos), !0, !this.horiz, void 0, !0)
                }
                getPlotLinePath(D) {
                    let V = this, G = V.chart, ee = V.left, J = V.top, te = D.old, z = D.value, Y = D.lineWidth, U = te && G.oldChartHeight || G.chartHeight, Z = te && G.oldChartWidth || G.chartWidth, $ = V.transB, ne = D.translatedValue, oe = D.force, se, le, he, Q, q;
                    function ae(ce, ue, fe) {
                        return oe !== "pass" && (ce < ue || ce > fe) && (oe ? ce = p(ce, ue, fe) : q = !0),
                        ce
                    }
                    let re = {
                        value: z,
                        lineWidth: Y,
                        old: te,
                        force: oe,
                        acrossPanes: D.acrossPanes,
                        translatedValue: ne
                    };
                    return P(this, "getPlotLinePath", re, function(ce) {
                        se = he = Math.round((ne = p(ne = j(ne, V.translate(z, void 0, void 0, te)), -1e5, 1e5)) + $),
                        le = Q = Math.round(U - ne - $),
                        I(ne) ? V.horiz ? (le = J,
                        Q = U - V.bottom,
                        se = he = ae(se, ee, ee + V.width)) : (se = ee,
                        he = Z - V.right,
                        le = Q = ae(le, J, J + V.height)) : (q = !0,
                        oe = !1),
                        ce.path = q && !oe ? void 0 : G.renderer.crispLine([["M", se, le], ["L", he, Q]], Y || 1)
                    }),
                    re.path || null
                }
                getLinearTickPositions(D, V, G) {
                    let ee, J, te, z = g(Math.floor(V / D) * D), Y = g(Math.ceil(G / D) * D), U = [];
                    if (g(z + D) === z && (te = 20),
                    this.single)
                        return [V];
                    for (ee = z; ee <= Y && (U.push(ee),
                    (ee = g(ee + D, te)) !== J); )
                        J = ee;
                    return U
                }
                getMinorTickInterval() {
                    let D = this.options;
                    return D.minorTicks === !0 ? j(D.minorTickInterval, "auto") : D.minorTicks === !1 ? null : D.minorTickInterval
                }
                getMinorTickPositions() {
                    let D = this.options, V = this.tickPositions, G = this.minorTickInterval, ee = this.pointRangePadding || 0, J = this.min - ee, te = this.max + ee, z = te - J, Y = [], U;
                    if (z && z / G < this.len / 3) {
                        let Z = this.logarithmic;
                        if (Z)
                            this.paddedTicks.forEach(function($, ne, oe) {
                                ne && Y.push.apply(Y, Z.getLogTickPositions(G, oe[ne - 1], oe[ne], !0))
                            });
                        else if (this.dateTime && this.getMinorTickInterval() === "auto")
                            Y = Y.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(G), J, te, D.startOfWeek));
                        else
                            for (U = J + (V[0] - J) % G; U <= te && U !== Y[0]; U += G)
                                Y.push(U)
                    }
                    return Y.length !== 0 && this.trimTicks(Y),
                    Y
                }
                adjustForMinRange() {
                    let D = this.options, V = this.logarithmic, G = this.min, ee = this.max, J, te, z, Y, U, Z;
                    this.isXAxis && this.minRange === void 0 && !V && (C(D.min) || C(D.max) || C(D.floor) || C(D.ceiling) ? this.minRange = null : (z = _(this.series.map($=>{
                        var ne;
                        return ($.xIncrement ? (ne = $.xData) == null ? void 0 : ne.slice(0, 2) : $.xData) || []
                    }
                    )) || 0,
                    this.minRange = Math.min(5 * z, this.dataMax - this.dataMin))),
                    ee - G < this.minRange && (te = this.dataMax - this.dataMin >= this.minRange,
                    J = ((Z = this.minRange) - ee + G) / 2,
                    Y = [G - J, j(D.min, G - J)],
                    te && (Y[2] = V ? V.log2lin(this.dataMin) : this.dataMin),
                    U = [(G = S(Y)) + Z, j(D.max, G + Z)],
                    te && (U[2] = V ? V.log2lin(this.dataMax) : this.dataMax),
                    (ee = v(U)) - G < Z && (Y[0] = ee - Z,
                    Y[1] = j(D.min, ee - Z),
                    G = S(Y))),
                    this.min = G,
                    this.max = ee
                }
                getClosest() {
                    let D, V;
                    if (this.categories)
                        V = 1;
                    else {
                        let G = [];
                        this.series.forEach(function(ee) {
                            var te;
                            let J = ee.closestPointRange;
                            ((te = ee.xData) == null ? void 0 : te.length) === 1 ? G.push(ee.xData[0]) : !ee.noSharedTooltip && C(J) && ee.reserveSpace() && (V = C(V) ? Math.min(V, J) : J)
                        }),
                        G.length && (G.sort((ee,J)=>ee - J),
                        D = _([G]))
                    }
                    return D && V ? Math.min(D, V) : D || V
                }
                nameToX(D) {
                    let V = L(this.options.categories), G = V ? this.categories : this.names, ee = D.options.x, J;
                    return D.series.requireSorting = !1,
                    C(ee) || (ee = this.options.uniqueNames && G ? V ? G.indexOf(D.name) : j(G.keys[D.name], -1) : D.series.autoIncrement()),
                    ee === -1 ? !V && G && (J = G.length) : J = ee,
                    J !== void 0 ? (this.names[J] = D.name,
                    this.names.keys[D.name] = J) : D.x && (J = D.x),
                    J
                }
                updateNames() {
                    let D = this
                      , V = this.names;
                    V.length > 0 && (Object.keys(V.keys).forEach(function(ee) {
                        delete V.keys[ee]
                    }),
                    V.length = 0,
                    this.minRange = this.userMinRange,
                    (this.series || []).forEach(function(ee) {
                        ee.xIncrement = null,
                        (!ee.points || ee.isDirtyData) && (D.max = Math.max(D.max, ee.xData.length - 1),
                        ee.processData(),
                        ee.generatePoints()),
                        ee.data.forEach(function(J, te) {
                            let z;
                            J && J.options && J.name !== void 0 && (z = D.nameToX(J)) !== void 0 && z !== J.x && (J.x = z,
                            ee.xData[te] = z)
                        })
                    }))
                }
                setAxisTranslation() {
                    let D = this, V = D.max - D.min, G = D.linkedParent, ee = !!D.categories, J = D.isXAxis, te = D.axisPointRange || 0, z, Y = 0, U = 0, Z, $ = D.transA;
                    (J || ee || te) && (z = D.getClosest(),
                    G ? (Y = G.minPointOffset,
                    U = G.pointRangePadding) : D.series.forEach(function(ne) {
                        let oe = ee ? 1 : J ? j(ne.options.pointRange, z, 0) : D.axisPointRange || 0
                          , se = ne.options.pointPlacement;
                        if (te = Math.max(te, oe),
                        !D.single || ee) {
                            let le = ne.is("xrange") ? !J : J;
                            Y = Math.max(Y, le && k(se) ? 0 : oe / 2),
                            U = Math.max(U, le && se === "on" ? 0 : oe)
                        }
                    }),
                    Z = D.ordinal && D.ordinal.slope && z ? D.ordinal.slope / z : 1,
                    D.minPointOffset = Y *= Z,
                    D.pointRangePadding = U *= Z,
                    D.pointRange = Math.min(te, D.single && ee ? 1 : V),
                    J && z && (D.closestPointRange = z)),
                    D.translationSlope = D.transA = $ = D.staticScale || D.len / (V + U || 1),
                    D.transB = D.horiz ? D.left : D.bottom,
                    D.minPixelPadding = $ * Y,
                    P(this, "afterSetAxisTranslation")
                }
                minFromRange() {
                    return this.max - this.range
                }
                setTickInterval(D) {
                    let V = this.chart, G = this.logarithmic, ee = this.options, J = this.isXAxis, te = this.isLinked, z = ee.tickPixelInterval, Y = this.categories, U = this.softThreshold, Z = ee.maxPadding, $ = ee.minPadding, ne, oe, se = I(ee.tickInterval) && ee.tickInterval >= 0 ? ee.tickInterval : void 0, le = I(this.threshold) ? this.threshold : null, he, Q, q, ae;
                    if (this.dateTime || Y || te || this.getTickAmount(),
                    q = j(this.userMin, ee.min),
                    ae = j(this.userMax, ee.max),
                    te ? (this.linkedParent = V[this.coll][ee.linkedTo],
                    oe = this.linkedParent.getExtremes(),
                    this.min = j(oe.min, oe.dataMin),
                    this.max = j(oe.max, oe.dataMax),
                    ee.type !== this.linkedParent.options.type && R(11, 1, V)) : (U && C(le) && (this.dataMin >= le ? (he = le,
                    $ = 0) : this.dataMax <= le && (Q = le,
                    Z = 0)),
                    this.min = j(q, he, this.dataMin),
                    this.max = j(ae, Q, this.dataMax)),
                    G && (this.positiveValuesOnly && !D && 0 >= Math.min(this.min, j(this.dataMin, this.min)) && R(10, 1, V),
                    this.min = g(G.log2lin(this.min), 16),
                    this.max = g(G.log2lin(this.max), 16)),
                    this.range && C(this.max) && (this.userMin = this.min = q = Math.max(this.dataMin, this.minFromRange()),
                    this.userMax = ae = this.max,
                    this.range = null),
                    P(this, "foundExtremes"),
                    this.beforePadding && this.beforePadding(),
                    this.adjustForMinRange(),
                    !I(this.userMin) && I(ee.softMin) && ee.softMin < this.min && (this.min = q = ee.softMin),
                    !I(this.userMax) && I(ee.softMax) && ee.softMax > this.max && (this.max = ae = ee.softMax),
                    !Y && !this.axisPointRange && !(this.stacking && this.stacking.usePercentage) && !te && C(this.min) && C(this.max) && (ne = this.max - this.min) && (!C(q) && $ && (this.min -= ne * $),
                    !C(ae) && Z && (this.max += ne * Z)),
                    !I(this.userMin) && I(ee.floor) && (this.min = Math.max(this.min, ee.floor)),
                    !I(this.userMax) && I(ee.ceiling) && (this.max = Math.min(this.max, ee.ceiling)),
                    U && C(this.dataMin) && (le = le || 0,
                    !C(q) && this.min < le && this.dataMin >= le ? this.min = this.options.minRange ? Math.min(le, this.max - this.minRange) : le : !C(ae) && this.max > le && this.dataMax <= le && (this.max = this.options.minRange ? Math.max(le, this.min + this.minRange) : le)),
                    I(this.min) && I(this.max) && !this.chart.polar && this.min > this.max && (C(this.options.min) ? this.max = this.min : C(this.options.max) && (this.min = this.max)),
                    this.min === this.max || this.min === void 0 || this.max === void 0 ? this.tickInterval = 1 : te && this.linkedParent && !se && z === this.linkedParent.options.tickPixelInterval ? this.tickInterval = se = this.linkedParent.tickInterval : this.tickInterval = j(se, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, Y ? 1 : (this.max - this.min) * z / Math.max(this.len, z)),
                    J && !D) {
                        let ce = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
                        this.series.forEach(function(ue) {
                            ue.forceCrop = ue.forceCropping && ue.forceCropping(),
                            ue.processData(ce)
                        }),
                        P(this, "postProcessData", {
                            hasExtremesChanged: ce
                        })
                    }
                    this.setAxisTranslation(),
                    P(this, "initialAxisTranslation"),
                    this.pointRange && !se && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
                    let re = j(ee.minTickInterval, this.dateTime && !this.series.some(ce=>ce.noSharedTooltip) ? this.closestPointRange : 0);
                    !se && this.tickInterval < re && (this.tickInterval = re),
                    this.dateTime || this.logarithmic || se || (this.tickInterval = X(this, this.tickInterval)),
                    this.tickAmount || (this.tickInterval = this.unsquish()),
                    this.setTickPositions()
                }
                setTickPositions() {
                    let D = this.options, V = D.tickPositions, G = D.tickPositioner, ee = this.getMinorTickInterval(), J = this.hasVerticalPanning(), te = this.coll === "colorAxis", z = (te || !J) && D.startOnTick, Y = (te || !J) && D.endOnTick, U = [], Z;
                    if (this.tickmarkOffset = this.categories && D.tickmarkPlacement === "between" && this.tickInterval === 1 ? .5 : 0,
                    this.minorTickInterval = ee === "auto" && this.tickInterval ? this.tickInterval / D.minorTicksPerMajor : ee,
                    this.single = this.min === this.max && C(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || D.allowDecimals !== !1),
                    V)
                        U = V.slice();
                    else if (I(this.min) && I(this.max)) {
                        if ((!this.ordinal || !this.ordinal.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))
                            U = [this.min, this.max],
                            R(19, !1, this.chart);
                        else if (this.dateTime)
                            U = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, D.units), this.min, this.max, D.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);
                        else if (this.logarithmic)
                            U = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
                        else {
                            let $ = this.tickInterval
                              , ne = $;
                            for (; ne <= 2 * $ && (U = this.getLinearTickPositions(this.tickInterval, this.min, this.max),
                            this.tickAmount && U.length > this.tickAmount); )
                                this.tickInterval = X(this, ne *= 1.1)
                        }
                        U.length > this.len && (U = [U[0], U[U.length - 1]])[0] === U[1] && (U.length = 1),
                        G && (this.tickPositions = U,
                        (Z = G.apply(this, [this.min, this.max])) && (U = Z))
                    }
                    this.tickPositions = U,
                    this.paddedTicks = U.slice(0),
                    this.trimTicks(U, z, Y),
                    !this.isLinked && I(this.min) && I(this.max) && (this.single && U.length < 2 && !this.categories && !this.series.some($=>$.is("heatmap") && $.options.pointPlacement === "between") && (this.min -= .5,
                    this.max += .5),
                    V || Z || this.adjustTickAmount()),
                    P(this, "afterSetTickPositions")
                }
                trimTicks(D, V, G) {
                    let ee = D[0]
                      , J = D[D.length - 1]
                      , te = !this.isOrdinal && this.minPointOffset || 0;
                    if (P(this, "trimTicks"),
                    !this.isLinked) {
                        if (V && ee !== -1 / 0)
                            this.min = ee;
                        else
                            for (; this.min - te > D[0]; )
                                D.shift();
                        if (G)
                            this.max = J;
                        else
                            for (; this.max + te < D[D.length - 1]; )
                                D.pop();
                        D.length === 0 && C(ee) && !this.options.tickPositions && D.push((J + ee) / 2)
                    }
                }
                alignToOthers() {
                    let D, V = this, G = [this], ee = V.options, J = this.coll === "yAxis" && this.chart.options.chart.alignThresholds, te = [];
                    if (V.thresholdAlignment = void 0,
                    (this.chart.options.chart.alignTicks !== !1 && ee.alignTicks || J) && ee.startOnTick !== !1 && ee.endOnTick !== !1 && !V.logarithmic) {
                        let z = U=>{
                            let {horiz: Z, options: $} = U;
                            return [Z ? $.left : $.top, $.width, $.height, $.pane].join(",")
                        }
                          , Y = z(this);
                        this.chart[this.coll].forEach(function(U) {
                            let {series: Z} = U;
                            Z.length && Z.some($=>$.visible) && U !== V && z(U) === Y && (D = !0,
                            G.push(U))
                        })
                    }
                    if (D && J) {
                        G.forEach(Y=>{
                            let U = Y.getThresholdAlignment(V);
                            I(U) && te.push(U)
                        }
                        );
                        let z = te.length > 1 ? te.reduce((Y,U)=>Y += U, 0) / te.length : void 0;
                        G.forEach(Y=>{
                            Y.thresholdAlignment = z
                        }
                        )
                    }
                    return D
                }
                getThresholdAlignment(D) {
                    if ((!I(this.dataMin) || this !== D && this.series.some(V=>V.isDirty || V.isDirtyData)) && this.getSeriesExtremes(),
                    I(this.threshold)) {
                        let V = p((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
                        return this.options.reversed && (V = 1 - V),
                        V
                    }
                }
                getTickAmount() {
                    let D = this.options
                      , V = D.tickPixelInterval
                      , G = D.tickAmount;
                    C(D.tickInterval) || G || !(this.len < V) || this.isRadial || this.logarithmic || !D.startOnTick || !D.endOnTick || (G = 2),
                    !G && this.alignToOthers() && (G = Math.ceil(this.len / V) + 1),
                    G < 4 && (this.finalTickAmt = G,
                    G = 5),
                    this.tickAmount = G
                }
                adjustTickAmount() {
                    let D = this, {finalTickAmt: V, max: G, min: ee, options: J, tickPositions: te, tickAmount: z, thresholdAlignment: Y} = D, U = te && te.length, Z = j(D.threshold, D.softThreshold ? 0 : null), $, ne, oe = D.tickInterval, se, le = ()=>te.push(g(te[te.length - 1] + oe)), he = ()=>te.unshift(g(te[0] - oe));
                    if (I(Y) && (se = Y < .5 ? Math.ceil(Y * (z - 1)) : Math.floor(Y * (z - 1)),
                    J.reversed && (se = z - 1 - se)),
                    D.hasData() && I(ee) && I(G)) {
                        let Q = ()=>{
                            D.transA *= (U - 1) / (z - 1),
                            D.min = J.startOnTick ? te[0] : Math.min(ee, te[0]),
                            D.max = J.endOnTick ? te[te.length - 1] : Math.max(G, te[te.length - 1])
                        }
                        ;
                        if (I(se) && I(D.threshold)) {
                            for (; te[se] !== Z || te.length !== z || te[0] > ee || te[te.length - 1] < G; ) {
                                for (te.length = 0,
                                te.push(D.threshold); te.length < z; )
                                    te[se] === void 0 || te[se] > D.threshold ? he() : le();
                                if (oe > 8 * D.tickInterval)
                                    break;
                                oe *= 2
                            }
                            Q()
                        } else if (U < z) {
                            for (; te.length < z; )
                                te.length % 2 || ee === Z ? le() : he();
                            Q()
                        }
                        if (C(V)) {
                            for (ne = $ = te.length; ne--; )
                                (V === 3 && ne % 2 == 1 || V <= 2 && ne > 0 && ne < $ - 1) && te.splice(ne, 1);
                            D.finalTickAmt = void 0
                        }
                    }
                }
                setScale() {
                    let {coll: D, stacking: V} = this
                      , G = !1
                      , ee = !1;
                    this.series.forEach(te=>{
                        G = G || te.isDirtyData || te.isDirty,
                        ee = ee || te.xAxis && te.xAxis.isDirty || !1
                    }
                    ),
                    this.setAxisSize();
                    let J = this.len !== (this.old && this.old.len);
                    J || G || ee || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (V && D === "yAxis" && V.buildStacks(),
                    this.forceRedraw = !1,
                    this.userMinRange || (this.minRange = void 0),
                    this.getSeriesExtremes(),
                    this.setTickInterval(),
                    V && D === "xAxis" && V.buildStacks(),
                    this.isDirty || (this.isDirty = J || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : V && V.cleanStacks(),
                    G && this.panningState && (this.panningState.isDirty = !0),
                    P(this, "afterSetScale")
                }
                setExtremes(D, V, G, ee, J) {
                    let te = this
                      , z = te.chart;
                    G = j(G, !0),
                    te.series.forEach(function(Y) {
                        delete Y.kdTree
                    }),
                    P(te, "setExtremes", J = F(J, {
                        min: D,
                        max: V
                    }), function() {
                        te.userMin = D,
                        te.userMax = V,
                        te.eventArgs = J,
                        G && z.redraw(ee)
                    })
                }
                zoom(D, V) {
                    let G = this
                      , ee = this.dataMin
                      , J = this.dataMax
                      , te = this.options
                      , z = Math.min(ee, j(te.min, ee))
                      , Y = Math.max(J, j(te.max, J))
                      , U = {
                        newMin: D,
                        newMax: V
                    };
                    return P(this, "zoom", U, function(Z) {
                        let $ = Z.newMin
                          , ne = Z.newMax;
                        ($ !== G.min || ne !== G.max) && (!G.allowZoomOutside && (C(ee) && ($ < z && ($ = z),
                        $ > Y && ($ = Y)),
                        C(J) && (ne < z && (ne = z),
                        ne > Y && (ne = Y))),
                        G.displayBtn = $ !== void 0 || ne !== void 0,
                        G.setExtremes($, ne, !1, void 0, {
                            trigger: "zoom"
                        })),
                        Z.zoomed = !0
                    }),
                    U.zoomed
                }
                setAxisSize() {
                    let D = this.chart
                      , V = this.options
                      , G = V.offsets || [0, 0, 0, 0]
                      , ee = this.horiz
                      , J = this.width = Math.round(B(j(V.width, D.plotWidth - G[3] + G[1]), D.plotWidth))
                      , te = this.height = Math.round(B(j(V.height, D.plotHeight - G[0] + G[2]), D.plotHeight))
                      , z = this.top = Math.round(B(j(V.top, D.plotTop + G[0]), D.plotHeight, D.plotTop))
                      , Y = this.left = Math.round(B(j(V.left, D.plotLeft + G[3]), D.plotWidth, D.plotLeft));
                    this.bottom = D.chartHeight - te - z,
                    this.right = D.chartWidth - J - Y,
                    this.len = Math.max(ee ? J : te, 0),
                    this.pos = ee ? Y : z
                }
                getExtremes() {
                    let D = this.logarithmic;
                    return {
                        min: D ? g(D.lin2log(this.min)) : this.min,
                        max: D ? g(D.lin2log(this.max)) : this.max,
                        dataMin: this.dataMin,
                        dataMax: this.dataMax,
                        userMin: this.userMin,
                        userMax: this.userMax
                    }
                }
                getThreshold(D) {
                    let V = this.logarithmic
                      , G = V ? V.lin2log(this.min) : this.min
                      , ee = V ? V.lin2log(this.max) : this.max;
                    return D === null || D === -1 / 0 ? D = G : D === 1 / 0 ? D = ee : G > D ? D = G : ee < D && (D = ee),
                    this.translate(D, 0, 1, 0, 1)
                }
                autoLabelAlign(D) {
                    let V = (j(D, 0) - 90 * this.side + 720) % 360
                      , G = {
                        align: "center"
                    };
                    return P(this, "autoLabelAlign", G, function(ee) {
                        V > 15 && V < 165 ? ee.align = "right" : V > 195 && V < 345 && (ee.align = "left")
                    }),
                    G.align
                }
                tickSize(D) {
                    let V = this.options, G = j(V[D === "tick" ? "tickWidth" : "minorTickWidth"], D === "tick" && this.isXAxis && !this.categories ? 1 : 0), ee = V[D === "tick" ? "tickLength" : "minorTickLength"], J;
                    G && ee && (V[D + "Position"] === "inside" && (ee = -ee),
                    J = [ee, G]);
                    let te = {
                        tickSize: J
                    };
                    return P(this, "afterTickSize", te),
                    te.tickSize
                }
                labelMetrics() {
                    let D = this.chart.renderer
                      , V = this.ticks
                      , G = V[Object.keys(V)[0]] || {};
                    return this.chart.renderer.fontMetrics(G.label || G.movedLabel || D.box)
                }
                unsquish() {
                    let D = this.options.labels, V = this.horiz, G = this.tickInterval, ee = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / G), J = D.rotation, te = .75 * this.labelMetrics().h, z = Math.max(this.max - this.min, 0), Y = function(oe) {
                        let se = oe / (ee || 1);
                        return (se = se > 1 ? Math.ceil(se) : 1) * G > z && oe !== 1 / 0 && ee !== 1 / 0 && z && (se = Math.ceil(z / G)),
                        g(se * G)
                    }, U = G, Z, $ = Number.MAX_VALUE, ne;
                    if (V) {
                        if (!D.staggerLines && (I(J) ? ne = [J] : ee < D.autoRotationLimit && (ne = D.autoRotation)),
                        ne) {
                            let oe, se;
                            for (let le of ne)
                                (le === J || le && le >= -90 && le <= 90) && (se = (oe = Y(Math.abs(te / Math.sin(x * le)))) + Math.abs(le / 360)) < $ && ($ = se,
                                Z = le,
                                U = oe)
                        }
                    } else
                        U = Y(te);
                    return this.autoRotation = ne,
                    this.labelRotation = j(Z, I(J) ? J : 0),
                    D.step ? G : U
                }
                getSlotWidth(D) {
                    let V = this.chart
                      , G = this.horiz
                      , ee = this.options.labels
                      , J = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1)
                      , te = V.margin[3];
                    if (D && I(D.slotWidth))
                        return D.slotWidth;
                    if (G && ee.step < 2)
                        return ee.rotation ? 0 : (this.staggerLines || 1) * this.len / J;
                    if (!G) {
                        let z = ee.style.width;
                        if (z !== void 0)
                            return parseInt(String(z), 10);
                        if (te)
                            return te - V.spacing[3]
                    }
                    return .33 * V.chartWidth
                }
                renderUnsquish() {
                    let D = this.chart, V = D.renderer, G = this.tickPositions, ee = this.ticks, J = this.options.labels, te = J.style, z = this.horiz, Y = this.getSlotWidth(), U = Math.max(1, Math.round(Y - 2 * J.padding)), Z = {}, $ = this.labelMetrics(), ne = te.textOverflow, oe, se, le = 0, he, Q;
                    if (k(J.rotation) || (Z.rotation = J.rotation || 0),
                    G.forEach(function(q) {
                        let ae = ee[q];
                        ae.movedLabel && ae.replaceMovedLabel(),
                        ae && ae.label && ae.label.textPxLength > le && (le = ae.label.textPxLength)
                    }),
                    this.maxLabelLength = le,
                    this.autoRotation)
                        le > U && le > $.h ? Z.rotation = this.labelRotation : this.labelRotation = 0;
                    else if (Y && (oe = U,
                    !ne))
                        for (se = "clip",
                        Q = G.length; !z && Q--; )
                            (he = ee[G[Q]].label) && (he.styles && he.styles.textOverflow === "ellipsis" ? he.css({
                                textOverflow: "clip"
                            }) : he.textPxLength > Y && he.css({
                                width: Y + "px"
                            }),
                            he.getBBox().height > this.len / G.length - ($.h - $.f) && (he.specificTextOverflow = "ellipsis"));
                    Z.rotation && (oe = le > .5 * D.chartHeight ? .33 * D.chartHeight : le,
                    ne || (se = "ellipsis")),
                    this.labelAlign = J.align || this.autoLabelAlign(this.labelRotation),
                    this.labelAlign && (Z.align = this.labelAlign),
                    G.forEach(function(q) {
                        let ae = ee[q]
                          , re = ae && ae.label
                          , ce = te.width
                          , ue = {};
                        re && (re.attr(Z),
                        ae.shortenLabel ? ae.shortenLabel() : oe && !ce && te.whiteSpace !== "nowrap" && (oe < re.textPxLength || re.element.tagName === "SPAN") ? (ue.width = oe + "px",
                        ne || (ue.textOverflow = re.specificTextOverflow || se),
                        re.css(ue)) : re.styles && re.styles.width && !ue.width && !ce && re.css({
                            width: null
                        }),
                        delete re.specificTextOverflow,
                        ae.rotation = Z.rotation)
                    }, this),
                    this.tickRotCorr = V.rotCorr($.b, this.labelRotation || 0, this.side !== 0)
                }
                hasData() {
                    return this.series.some(function(D) {
                        return D.hasData()
                    }) || this.options.showEmpty && C(this.min) && C(this.max)
                }
                addTitle(D) {
                    let V, G = this.chart.renderer, ee = this.horiz, J = this.opposite, te = this.options, z = te.title, Y = this.chart.styledMode;
                    this.axisTitle || ((V = z.textAlign) || (V = (ee ? {
                        low: "left",
                        middle: "center",
                        high: "right"
                    } : {
                        low: J ? "right" : "left",
                        middle: "center",
                        high: J ? "left" : "right"
                    })[z.align]),
                    this.axisTitle = G.text(z.text || "", 0, 0, z.useHTML).attr({
                        zIndex: 7,
                        rotation: z.rotation,
                        align: V
                    }).addClass("highcharts-axis-title"),
                    Y || this.axisTitle.css(w(z.style)),
                    this.axisTitle.add(this.axisGroup),
                    this.axisTitle.isNew = !0),
                    Y || z.style.width || this.isRadial || this.axisTitle.css({
                        width: this.len + "px"
                    }),
                    this.axisTitle[D ? "show" : "hide"](D)
                }
                generateTick(D) {
                    let V = this.ticks;
                    V[D] ? V[D].addLabel() : V[D] = new u(this,D)
                }
                getOffset() {
                    let D = this, {chart: V, horiz: G, options: ee, side: J, ticks: te, tickPositions: z, coll: Y, axisParent: U} = D, Z = V.renderer, $ = V.inverted && !D.isZAxis ? [1, 0, 3, 2][J] : J, ne = D.hasData(), oe = ee.title, se = ee.labels, le = I(ee.crossing), he = V.axisOffset, Q = V.clipOffset, q = [-1, 1, 1, -1][J], ae = ee.className, re, ce = 0, ue, fe = 0, de = 0, ge, ye;
                    if (D.showAxis = re = ne || ee.showEmpty,
                    D.staggerLines = D.horiz && se.staggerLines || void 0,
                    !D.axisGroup) {
                        let pe = (xe,ke,Ee)=>Z.g(xe).attr({
                            zIndex: Ee
                        }).addClass(`highcharts-${Y.toLowerCase()}${ke} ` + (this.isRadial ? `highcharts-radial-axis${ke} ` : "") + (ae || "")).add(U);
                        D.gridGroup = pe("grid", "-grid", ee.gridZIndex),
                        D.axisGroup = pe("axis", "", ee.zIndex),
                        D.labelGroup = pe("axis-labels", "-labels", se.zIndex)
                    }
                    if (ne || D.isLinked ? (z.forEach(function(pe) {
                        D.generateTick(pe)
                    }),
                    D.renderUnsquish(),
                    D.reserveSpaceDefault = J === 0 || J === 2 || {
                        1: "left",
                        3: "right"
                    }[J] === D.labelAlign,
                    j(se.reserveSpace, !le && null, D.labelAlign === "center" || null, D.reserveSpaceDefault) && z.forEach(function(pe) {
                        de = Math.max(te[pe].getLabelSize(), de)
                    }),
                    D.staggerLines && (de *= D.staggerLines),
                    D.labelOffset = de * (D.opposite ? -1 : 1)) : A(te, function(pe, xe) {
                        pe.destroy(),
                        delete te[xe]
                    }),
                    oe && oe.text && oe.enabled !== !1 && (D.addTitle(re),
                    re && !le && oe.reserveSpace !== !1 && (D.titleOffset = ce = D.axisTitle.getBBox()[G ? "height" : "width"],
                    fe = C(ue = oe.offset) ? 0 : j(oe.margin, G ? 5 : 10))),
                    D.renderLine(),
                    D.offset = q * j(ee.offset, he[J] ? he[J] + (ee.margin || 0) : 0),
                    D.tickRotCorr = D.tickRotCorr || {
                        x: 0,
                        y: 0
                    },
                    ye = J === 0 ? -D.labelMetrics().h : J === 2 ? D.tickRotCorr.y : 0,
                    ge = Math.abs(de) + fe,
                    de && (ge -= ye,
                    ge += q * (G ? j(se.y, D.tickRotCorr.y + q * se.distance) : j(se.x, q * se.distance))),
                    D.axisTitleMargin = j(ue, ge),
                    D.getMaxLabelDimensions && (D.maxLabelDimensions = D.getMaxLabelDimensions(te, z)),
                    Y !== "colorAxis") {
                        let pe = this.tickSize("tick");
                        he[J] = Math.max(he[J], (D.axisTitleMargin || 0) + ce + q * D.offset, ge, z && z.length && pe ? pe[0] + q * D.offset : 0);
                        let xe = !D.axisLine || ee.offset ? 0 : 2 * Math.floor(D.axisLine.strokeWidth() / 2);
                        Q[$] = Math.max(Q[$], xe)
                    }
                    P(this, "afterGetOffset")
                }
                getLinePath(D) {
                    let V = this.chart
                      , G = this.opposite
                      , ee = this.offset
                      , J = this.horiz
                      , te = this.left + (G ? this.width : 0) + ee
                      , z = V.chartHeight - this.bottom - (G ? this.height : 0) + ee;
                    return G && (D *= -1),
                    V.renderer.crispLine([["M", J ? this.left : te, J ? z : this.top], ["L", J ? V.chartWidth - this.right : te, J ? z : V.chartHeight - this.bottom]], D)
                }
                renderLine() {
                    this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup),
                    this.chart.styledMode || this.axisLine.attr({
                        stroke: this.options.lineColor,
                        "stroke-width": this.options.lineWidth,
                        zIndex: 7
                    }))
                }
                getTitlePosition(D) {
                    let V = this.horiz
                      , G = this.left
                      , ee = this.top
                      , J = this.len
                      , te = this.options.title
                      , z = V ? G : ee
                      , Y = this.opposite
                      , U = this.offset
                      , Z = te.x
                      , $ = te.y
                      , ne = this.chart.renderer.fontMetrics(D)
                      , oe = D ? Math.max(D.getBBox(!1, 0).height - ne.h - 1, 0) : 0
                      , se = {
                        low: z + (V ? 0 : J),
                        middle: z + J / 2,
                        high: z + (V ? J : 0)
                    }[te.align]
                      , le = (V ? ee + this.height : G) + (V ? 1 : -1) * (Y ? -1 : 1) * (this.axisTitleMargin || 0) + [-oe, oe, ne.f, -oe][this.side]
                      , he = {
                        x: V ? se + Z : le + (Y ? this.width : 0) + U + Z,
                        y: V ? le + $ - (Y ? this.height : 0) + U : se + $
                    };
                    return P(this, "afterGetTitlePosition", {
                        titlePosition: he
                    }),
                    he
                }
                renderMinorTick(D, V) {
                    let G = this.minorTicks;
                    G[D] || (G[D] = new u(this,D,"minor")),
                    V && G[D].isNew && G[D].render(null, !0),
                    G[D].render(null, !1, 1)
                }
                renderTick(D, V, G) {
                    let ee = this.isLinked
                      , J = this.ticks;
                    (!ee || D >= this.min && D <= this.max || this.grid && this.grid.isColumn) && (J[D] || (J[D] = new u(this,D)),
                    G && J[D].isNew && J[D].render(V, !0, -1),
                    J[D].render(V))
                }
                render() {
                    let D, V, G = this, ee = G.chart, J = G.logarithmic, te = ee.renderer, z = G.options, Y = G.isLinked, U = G.tickPositions, Z = G.axisTitle, $ = G.ticks, ne = G.minorTicks, oe = G.alternateBands, se = z.stackLabels, le = z.alternateGridColor, he = z.crossing, Q = G.tickmarkOffset, q = G.axisLine, ae = G.showAxis, re = d(te.globalAnimation);
                    if (G.labelEdge.length = 0,
                    G.overlap = !1,
                    [$, ne, oe].forEach(function(ce) {
                        A(ce, function(ue) {
                            ue.isActive = !1
                        })
                    }),
                    I(he)) {
                        let ce = this.isXAxis ? ee.yAxis[0] : ee.xAxis[0]
                          , ue = [1, -1, -1, 1][this.side];
                        if (ce) {
                            let fe = ce.toPixels(he, !0);
                            G.horiz && (fe = ce.len - fe),
                            G.offset = ue * fe
                        }
                    }
                    if (G.hasData() || Y) {
                        let ce = G.chart.hasRendered && G.old && I(G.old.min);
                        G.minorTickInterval && !G.categories && G.getMinorTickPositions().forEach(function(ue) {
                            G.renderMinorTick(ue, ce)
                        }),
                        U.length && (U.forEach(function(ue, fe) {
                            G.renderTick(ue, fe, ce)
                        }),
                        Q && (G.min === 0 || G.single) && ($[-1] || ($[-1] = new u(G,-1,null,!0)),
                        $[-1].render(-1))),
                        le && U.forEach(function(ue, fe) {
                            V = U[fe + 1] !== void 0 ? U[fe + 1] + Q : G.max - Q,
                            fe % 2 == 0 && ue < G.max && V <= G.max + (ee.polar ? -Q : Q) && (oe[ue] || (oe[ue] = new c.PlotLineOrBand(G)),
                            D = ue + Q,
                            oe[ue].options = {
                                from: J ? J.lin2log(D) : D,
                                to: J ? J.lin2log(V) : V,
                                color: le,
                                className: "highcharts-alternate-grid"
                            },
                            oe[ue].render(),
                            oe[ue].isActive = !0)
                        }),
                        G._addedPlotLB || (G._addedPlotLB = !0,
                        (z.plotLines || []).concat(z.plotBands || []).forEach(function(ue) {
                            G.addPlotBandOrLine(ue)
                        }))
                    }
                    [$, ne, oe].forEach(function(ce) {
                        let ue = []
                          , fe = re.duration;
                        A(ce, function(de, ge) {
                            de.isActive || (de.render(ge, !1, 0),
                            de.isActive = !1,
                            ue.push(ge))
                        }),
                        H(function() {
                            let de = ue.length;
                            for (; de--; )
                                ce[ue[de]] && !ce[ue[de]].isActive && (ce[ue[de]].destroy(),
                                delete ce[ue[de]])
                        }, ce !== oe && ee.hasRendered && fe ? fe : 0)
                    }),
                    q && (q[q.isPlaced ? "animate" : "attr"]({
                        d: this.getLinePath(q.strokeWidth())
                    }),
                    q.isPlaced = !0,
                    q[ae ? "show" : "hide"](ae)),
                    Z && ae && (Z[Z.isNew ? "attr" : "animate"](G.getTitlePosition(Z)),
                    Z.isNew = !1),
                    se && se.enabled && G.stacking && G.stacking.renderStackTotals(),
                    G.old = {
                        len: G.len,
                        max: G.max,
                        min: G.min,
                        transA: G.transA,
                        userMax: G.userMax,
                        userMin: G.userMin
                    },
                    G.isDirty = !1,
                    P(this, "afterRender")
                }
                redraw() {
                    this.visible && (this.render(),
                    this.plotLinesAndBands.forEach(function(D) {
                        D.render()
                    })),
                    this.series.forEach(function(D) {
                        D.isDirty = !0
                    })
                }
                getKeepProps() {
                    return this.keepProps || ie.keepProps
                }
                destroy(D) {
                    let V = this
                      , G = V.plotLinesAndBands
                      , ee = this.eventOptions;
                    if (P(this, "destroy", {
                        keepEvents: D
                    }),
                    D || W(V),
                    [V.ticks, V.minorTicks, V.alternateBands].forEach(function(J) {
                        E(J)
                    }),
                    G) {
                        let J = G.length;
                        for (; J--; )
                            G[J].destroy()
                    }
                    for (let J in ["axisLine", "axisTitle", "axisGroup", "gridGroup", "labelGroup", "cross", "scrollbar"].forEach(function(te) {
                        V[te] && (V[te] = V[te].destroy())
                    }),
                    V.plotLinesAndBandsGroups)
                        V.plotLinesAndBandsGroups[J] = V.plotLinesAndBandsGroups[J].destroy();
                    A(V, function(J, te) {
                        V.getKeepProps().indexOf(te) === -1 && delete V[te]
                    }),
                    this.eventOptions = ee
                }
                drawCrosshair(D, V) {
                    let G = this.crosshair, ee = j(G && G.snap, !0), J = this.chart, te, z, Y, U = this.cross, Z;
                    if (P(this, "drawCrosshair", {
                        e: D,
                        point: V
                    }),
                    D || (D = this.cross && this.cross.e),
                    G && (C(V) || !ee) !== !1) {
                        if (ee ? C(V) && (z = j(this.coll !== "colorAxis" ? V.crosshairPos : null, this.isXAxis ? V.plotX : this.len - V.plotY)) : z = D && (this.horiz ? D.chartX - this.pos : this.len - D.chartY + this.pos),
                        C(z) && (Z = {
                            value: V && (this.isXAxis ? V.x : j(V.stackY, V.y)),
                            translatedValue: z
                        },
                        J.polar && F(Z, {
                            isCrosshair: !0,
                            chartX: D && D.chartX,
                            chartY: D && D.chartY,
                            point: V
                        }),
                        te = this.getPlotLinePath(Z) || null),
                        !C(te)) {
                            this.hideCrosshair();
                            return
                        }
                        Y = this.categories && !this.isRadial,
                        U || (this.cross = U = J.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (Y ? "category " : "thin ") + (G.className || "")).attr({
                            zIndex: j(G.zIndex, 2)
                        }).add(),
                        !J.styledMode && (U.attr({
                            stroke: G.color || (Y ? o.parse("#ccd3ff").setOpacity(.25).get() : "#cccccc"),
                            "stroke-width": j(G.width, 1)
                        }).css({
                            "pointer-events": "none"
                        }),
                        G.dashStyle && U.attr({
                            dashstyle: G.dashStyle
                        }))),
                        U.show().attr({
                            d: te
                        }),
                        Y && !G.width && U.attr({
                            "stroke-width": this.transA
                        }),
                        this.cross.e = D
                    } else
                        this.hideCrosshair();
                    P(this, "afterDrawCrosshair", {
                        e: D,
                        point: V
                    })
                }
                hideCrosshair() {
                    this.cross && this.cross.hide(),
                    P(this, "afterHideCrosshair")
                }
                hasVerticalPanning() {
                    let D = this.chart.options.chart.panning;
                    return !!(D && D.enabled && /y/.test(D.type))
                }
                update(D, V) {
                    let G = this.chart;
                    D = w(this.userOptions, D),
                    this.destroy(!0),
                    this.init(G, D),
                    G.isDirtyBox = !0,
                    j(V, !0) && G.redraw()
                }
                remove(D) {
                    let V = this.chart
                      , G = this.coll
                      , ee = this.series
                      , J = ee.length;
                    for (; J--; )
                        ee[J] && ee[J].remove(!1);
                    O(V.axes, this),
                    O(V[G] || [], this),
                    V.orderItems(G),
                    this.destroy(),
                    V.isDirtyBox = !0,
                    j(D, !0) && V.redraw()
                }
                setTitle(D, V) {
                    this.update({
                        title: D
                    }, V)
                }
                setCategories(D, V) {
                    this.update({
                        categories: D
                    }, V)
                }
            }
            return ie.defaultOptions = s.defaultXAxisOptions,
            ie.keepProps = ["coll", "extKey", "hcEvents", "names", "series", "userMax", "userMin"],
            ie
        }),
        i(n, "Core/Axis/DateTimeAxis.js", [n["Core/Utilities.js"]], function(r) {
            var s;
            let {addEvent: o, getMagnitude: a, normalizeTickInterval: l, timeUnits: c} = r;
            return function(u) {
                let h = [];
                function d() {
                    return this.chart.time.getTimeTicks.apply(this.chart.time, arguments)
                }
                function m(x) {
                    if (x.userOptions.type !== "datetime") {
                        this.dateTime = void 0;
                        return
                    }
                    this.dateTime || (this.dateTime = new f(this))
                }
                u.compose = function(x) {
                    if (r.pushUnique(h, x)) {
                        x.keepProps.push("dateTime");
                        let S = x.prototype;
                        S.getTimeTicks = d,
                        o(x, "init", m)
                    }
                    return x
                }
                ;
                class f {
                    constructor(S) {
                        this.axis = S
                    }
                    normalizeTimeTickInterval(S, v) {
                        let p = v || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], g = p[p.length - 1], C = c[g[0]], E = g[1], O;
                        for (O = 0; O < p.length; O++)
                            if (C = c[(g = p[O])[0]],
                            E = g[1],
                            p[O + 1]) {
                                let F = (C * E[E.length - 1] + c[p[O + 1][0]]) / 2;
                                if (S <= F)
                                    break
                            }
                        C === c.year && S < 5 * C && (E = [1, 2, 5]);
                        let R = l(S / C, E, g[0] === "year" ? Math.max(a(S / C), 1) : 1);
                        return {
                            unitRange: C,
                            count: R,
                            unitName: g[0]
                        }
                    }
                    getXDateFormat(S, v) {
                        let {axis: p} = this
                          , g = p.chart.time;
                        return p.closestPointRange ? g.getDateFormat(p.closestPointRange, S, p.options.startOfWeek, v) || g.resolveDTLFormat(v.year).main : g.resolveDTLFormat(v.day).main
                    }
                }
                u.Additions = f
            }(s || (s = {})),
            s
        }),
        i(n, "Core/Axis/LogarithmicAxis.js", [n["Core/Utilities.js"]], function(r) {
            var s;
            let {addEvent: o, normalizeTickInterval: a, pick: l} = r;
            return function(c) {
                let u = [];
                function h(f) {
                    let x = f.userOptions
                      , S = this.logarithmic;
                    x.type !== "logarithmic" ? this.logarithmic = void 0 : S || (S = this.logarithmic = new m(this))
                }
                function d() {
                    let f = this.logarithmic;
                    f && (this.lin2val = function(x) {
                        return f.lin2log(x)
                    }
                    ,
                    this.val2lin = function(x) {
                        return f.log2lin(x)
                    }
                    )
                }
                c.compose = function(f) {
                    return r.pushUnique(u, f) && (f.keepProps.push("logarithmic"),
                    o(f, "init", h),
                    o(f, "afterInit", d)),
                    f
                }
                ;
                class m {
                    constructor(x) {
                        this.axis = x
                    }
                    getLogTickPositions(x, S, v, p) {
                        let g = this.axis
                          , C = g.len
                          , E = g.options
                          , O = [];
                        if (p || (this.minorAutoInterval = void 0),
                        x >= .5)
                            x = Math.round(x),
                            O = g.getLinearTickPositions(x, S, v);
                        else if (x >= .08) {
                            let R, F, P, _, T, L, I, k = Math.floor(S);
                            for (R = x > .3 ? [1, 2, 4] : x > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9],
                            F = k; F < v + 1 && !I; F++)
                                for (P = 0,
                                _ = R.length; P < _ && !I; P++)
                                    (T = this.log2lin(this.lin2log(F) * R[P])) > S && (!p || L <= v) && L !== void 0 && O.push(L),
                                    L > v && (I = !0),
                                    L = T
                        } else {
                            let R = this.lin2log(S)
                              , F = this.lin2log(v)
                              , P = p ? g.getMinorTickInterval() : E.tickInterval
                              , _ = P === "auto" ? null : P
                              , T = E.tickPixelInterval / (p ? 5 : 1)
                              , L = p ? C / g.tickPositions.length : C;
                            x = a(x = l(_, this.minorAutoInterval, (F - R) * T / (L || 1))),
                            O = g.getLinearTickPositions(x, R, F).map(this.log2lin),
                            p || (this.minorAutoInterval = x / 5)
                        }
                        return p || (g.tickInterval = x),
                        O
                    }
                    lin2log(x) {
                        return Math.pow(10, x)
                    }
                    log2lin(x) {
                        return Math.log(x) / Math.LN10
                    }
                }
                c.Additions = m
            }(s || (s = {})),
            s
        }),
        i(n, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [n["Core/Utilities.js"]], function(r) {
            var s;
            let {erase: o, extend: a, isNumber: l} = r;
            return function(c) {
                let u, h = [];
                function d(g) {
                    return this.addPlotBandOrLine(g, "plotBands")
                }
                function m(g, C) {
                    let E = this.userOptions
                      , O = new u(this,g);
                    if (this.visible && (O = O.render()),
                    O) {
                        if (this._addedPlotLB || (this._addedPlotLB = !0,
                        (E.plotLines || []).concat(E.plotBands || []).forEach(R=>{
                            this.addPlotBandOrLine(R)
                        }
                        )),
                        C) {
                            let R = E[C] || [];
                            R.push(g),
                            E[C] = R
                        }
                        this.plotLinesAndBands.push(O)
                    }
                    return O
                }
                function f(g) {
                    return this.addPlotBandOrLine(g, "plotLines")
                }
                function x(g, C, E) {
                    E = E || this.options;
                    let O = this.getPlotLinePath({
                        value: C,
                        force: !0,
                        acrossPanes: E.acrossPanes
                    }), R = [], F = this.horiz, P = !l(this.min) || !l(this.max) || g < this.min && C < this.min || g > this.max && C > this.max, _ = this.getPlotLinePath({
                        value: g,
                        force: !0,
                        acrossPanes: E.acrossPanes
                    }), T, L = 1, I;
                    if (_ && O)
                        for (P && (I = _.toString() === O.toString(),
                        L = 0),
                        T = 0; T < _.length; T += 2) {
                            let k = _[T]
                              , w = _[T + 1]
                              , b = O[T]
                              , A = O[T + 1];
                            (k[0] === "M" || k[0] === "L") && (w[0] === "M" || w[0] === "L") && (b[0] === "M" || b[0] === "L") && (A[0] === "M" || A[0] === "L") && (F && b[1] === k[1] ? (b[1] += L,
                            A[1] += L) : F || b[2] !== k[2] || (b[2] += L,
                            A[2] += L),
                            R.push(["M", k[1], k[2]], ["L", w[1], w[2]], ["L", A[1], A[2]], ["L", b[1], b[2]], ["Z"])),
                            R.isFlat = I
                        }
                    else
                        _ = null;
                    return R
                }
                function S(g) {
                    this.removePlotBandOrLine(g)
                }
                function v(g) {
                    let C = this.plotLinesAndBands
                      , E = this.options
                      , O = this.userOptions;
                    if (C) {
                        let R = C.length;
                        for (; R--; )
                            C[R].id === g && C[R].destroy();
                        [E.plotLines || [], O.plotLines || [], E.plotBands || [], O.plotBands || []].forEach(function(F) {
                            for (R = F.length; R--; )
                                (F[R] || {}).id === g && o(F, F[R])
                        })
                    }
                }
                function p(g) {
                    this.removePlotBandOrLine(g)
                }
                c.compose = function(g, C) {
                    return u || (u = g),
                    r.pushUnique(h, C) && a(C.prototype, {
                        addPlotBand: d,
                        addPlotLine: f,
                        addPlotBandOrLine: m,
                        getPlotBandPath: x,
                        removePlotBand: S,
                        removePlotLine: p,
                        removePlotBandOrLine: v
                    }),
                    C
                }
            }(s || (s = {})),
            s
        }),
        i(n, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [n["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], n["Core/Utilities.js"]], function(r, s) {
            let {arrayMax: o, arrayMin: a, defined: l, destroyObjectProperties: c, erase: u, fireEvent: h, merge: d, objectEach: m, pick: f} = s;
            class x {
                static compose(v) {
                    return r.compose(x, v)
                }
                constructor(v, p) {
                    this.id = void 0,
                    this.axis = v,
                    p && (this.options = p,
                    this.id = p.id)
                }
                render() {
                    h(this, "render");
                    let v = this, p = v.axis, g = p.horiz, C = p.logarithmic, E = v.options, O = E.color, R = f(E.zIndex, 0), F = E.events, P = {}, _ = p.chart.renderer, T = E.label, L = v.label, I = E.to, k = E.from, w = E.value, b = v.svgElem, A = [], j, B = l(k) && l(I), W = l(w), N = !b, H = {
                        class: "highcharts-plot-" + (B ? "band " : "line ") + (E.className || "")
                    }, X = B ? "bands" : "lines";
                    if (C && (k = C.log2lin(k),
                    I = C.log2lin(I),
                    w = C.log2lin(w)),
                    !p.chart.styledMode && (W ? (H.stroke = O || "#999999",
                    H["stroke-width"] = f(E.width, 1),
                    E.dashStyle && (H.dashstyle = E.dashStyle)) : B && (H.fill = O || "#e6e9ff",
                    E.borderWidth && (H.stroke = E.borderColor,
                    H["stroke-width"] = E.borderWidth))),
                    P.zIndex = R,
                    X += "-" + R,
                    (j = p.plotLinesAndBandsGroups[X]) || (p.plotLinesAndBandsGroups[X] = j = _.g("plot-" + X).attr(P).add()),
                    N && (v.svgElem = b = _.path().attr(H).add(j)),
                    W)
                        A = p.getPlotLinePath({
                            value: w,
                            lineWidth: b.strokeWidth(),
                            acrossPanes: E.acrossPanes
                        });
                    else {
                        if (!B)
                            return;
                        A = p.getPlotBandPath(k, I, E)
                    }
                    return !v.eventsAdded && F && (m(F, function(ie, K) {
                        b.on(K, function(D) {
                            F[K].apply(v, [D])
                        })
                    }),
                    v.eventsAdded = !0),
                    (N || !b.d) && A && A.length ? b.attr({
                        d: A
                    }) : b && (A ? (b.show(),
                    b.animate({
                        d: A
                    })) : b.d && (b.hide(),
                    L && (v.label = L = L.destroy()))),
                    T && (l(T.text) || l(T.formatter)) && A && A.length && p.width > 0 && p.height > 0 && !A.isFlat ? (T = d({
                        align: g && B && "center",
                        x: g ? !B && 4 : 10,
                        verticalAlign: !g && B && "middle",
                        y: g ? B ? 16 : 10 : B ? 6 : -4,
                        rotation: g && !B && 90
                    }, T),
                    this.renderLabel(T, A, B, R)) : L && L.hide(),
                    v
                }
                renderLabel(v, p, g, C) {
                    let E = this.axis
                      , O = E.chart.renderer
                      , R = this.label;
                    R || (this.label = R = O.text(this.getLabelText(v), 0, 0, v.useHTML).attr({
                        align: v.textAlign || v.align,
                        rotation: v.rotation,
                        class: "highcharts-plot-" + (g ? "band" : "line") + "-label " + (v.className || ""),
                        zIndex: C
                    }),
                    E.chart.styledMode || R.css(d({
                        fontSize: "0.8em",
                        textOverflow: "ellipsis"
                    }, v.style)),
                    R.add());
                    let F = p.xBounds || [p[0][1], p[1][1], g ? p[2][1] : p[0][1]]
                      , P = p.yBounds || [p[0][2], p[1][2], g ? p[2][2] : p[0][2]]
                      , _ = a(F)
                      , T = a(P);
                    if (R.align(v, !1, {
                        x: _,
                        y: T,
                        width: o(F) - _,
                        height: o(P) - T
                    }),
                    !R.alignValue || R.alignValue === "left") {
                        let L = v.clip ? E.width : E.chart.chartWidth;
                        R.css({
                            width: (R.rotation === 90 ? E.height - (R.alignAttr.y - E.top) : L - (R.alignAttr.x - E.left)) + "px"
                        })
                    }
                    R.show(!0)
                }
                getLabelText(v) {
                    return l(v.formatter) ? v.formatter.call(this) : v.text
                }
                destroy() {
                    u(this.axis.plotLinesAndBands, this),
                    delete this.axis,
                    c(this)
                }
            }
            return x
        }),
        i(n, "Core/Tooltip.js", [n["Core/Templating.js"], n["Core/Globals.js"], n["Core/Renderer/RendererUtilities.js"], n["Core/Renderer/RendererRegistry.js"], n["Core/Utilities.js"]], function(r, s, o, a, l) {
            let {format: c} = r
              , {doc: u, isSafari: h} = s
              , {distribute: d} = o
              , {addEvent: m, clamp: f, css: x, discardElement: S, extend: v, fireEvent: p, isArray: g, isNumber: C, isString: E, merge: O, pick: R, splat: F, syncTimeout: P} = l;
            class _ {
                constructor(L, I) {
                    this.allowShared = !0,
                    this.crosshairs = [],
                    this.distance = 0,
                    this.isHidden = !0,
                    this.isSticky = !1,
                    this.now = {},
                    this.options = {},
                    this.outside = !1,
                    this.chart = L,
                    this.init(L, I)
                }
                bodyFormatter(L) {
                    return L.map(function(I) {
                        let k = I.series.tooltipOptions;
                        return (k[(I.point.formatPrefix || "point") + "Formatter"] || I.point.tooltipFormatter).call(I.point, k[(I.point.formatPrefix || "point") + "Format"] || "")
                    })
                }
                cleanSplit(L) {
                    this.chart.series.forEach(function(I) {
                        let k = I && I.tt;
                        k && (!k.isActive || L ? I.tt = k.destroy() : k.isActive = !1)
                    })
                }
                defaultFormatter(L) {
                    let I, k = this.points || F(this);
                    return (I = (I = [L.tooltipFooterHeaderFormatter(k[0])]).concat(L.bodyFormatter(k))).push(L.tooltipFooterHeaderFormatter(k[0], !0)),
                    I
                }
                destroy() {
                    this.label && (this.label = this.label.destroy()),
                    this.split && (this.cleanSplit(!0),
                    this.tt && (this.tt = this.tt.destroy())),
                    this.renderer && (this.renderer = this.renderer.destroy(),
                    S(this.container)),
                    l.clearTimeout(this.hideTimer),
                    l.clearTimeout(this.tooltipTimeout)
                }
                getAnchor(L, I) {
                    let k, w = this.chart, b = w.pointer, A = w.inverted, j = w.plotTop, B = w.plotLeft;
                    if ((L = F(L))[0].series && L[0].series.yAxis && !L[0].series.yAxis.options.reversedStacks && (L = L.slice().reverse()),
                    this.followPointer && I)
                        I.chartX === void 0 && (I = b.normalize(I)),
                        k = [I.chartX - B, I.chartY - j];
                    else if (L[0].tooltipPos)
                        k = L[0].tooltipPos;
                    else {
                        let W = 0
                          , N = 0;
                        L.forEach(function(H) {
                            let X = H.pos(!0);
                            X && (W += X[0],
                            N += X[1])
                        }),
                        W /= L.length,
                        N /= L.length,
                        this.shared && L.length > 1 && I && (A ? W = I.chartX : N = I.chartY),
                        k = [W - B, N - j]
                    }
                    return k.map(Math.round)
                }
                getClassName(L, I, k) {
                    let w = this.options
                      , b = L.series
                      , A = b.options;
                    return [w.className, "highcharts-label", k && "highcharts-tooltip-header", I ? "highcharts-tooltip-box" : "highcharts-tooltip", !k && "highcharts-color-" + R(L.colorIndex, b.colorIndex), A && A.className].filter(E).join(" ")
                }
                getLabel() {
                    let L = this
                      , I = this.chart.styledMode
                      , k = this.options
                      , w = this.split && this.allowShared
                      , b = this.container
                      , A = this.chart.renderer;
                    if (this.label) {
                        let j = !this.label.hasClass("highcharts-label");
                        (!w && j || w && !j) && this.destroy()
                    }
                    if (!this.label) {
                        if (this.outside) {
                            let j = this.chart.options.chart.style
                              , B = a.getRendererType();
                            this.container = b = s.doc.createElement("div"),
                            b.className = "highcharts-tooltip-container",
                            x(b, {
                                position: "absolute",
                                top: "1px",
                                pointerEvents: "none",
                                zIndex: Math.max(this.options.style.zIndex || 0, (j && j.zIndex || 0) + 3)
                            }),
                            this.renderer = A = new B(b,0,0,j,void 0,void 0,A.styledMode)
                        }
                        if (w ? this.label = A.g("tooltip") : (this.label = A.label("", 0, 0, k.shape, void 0, void 0, k.useHTML, void 0, "tooltip").attr({
                            padding: k.padding,
                            r: k.borderRadius
                        }),
                        I || this.label.attr({
                            fill: k.backgroundColor,
                            "stroke-width": k.borderWidth || 0
                        }).css(k.style).css({
                            pointerEvents: k.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none")
                        })),
                        L.outside) {
                            let j = this.label
                              , {xSetter: B, ySetter: W} = j;
                            j.xSetter = function(N) {
                                B.call(j, L.distance),
                                b && (b.style.left = N + "px")
                            }
                            ,
                            j.ySetter = function(N) {
                                W.call(j, L.distance),
                                b && (b.style.top = N + "px")
                            }
                        }
                        this.label.attr({
                            zIndex: 8
                        }).shadow(k.shadow).add()
                    }
                    return b && !b.parentElement && s.doc.body.appendChild(b),
                    this.label
                }
                getPlayingField() {
                    let {body: L, documentElement: I} = u
                      , {chart: k, distance: w, outside: b} = this;
                    return {
                        width: b ? Math.max(L.scrollWidth, I.scrollWidth, L.offsetWidth, I.offsetWidth, I.clientWidth) - 2 * w : k.chartWidth,
                        height: b ? Math.max(L.scrollHeight, I.scrollHeight, L.offsetHeight, I.offsetHeight, I.clientHeight) : k.chartHeight
                    }
                }
                getPosition(L, I, k) {
                    let w = this.chart, b = this.distance, A = {}, j = w.inverted && k.h || 0, B = this.outside, W = this.getPlayingField(), N = W.width, H = W.height, X = w.pointer.getChartPosition(), ie = $=>$ * X.scaleX, K = $=>$ * X.scaleY, D = $=>{
                        let ne = $ === "x";
                        return [$, ne ? N : H, ne ? L : I].concat(B ? [ne ? ie(L) : K(I), ne ? X.left - b + ie(k.plotX + w.plotLeft) : X.top - b + K(k.plotY + w.plotTop), 0, ne ? N : H] : [ne ? L : I, ne ? k.plotX + w.plotLeft : k.plotY + w.plotTop, ne ? w.plotLeft : w.plotTop, ne ? w.plotLeft + w.plotWidth : w.plotTop + w.plotHeight])
                    }
                    , V = D("y"), G = D("x"), ee, J = !!k.negative;
                    !w.polar && w.hoverSeries && w.hoverSeries.yAxis && w.hoverSeries.yAxis.reversed && (J = !J);
                    let te = !this.followPointer && R(k.ttBelow, !w.inverted === J)
                      , z = function($, ne, oe, se, le, he, Q) {
                        let q = B ? $ === "y" ? K(b) : ie(b) : b
                          , ae = (oe - se) / 2
                          , re = se < le - b
                          , ce = le + b + se < ne
                          , ue = le - q - oe + ae
                          , fe = le + q - ae;
                        if (te && ce)
                            A[$] = fe;
                        else if (!te && re)
                            A[$] = ue;
                        else if (re)
                            A[$] = Math.min(Q - se, ue - j < 0 ? ue : ue - j);
                        else {
                            if (!ce)
                                return !1;
                            A[$] = Math.max(he, fe + j + oe > ne ? fe : fe + j)
                        }
                    }
                      , Y = function($, ne, oe, se, le) {
                        let he;
                        return le < b || le > ne - b ? he = !1 : le < oe / 2 ? A[$] = 1 : le > ne - se / 2 ? A[$] = ne - se - 2 : A[$] = le - oe / 2,
                        he
                    }
                      , U = function($) {
                        let ne = V;
                        V = G,
                        G = ne,
                        ee = $
                    }
                      , Z = function() {
                        z.apply(0, V) !== !1 ? Y.apply(0, G) !== !1 || ee || (U(!0),
                        Z()) : ee ? A.x = A.y = 0 : (U(!0),
                        Z())
                    };
                    return (w.inverted || this.len > 1) && U(),
                    Z(),
                    A
                }
                hide(L) {
                    let I = this;
                    l.clearTimeout(this.hideTimer),
                    L = R(L, this.options.hideDelay),
                    this.isHidden || (this.hideTimer = P(function() {
                        let k = I.getLabel();
                        I.getLabel().animate({
                            opacity: 0
                        }, {
                            duration: L && 150,
                            complete: ()=>{
                                k.hide(),
                                I.container && I.container.remove()
                            }
                        }),
                        I.isHidden = !0
                    }, L))
                }
                init(L, I) {
                    this.chart = L,
                    this.options = I,
                    this.crosshairs = [],
                    this.now = {
                        x: 0,
                        y: 0
                    },
                    this.isHidden = !0,
                    this.split = I.split && !L.inverted && !L.polar,
                    this.shared = I.shared || this.split,
                    this.outside = R(I.outside, !!(L.scrollablePixelsX || L.scrollablePixelsY))
                }
                shouldStickOnContact(L) {
                    return !!(!this.followPointer && this.options.stickOnContact && (!L || this.chart.pointer.inClass(L.target, "highcharts-tooltip")))
                }
                move(L, I, k, w) {
                    let b = this
                      , A = b.now
                      , j = b.options.animation !== !1 && !b.isHidden && (Math.abs(L - A.x) > 1 || Math.abs(I - A.y) > 1)
                      , B = b.followPointer || b.len > 1;
                    v(A, {
                        x: j ? (2 * A.x + L) / 3 : L,
                        y: j ? (A.y + I) / 2 : I,
                        anchorX: B ? void 0 : j ? (2 * A.anchorX + k) / 3 : k,
                        anchorY: B ? void 0 : j ? (A.anchorY + w) / 2 : w
                    }),
                    b.getLabel().attr(A),
                    b.drawTracker(),
                    j && (l.clearTimeout(this.tooltipTimeout),
                    this.tooltipTimeout = setTimeout(function() {
                        b && b.move(L, I, k, w)
                    }, 32))
                }
                refresh(L, I) {
                    let k = this.chart
                      , w = this.options
                      , b = k.pointer
                      , A = F(L)
                      , j = A[0]
                      , B = []
                      , W = w.format
                      , N = w.formatter || this.defaultFormatter
                      , H = this.shared
                      , X = k.styledMode
                      , ie = {};
                    if (!w.enabled || !j.series)
                        return;
                    l.clearTimeout(this.hideTimer),
                    this.allowShared = !(!g(L) && L.series && L.series.noSharedTooltip),
                    this.followPointer = !this.split && j.series.tooltipOptions.followPointer;
                    let K = this.getAnchor(L, I)
                      , D = K[0]
                      , V = K[1];
                    H && this.allowShared ? (b.applyInactiveState(A),
                    A.forEach(function(J) {
                        J.setState("hover"),
                        B.push(J.getLabelConfig())
                    }),
                    (ie = j.getLabelConfig()).points = B) : ie = j.getLabelConfig(),
                    this.len = B.length;
                    let G = E(W) ? c(W, ie, k) : N.call(ie, this)
                      , ee = j.series;
                    if (this.distance = R(ee.tooltipOptions.distance, 16),
                    G === !1)
                        this.hide();
                    else {
                        if (this.split && this.allowShared)
                            this.renderSplit(G, A);
                        else {
                            let J = D
                              , te = V;
                            if (I && b.isDirectTouch && (J = I.chartX - k.plotLeft,
                            te = I.chartY - k.plotTop),
                            k.polar || ee.options.clip === !1 || A.some(z=>b.isDirectTouch || z.series.shouldShowTooltip(J, te))) {
                                let z = this.getLabel();
                                (!w.style.width || X) && z.css({
                                    width: (this.outside ? this.getPlayingField() : k.spacingBox).width + "px"
                                }),
                                z.attr({
                                    text: G && G.join ? G.join("") : G
                                }),
                                z.addClass(this.getClassName(j), !0),
                                X || z.attr({
                                    stroke: w.borderColor || j.color || ee.color || "#666666"
                                }),
                                this.updatePosition({
                                    plotX: D,
                                    plotY: V,
                                    negative: j.negative,
                                    ttBelow: j.ttBelow,
                                    h: K[2] || 0
                                })
                            } else {
                                this.hide();
                                return
                            }
                        }
                        this.isHidden && this.label && this.label.attr({
                            opacity: 1
                        }).show(),
                        this.isHidden = !1
                    }
                    p(this, "refresh")
                }
                renderSplit(L, I) {
                    let k = this
                      , {chart: w, chart: {chartWidth: b, chartHeight: A, plotHeight: j, plotLeft: B, plotTop: W, pointer: N, scrollablePixelsY: H=0, scrollablePixelsX: X, scrollingContainer: {scrollLeft: ie, scrollTop: K}={
                        scrollLeft: 0,
                        scrollTop: 0
                    }, styledMode: D}, distance: V, options: G, options: {positioner: ee}} = k
                      , J = k.outside && typeof X != "number" ? u.documentElement.getBoundingClientRect() : {
                        left: ie,
                        right: ie + b,
                        top: K,
                        bottom: K + A
                    }
                      , te = k.getLabel()
                      , z = this.renderer || w.renderer
                      , Y = !!(w.xAxis[0] && w.xAxis[0].opposite)
                      , {left: U, top: Z} = N.getChartPosition()
                      , $ = W + K
                      , ne = 0
                      , oe = j - H;
                    function se(re, ce, ue, fe, de=!0) {
                        let ge, ye;
                        return ue ? (ge = Y ? 0 : oe,
                        ye = f(re - fe / 2, J.left, J.right - fe - (k.outside ? U : 0))) : (ge = ce - $,
                        ye = f(ye = de ? re - fe - V : re + V, de ? ye : J.left, J.right)),
                        {
                            x: ye,
                            y: ge
                        }
                    }
                    E(L) && (L = [!1, L]);
                    let le = L.slice(0, I.length + 1).reduce(function(re, ce, ue) {
                        if (ce !== !1 && ce !== "") {
                            let fe = I[ue - 1] || {
                                isHeader: !0,
                                plotX: I[0].plotX,
                                plotY: j,
                                series: {}
                            }
                              , de = fe.isHeader
                              , ge = de ? k : fe.series
                              , ye = ge.tt = function(we, ve, _e) {
                                let Oe = we
                                  , {isHeader: ze, series: Qe} = ve;
                                if (!Oe) {
                                    let Fe = {
                                        padding: G.padding,
                                        r: G.borderRadius
                                    };
                                    D || (Fe.fill = G.backgroundColor,
                                    Fe["stroke-width"] = G.borderWidth ?? 1),
                                    Oe = z.label("", 0, 0, G[ze ? "headerShape" : "shape"], void 0, void 0, G.useHTML).addClass(k.getClassName(ve, !0, ze)).attr(Fe).add(te)
                                }
                                return Oe.isActive = !0,
                                Oe.attr({
                                    text: _e
                                }),
                                D || Oe.css(G.style).attr({
                                    stroke: G.borderColor || ve.color || Qe.color || "#333333"
                                }),
                                Oe
                            }(ge.tt, fe, ce.toString())
                              , pe = ye.getBBox()
                              , xe = pe.width + ye.strokeWidth();
                            de && (ne = pe.height,
                            oe += ne,
                            Y && ($ -= ne));
                            let {anchorX: ke, anchorY: Ee} = function(we) {
                                let ve, _e, {isHeader: Oe, plotX: ze=0, plotY: Qe=0, series: Fe} = we;
                                if (Oe)
                                    ve = Math.max(B + ze, B),
                                    _e = W + j / 2;
                                else {
                                    let {xAxis: rt, yAxis: Ne} = Fe;
                                    ve = rt.pos + f(ze, -V, rt.len + V),
                                    Fe.shouldShowTooltip(0, Ne.pos - W + Qe, {
                                        ignoreX: !0
                                    }) && (_e = Ne.pos + Qe)
                                }
                                return {
                                    anchorX: ve = f(ve, J.left - V, J.right + V),
                                    anchorY: _e
                                }
                            }(fe);
                            if (typeof Ee == "number") {
                                let we = pe.height + 1
                                  , ve = ee ? ee.call(k, xe, we, fe) : se(ke, Ee, de, xe);
                                re.push({
                                    align: ee ? 0 : void 0,
                                    anchorX: ke,
                                    anchorY: Ee,
                                    boxWidth: xe,
                                    point: fe,
                                    rank: R(ve.rank, de ? 1 : 0),
                                    size: we,
                                    target: ve.y,
                                    tt: ye,
                                    x: ve.x
                                })
                            } else
                                ye.isActive = !1
                        }
                        return re
                    }, []);
                    !ee && le.some(re=>{
                        let {outside: ce} = k
                          , ue = (ce ? U : 0) + re.anchorX;
                        return ue < J.left && ue + re.boxWidth < J.right || ue < U - J.left + re.boxWidth && J.right - ue > ue
                    }
                    ) && (le = le.map(re=>{
                        let {x: ce, y: ue} = se(re.anchorX, re.anchorY, re.point.isHeader, re.boxWidth, !1);
                        return v(re, {
                            target: ue,
                            x: ce
                        })
                    }
                    )),
                    k.cleanSplit(),
                    d(le, oe);
                    let he = {
                        left: U,
                        right: U
                    };
                    le.forEach(function(re) {
                        let {x: ce, boxWidth: ue, isHeader: fe} = re;
                        !fe && (k.outside && U + ce < he.left && (he.left = U + ce),
                        !fe && k.outside && he.left + ue > he.right && (he.right = U + ce))
                    }),
                    le.forEach(function(re) {
                        let {x: ce, anchorX: ue, anchorY: fe, pos: de, point: {isHeader: ge}} = re
                          , ye = {
                            visibility: de === void 0 ? "hidden" : "inherit",
                            x: ce,
                            y: (de || 0) + $,
                            anchorX: ue,
                            anchorY: fe
                        };
                        if (k.outside && ce < ue) {
                            let pe = U - he.left;
                            pe > 0 && (ge || (ye.x = ce + pe,
                            ye.anchorX = ue + pe),
                            ge && (ye.x = (he.right - he.left) / 2,
                            ye.anchorX = ue + pe))
                        }
                        re.tt.attr(ye)
                    });
                    let {container: Q, outside: q, renderer: ae} = k;
                    if (q && Q && ae) {
                        let {width: re, height: ce, x: ue, y: fe} = te.getBBox();
                        ae.setSize(re + ue, ce + fe, !1),
                        Q.style.left = he.left + "px",
                        Q.style.top = Z + "px"
                    }
                    h && te.attr({
                        opacity: te.opacity === 1 ? .999 : 1
                    })
                }
                drawTracker() {
                    if (!this.shouldStickOnContact()) {
                        this.tracker && (this.tracker = this.tracker.destroy());
                        return
                    }
                    let L = this.chart
                      , I = this.label
                      , k = this.shared ? L.hoverPoints : L.hoverPoint;
                    if (!I || !k)
                        return;
                    let w = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
                      , b = this.getAnchor(k)
                      , A = I.getBBox();
                    b[0] += L.plotLeft - (I.translateX || 0),
                    b[1] += L.plotTop - (I.translateY || 0),
                    w.x = Math.min(0, b[0]),
                    w.y = Math.min(0, b[1]),
                    w.width = b[0] < 0 ? Math.max(Math.abs(b[0]), A.width - b[0]) : Math.max(Math.abs(b[0]), A.width),
                    w.height = b[1] < 0 ? Math.max(Math.abs(b[1]), A.height - Math.abs(b[1])) : Math.max(Math.abs(b[1]), A.height),
                    this.tracker ? this.tracker.attr(w) : (this.tracker = I.renderer.rect(w).addClass("highcharts-tracker").add(I),
                    L.styledMode || this.tracker.attr({
                        fill: "rgba(0,0,0,0)"
                    }))
                }
                styledModeFormat(L) {
                    return L.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"')
                }
                tooltipFooterHeaderFormatter(L, I) {
                    let k = L.series
                      , w = k.tooltipOptions
                      , b = k.xAxis
                      , A = b && b.dateTime
                      , j = {
                        isFooter: I,
                        labelConfig: L
                    }
                      , B = w.xDateFormat
                      , W = w[I ? "footerFormat" : "headerFormat"];
                    return p(this, "headerFormatter", j, function(N) {
                        A && !B && C(L.key) && (B = A.getXDateFormat(L.key, w.dateTimeLabelFormats)),
                        A && B && (L.point && L.point.tooltipDateKeys || ["key"]).forEach(function(H) {
                            W = W.replace("{point." + H + "}", "{point." + H + ":" + B + "}")
                        }),
                        k.chart.styledMode && (W = this.styledModeFormat(W)),
                        N.text = c(W, {
                            point: L,
                            series: k
                        }, this.chart)
                    }),
                    j.text
                }
                update(L) {
                    this.destroy(),
                    this.init(this.chart, O(!0, this.options, L))
                }
                updatePosition(L) {
                    let {chart: I, container: k, distance: w, options: b, renderer: A} = this, {height: j=0, width: B=0} = this.getLabel(), W = I.pointer, {left: N, top: H, scaleX: X, scaleY: ie} = W.getChartPosition(), K = (b.positioner || this.getPosition).call(this, B, j, L), D = (L.plotX || 0) + I.plotLeft, V = (L.plotY || 0) + I.plotTop, G;
                    A && k && (b.positioner && (K.x += N - w,
                    K.y += H - w),
                    G = (b.borderWidth || 0) + 2 * w + 2,
                    A.setSize(B + G, j + G, !1),
                    (X !== 1 || ie !== 1) && (x(k, {
                        transform: `scale(${X}, ${ie})`
                    }),
                    D *= X,
                    V *= ie),
                    D += N - K.x,
                    V += H - K.y),
                    this.move(Math.round(K.x), Math.round(K.y || 0), D, V)
                }
            }
            return function(T) {
                let L = [];
                T.compose = function(I) {
                    l.pushUnique(L, I) && m(I, "afterInit", function() {
                        let k = this.chart;
                        k.options.tooltip && (k.tooltip = new T(k,k.options.tooltip))
                    })
                }
            }(_ || (_ = {})),
            _
        }),
        i(n, "Core/Series/Point.js", [n["Core/Renderer/HTML/AST.js"], n["Core/Animation/AnimationUtilities.js"], n["Core/Defaults.js"], n["Core/Templating.js"], n["Core/Utilities.js"]], function(r, s, o, a, l) {
            let {animObject: c} = s
              , {defaultOptions: u} = o
              , {format: h} = a
              , {addEvent: d, defined: m, erase: f, extend: x, fireEvent: S, getNestedProperty: v, isArray: p, isFunction: g, isNumber: C, isObject: E, merge: O, objectEach: R, pick: F, syncTimeout: P, removeEvent: _, uniqueKey: T} = l;
            class L {
                constructor() {
                    this.category = void 0,
                    this.destroyed = !1,
                    this.formatPrefix = "point",
                    this.id = void 0,
                    this.isNull = !1,
                    this.name = void 0,
                    this.options = void 0,
                    this.percentage = void 0,
                    this.selected = !1,
                    this.series = void 0,
                    this.shapeArgs = void 0,
                    this.total = void 0,
                    this.visible = !0,
                    this.x = void 0
                }
                animateBeforeDestroy() {
                    let k = this
                      , w = {
                        x: k.startXPos,
                        opacity: 0
                    }
                      , b = k.getGraphicalProps();
                    b.singular.forEach(function(A) {
                        k[A] = k[A].animate(A === "dataLabel" ? {
                            x: k[A].startXPos,
                            y: k[A].startYPos,
                            opacity: 0
                        } : w)
                    }),
                    b.plural.forEach(function(A) {
                        k[A].forEach(function(j) {
                            j.element && j.animate(x({
                                x: k.startXPos
                            }, j.startYPos ? {
                                x: j.startXPos,
                                y: j.startYPos
                            } : {}))
                        })
                    })
                }
                applyOptions(k, w) {
                    let b = this.series
                      , A = b.options.pointValKey || b.pointValKey;
                    return x(this, k = L.prototype.optionsToObject.call(this, k)),
                    this.options = this.options ? x(this.options, k) : k,
                    k.group && delete this.group,
                    k.dataLabels && delete this.dataLabels,
                    A && (this.y = L.prototype.getNestedProperty.call(this, A)),
                    this.selected && (this.state = "select"),
                    "name"in this && w === void 0 && b.xAxis && b.xAxis.hasNames && (this.x = b.xAxis.nameToX(this)),
                    this.x === void 0 && b ? w === void 0 ? this.x = b.autoIncrement() : this.x = w : C(k.x) && b.options.relativeXValue && (this.x = b.autoIncrement(k.x)),
                    this.isNull = this.isValid && !this.isValid(),
                    this.formatPrefix = this.isNull ? "null" : "point",
                    this
                }
                destroy() {
                    if (!this.destroyed) {
                        let k = this
                          , w = k.series
                          , b = w.chart
                          , A = w.options.dataSorting
                          , j = b.hoverPoints
                          , B = k.series.chart.renderer.globalAnimation
                          , W = c(B)
                          , N = ()=>{
                            for (let H in (k.graphic || k.graphics || k.dataLabel || k.dataLabels) && (_(k),
                            k.destroyElements()),
                            k)
                                delete k[H]
                        }
                        ;
                        k.legendItem && b.legend.destroyItem(k),
                        j && (k.setState(),
                        f(j, k),
                        j.length || (b.hoverPoints = null)),
                        k === b.hoverPoint && k.onMouseOut(),
                        A && A.enabled ? (this.animateBeforeDestroy(),
                        P(N, W.duration)) : N(),
                        b.pointCount--
                    }
                    this.destroyed = !0
                }
                destroyElements(k) {
                    let w = this
                      , b = w.getGraphicalProps(k);
                    b.singular.forEach(function(A) {
                        w[A] = w[A].destroy()
                    }),
                    b.plural.forEach(function(A) {
                        w[A].forEach(function(j) {
                            j && j.element && j.destroy()
                        }),
                        delete w[A]
                    })
                }
                firePointEvent(k, w, b) {
                    let A = this
                      , j = this.series
                      , B = j.options;
                    (B.point.events[k] || A.options && A.options.events && A.options.events[k]) && A.importEvents(),
                    k === "click" && B.allowPointSelect && (b = function(W) {
                        !A.destroyed && A.select && A.select(null, W.ctrlKey || W.metaKey || W.shiftKey)
                    }
                    ),
                    S(A, k, w, b)
                }
                getClassName() {
                    return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (this.colorIndex !== void 0 ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "")
                }
                getGraphicalProps(k) {
                    let w, b, A = this, j = [], B = {
                        singular: [],
                        plural: []
                    };
                    for ((k = k || {
                        graphic: 1,
                        dataLabel: 1
                    }).graphic && j.push("graphic", "connector"),
                    k.dataLabel && j.push("dataLabel", "dataLabelPath", "dataLabelUpper"),
                    b = j.length; b--; )
                        A[w = j[b]] && B.singular.push(w);
                    return ["graphic", "dataLabel"].forEach(function(W) {
                        let N = W + "s";
                        k[W] && A[N] && B.plural.push(N)
                    }),
                    B
                }
                getLabelConfig() {
                    return {
                        x: this.category,
                        y: this.y,
                        color: this.color,
                        colorIndex: this.colorIndex,
                        key: this.name || this.category,
                        series: this.series,
                        point: this,
                        percentage: this.percentage,
                        total: this.total || this.stackTotal
                    }
                }
                getNestedProperty(k) {
                    return k ? k.indexOf("custom.") === 0 ? v(k, this.options) : this[k] : void 0
                }
                getZone() {
                    let k = this.series, w = k.zones, b = k.zoneAxis || "y", A, j = 0;
                    for (A = w[0]; this[b] >= A.value; )
                        A = w[++j];
                    return this.nonZonedColor || (this.nonZonedColor = this.color),
                    A && A.color && !this.options.color ? this.color = A.color : this.color = this.nonZonedColor,
                    A
                }
                hasNewShapeType() {
                    return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType
                }
                init(k, w, b) {
                    return this.series = k,
                    this.applyOptions(w, b),
                    this.id = m(this.id) ? this.id : T(),
                    this.resolveColor(),
                    k.chart.pointCount++,
                    S(this, "afterInit"),
                    this
                }
                isValid() {
                    return (C(this.x) || this.x instanceof Date) && C(this.y)
                }
                optionsToObject(k) {
                    let w = this.series, b = w.options.keys, A = b || w.pointArrayMap || ["y"], j = A.length, B = {}, W, N = 0, H = 0;
                    if (C(k) || k === null)
                        B[A[0]] = k;
                    else if (p(k))
                        for (!b && k.length > j && ((W = typeof k[0]) == "string" ? B.name = k[0] : W === "number" && (B.x = k[0]),
                        N++); H < j; )
                            b && k[N] === void 0 || (A[H].indexOf(".") > 0 ? L.prototype.setNestedProperty(B, k[N], A[H]) : B[A[H]] = k[N]),
                            N++,
                            H++;
                    else
                        typeof k == "object" && (B = k,
                        k.dataLabels && (w.hasDataLabels = ()=>!0),
                        k.marker && (w._hasPointMarkers = !0));
                    return B
                }
                pos(k, w=this.plotY) {
                    if (!this.destroyed) {
                        let {plotX: b, series: A} = this
                          , {chart: j, xAxis: B, yAxis: W} = A
                          , N = 0
                          , H = 0;
                        if (C(b) && C(w))
                            return k && (N = B ? B.pos : j.plotLeft,
                            H = W ? W.pos : j.plotTop),
                            j.inverted && B && W ? [W.len - w + H, B.len - b + N] : [b + N, w + H]
                    }
                }
                resolveColor() {
                    let k = this.series, w = k.chart.options.chart, b = k.chart.styledMode, A, j, B = w.colorCount, W;
                    delete this.nonZonedColor,
                    k.options.colorByPoint ? (b || (A = (j = k.options.colors || k.chart.options.colors)[k.colorCounter],
                    B = j.length),
                    W = k.colorCounter,
                    k.colorCounter++,
                    k.colorCounter === B && (k.colorCounter = 0)) : (b || (A = k.color),
                    W = k.colorIndex),
                    this.colorIndex = F(this.options.colorIndex, W),
                    this.color = F(this.options.color, A)
                }
                setNestedProperty(k, w, b) {
                    return b.split(".").reduce(function(j, B, W, N) {
                        let H = N.length - 1 === W;
                        return j[B] = H ? w : E(j[B], !0) ? j[B] : {},
                        j[B]
                    }, k),
                    k
                }
                shouldDraw() {
                    return !this.isNull
                }
                tooltipFormatter(k) {
                    let w = this.series
                      , b = w.tooltipOptions
                      , A = F(b.valueDecimals, "")
                      , j = b.valuePrefix || ""
                      , B = b.valueSuffix || "";
                    return w.chart.styledMode && (k = w.chart.tooltip.styledModeFormat(k)),
                    (w.pointArrayMap || ["y"]).forEach(function(W) {
                        W = "{point." + W,
                        (j || B) && (k = k.replace(RegExp(W + "}", "g"), j + W + "}" + B)),
                        k = k.replace(RegExp(W + "}", "g"), W + ":,." + A + "f}")
                    }),
                    h(k, {
                        point: this,
                        series: this.series
                    }, w.chart)
                }
                update(k, w, b, A) {
                    let j, B = this, W = B.series, N = B.graphic, H = W.chart, X = W.options;
                    function ie() {
                        B.applyOptions(k);
                        let K = N && B.hasMockGraphic
                          , D = B.y === null ? !K : K;
                        N && D && (B.graphic = N.destroy(),
                        delete B.hasMockGraphic),
                        E(k, !0) && (N && N.element && k && k.marker && k.marker.symbol !== void 0 && (B.graphic = N.destroy()),
                        k != null && k.dataLabels && B.dataLabel && (B.dataLabel = B.dataLabel.destroy())),
                        j = B.index,
                        W.updateParallelArrays(B, j),
                        X.data[j] = E(X.data[j], !0) || E(k, !0) ? B.options : F(k, X.data[j]),
                        W.isDirty = W.isDirtyData = !0,
                        !W.fixedBox && W.hasCartesianSeries && (H.isDirtyBox = !0),
                        X.legendType === "point" && (H.isDirtyLegend = !0),
                        w && H.redraw(b)
                    }
                    w = F(w, !0),
                    A === !1 ? ie() : B.firePointEvent("update", {
                        options: k
                    }, ie)
                }
                remove(k, w) {
                    this.series.removePoint(this.series.data.indexOf(this), k, w)
                }
                select(k, w) {
                    let b = this
                      , A = b.series
                      , j = A.chart;
                    k = F(k, !b.selected),
                    this.selectedStaging = k,
                    b.firePointEvent(k ? "select" : "unselect", {
                        accumulate: w
                    }, function() {
                        b.selected = b.options.selected = k,
                        A.options.data[A.data.indexOf(b)] = b.options,
                        b.setState(k && "select"),
                        w || j.getSelectedPoints().forEach(function(B) {
                            let W = B.series;
                            B.selected && B !== b && (B.selected = B.options.selected = !1,
                            W.options.data[W.data.indexOf(B)] = B.options,
                            B.setState(j.hoverPoints && W.options.inactiveOtherPoints ? "inactive" : ""),
                            B.firePointEvent("unselect"))
                        })
                    }),
                    delete this.selectedStaging
                }
                onMouseOver(k) {
                    let w = this.series
                      , b = w.chart
                      , A = b.pointer;
                    k = k ? A.normalize(k) : A.getChartCoordinatesFromPoint(this, b.inverted),
                    A.runPointActions(k, this)
                }
                onMouseOut() {
                    let k = this.series.chart;
                    this.firePointEvent("mouseOut"),
                    this.series.options.inactiveOtherPoints || (k.hoverPoints || []).forEach(function(w) {
                        w.setState()
                    }),
                    k.hoverPoints = k.hoverPoint = null
                }
                importEvents() {
                    if (!this.hasImportedEvents) {
                        let k = this
                          , w = O(k.series.options.point, k.options)
                          , b = w.events;
                        k.events = b,
                        R(b, function(A, j) {
                            g(A) && d(k, j, A)
                        }),
                        this.hasImportedEvents = !0
                    }
                }
                setState(k, w) {
                    let b = this.series, A = this.state, j = b.options.states[k || "normal"] || {}, B = u.plotOptions[b.type].marker && b.options.marker, W = B && B.enabled === !1, N = B && B.states && B.states[k || "normal"] || {}, H = N.enabled === !1, X = this.marker || {}, ie = b.chart, K = B && b.markerAttribs, D = b.halo, V, G, ee, J = b.stateMarkerGraphic, te;
                    if ((k = k || "") === this.state && !w || this.selected && k !== "select" || j.enabled === !1 || k && (H || W && N.enabled === !1) || k && X.states && X.states[k] && X.states[k].enabled === !1)
                        return;
                    if (this.state = k,
                    K && (V = b.markerAttribs(this, k)),
                    this.graphic && !this.hasMockGraphic) {
                        if (A && this.graphic.removeClass("highcharts-point-" + A),
                        k && this.graphic.addClass("highcharts-point-" + k),
                        !ie.styledMode) {
                            G = b.pointAttribs(this, k),
                            ee = F(ie.options.chart.animation, j.animation);
                            let Z = G.opacity;
                            b.options.inactiveOtherPoints && C(Z) && (this.dataLabels || []).forEach(function($) {
                                $ && !$.hasClass("highcharts-data-label-hidden") && ($.animate({
                                    opacity: Z
                                }, ee),
                                $.connector && $.connector.animate({
                                    opacity: Z
                                }, ee))
                            }),
                            this.graphic.animate(G, ee)
                        }
                        V && this.graphic.animate(V, F(ie.options.chart.animation, N.animation, B.animation)),
                        J && J.hide()
                    } else
                        k && N && (te = X.symbol || b.symbol,
                        J && J.currentSymbol !== te && (J = J.destroy()),
                        V && (J ? J[w ? "animate" : "attr"]({
                            x: V.x,
                            y: V.y
                        }) : te && (b.stateMarkerGraphic = J = ie.renderer.symbol(te, V.x, V.y, V.width, V.height).add(b.markerGroup),
                        J.currentSymbol = te)),
                        !ie.styledMode && J && this.state !== "inactive" && J.attr(b.pointAttribs(this, k))),
                        J && (J[k && this.isInside ? "show" : "hide"](),
                        J.element.point = this,
                        J.addClass(this.getClassName(), !0));
                    let z = j.halo
                      , Y = this.graphic || J
                      , U = Y && Y.visibility || "inherit";
                    z && z.size && Y && U !== "hidden" && !this.isCluster ? (D || (b.halo = D = ie.renderer.path().add(Y.parentGroup)),
                    D.show()[w ? "animate" : "attr"]({
                        d: this.haloPath(z.size)
                    }),
                    D.attr({
                        class: "highcharts-halo highcharts-color-" + F(this.colorIndex, b.colorIndex) + (this.className ? " " + this.className : ""),
                        visibility: U,
                        zIndex: -1
                    }),
                    D.point = this,
                    ie.styledMode || D.attr(x({
                        fill: this.color || b.color,
                        "fill-opacity": z.opacity
                    }, r.filterUserAttributes(z.attributes || {})))) : D && D.point && D.point.haloPath && D.animate({
                        d: D.point.haloPath(0)
                    }, null, D.hide),
                    S(this, "afterSetState", {
                        state: k
                    })
                }
                haloPath(k) {
                    let w = this.pos();
                    return w ? this.series.chart.renderer.symbols.circle(Math.floor(w[0]) - k, w[1] - k, 2 * k, 2 * k) : []
                }
            }
            return L
        }),
        i(n, "Core/Pointer.js", [n["Core/Color/Color.js"], n["Core/Globals.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {parse: a} = r
              , {charts: l, noop: c} = s
              , {addEvent: u, attr: h, css: d, defined: m, extend: f, find: x, fireEvent: S, isNumber: v, isObject: p, objectEach: g, offset: C, pick: E, splat: O} = o;
            class R {
                constructor(P, _) {
                    this.lastValidTouch = {},
                    this.pinchDown = [],
                    this.runChartClick = !1,
                    this.eventsToUnbind = [],
                    this.chart = P,
                    this.hasDragged = !1,
                    this.options = _,
                    this.init(P, _)
                }
                applyInactiveState(P) {
                    let _ = [], T;
                    (P || []).forEach(function(L) {
                        T = L.series,
                        _.push(T),
                        T.linkedParent && _.push(T.linkedParent),
                        T.linkedSeries && (_ = _.concat(T.linkedSeries)),
                        T.navigatorSeries && _.push(T.navigatorSeries)
                    }),
                    this.chart.series.forEach(function(L) {
                        _.indexOf(L) === -1 ? L.setState("inactive", !0) : L.options.inactiveOtherPoints && L.setAllPointsToState("inactive")
                    })
                }
                destroy() {
                    let P = this;
                    this.eventsToUnbind.forEach(_=>_()),
                    this.eventsToUnbind = [],
                    !s.chartCount && (R.unbindDocumentMouseUp && (R.unbindDocumentMouseUp = R.unbindDocumentMouseUp()),
                    R.unbindDocumentTouchEnd && (R.unbindDocumentTouchEnd = R.unbindDocumentTouchEnd())),
                    clearInterval(P.tooltipTimeout),
                    g(P, function(_, T) {
                        P[T] = void 0
                    })
                }
                getSelectionMarkerAttrs(P, _) {
                    let T = {
                        args: {
                            chartX: P,
                            chartY: _
                        },
                        attrs: {},
                        shapeType: "rect"
                    };
                    return S(this, "getSelectionMarkerAttrs", T, L=>{
                        let I, {chart: k, mouseDownX: w=0, mouseDownY: b=0, zoomHor: A, zoomVert: j} = this, B = L.attrs;
                        B.x = k.plotLeft,
                        B.y = k.plotTop,
                        B.width = A ? 1 : k.plotWidth,
                        B.height = j ? 1 : k.plotHeight,
                        A && (I = P - w,
                        B.width = Math.abs(I),
                        B.x = (I > 0 ? 0 : I) + w),
                        j && (I = _ - b,
                        B.height = Math.abs(I),
                        B.y = (I > 0 ? 0 : I) + b)
                    }
                    ),
                    T
                }
                drag(P) {
                    let _ = this.chart, T = _.options.chart, L = _.plotLeft, I = _.plotTop, k = _.plotWidth, w = _.plotHeight, b = this.mouseDownX || 0, A = this.mouseDownY || 0, j = p(T.panning) ? T.panning && T.panning.enabled : T.panning, B = T.panKey && P[T.panKey + "Key"], W = P.chartX, N = P.chartY, H, X = this.selectionMarker;
                    if ((!X || !X.touch) && (W < L ? W = L : W > L + k && (W = L + k),
                    N < I ? N = I : N > I + w && (N = I + w),
                    this.hasDragged = Math.sqrt(Math.pow(b - W, 2) + Math.pow(A - N, 2)),
                    this.hasDragged > 10)) {
                        H = _.isInsidePlot(b - L, A - I, {
                            visiblePlotOnly: !0
                        });
                        let {shapeType: ie, attrs: K} = this.getSelectionMarkerAttrs(W, N);
                        (_.hasCartesianSeries || _.mapView) && (this.zoomX || this.zoomY) && H && !B && !X && (this.selectionMarker = X = _.renderer[ie](),
                        X.attr({
                            class: "highcharts-selection-marker",
                            zIndex: 7
                        }).add(),
                        _.styledMode || X.attr({
                            fill: T.selectionMarkerFill || a("#334eff").setOpacity(.25).get()
                        })),
                        X && X.attr(K),
                        H && !X && j && _.pan(P, T.panning)
                    }
                }
                dragStart(P) {
                    let _ = this.chart;
                    _.mouseIsDown = P.type,
                    _.cancelClick = !1,
                    _.mouseDownX = this.mouseDownX = P.chartX,
                    _.mouseDownY = this.mouseDownY = P.chartY
                }
                getSelectionBox(P) {
                    let _ = {
                        args: {
                            marker: P
                        },
                        result: {}
                    };
                    return S(this, "getSelectionBox", _, T=>{
                        T.result = {
                            x: P.attr ? +P.attr("x") : P.x,
                            y: P.attr ? +P.attr("y") : P.y,
                            width: P.attr ? P.attr("width") : P.width,
                            height: P.attr ? P.attr("height") : P.height
                        }
                    }
                    ),
                    _.result
                }
                drop(P) {
                    let _ = this
                      , T = this.chart
                      , L = this.hasPinched;
                    if (this.selectionMarker) {
                        let {x: I, y: k, width: w, height: b} = this.getSelectionBox(this.selectionMarker)
                          , A = {
                            originalEvent: P,
                            xAxis: [],
                            yAxis: [],
                            x: I,
                            y: k,
                            width: w,
                            height: b
                        }
                          , j = !!T.mapView;
                        (this.hasDragged || L) && (T.axes.forEach(function(B) {
                            if (B.zoomEnabled && m(B.min) && (L || _[{
                                xAxis: "zoomX",
                                yAxis: "zoomY"
                            }[B.coll]]) && v(I) && v(k) && v(w) && v(b)) {
                                let W = B.horiz
                                  , N = P.type === "touchend" ? B.minPixelPadding : 0
                                  , H = B.toValue((W ? I : k) + N)
                                  , X = B.toValue((W ? I + w : k + b) - N);
                                A[B.coll].push({
                                    axis: B,
                                    min: Math.min(H, X),
                                    max: Math.max(H, X)
                                }),
                                j = !0
                            }
                        }),
                        j && S(T, "selection", A, function(B) {
                            T.zoom(f(B, L ? {
                                animation: !1
                            } : null))
                        })),
                        v(T.index) && (this.selectionMarker = this.selectionMarker.destroy()),
                        L && this.scaleGroups()
                    }
                    T && v(T.index) && (d(T.container, {
                        cursor: T._cursor
                    }),
                    T.cancelClick = +this.hasDragged > 10,
                    T.mouseIsDown = this.hasDragged = this.hasPinched = !1,
                    this.pinchDown = [])
                }
                findNearestKDPoint(P, _, T) {
                    let L;
                    return P.forEach(function(I) {
                        let k = I.noSharedTooltip && _
                          , w = !k && 0 > I.options.findNearestPointBy.indexOf("y")
                          , b = I.searchPoint(T, w);
                        p(b, !0) && b.series && (!p(L, !0) || function(A, j) {
                            let B = A.distX - j.distX
                              , W = A.dist - j.dist
                              , N = (j.series.group && j.series.group.zIndex) - (A.series.group && A.series.group.zIndex);
                            return B !== 0 && _ ? B : W !== 0 ? W : N !== 0 ? N : A.series.index > j.series.index ? -1 : 1
                        }(L, b) > 0) && (L = b)
                    }),
                    L
                }
                getChartCoordinatesFromPoint(P, _) {
                    let T = P.series
                      , L = T.xAxis
                      , I = T.yAxis
                      , k = P.shapeArgs;
                    if (L && I) {
                        let w = E(P.clientX, P.plotX)
                          , b = P.plotY || 0;
                        return P.isNode && k && v(k.x) && v(k.y) && (w = k.x,
                        b = k.y),
                        _ ? {
                            chartX: I.len + I.pos - b,
                            chartY: L.len + L.pos - w
                        } : {
                            chartX: w + L.pos,
                            chartY: b + I.pos
                        }
                    }
                    if (k && k.x && k.y)
                        return {
                            chartX: k.x,
                            chartY: k.y
                        }
                }
                getChartPosition() {
                    if (this.chartPosition)
                        return this.chartPosition;
                    let {container: P} = this.chart
                      , _ = C(P);
                    this.chartPosition = {
                        left: _.left,
                        top: _.top,
                        scaleX: 1,
                        scaleY: 1
                    };
                    let T = P.offsetWidth
                      , L = P.offsetHeight;
                    return T > 2 && L > 2 && (this.chartPosition.scaleX = _.width / T,
                    this.chartPosition.scaleY = _.height / L),
                    this.chartPosition
                }
                getCoordinates(P) {
                    let _ = {
                        xAxis: [],
                        yAxis: []
                    };
                    return this.chart.axes.forEach(function(T) {
                        _[T.isXAxis ? "xAxis" : "yAxis"].push({
                            axis: T,
                            value: T.toValue(P[T.horiz ? "chartX" : "chartY"])
                        })
                    }),
                    _
                }
                getHoverData(P, _, T, L, I, k) {
                    let w = [], b = function(H) {
                        return H.visible && !(!I && H.directTouch) && E(H.options.enableMouseTracking, !0)
                    }, A = _, j, B = {
                        chartX: k ? k.chartX : void 0,
                        chartY: k ? k.chartY : void 0,
                        shared: I
                    };
                    S(this, "beforeGetHoverData", B),
                    j = A && !A.stickyTracking ? [A] : T.filter(H=>H.stickyTracking && (B.filter || b)(H));
                    let N = L && P || !k ? P : this.findNearestKDPoint(j, I, k);
                    return A = N && N.series,
                    N && (I && !A.noSharedTooltip ? (j = T.filter(function(H) {
                        return B.filter ? B.filter(H) : b(H) && !H.noSharedTooltip
                    })).forEach(function(H) {
                        let X = x(H.points, function(ie) {
                            return ie.x === N.x && !ie.isNull
                        });
                        p(X) && (H.boosted && H.boost && (X = H.boost.getPoint(X)),
                        w.push(X))
                    }) : w.push(N)),
                    S(this, "afterGetHoverData", B = {
                        hoverPoint: N
                    }),
                    {
                        hoverPoint: B.hoverPoint,
                        hoverSeries: A,
                        hoverPoints: w
                    }
                }
                getPointFromEvent(P) {
                    let _ = P.target, T;
                    for (; _ && !T; )
                        T = _.point,
                        _ = _.parentNode;
                    return T
                }
                onTrackerMouseOut(P) {
                    let _ = this.chart
                      , T = P.relatedTarget
                      , L = _.hoverSeries;
                    this.isDirectTouch = !1,
                    !L || !T || L.stickyTracking || this.inClass(T, "highcharts-tooltip") || this.inClass(T, "highcharts-series-" + L.index) && this.inClass(T, "highcharts-tracker") || L.onMouseOut()
                }
                inClass(P, _) {
                    let T = P, L;
                    for (; T; ) {
                        if (L = h(T, "class")) {
                            if (L.indexOf(_) !== -1)
                                return !0;
                            if (L.indexOf("highcharts-container") !== -1)
                                return !1
                        }
                        T = T.parentElement
                    }
                }
                init(P, _) {
                    this.options = _,
                    this.chart = P,
                    this.runChartClick = !!(_.chart.events && _.chart.events.click),
                    this.pinchDown = [],
                    this.lastValidTouch = {},
                    this.setDOMEvents(),
                    S(this, "afterInit")
                }
                normalize(P, _) {
                    let T = P.touches
                      , L = T ? T.length ? T.item(0) : E(T.changedTouches, P.changedTouches)[0] : P;
                    _ || (_ = this.getChartPosition());
                    let I = L.pageX - _.left
                      , k = L.pageY - _.top;
                    return f(P, {
                        chartX: Math.round(I /= _.scaleX),
                        chartY: Math.round(k /= _.scaleY)
                    })
                }
                onContainerClick(P) {
                    let _ = this.chart
                      , T = _.hoverPoint
                      , L = this.normalize(P)
                      , I = _.plotLeft
                      , k = _.plotTop;
                    !_.cancelClick && (T && this.inClass(L.target, "highcharts-tracker") ? (S(T.series, "click", f(L, {
                        point: T
                    })),
                    _.hoverPoint && T.firePointEvent("click", L)) : (f(L, this.getCoordinates(L)),
                    _.isInsidePlot(L.chartX - I, L.chartY - k, {
                        visiblePlotOnly: !0
                    }) && S(_, "click", L)))
                }
                onContainerMouseDown(P) {
                    let _ = (1 & (P.buttons || P.button)) == 1;
                    P = this.normalize(P),
                    s.isFirefox && P.button !== 0 && this.onContainerMouseMove(P),
                    (P.button === void 0 || _) && (this.zoomOption(P),
                    _ && P.preventDefault && P.preventDefault(),
                    this.dragStart(P))
                }
                onContainerMouseLeave(P) {
                    let _ = l[E(R.hoverChartIndex, -1)];
                    P = this.normalize(P),
                    this.onContainerMouseMove(P),
                    _ && P.relatedTarget && !this.inClass(P.relatedTarget, "highcharts-tooltip") && (_.pointer.reset(),
                    _.pointer.chartPosition = void 0)
                }
                onContainerMouseEnter(P) {
                    delete this.chartPosition
                }
                onContainerMouseMove(P) {
                    let _ = this.chart
                      , T = _.tooltip
                      , L = this.normalize(P);
                    this.setHoverChartIndex(P),
                    (_.mouseIsDown === "mousedown" || this.touchSelect(L)) && this.drag(L),
                    !_.openMenu && (this.inClass(L.target, "highcharts-tracker") || _.isInsidePlot(L.chartX - _.plotLeft, L.chartY - _.plotTop, {
                        visiblePlotOnly: !0
                    })) && !(T && T.shouldStickOnContact(L)) && (this.inClass(L.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(L))
                }
                onDocumentTouchEnd(P) {
                    let _ = l[E(R.hoverChartIndex, -1)];
                    _ && _.pointer.drop(P)
                }
                onContainerTouchMove(P) {
                    this.touchSelect(P) ? this.onContainerMouseMove(P) : this.touch(P)
                }
                onContainerTouchStart(P) {
                    this.touchSelect(P) ? this.onContainerMouseDown(P) : (this.zoomOption(P),
                    this.touch(P, !0))
                }
                onDocumentMouseMove(P) {
                    let _ = this.chart
                      , T = _.tooltip
                      , L = this.chartPosition
                      , I = this.normalize(P, L);
                    !L || _.isInsidePlot(I.chartX - _.plotLeft, I.chartY - _.plotTop, {
                        visiblePlotOnly: !0
                    }) || T && T.shouldStickOnContact(I) || this.inClass(I.target, "highcharts-tracker") || this.reset()
                }
                onDocumentMouseUp(P) {
                    let _ = l[E(R.hoverChartIndex, -1)];
                    _ && _.pointer.drop(P)
                }
                pinch(P) {
                    let _ = this
                      , T = _.chart
                      , L = _.pinchDown
                      , I = P.touches || []
                      , k = I.length
                      , w = _.lastValidTouch
                      , b = _.hasZoom
                      , A = {}
                      , j = k === 1 && (_.inClass(P.target, "highcharts-tracker") && T.runTrackerClick || _.runChartClick)
                      , B = {}
                      , W = _.chart.tooltip
                      , N = k === 1 && E(W && W.options.followTouchMove, !0)
                      , H = _.selectionMarker;
                    k > 1 ? _.initiated = !0 : N && (_.initiated = !1),
                    b && _.initiated && !j && P.cancelable !== !1 && P.preventDefault(),
                    [].map.call(I, function(X) {
                        return _.normalize(X)
                    }),
                    P.type === "touchstart" ? ([].forEach.call(I, function(X, ie) {
                        L[ie] = {
                            chartX: X.chartX,
                            chartY: X.chartY
                        }
                    }),
                    w.x = [L[0].chartX, L[1] && L[1].chartX],
                    w.y = [L[0].chartY, L[1] && L[1].chartY],
                    T.axes.forEach(function(X) {
                        if (X.zoomEnabled) {
                            let ie = T.bounds[X.horiz ? "h" : "v"]
                              , K = X.minPixelPadding
                              , D = X.toPixels(Math.min(E(X.options.min, X.dataMin), X.dataMin))
                              , V = X.toPixels(Math.max(E(X.options.max, X.dataMax), X.dataMax))
                              , G = Math.min(D, V)
                              , ee = Math.max(D, V);
                            ie.min = Math.min(X.pos, G - K),
                            ie.max = Math.max(X.pos + X.len, ee + K)
                        }
                    }),
                    _.res = !0) : N ? this.runPointActions(_.normalize(P)) : L.length && (S(T, "touchpan", {
                        originalEvent: P
                    }, ()=>{
                        H || (_.selectionMarker = H = f({
                            destroy: c,
                            touch: !0
                        }, T.plotBox)),
                        _.pinchTranslate(L, I, A, H, B, w),
                        _.hasPinched = b,
                        _.scaleGroups(A, B)
                    }
                    ),
                    _.res && (_.res = !1,
                    this.reset(!1, 0)))
                }
                pinchTranslate(P, _, T, L, I, k) {
                    this.zoomHor && this.pinchTranslateDirection(!0, P, _, T, L, I, k),
                    this.zoomVert && this.pinchTranslateDirection(!1, P, _, T, L, I, k)
                }
                pinchTranslateDirection(P, _, T, L, I, k, w, b) {
                    let A = this.chart, j = P ? "x" : "y", B = P ? "X" : "Y", W = "chart" + B, N = P ? "width" : "height", H = A["plot" + (P ? "Left" : "Top")], X = A.inverted, ie = A.bounds[P ? "h" : "v"], K = _.length === 1, D = _[0][W], V = !K && _[1][W], G = function() {
                        typeof U == "number" && Math.abs(D - V) > 20 && (z = b || Math.abs(Y - U) / Math.abs(D - V)),
                        te = (H - Y) / z + D,
                        ee = A["plot" + (P ? "Width" : "Height")] / z
                    }, ee, J, te, z = b || 1, Y = T[0][W], U = !K && T[1][W], Z;
                    G(),
                    (J = te) < ie.min ? (J = ie.min,
                    Z = !0) : J + ee > ie.max && (J = ie.max - ee,
                    Z = !0),
                    Z ? (Y -= .8 * (Y - w[j][0]),
                    typeof U == "number" && (U -= .8 * (U - w[j][1])),
                    G()) : w[j] = [Y, U],
                    X || (k[j] = te - H,
                    k[N] = ee);
                    let $ = X ? P ? "scaleY" : "scaleX" : "scale" + B
                      , ne = X ? 1 / z : z;
                    I[N] = ee,
                    I[j] = J,
                    L[$] = z * (X && !P ? -1 : 1),
                    L["translate" + B] = ne * H + (Y - ne * D)
                }
                reset(P, _) {
                    let T = this.chart
                      , L = T.hoverSeries
                      , I = T.hoverPoint
                      , k = T.hoverPoints
                      , w = T.tooltip
                      , b = w && w.shared ? k : I;
                    P && b && O(b).forEach(function(A) {
                        A.series.isCartesian && A.plotX === void 0 && (P = !1)
                    }),
                    P ? w && b && O(b).length && (w.refresh(b),
                    w.shared && k ? k.forEach(function(A) {
                        A.setState(A.state, !0),
                        A.series.isCartesian && (A.series.xAxis.crosshair && A.series.xAxis.drawCrosshair(null, A),
                        A.series.yAxis.crosshair && A.series.yAxis.drawCrosshair(null, A))
                    }) : I && (I.setState(I.state, !0),
                    T.axes.forEach(function(A) {
                        A.crosshair && I.series[A.coll] === A && A.drawCrosshair(null, I)
                    }))) : (I && I.onMouseOut(),
                    k && k.forEach(function(A) {
                        A.setState()
                    }),
                    L && L.onMouseOut(),
                    w && w.hide(_),
                    this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()),
                    T.axes.forEach(function(A) {
                        A.hideCrosshair()
                    }),
                    this.hoverX = T.hoverPoints = T.hoverPoint = null)
                }
                runPointActions(P, _, T) {
                    let L = this.chart
                      , I = L.series
                      , k = L.tooltip && L.tooltip.options.enabled ? L.tooltip : void 0
                      , w = !!k && k.shared
                      , b = _ || L.hoverPoint
                      , A = b && b.series || L.hoverSeries
                      , j = (!P || P.type !== "touchmove") && (!!_ || A && A.directTouch && this.isDirectTouch)
                      , B = this.getHoverData(b, A, I, j, w, P);
                    b = B.hoverPoint,
                    A = B.hoverSeries;
                    let W = B.hoverPoints
                      , N = A && A.tooltipOptions.followPointer && !A.tooltipOptions.split
                      , H = w && A && !A.noSharedTooltip;
                    if (b && (T || b !== L.hoverPoint || k && k.isHidden)) {
                        if ((L.hoverPoints || []).forEach(function(X) {
                            W.indexOf(X) === -1 && X.setState()
                        }),
                        L.hoverSeries !== A && A.onMouseOver(),
                        this.applyInactiveState(W),
                        (W || []).forEach(function(X) {
                            X.setState("hover")
                        }),
                        L.hoverPoint && L.hoverPoint.firePointEvent("mouseOut"),
                        !b.series)
                            return;
                        L.hoverPoints = W,
                        L.hoverPoint = b,
                        b.firePointEvent("mouseOver", void 0, ()=>{
                            k && b && k.refresh(H ? W : b, P)
                        }
                        )
                    } else if (N && k && !k.isHidden) {
                        let X = k.getAnchor([{}], P);
                        L.isInsidePlot(X[0], X[1], {
                            visiblePlotOnly: !0
                        }) && k.updatePosition({
                            plotX: X[0],
                            plotY: X[1]
                        })
                    }
                    this.unDocMouseMove || (this.unDocMouseMove = u(L.container.ownerDocument, "mousemove", function(X) {
                        let ie = l[R.hoverChartIndex];
                        ie && ie.pointer.onDocumentMouseMove(X)
                    }),
                    this.eventsToUnbind.push(this.unDocMouseMove)),
                    L.axes.forEach(function(X) {
                        let ie, K = E((X.crosshair || {}).snap, !0);
                        !K || (ie = L.hoverPoint) && ie.series[X.coll] === X || (ie = x(W, D=>D.series && D.series[X.coll] === X)),
                        ie || !K ? X.drawCrosshair(P, ie) : X.hideCrosshair()
                    })
                }
                scaleGroups(P, _) {
                    let T = this.chart;
                    T.series.forEach(function(L) {
                        let I = P || L.getPlotBox("series");
                        L.group && (L.xAxis && L.xAxis.zoomEnabled || T.mapView) && (L.group.attr(I),
                        L.markerGroup && (L.markerGroup.attr(P || L.getPlotBox("marker")),
                        L.markerGroup.clip(_ ? T.clipRect : null)),
                        L.dataLabelsGroup && L.dataLabelsGroup.attr(I))
                    }),
                    T.clipRect.attr(_ || T.clipBox)
                }
                setDOMEvents() {
                    let P = this.chart.container
                      , _ = P.ownerDocument;
                    P.onmousedown = this.onContainerMouseDown.bind(this),
                    P.onmousemove = this.onContainerMouseMove.bind(this),
                    P.onclick = this.onContainerClick.bind(this),
                    this.eventsToUnbind.push(u(P, "mouseenter", this.onContainerMouseEnter.bind(this))),
                    this.eventsToUnbind.push(u(P, "mouseleave", this.onContainerMouseLeave.bind(this))),
                    R.unbindDocumentMouseUp || (R.unbindDocumentMouseUp = u(_, "mouseup", this.onDocumentMouseUp.bind(this)));
                    let T = this.chart.renderTo.parentElement;
                    for (; T && T.tagName !== "BODY"; )
                        this.eventsToUnbind.push(u(T, "scroll", ()=>{
                            delete this.chartPosition
                        }
                        )),
                        T = T.parentElement;
                    s.hasTouch && (this.eventsToUnbind.push(u(P, "touchstart", this.onContainerTouchStart.bind(this), {
                        passive: !1
                    })),
                    this.eventsToUnbind.push(u(P, "touchmove", this.onContainerTouchMove.bind(this), {
                        passive: !1
                    })),
                    R.unbindDocumentTouchEnd || (R.unbindDocumentTouchEnd = u(_, "touchend", this.onDocumentTouchEnd.bind(this), {
                        passive: !1
                    })))
                }
                setHoverChartIndex(P) {
                    let _ = this.chart
                      , T = s.charts[E(R.hoverChartIndex, -1)];
                    T && T !== _ && T.pointer.onContainerMouseLeave(P || {
                        relatedTarget: _.container
                    }),
                    T && T.mouseIsDown || (R.hoverChartIndex = _.index)
                }
                touch(P, _) {
                    let T, L, I = this.chart;
                    this.setHoverChartIndex(),
                    P.touches.length === 1 ? (P = this.normalize(P),
                    I.isInsidePlot(P.chartX - I.plotLeft, P.chartY - I.plotTop, {
                        visiblePlotOnly: !0
                    }) && !I.openMenu ? (_ && this.runPointActions(P),
                    P.type === "touchmove" && (T = !!(L = this.pinchDown)[0] && Math.sqrt(Math.pow(L[0].chartX - P.chartX, 2) + Math.pow(L[0].chartY - P.chartY, 2)) >= 4),
                    E(T, !0) && this.pinch(P)) : _ && this.reset()) : P.touches.length === 2 && this.pinch(P)
                }
                touchSelect(P) {
                    return !!(this.chart.zooming.singleTouch && P.touches && P.touches.length === 1)
                }
                zoomOption(P) {
                    let _ = this.chart, T = (_.options.chart,
                    _.inverted), L = _.zooming.type || "", I, k;
                    /touch/.test(P.type) && (L = E(_.zooming.pinchType, L)),
                    this.zoomX = I = /x/.test(L),
                    this.zoomY = k = /y/.test(L),
                    this.zoomHor = I && !T || k && T,
                    this.zoomVert = k && !T || I && T,
                    this.hasZoom = I || k
                }
            }
            return function(F) {
                let P = []
                  , _ = [];
                F.compose = function(T) {
                    o.pushUnique(_, T) && u(T, "beforeRender", function() {
                        this.pointer = new F(this,this.options)
                    })
                }
                ,
                F.dissolve = function() {
                    for (let T = 0, L = P.length; T < L; ++T)
                        P[T]();
                    P.length = 0
                }
            }(R || (R = {})),
            R
        }),
        i(n, "Core/Legend/Legend.js", [n["Core/Animation/AnimationUtilities.js"], n["Core/Templating.js"], n["Core/Globals.js"], n["Core/Series/Point.js"], n["Core/Renderer/RendererUtilities.js"], n["Core/Utilities.js"]], function(r, s, o, a, l, c) {
            let {animObject: u, setAnimation: h} = r
              , {format: d} = s
              , {marginNames: m} = o
              , {distribute: f} = l
              , {addEvent: x, createElement: S, css: v, defined: p, discardElement: g, find: C, fireEvent: E, isNumber: O, merge: R, pick: F, relativeLength: P, stableSort: _, syncTimeout: T} = c;
            class L {
                constructor(k, w) {
                    this.allItems = [],
                    this.box = void 0,
                    this.contentGroup = void 0,
                    this.display = !1,
                    this.group = void 0,
                    this.initialItemY = 0,
                    this.itemHeight = 0,
                    this.itemMarginBottom = 0,
                    this.itemMarginTop = 0,
                    this.itemX = 0,
                    this.itemY = 0,
                    this.lastItemY = 0,
                    this.lastLineHeight = 0,
                    this.legendHeight = 0,
                    this.legendWidth = 0,
                    this.maxItemWidth = 0,
                    this.maxLegendWidth = 0,
                    this.offsetWidth = 0,
                    this.options = void 0,
                    this.padding = 0,
                    this.pages = [],
                    this.proximate = !1,
                    this.scrollGroup = void 0,
                    this.symbolHeight = 0,
                    this.symbolWidth = 0,
                    this.titleHeight = 0,
                    this.totalItemWidth = 0,
                    this.widthOption = 0,
                    this.chart = k,
                    this.init(k, w)
                }
                init(k, w) {
                    this.chart = k,
                    this.setOptions(w),
                    w.enabled && (this.render(),
                    x(this.chart, "endResize", function() {
                        this.legend.positionCheckboxes()
                    })),
                    x(this.chart, "render", ()=>{
                        this.options.enabled && this.proximate && (this.proximatePositions(),
                        this.positionItems())
                    }
                    )
                }
                setOptions(k) {
                    let w = F(k.padding, 8);
                    this.options = k,
                    this.chart.styledMode || (this.itemStyle = k.itemStyle,
                    this.itemHiddenStyle = R(this.itemStyle, k.itemHiddenStyle)),
                    this.itemMarginTop = k.itemMarginTop,
                    this.itemMarginBottom = k.itemMarginBottom,
                    this.padding = w,
                    this.initialItemY = w - 5,
                    this.symbolWidth = F(k.symbolWidth, 16),
                    this.pages = [],
                    this.proximate = k.layout === "proximate" && !this.chart.inverted,
                    this.baseline = void 0
                }
                update(k, w) {
                    let b = this.chart;
                    this.setOptions(R(!0, this.options, k)),
                    this.destroy(),
                    b.isDirtyLegend = b.isDirtyBox = !0,
                    F(w, !0) && b.redraw(),
                    E(this, "afterUpdate", {
                        redraw: w
                    })
                }
                colorizeItem(k, w) {
                    let {group: b, label: A, line: j, symbol: B} = k.legendItem || {};
                    if (b && b[w ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"),
                    !this.chart.styledMode) {
                        let {itemHiddenStyle: W} = this
                          , N = W.color
                          , H = w && k.color || N
                          , X = k.options && k.options.marker
                          , ie = {
                            fill: H
                        };
                        A == null || A.css(R(w ? this.itemStyle : W)),
                        j == null || j.attr({
                            stroke: H
                        }),
                        B && (X && B.isMarker && (ie = k.pointAttribs(),
                        w || (ie.stroke = ie.fill = N)),
                        B.attr(ie))
                    }
                    E(this, "afterColorizeItem", {
                        item: k,
                        visible: w
                    })
                }
                positionItems() {
                    this.allItems.forEach(this.positionItem, this),
                    this.chart.isResizing || this.positionCheckboxes()
                }
                positionItem(k) {
                    let {group: w, x: b=0, y: A=0} = k.legendItem || {}
                      , j = this.options
                      , B = j.symbolPadding
                      , W = !j.rtl
                      , N = k.checkbox;
                    if (w && w.element) {
                        let H = {
                            translateX: W ? b : this.legendWidth - b - 2 * B - 4,
                            translateY: A
                        };
                        w[p(w.translateY) ? "animate" : "attr"](H, void 0, ()=>{
                            E(this, "afterPositionItem", {
                                item: k
                            })
                        }
                        )
                    }
                    N && (N.x = b,
                    N.y = A)
                }
                destroyItem(k) {
                    let w = k.checkbox
                      , b = k.legendItem || {};
                    for (let A of ["group", "label", "line", "symbol"])
                        b[A] && (b[A] = b[A].destroy());
                    w && g(w),
                    k.legendItem = void 0
                }
                destroy() {
                    for (let k of this.getAllItems())
                        this.destroyItem(k);
                    for (let k of ["clipRect", "up", "down", "pager", "nav", "box", "title", "group"])
                        this[k] && (this[k] = this[k].destroy());
                    this.display = null
                }
                positionCheckboxes() {
                    let k, w = this.group && this.group.alignAttr, b = this.clipHeight || this.legendHeight, A = this.titleHeight;
                    w && (k = w.translateY,
                    this.allItems.forEach(function(j) {
                        let B, W = j.checkbox;
                        W && (B = k + A + W.y + (this.scrollOffset || 0) + 3,
                        v(W, {
                            left: w.translateX + j.checkboxOffset + W.x - 20 + "px",
                            top: B + "px",
                            display: this.proximate || B > k - 6 && B < k + b - 6 ? "" : "none"
                        }))
                    }, this))
                }
                renderTitle() {
                    let k = this.options, w = this.padding, b = k.title, A, j = 0;
                    b.text && (this.title || (this.title = this.chart.renderer.label(b.text, w - 3, w - 4, void 0, void 0, void 0, k.useHTML, void 0, "legend-title").attr({
                        zIndex: 1
                    }),
                    this.chart.styledMode || this.title.css(b.style),
                    this.title.add(this.group)),
                    b.width || this.title.css({
                        width: this.maxLegendWidth + "px"
                    }),
                    j = (A = this.title.getBBox()).height,
                    this.offsetWidth = A.width,
                    this.contentGroup.attr({
                        translateY: j
                    })),
                    this.titleHeight = j
                }
                setText(k) {
                    let w = this.options;
                    k.legendItem.label.attr({
                        text: w.labelFormat ? d(w.labelFormat, k, this.chart) : w.labelFormatter.call(k)
                    })
                }
                renderItem(k) {
                    let w = k.legendItem = k.legendItem || {}
                      , b = this.chart
                      , A = b.renderer
                      , j = this.options
                      , B = j.layout === "horizontal"
                      , W = this.symbolWidth
                      , N = j.symbolPadding || 0
                      , H = this.itemStyle
                      , X = this.itemHiddenStyle
                      , ie = B ? F(j.itemDistance, 20) : 0
                      , K = !j.rtl
                      , D = !k.series
                      , V = !D && k.series.drawLegendSymbol ? k.series : k
                      , G = V.options
                      , ee = !!this.createCheckboxForItem && G && G.showCheckbox
                      , J = j.useHTML
                      , te = k.options.className
                      , z = w.label
                      , Y = W + N + ie + (ee ? 20 : 0);
                    !z && (w.group = A.g("legend-item").addClass("highcharts-" + V.type + "-series highcharts-color-" + k.colorIndex + (te ? " " + te : "") + (D ? " highcharts-series-" + k.index : "")).attr({
                        zIndex: 1
                    }).add(this.scrollGroup),
                    w.label = z = A.text("", K ? W + N : -N, this.baseline || 0, J),
                    b.styledMode || z.css(R(k.visible ? H : X)),
                    z.attr({
                        align: K ? "left" : "right",
                        zIndex: 2
                    }).add(w.group),
                    !this.baseline && (this.fontMetrics = A.fontMetrics(z),
                    this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop,
                    z.attr("y", this.baseline),
                    this.symbolHeight = F(j.symbolHeight, this.fontMetrics.f),
                    j.squareSymbol && (this.symbolWidth = F(j.symbolWidth, Math.max(this.symbolHeight, 16)),
                    Y = this.symbolWidth + N + ie + (ee ? 20 : 0),
                    K && z.attr("x", this.symbolWidth + N))),
                    V.drawLegendSymbol(this, k),
                    this.setItemEvents && this.setItemEvents(k, z, J)),
                    ee && !k.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(k),
                    this.colorizeItem(k, k.visible),
                    (b.styledMode || !H.width) && z.css({
                        width: (j.itemWidth || this.widthOption || b.spacingBox.width) - Y + "px"
                    }),
                    this.setText(k);
                    let U = z.getBBox()
                      , Z = this.fontMetrics && this.fontMetrics.h || 0;
                    k.itemWidth = k.checkboxOffset = j.itemWidth || w.labelWidth || U.width + Y,
                    this.maxItemWidth = Math.max(this.maxItemWidth, k.itemWidth),
                    this.totalItemWidth += k.itemWidth,
                    this.itemHeight = k.itemHeight = Math.round(w.labelHeight || (U.height > 1.5 * Z ? U.height : Z))
                }
                layoutItem(k) {
                    let w = this.options
                      , b = this.padding
                      , A = w.layout === "horizontal"
                      , j = k.itemHeight
                      , B = this.itemMarginBottom
                      , W = this.itemMarginTop
                      , N = A ? F(w.itemDistance, 20) : 0
                      , H = this.maxLegendWidth
                      , X = w.alignColumns && this.totalItemWidth > H ? this.maxItemWidth : k.itemWidth
                      , ie = k.legendItem || {};
                    A && this.itemX - b + X > H && (this.itemX = b,
                    this.lastLineHeight && (this.itemY += W + this.lastLineHeight + B),
                    this.lastLineHeight = 0),
                    this.lastItemY = W + this.itemY + B,
                    this.lastLineHeight = Math.max(j, this.lastLineHeight),
                    ie.x = this.itemX,
                    ie.y = this.itemY,
                    A ? this.itemX += X : (this.itemY += W + j + B,
                    this.lastLineHeight = j),
                    this.offsetWidth = this.widthOption || Math.max((A ? this.itemX - b - (k.checkbox ? 0 : N) : X) + b, this.offsetWidth)
                }
                getAllItems() {
                    let k = [];
                    return this.chart.series.forEach(function(w) {
                        let b = w && w.options;
                        w && F(b.showInLegend, !p(b.linkedTo) && void 0, !0) && (k = k.concat((w.legendItem || {}).labels || (b.legendType === "point" ? w.data : w)))
                    }),
                    E(this, "afterGetAllItems", {
                        allItems: k
                    }),
                    k
                }
                getAlignment() {
                    let k = this.options;
                    return this.proximate ? k.align.charAt(0) + "tv" : k.floating ? "" : k.align.charAt(0) + k.verticalAlign.charAt(0) + k.layout.charAt(0)
                }
                adjustMargins(k, w) {
                    let b = this.chart
                      , A = this.options
                      , j = this.getAlignment();
                    j && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function(B, W) {
                        B.test(j) && !p(k[W]) && (b[m[W]] = Math.max(b[m[W]], b.legend[(W + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][W] * A[W % 2 ? "x" : "y"] + F(A.margin, 12) + w[W] + (b.titleOffset[W] || 0)))
                    })
                }
                proximatePositions() {
                    let k, w = this.chart, b = [], A = this.options.align === "left";
                    for (let j of (this.allItems.forEach(function(B) {
                        let W, N, H = A, X, ie;
                        B.yAxis && (B.xAxis.options.reversed && (H = !H),
                        B.points && (W = C(H ? B.points : B.points.slice(0).reverse(), function(K) {
                            return O(K.plotY)
                        })),
                        N = this.itemMarginTop + B.legendItem.label.getBBox().height + this.itemMarginBottom,
                        ie = B.yAxis.top - w.plotTop,
                        X = B.visible ? (W ? W.plotY : B.yAxis.height) + (ie - .3 * N) : ie + B.yAxis.height,
                        b.push({
                            target: X,
                            size: N,
                            item: B
                        }))
                    }, this),
                    f(b, w.plotHeight)))
                        k = j.item.legendItem || {},
                        O(j.pos) && (k.y = w.plotTop - w.spacing[0] + j.pos)
                }
                render() {
                    let k = this.chart, w = k.renderer, b = this.options, A = this.padding, j = this.getAllItems(), B, W, N, H = this.group, X, ie = this.box;
                    this.itemX = A,
                    this.itemY = this.initialItemY,
                    this.offsetWidth = 0,
                    this.lastItemY = 0,
                    this.widthOption = P(b.width, k.spacingBox.width - A),
                    X = k.spacingBox.width - 2 * A - b.x,
                    ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (X /= 2),
                    this.maxLegendWidth = this.widthOption || X,
                    H || (this.group = H = w.g("legend").addClass(b.className || "").attr({
                        zIndex: 7
                    }).add(),
                    this.contentGroup = w.g().attr({
                        zIndex: 1
                    }).add(H),
                    this.scrollGroup = w.g().add(this.contentGroup)),
                    this.renderTitle(),
                    _(j, (K,D)=>(K.options && K.options.legendIndex || 0) - (D.options && D.options.legendIndex || 0)),
                    b.reversed && j.reverse(),
                    this.allItems = j,
                    this.display = B = !!j.length,
                    this.lastLineHeight = 0,
                    this.maxItemWidth = 0,
                    this.totalItemWidth = 0,
                    this.itemHeight = 0,
                    j.forEach(this.renderItem, this),
                    j.forEach(this.layoutItem, this),
                    W = (this.widthOption || this.offsetWidth) + A,
                    N = this.lastItemY + this.lastLineHeight + this.titleHeight,
                    N = this.handleOverflow(N) + A,
                    ie || (this.box = ie = w.rect().addClass("highcharts-legend-box").attr({
                        r: b.borderRadius
                    }).add(H)),
                    k.styledMode || ie.attr({
                        stroke: b.borderColor,
                        "stroke-width": b.borderWidth || 0,
                        fill: b.backgroundColor || "none"
                    }).shadow(b.shadow),
                    W > 0 && N > 0 && ie[ie.placed ? "animate" : "attr"](ie.crisp.call({}, {
                        x: 0,
                        y: 0,
                        width: W,
                        height: N
                    }, ie.strokeWidth())),
                    H[B ? "show" : "hide"](),
                    k.styledMode && H.getStyle("display") === "none" && (W = N = 0),
                    this.legendWidth = W,
                    this.legendHeight = N,
                    B && this.align(),
                    this.proximate || this.positionItems(),
                    E(this, "afterRender")
                }
                align(k=this.chart.spacingBox) {
                    let w = this.chart
                      , b = this.options
                      , A = k.y;
                    /(lth|ct|rth)/.test(this.getAlignment()) && w.titleOffset[0] > 0 ? A += w.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && w.titleOffset[2] > 0 && (A -= w.titleOffset[2]),
                    A !== k.y && (k = R(k, {
                        y: A
                    })),
                    w.hasRendered || (this.group.placed = !1),
                    this.group.align(R(b, {
                        width: this.legendWidth,
                        height: this.legendHeight,
                        verticalAlign: this.proximate ? "top" : b.verticalAlign
                    }), !0, k)
                }
                handleOverflow(k) {
                    let w = this, b = this.chart, A = b.renderer, j = this.options, B = j.y, W = j.verticalAlign === "top", N = this.padding, H = j.maxHeight, X = j.navigation, ie = F(X.animation, !0), K = X.arrowSize || 12, D = this.pages, V = this.allItems, G = function($) {
                        typeof $ == "number" ? Z.attr({
                            height: $
                        }) : Z && (w.clipRect = Z.destroy(),
                        w.contentGroup.clip()),
                        w.contentGroup.div && (w.contentGroup.div.style.clip = $ ? "rect(" + N + "px,9999px," + (N + $) + "px,0)" : "auto")
                    }, ee = function($) {
                        return w[$] = A.circle(0, 0, 1.3 * K).translate(K / 2, K / 2).add(U),
                        b.styledMode || w[$].attr("fill", "rgba(0,0,0,0.0001)"),
                        w[$]
                    }, J, te, z, Y = b.spacingBox.height + (W ? -B : B) - N, U = this.nav, Z = this.clipRect;
                    return j.layout !== "horizontal" || j.verticalAlign === "middle" || j.floating || (Y /= 2),
                    H && (Y = Math.min(Y, H)),
                    D.length = 0,
                    k && Y > 0 && k > Y && X.enabled !== !1 ? (this.clipHeight = J = Math.max(Y - 20 - this.titleHeight - N, 0),
                    this.currentPage = F(this.currentPage, 1),
                    this.fullHeight = k,
                    V.forEach(($,ne)=>{
                        z = $.legendItem || {};
                        let oe = z.y || 0
                          , se = Math.round(z.label.getBBox().height)
                          , le = D.length;
                        (!le || oe - D[le - 1] > J && (te || oe) !== D[le - 1]) && (D.push(te || oe),
                        le++),
                        z.pageIx = le - 1,
                        te && ((V[ne - 1].legendItem || {}).pageIx = le - 1),
                        ne === V.length - 1 && oe + se - D[le - 1] > J && oe > D[le - 1] && (D.push(oe),
                        z.pageIx = le),
                        oe !== te && (te = oe)
                    }
                    ),
                    Z || (Z = w.clipRect = A.clipRect(0, N - 2, 9999, 0),
                    w.contentGroup.clip(Z)),
                    G(J),
                    U || (this.nav = U = A.g().attr({
                        zIndex: 1
                    }).add(this.group),
                    this.up = A.symbol("triangle", 0, 0, K, K).add(U),
                    ee("upTracker").on("click", function() {
                        w.scroll(-1, ie)
                    }),
                    this.pager = A.text("", 15, 10).addClass("highcharts-legend-navigation"),
                    !b.styledMode && X.style && this.pager.css(X.style),
                    this.pager.add(U),
                    this.down = A.symbol("triangle-down", 0, 0, K, K).add(U),
                    ee("downTracker").on("click", function() {
                        w.scroll(1, ie)
                    })),
                    w.scroll(0),
                    k = Y) : U && (G(),
                    this.nav = U.destroy(),
                    this.scrollGroup.attr({
                        translateY: 1
                    }),
                    this.clipHeight = 0),
                    k
                }
                scroll(k, w) {
                    let b = this.chart
                      , A = this.pages
                      , j = A.length
                      , B = this.clipHeight
                      , W = this.options.navigation
                      , N = this.pager
                      , H = this.padding
                      , X = this.currentPage + k;
                    if (X > j && (X = j),
                    X > 0) {
                        w !== void 0 && h(w, b),
                        this.nav.attr({
                            translateX: H,
                            translateY: B + this.padding + 7 + this.titleHeight,
                            visibility: "inherit"
                        }),
                        [this.up, this.upTracker].forEach(function(K) {
                            K.attr({
                                class: X === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                            })
                        }),
                        N.attr({
                            text: X + "/" + j
                        }),
                        [this.down, this.downTracker].forEach(function(K) {
                            K.attr({
                                x: 18 + this.pager.getBBox().width,
                                class: X === j ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                            })
                        }, this),
                        b.styledMode || (this.up.attr({
                            fill: X === 1 ? W.inactiveColor : W.activeColor
                        }),
                        this.upTracker.css({
                            cursor: X === 1 ? "default" : "pointer"
                        }),
                        this.down.attr({
                            fill: X === j ? W.inactiveColor : W.activeColor
                        }),
                        this.downTracker.css({
                            cursor: X === j ? "default" : "pointer"
                        })),
                        this.scrollOffset = -A[X - 1] + this.initialItemY,
                        this.scrollGroup.animate({
                            translateY: this.scrollOffset
                        }),
                        this.currentPage = X,
                        this.positionCheckboxes();
                        let ie = u(F(w, b.renderer.globalAnimation, !0));
                        T(()=>{
                            E(this, "afterScroll", {
                                currentPage: X
                            })
                        }
                        , ie.duration)
                    }
                }
                setItemEvents(k, w, b) {
                    let A = this
                      , j = k.legendItem || {}
                      , B = A.chart.renderer.boxWrapper
                      , W = k instanceof a
                      , N = "highcharts-legend-" + (W ? "point" : "series") + "-active"
                      , H = A.chart.styledMode
                      , X = b ? [w, j.symbol] : [j.group]
                      , ie = K=>{
                        A.allItems.forEach(D=>{
                            k !== D && [D].concat(D.linkedSeries || []).forEach(V=>{
                                V.setState(K, !W)
                            }
                            )
                        }
                        )
                    }
                    ;
                    for (let K of X)
                        K && K.on("mouseover", function() {
                            k.visible && ie("inactive"),
                            k.setState("hover"),
                            k.visible && B.addClass(N),
                            H || w.css(A.options.itemHoverStyle)
                        }).on("mouseout", function() {
                            A.chart.styledMode || w.css(R(k.visible ? A.itemStyle : A.itemHiddenStyle)),
                            ie(""),
                            B.removeClass(N),
                            k.setState()
                        }).on("click", function(D) {
                            let V = "legendItemClick"
                              , G = function() {
                                k.setVisible && k.setVisible(),
                                ie(k.visible ? "inactive" : "")
                            };
                            B.removeClass(N),
                            D = {
                                browserEvent: D
                            },
                            k.firePointEvent ? k.firePointEvent(V, D, G) : E(k, V, D, G)
                        })
                }
                createCheckboxForItem(k) {
                    k.checkbox = S("input", {
                        type: "checkbox",
                        className: "highcharts-legend-checkbox",
                        checked: k.selected,
                        defaultChecked: k.selected
                    }, this.options.itemCheckboxStyle, this.chart.container),
                    x(k.checkbox, "click", function(w) {
                        let b = w.target;
                        E(k.series || k, "checkboxClick", {
                            checked: b.checked,
                            item: k
                        }, function() {
                            k.select()
                        })
                    })
                }
            }
            return function(I) {
                let k = [];
                I.compose = function(w) {
                    c.pushUnique(k, w) && x(w, "beforeMargins", function() {
                        this.legend = new I(this,this.options.legend)
                    })
                }
            }(L || (L = {})),
            L
        }),
        i(n, "Core/Legend/LegendSymbol.js", [n["Core/Utilities.js"]], function(r) {
            var s, o;
            let {extend: a, merge: l, pick: c} = r;
            return (o = s || (s = {})).lineMarker = function(u, h) {
                let d = this.legendItem = this.legendItem || {}, m = this.options, f = u.symbolWidth, x = u.symbolHeight, S = this.symbol || "circle", v = x / 2, p = this.chart.renderer, g = d.group, C = u.baseline - Math.round(.3 * u.fontMetrics.b), E = {}, O, R = m.marker, F = 0;
                if (this.chart.styledMode || (E = {
                    "stroke-width": Math.min(m.lineWidth || 0, 24)
                },
                m.dashStyle ? E.dashstyle = m.dashStyle : m.linecap === "square" || (E["stroke-linecap"] = "round")),
                d.line = p.path().addClass("highcharts-graph").attr(E).add(g),
                E["stroke-linecap"] && (F = Math.min(d.line.strokeWidth(), f) / 2),
                f && d.line.attr({
                    d: [["M", F, C], ["L", f - F, C]]
                }),
                R && R.enabled !== !1 && f) {
                    let P = Math.min(c(R.radius, v), v);
                    S.indexOf("url") === 0 && (R = l(R, {
                        width: x,
                        height: x
                    }),
                    P = 0),
                    d.symbol = O = p.symbol(S, f / 2 - P, C - P, 2 * P, 2 * P, a({
                        context: "legend"
                    }, R)).addClass("highcharts-point").add(g),
                    O.isMarker = !0
                }
            }
            ,
            o.rectangle = function(u, h) {
                let d = h.legendItem || {}
                  , m = u.options
                  , f = u.symbolHeight
                  , x = m.squareSymbol
                  , S = x ? f : u.symbolWidth;
                d.symbol = this.chart.renderer.rect(x ? (u.symbolWidth - f) / 2 : 0, u.baseline - f + 1, S, f, c(u.options.symbolRadius, f / 2)).addClass("highcharts-point").attr({
                    zIndex: 3
                }).add(d.group)
            }
            ,
            s
        }),
        i(n, "Core/Series/SeriesDefaults.js", [], function() {
            return {
                lineWidth: 2,
                allowPointSelect: !1,
                crisp: !0,
                showCheckbox: !1,
                animation: {
                    duration: 1e3
                },
                enableMouseTracking: !0,
                events: {},
                marker: {
                    enabledThreshold: 2,
                    lineColor: "#ffffff",
                    lineWidth: 0,
                    radius: 4,
                    states: {
                        normal: {
                            animation: !0
                        },
                        hover: {
                            animation: {
                                duration: 150
                            },
                            enabled: !0,
                            radiusPlus: 2,
                            lineWidthPlus: 1
                        },
                        select: {
                            fillColor: "#cccccc",
                            lineColor: "#000000",
                            lineWidth: 2
                        }
                    }
                },
                point: {
                    events: {}
                },
                dataLabels: {
                    animation: {},
                    align: "center",
                    borderWidth: 0,
                    defer: !0,
                    formatter: function() {
                        let {numberFormatter: r} = this.series.chart;
                        return typeof this.y != "number" ? "" : r(this.y, -1)
                    },
                    padding: 5,
                    style: {
                        fontSize: "0.7em",
                        fontWeight: "bold",
                        color: "contrast",
                        textOutline: "1px contrast"
                    },
                    verticalAlign: "bottom",
                    x: 0,
                    y: 0
                },
                cropThreshold: 300,
                opacity: 1,
                pointRange: 0,
                softThreshold: !0,
                states: {
                    normal: {
                        animation: !0
                    },
                    hover: {
                        animation: {
                            duration: 150
                        },
                        lineWidthPlus: 1,
                        marker: {},
                        halo: {
                            size: 10,
                            opacity: .25
                        }
                    },
                    select: {
                        animation: {
                            duration: 0
                        }
                    },
                    inactive: {
                        animation: {
                            duration: 150
                        },
                        opacity: .2
                    }
                },
                stickyTracking: !0,
                turboThreshold: 1e3,
                findNearestPointBy: "x"
            }
        }),
        i(n, "Core/Series/SeriesRegistry.js", [n["Core/Globals.js"], n["Core/Defaults.js"], n["Core/Series/Point.js"], n["Core/Utilities.js"]], function(r, s, o, a) {
            var l;
            let {defaultOptions: c} = s
              , {extendClass: u, merge: h} = a;
            return function(d) {
                function m(f, x) {
                    let S = c.plotOptions || {}
                      , v = x.defaultOptions
                      , p = x.prototype;
                    p.type = f,
                    p.pointClass || (p.pointClass = o),
                    v && (S[f] = v),
                    d.seriesTypes[f] = x
                }
                d.seriesTypes = r.seriesTypes,
                d.registerSeriesType = m,
                d.seriesType = function(f, x, S, v, p) {
                    let g = c.plotOptions || {};
                    return x = x || "",
                    g[f] = h(g[x], S),
                    m(f, u(d.seriesTypes[x] || function() {}
                    , v)),
                    d.seriesTypes[f].prototype.type = f,
                    p && (d.seriesTypes[f].prototype.pointClass = u(o, p)),
                    d.seriesTypes[f]
                }
            }(l || (l = {})),
            l
        }),
        i(n, "Core/Series/Series.js", [n["Core/Animation/AnimationUtilities.js"], n["Core/Defaults.js"], n["Core/Foundation.js"], n["Core/Globals.js"], n["Core/Legend/LegendSymbol.js"], n["Core/Series/Point.js"], n["Core/Series/SeriesDefaults.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Renderer/SVG/SVGElement.js"], n["Core/Utilities.js"]], function(r, s, o, a, l, c, u, h, d, m) {
            let {animObject: f, setAnimation: x} = r
              , {defaultOptions: S} = s
              , {registerEventOptions: v} = o
              , {hasTouch: p, svg: g, win: C} = a
              , {seriesTypes: E} = h
              , {addEvent: O, arrayMax: R, arrayMin: F, clamp: P, correctFloat: _, defined: T, diffObjects: L, erase: I, error: k, extend: w, find: b, fireEvent: A, getClosestDistance: j, getNestedProperty: B, insertItem: W, isArray: N, isNumber: H, isString: X, merge: ie, objectEach: K, pick: D, removeEvent: V, splat: G, syncTimeout: ee} = m;
            class J {
                constructor() {
                    this._i = void 0,
                    this.chart = void 0,
                    this.data = void 0,
                    this.eventOptions = void 0,
                    this.eventsToUnbind = void 0,
                    this.index = void 0,
                    this.linkedSeries = void 0,
                    this.options = void 0,
                    this.points = void 0,
                    this.processedXData = void 0,
                    this.processedYData = void 0,
                    this.tooltipOptions = void 0,
                    this.userOptions = void 0,
                    this.xAxis = void 0,
                    this.yAxis = void 0,
                    this.zones = void 0
                }
                init(z, Y) {
                    let U;
                    A(this, "init", {
                        options: Y
                    });
                    let Z = this
                      , $ = z.series;
                    this.eventsToUnbind = [],
                    Z.chart = z,
                    Z.options = Z.setOptions(Y);
                    let ne = Z.options
                      , oe = ne.visible !== !1;
                    Z.linkedSeries = [],
                    Z.bindAxes(),
                    w(Z, {
                        name: ne.name,
                        state: "",
                        visible: oe,
                        selected: ne.selected === !0
                    }),
                    v(this, ne);
                    let se = ne.events;
                    (se && se.click || ne.point && ne.point.events && ne.point.events.click || ne.allowPointSelect) && (z.runTrackerClick = !0),
                    Z.getColor(),
                    Z.getSymbol(),
                    Z.parallelArrays.forEach(function(le) {
                        Z[le + "Data"] || (Z[le + "Data"] = [])
                    }),
                    Z.isCartesian && (z.hasCartesianSeries = !0),
                    $.length && (U = $[$.length - 1]),
                    Z._i = D(U && U._i, -1) + 1,
                    Z.opacity = Z.options.opacity,
                    z.orderItems("series", W(this, $)),
                    ne.dataSorting && ne.dataSorting.enabled ? Z.setDataSortingOptions() : Z.points || Z.data || Z.setData(ne.data, !1),
                    A(this, "afterInit")
                }
                is(z) {
                    return E[z] && this instanceof E[z]
                }
                bindAxes() {
                    let z, Y = this, U = Y.options, Z = Y.chart;
                    A(this, "bindAxes", null, function() {
                        (Y.axisTypes || []).forEach(function($) {
                            Z[$].forEach(function(ne) {
                                z = ne.options,
                                (D(U[$], 0) === ne.index || U[$] !== void 0 && U[$] === z.id) && (W(Y, ne.series),
                                Y[$] = ne,
                                ne.isDirty = !0)
                            }),
                            Y[$] || Y.optionalAxis === $ || k(18, !0, Z)
                        })
                    }),
                    A(this, "afterBindAxes")
                }
                updateParallelArrays(z, Y, U) {
                    let Z = z.series
                      , $ = H(Y) ? function(ne) {
                        let oe = ne === "y" && Z.toYData ? Z.toYData(z) : z[ne];
                        Z[ne + "Data"][Y] = oe
                    }
                    : function(ne) {
                        Array.prototype[Y].apply(Z[ne + "Data"], U)
                    }
                    ;
                    Z.parallelArrays.forEach($)
                }
                hasData() {
                    return this.visible && this.dataMax !== void 0 && this.dataMin !== void 0 || this.visible && this.yData && this.yData.length > 0
                }
                hasMarkerChanged(z, Y) {
                    let U = z.marker
                      , Z = Y.marker || {};
                    return U && (Z.enabled && !U.enabled || Z.symbol !== U.symbol || Z.height !== U.height || Z.width !== U.width)
                }
                autoIncrement(z) {
                    let Y = this.options, U = Y.pointIntervalUnit, Z = Y.relativeXValue, $ = this.chart.time, ne = this.xIncrement, oe, se;
                    return ne = D(ne, Y.pointStart, 0),
                    this.pointInterval = se = D(this.pointInterval, Y.pointInterval, 1),
                    Z && H(z) && (se *= z),
                    U && (oe = new $.Date(ne),
                    U === "day" ? $.set("Date", oe, $.get("Date", oe) + se) : U === "month" ? $.set("Month", oe, $.get("Month", oe) + se) : U === "year" && $.set("FullYear", oe, $.get("FullYear", oe) + se),
                    se = oe.getTime() - ne),
                    Z && H(z) ? ne + se : (this.xIncrement = ne + se,
                    ne)
                }
                setDataSortingOptions() {
                    let z = this.options;
                    w(this, {
                        requireSorting: !1,
                        sorted: !1,
                        enabledDataSorting: !0,
                        allowDG: !1
                    }),
                    T(z.pointRange) || (z.pointRange = 1)
                }
                setOptions(z) {
                    var fe, de;
                    let Y, U = this.chart, Z = U.options, $ = Z.plotOptions, ne = U.userOptions || {}, oe = ie(z), se = U.styledMode, le = {
                        plotOptions: $,
                        userOptions: oe
                    };
                    A(this, "setOptions", le);
                    let he = le.plotOptions[this.type]
                      , Q = ne.plotOptions || {}
                      , q = Q.series || {}
                      , ae = S.plotOptions[this.type] || {}
                      , re = Q[this.type] || {};
                    this.userOptions = le.userOptions;
                    let ce = ie(he, $.series, re, oe);
                    this.tooltipOptions = ie(S.tooltip, (fe = S.plotOptions.series) == null ? void 0 : fe.tooltip, ae == null ? void 0 : ae.tooltip, U.userOptions.tooltip, (de = Q.series) == null ? void 0 : de.tooltip, re.tooltip, oe.tooltip),
                    this.stickyTracking = D(oe.stickyTracking, re.stickyTracking, q.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || ce.stickyTracking),
                    he.marker === null && delete ce.marker,
                    this.zoneAxis = ce.zoneAxis;
                    let ue = this.zones = (ce.zones || []).slice();
                    return (ce.negativeColor || ce.negativeFillColor) && !ce.zones && (Y = {
                        value: ce[this.zoneAxis + "Threshold"] || ce.threshold || 0,
                        className: "highcharts-negative"
                    },
                    se || (Y.color = ce.negativeColor,
                    Y.fillColor = ce.negativeFillColor),
                    ue.push(Y)),
                    ue.length && T(ue[ue.length - 1].value) && ue.push(se ? {} : {
                        color: this.color,
                        fillColor: this.fillColor
                    }),
                    A(this, "afterSetOptions", {
                        options: ce
                    }),
                    ce
                }
                getName() {
                    return D(this.options.name, "Series " + (this.index + 1))
                }
                getCyclic(z, Y, U) {
                    let Z, $, ne = this.chart, oe = `${z}Index`, se = `${z}Counter`, le = (U == null ? void 0 : U.length) || ne.options.chart.colorCount;
                    !Y && (T($ = D(z === "color" ? this.options.colorIndex : void 0, this[oe])) ? Z = $ : (ne.series.length || (ne[se] = 0),
                    Z = ne[se] % le,
                    ne[se] += 1),
                    U && (Y = U[Z])),
                    Z !== void 0 && (this[oe] = Z),
                    this[z] = Y
                }
                getColor() {
                    this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || S.plotOptions[this.type].color, this.chart.options.colors)
                }
                getPointsCollection() {
                    return (this.hasGroupedData ? this.points : this.data) || []
                }
                getSymbol() {
                    let z = this.options.marker;
                    this.getCyclic("symbol", z.symbol, this.chart.options.symbols)
                }
                findPointIndex(z, Y) {
                    let U, Z, $, ne = z.id, oe = z.x, se = this.points, le = this.options.dataSorting;
                    if (ne) {
                        let he = this.chart.get(ne);
                        he instanceof c && (U = he)
                    } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
                        let he = Q=>!Q.touched && Q.index === z.index;
                        if (le && le.matchByName ? he = Q=>!Q.touched && Q.name === z.name : this.options.relativeXValue && (he = Q=>!Q.touched && Q.options.x === z.x),
                        !(U = b(se, he)))
                            return
                    }
                    return U && ($ = U && U.index) !== void 0 && (Z = !0),
                    $ === void 0 && H(oe) && ($ = this.xData.indexOf(oe, Y)),
                    $ !== -1 && $ !== void 0 && this.cropped && ($ = $ >= this.cropStart ? $ - this.cropStart : $),
                    !Z && H($) && se[$] && se[$].touched && ($ = void 0),
                    $
                }
                updateData(z, Y) {
                    let U = this.options, Z = U.dataSorting, $ = this.points, ne = [], oe = this.requireSorting, se = z.length === $.length, le, he, Q, q, ae = !0;
                    if (this.xIncrement = null,
                    z.forEach(function(re, ce) {
                        let ue, fe = T(re) && this.pointClass.prototype.optionsToObject.call({
                            series: this
                        }, re) || {}, de = fe.x;
                        fe.id || H(de) ? ((ue = this.findPointIndex(fe, q)) === -1 || ue === void 0 ? ne.push(re) : $[ue] && re !== U.data[ue] ? ($[ue].update(re, !1, null, !1),
                        $[ue].touched = !0,
                        oe && (q = ue + 1)) : $[ue] && ($[ue].touched = !0),
                        (!se || ce !== ue || Z && Z.enabled || this.hasDerivedData) && (le = !0)) : ne.push(re)
                    }, this),
                    le)
                        for (he = $.length; he--; )
                            (Q = $[he]) && !Q.touched && Q.remove && Q.remove(!1, Y);
                    else
                        !se || Z && Z.enabled ? ae = !1 : (z.forEach(function(re, ce) {
                            re === $[ce].y || $[ce].destroyed || $[ce].update(re, !1, null, !1)
                        }),
                        ne.length = 0);
                    return $.forEach(function(re) {
                        re && (re.touched = !1)
                    }),
                    !!ae && (ne.forEach(function(re) {
                        this.addPoint(re, !1, null, null, !1)
                    }, this),
                    this.xIncrement === null && this.xData && this.xData.length && (this.xIncrement = R(this.xData),
                    this.autoIncrement()),
                    !0)
                }
                setData(z, Y=!0, U, Z) {
                    var ve;
                    let $ = this, ne = $.points, oe = ne && ne.length || 0, se = $.options, le = $.chart, he = se.dataSorting, Q = $.xAxis, q = se.turboThreshold, ae = this.xData, re = this.yData, ce = $.pointArrayMap, ue = ce && ce.length, fe = se.keys, de, ge, ye, pe = 0, xe = 1, ke = null, Ee;
                    le.options.chart.allowMutatingData || (se.data && delete $.options.data,
                    $.userOptions.data && delete $.userOptions.data,
                    Ee = ie(!0, z)),
                    z = Ee || z || [];
                    let we = z.length;
                    if (he && he.enabled && (z = this.sortData(z)),
                    le.options.chart.allowMutatingData && Z !== !1 && we && oe && !$.cropped && !$.hasGroupedData && $.visible && !$.boosted && (ye = this.updateData(z, U)),
                    !ye) {
                        if ($.xIncrement = null,
                        $.colorCounter = 0,
                        this.parallelArrays.forEach(function(_e) {
                            $[_e + "Data"].length = 0
                        }),
                        q && we > q)
                            if (H(ke = $.getFirstValidPoint(z)))
                                for (de = 0; de < we; de++)
                                    ae[de] = this.autoIncrement(),
                                    re[de] = z[de];
                            else if (N(ke))
                                if (ue)
                                    if (ke.length === ue)
                                        for (de = 0; de < we; de++)
                                            ae[de] = this.autoIncrement(),
                                            re[de] = z[de];
                                    else
                                        for (de = 0; de < we; de++)
                                            ge = z[de],
                                            ae[de] = ge[0],
                                            re[de] = ge.slice(1, ue + 1);
                                else if (fe && (pe = fe.indexOf("x"),
                                xe = fe.indexOf("y"),
                                pe = pe >= 0 ? pe : 0,
                                xe = xe >= 0 ? xe : 1),
                                ke.length === 1 && (xe = 0),
                                pe === xe)
                                    for (de = 0; de < we; de++)
                                        ae[de] = this.autoIncrement(),
                                        re[de] = z[de][xe];
                                else
                                    for (de = 0; de < we; de++)
                                        ge = z[de],
                                        ae[de] = ge[pe],
                                        re[de] = ge[xe];
                            else
                                k(12, !1, le);
                        else
                            for (de = 0; de < we; de++)
                                ge = {
                                    series: $
                                },
                                $.pointClass.prototype.applyOptions.apply(ge, [z[de]]),
                                $.updateParallelArrays(ge, de);
                        for (re && X(re[0]) && k(14, !0, le),
                        $.data = [],
                        $.options.data = $.userOptions.data = z,
                        de = oe; de--; )
                            (ve = ne[de]) == null || ve.destroy();
                        Q && (Q.minRange = Q.userMinRange),
                        $.isDirty = le.isDirtyBox = !0,
                        $.isDirtyData = !!ne,
                        U = !1
                    }
                    se.legendType === "point" && (this.processData(),
                    this.generatePoints()),
                    Y && le.redraw(U)
                }
                sortData(z) {
                    let Y = this
                      , U = Y.options
                      , Z = U.dataSorting
                      , $ = Z.sortKey || "y"
                      , ne = function(se, le) {
                        return T(le) && se.pointClass.prototype.optionsToObject.call({
                            series: se
                        }, le) || {}
                    };
                    return z.forEach(function(se, le) {
                        z[le] = ne(Y, se),
                        z[le].index = le
                    }, this),
                    z.concat().sort((se,le)=>{
                        let he = B($, se)
                          , Q = B($, le);
                        return Q < he ? -1 : Q > he ? 1 : 0
                    }
                    ).forEach(function(se, le) {
                        se.x = le
                    }, this),
                    Y.linkedSeries && Y.linkedSeries.forEach(function(se) {
                        let le = se.options
                          , he = le.data;
                        le.dataSorting && le.dataSorting.enabled || !he || (he.forEach(function(Q, q) {
                            he[q] = ne(se, Q),
                            z[q] && (he[q].x = z[q].x,
                            he[q].index = q)
                        }),
                        se.setData(he, !1))
                    }),
                    z
                }
                getProcessedData(z) {
                    let Y = this, U = Y.xAxis, Z = Y.options, $ = Z.cropThreshold, ne = z || Y.getExtremesFromAll || Z.getExtremesFromAll, oe = U == null ? void 0 : U.logarithmic, se = Y.isCartesian, le, he, Q = 0, q, ae, re, ce = Y.xData, ue = Y.yData, fe = !1, de = ce.length;
                    U && (ae = (q = U.getExtremes()).min,
                    re = q.max,
                    fe = !!(U.categories && !U.names.length)),
                    se && Y.sorted && !ne && (!$ || de > $ || Y.forceCrop) && (ce[de - 1] < ae || ce[0] > re ? (ce = [],
                    ue = []) : Y.yData && (ce[0] < ae || ce[de - 1] > re) && (ce = (le = this.cropData(Y.xData, Y.yData, ae, re)).xData,
                    ue = le.yData,
                    Q = le.start,
                    he = !0));
                    let ge = j([oe ? ce.map(oe.log2lin) : ce], ()=>Y.requireSorting && !fe && k(15, !1, Y.chart));
                    return {
                        xData: ce,
                        yData: ue,
                        cropped: he,
                        cropStart: Q,
                        closestPointRange: ge
                    }
                }
                processData(z) {
                    let Y = this.xAxis;
                    if (this.isCartesian && !this.isDirty && !Y.isDirty && !this.yAxis.isDirty && !z)
                        return !1;
                    let U = this.getProcessedData();
                    this.cropped = U.cropped,
                    this.cropStart = U.cropStart,
                    this.processedXData = U.xData,
                    this.processedYData = U.yData,
                    this.closestPointRange = this.basePointRange = U.closestPointRange,
                    A(this, "afterProcessData")
                }
                cropData(z, Y, U, Z) {
                    let $ = z.length, ne, oe, se = 0, le = $;
                    for (ne = 0; ne < $; ne++)
                        if (z[ne] >= U) {
                            se = Math.max(0, ne - 1);
                            break
                        }
                    for (oe = ne; oe < $; oe++)
                        if (z[oe] > Z) {
                            le = oe + 1;
                            break
                        }
                    return {
                        xData: z.slice(se, le),
                        yData: Y.slice(se, le),
                        start: se,
                        end: le
                    }
                }
                generatePoints() {
                    let z = this.options, Y = this.processedData || z.data, U = this.processedXData, Z = this.processedYData, $ = this.pointClass, ne = U.length, oe = this.cropStart || 0, se = this.hasGroupedData, le = z.keys, he = [], Q = z.dataGrouping && z.dataGrouping.groupAll ? oe : 0, q, ae, re, ce, ue = this.data;
                    if (!ue && !se) {
                        let fe = [];
                        fe.length = Y.length,
                        ue = this.data = fe
                    }
                    for (le && se && (this.options.keys = !1),
                    ce = 0; ce < ne; ce++)
                        ae = oe + ce,
                        se ? ((re = new $().init(this, [U[ce]].concat(G(Z[ce])))).dataGroup = this.groupMap[Q + ce],
                        re.dataGroup.options && (re.options = re.dataGroup.options,
                        w(re, re.dataGroup.options),
                        delete re.dataLabels)) : (re = ue[ae]) || Y[ae] === void 0 || (ue[ae] = re = new $().init(this, Y[ae], U[ce])),
                        re && (re.index = se ? Q + ce : ae,
                        he[ce] = re);
                    if (this.options.keys = le,
                    ue && (ne !== (q = ue.length) || se))
                        for (ce = 0; ce < q; ce++)
                            ce !== oe || se || (ce += ne),
                            ue[ce] && (ue[ce].destroyElements(),
                            ue[ce].plotX = void 0);
                    this.data = ue,
                    this.points = he,
                    A(this, "afterGeneratePoints")
                }
                getXExtremes(z) {
                    return {
                        min: F(z),
                        max: R(z)
                    }
                }
                getExtremes(z, Y) {
                    let U = this.xAxis, Z = this.yAxis, $ = this.processedXData || this.xData, ne = [], oe = this.requireSorting && !this.is("column") ? 1 : 0, se = !!Z && Z.positiveValuesOnly, le, he, Q, q, ae, re, ce, ue = 0, fe = 0, de = 0;
                    z = z || this.stackedYData || this.processedYData || [];
                    let ge = z.length;
                    for (U && (ue = (le = U.getExtremes()).min,
                    fe = le.max),
                    re = 0; re < ge; re++)
                        if (q = $[re],
                        he = (H(ae = z[re]) || N(ae)) && ((H(ae) ? ae > 0 : ae.length) || !se),
                        Q = Y || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !U || ($[re + oe] || q) >= ue && ($[re - oe] || q) <= fe,
                        he && Q)
                            if (ce = ae.length)
                                for (; ce--; )
                                    H(ae[ce]) && (ne[de++] = ae[ce]);
                            else
                                ne[de++] = ae;
                    let ye = {
                        activeYData: ne,
                        dataMin: F(ne),
                        dataMax: R(ne)
                    };
                    return A(this, "afterGetExtremes", {
                        dataExtremes: ye
                    }),
                    ye
                }
                applyExtremes() {
                    let z = this.getExtremes();
                    return this.dataMin = z.dataMin,
                    this.dataMax = z.dataMax,
                    z
                }
                getFirstValidPoint(z) {
                    let Y = z.length
                      , U = 0
                      , Z = null;
                    for (; Z === null && U < Y; )
                        Z = z[U],
                        U++;
                    return Z
                }
                translate() {
                    var ge;
                    this.processedXData || this.processData(),
                    this.generatePoints();
                    let z = this.options, Y = z.stacking, U = this.xAxis, Z = U.categories, $ = this.enabledDataSorting, ne = this.yAxis, oe = this.points, se = oe.length, le = this.pointPlacementToXValue(), he = !!le, Q = z.threshold, q = z.startFromThreshold ? Q : 0, ae, re, ce, ue, fe = Number.MAX_VALUE;
                    function de(ye) {
                        return P(ye, -1e5, 1e5)
                    }
                    for (ae = 0; ae < se; ae++) {
                        let ye, pe = oe[ae], xe = pe.x, ke, Ee, we = pe.y, ve = pe.low, _e = Y && ((ge = ne.stacking) == null ? void 0 : ge.stacks[(this.negStacks && we < (q ? 0 : Q) ? "-" : "") + this.stackKey]);
                        re = U.translate(xe, !1, !1, !1, !0, le),
                        pe.plotX = H(re) ? _(de(re)) : void 0,
                        Y && this.visible && _e && _e[xe] && (ue = this.getStackIndicator(ue, xe, this.index),
                        !pe.isNull && ue.key && (Ee = (ke = _e[xe]).points[ue.key]),
                        ke && N(Ee) && (ve = Ee[0],
                        we = Ee[1],
                        ve === q && ue.key === _e[xe].base && (ve = D(H(Q) ? Q : ne.min)),
                        ne.positiveValuesOnly && T(ve) && ve <= 0 && (ve = void 0),
                        pe.total = pe.stackTotal = D(ke.total),
                        pe.percentage = T(pe.y) && ke.total ? pe.y / ke.total * 100 : void 0,
                        pe.stackY = we,
                        this.irregularWidths || ke.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))),
                        pe.yBottom = T(ve) ? de(ne.translate(ve, !1, !0, !1, !0)) : void 0,
                        this.dataModify && (we = this.dataModify.modifyValue(we, ae)),
                        H(we) && pe.plotX !== void 0 && (ye = H(ye = ne.translate(we, !1, !0, !1, !0)) ? de(ye) : void 0),
                        pe.plotY = ye,
                        pe.isInside = this.isPointInside(pe),
                        pe.clientX = he ? _(U.translate(xe, !1, !1, !1, !0, le)) : re,
                        pe.negative = (pe.y || 0) < (Q || 0),
                        pe.category = D(Z && Z[pe.x], pe.x),
                        pe.isNull || pe.visible === !1 || (ce !== void 0 && (fe = Math.min(fe, Math.abs(re - ce))),
                        ce = re),
                        pe.zone = this.zones.length ? pe.getZone() : void 0,
                        !pe.graphic && this.group && $ && (pe.isNew = !0)
                    }
                    this.closestPointRangePx = fe,
                    A(this, "afterTranslate")
                }
                getValidPoints(z, Y, U) {
                    let Z = this.chart;
                    return (z || this.points || []).filter(function($) {
                        let {plotX: ne, plotY: oe} = $;
                        return !(!U && ($.isNull || !H(oe))) && (!Y || !!Z.isInsidePlot(ne, oe, {
                            inverted: Z.inverted
                        })) && $.visible !== !1
                    })
                }
                getClipBox() {
                    let {chart: z, xAxis: Y, yAxis: U} = this
                      , Z = ie(z.clipBox);
                    return Y && Y.len !== z.plotSizeX && (Z.width = Y.len),
                    U && U.len !== z.plotSizeY && (Z.height = U.len),
                    Z
                }
                getSharedClipKey() {
                    return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0),
                    this.sharedClipKey
                }
                setClip() {
                    let {chart: z, group: Y, markerGroup: U} = this
                      , Z = z.sharedClips
                      , $ = z.renderer
                      , ne = this.getClipBox()
                      , oe = this.getSharedClipKey()
                      , se = Z[oe];
                    se ? se.animate(ne) : Z[oe] = se = $.clipRect(ne),
                    Y && Y.clip(this.options.clip === !1 ? void 0 : se),
                    U && U.clip()
                }
                animate(z) {
                    let {chart: Y, group: U, markerGroup: Z} = this
                      , $ = Y.inverted
                      , ne = f(this.options.animation)
                      , oe = [this.getSharedClipKey(), ne.duration, ne.easing, ne.defer].join(",")
                      , se = Y.sharedClips[oe]
                      , le = Y.sharedClips[oe + "m"];
                    if (z && U) {
                        let he = this.getClipBox();
                        if (se)
                            se.attr("height", he.height);
                        else {
                            he.width = 0,
                            $ && (he.x = Y.plotHeight),
                            se = Y.renderer.clipRect(he),
                            Y.sharedClips[oe] = se;
                            let Q = {
                                x: -99,
                                y: -99,
                                width: $ ? Y.plotWidth + 199 : 99,
                                height: $ ? 99 : Y.plotHeight + 199
                            };
                            le = Y.renderer.clipRect(Q),
                            Y.sharedClips[oe + "m"] = le
                        }
                        U.clip(se),
                        Z && Z.clip(le)
                    } else if (se && !se.hasClass("highcharts-animating")) {
                        let he = this.getClipBox()
                          , Q = ne.step;
                        Z && Z.element.childNodes.length && (ne.step = function(q, ae) {
                            Q && Q.apply(ae, arguments),
                            ae.prop === "width" && le && le.element && le.attr($ ? "height" : "width", q + 99)
                        }
                        ),
                        se.addClass("highcharts-animating").animate(he, ne)
                    }
                }
                afterAnimate() {
                    this.setClip(),
                    K(this.chart.sharedClips, (z,Y,U)=>{
                        z && !this.chart.container.querySelector(`[clip-path="url(#${z.id})"]`) && (z.destroy(),
                        delete U[Y])
                    }
                    ),
                    this.finishedAnimating = !0,
                    A(this, "afterAnimate")
                }
                drawPoints(z=this.points) {
                    let Y, U, Z, $, ne, oe, se, le = this.chart, he = le.styledMode, {colorAxis: Q, options: q} = this, ae = q.marker, re = this[this.specialGroup || "markerGroup"], ce = this.xAxis, ue = D(ae.enabled, !ce || !!ce.isRadial || null, this.closestPointRangePx >= ae.enabledThreshold * ae.radius);
                    if (ae.enabled !== !1 || this._hasPointMarkers)
                        for (Y = 0; Y < z.length; Y++)
                            if ($ = (Z = (U = z[Y]).graphic) ? "animate" : "attr",
                            ne = U.marker || {},
                            oe = !!U.marker,
                            (ue && ne.enabled === void 0 || ne.enabled) && !U.isNull && U.visible !== !1) {
                                let de = D(ne.symbol, this.symbol, "rect");
                                se = this.markerAttribs(U, U.selected && "select"),
                                this.enabledDataSorting && (U.startXPos = ce.reversed ? -(se.width || 0) : ce.width);
                                let ge = U.isInside !== !1;
                                if (!Z && ge && ((se.width || 0) > 0 || U.hasImage) && (U.graphic = Z = le.renderer.symbol(de, se.x, se.y, se.width, se.height, oe ? ne : ae).add(re),
                                this.enabledDataSorting && le.hasRendered && (Z.attr({
                                    x: U.startXPos
                                }),
                                $ = "animate")),
                                Z && $ === "animate" && Z[ge ? "show" : "hide"](ge).animate(se),
                                Z) {
                                    let ye = this.pointAttribs(U, he || !U.selected ? void 0 : "select");
                                    he ? Q && Z.css({
                                        fill: ye.fill
                                    }) : Z[$](ye)
                                }
                                Z && Z.addClass(U.getClassName(), !0)
                            } else
                                Z && (U.graphic = Z.destroy())
                }
                markerAttribs(z, Y) {
                    let U = this.options, Z = U.marker, $ = z.marker || {}, ne = $.symbol || Z.symbol, oe = {}, se, le, he = D($.radius, Z && Z.radius);
                    Y && (se = Z.states[Y],
                    he = D((le = $.states && $.states[Y]) && le.radius, se && se.radius, he && he + (se && se.radiusPlus || 0))),
                    z.hasImage = ne && ne.indexOf("url") === 0,
                    z.hasImage && (he = 0);
                    let Q = z.pos();
                    return H(he) && Q && (oe.x = Q[0] - he,
                    oe.y = Q[1] - he,
                    U.crisp && (oe.x = Math.floor(oe.x))),
                    he && (oe.width = oe.height = 2 * he),
                    oe
                }
                pointAttribs(z, Y) {
                    let U = this.options.marker, Z = z && z.options, $ = Z && Z.marker || {}, ne = Z && Z.color, oe = z && z.color, se = z && z.zone && z.zone.color, le, he, Q = this.color, q, ae, re = D($.lineWidth, U.lineWidth), ce = 1;
                    return Q = ne || se || oe || Q,
                    q = $.fillColor || U.fillColor || Q,
                    ae = $.lineColor || U.lineColor || Q,
                    Y = Y || "normal",
                    le = U.states[Y] || {},
                    re = D((he = $.states && $.states[Y] || {}).lineWidth, le.lineWidth, re + D(he.lineWidthPlus, le.lineWidthPlus, 0)),
                    q = he.fillColor || le.fillColor || q,
                    {
                        stroke: ae = he.lineColor || le.lineColor || ae,
                        "stroke-width": re,
                        fill: q,
                        opacity: ce = D(he.opacity, le.opacity, ce)
                    }
                }
                destroy(z) {
                    let Y, U, Z, $ = this, ne = $.chart, oe = /AppleWebKit\/533/.test(C.navigator.userAgent), se = $.data || [];
                    for (A($, "destroy", {
                        keepEventsForUpdate: z
                    }),
                    this.removeEvents(z),
                    ($.axisTypes || []).forEach(function(le) {
                        (Z = $[le]) && Z.series && (I(Z.series, $),
                        Z.isDirty = Z.forceRedraw = !0)
                    }),
                    $.legendItem && $.chart.legend.destroyItem($),
                    Y = se.length; Y--; )
                        (U = se[Y]) && U.destroy && U.destroy();
                    $.clips && $.clips.forEach(le=>le.destroy()),
                    m.clearTimeout($.animationTimeout),
                    K($, function(le, he) {
                        le instanceof d && !le.survive && le[oe && he === "group" ? "hide" : "destroy"]()
                    }),
                    ne.hoverSeries === $ && (ne.hoverSeries = void 0),
                    I(ne.series, $),
                    ne.orderItems("series"),
                    K($, function(le, he) {
                        z && he === "hcEvents" || delete $[he]
                    })
                }
                applyZones() {
                    let z = this, Y = this.chart, U = Y.renderer, Z = this.zones, $ = this.clips || [], ne = this.graph, oe = this.area, se = Math.max(Y.plotWidth, Y.plotHeight), le = this[(this.zoneAxis || "y") + "Axis"], he = Y.inverted, Q, q, ae, re, ce, ue, fe, de, ge, ye, pe, xe = !1;
                    Z.length && (ne || oe) && le && le.min !== void 0 ? (ce = le.reversed,
                    ue = le.horiz,
                    ne && !this.showLine && ne.hide(),
                    oe && oe.hide(),
                    re = le.getExtremes(),
                    Z.forEach(function(ke, Ee) {
                        Q = ce ? ue ? Y.plotWidth : 0 : ue ? 0 : le.toPixels(re.min) || 0,
                        Q = P(D(q, Q), 0, se),
                        q = P(Math.round(le.toPixels(D(ke.value, re.max), !0) || 0), 0, se),
                        xe && (Q = q = le.toPixels(re.max)),
                        fe = Math.abs(Q - q),
                        de = Math.min(Q, q),
                        ge = Math.max(Q, q),
                        le.isXAxis ? (ae = {
                            x: he ? ge : de,
                            y: 0,
                            width: fe,
                            height: se
                        },
                        ue || (ae.x = Y.plotHeight - ae.x)) : (ae = {
                            x: 0,
                            y: he ? ge : de,
                            width: se,
                            height: fe
                        },
                        ue && (ae.y = Y.plotWidth - ae.y)),
                        $[Ee] ? $[Ee].animate(ae) : $[Ee] = U.clipRect(ae),
                        ye = z["zone-area-" + Ee],
                        pe = z["zone-graph-" + Ee],
                        ne && pe && pe.clip($[Ee]),
                        oe && ye && ye.clip($[Ee]),
                        xe = ke.value > re.max,
                        z.resetZones && q === 0 && (q = void 0)
                    }),
                    this.clips = $) : z.visible && (ne && ne.show(),
                    oe && oe.show())
                }
                plotGroup(z, Y, U, Z, $) {
                    let ne = this[z]
                      , oe = !ne
                      , se = {
                        visibility: U,
                        zIndex: Z || .1
                    };
                    return this.opacity === void 0 || this.chart.styledMode || this.state === "inactive" || (se.opacity = this.opacity),
                    oe && (this[z] = ne = this.chart.renderer.g().add($)),
                    ne.addClass("highcharts-" + Y + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (T(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (ne.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0),
                    ne.attr(se)[oe ? "attr" : "animate"](this.getPlotBox(Y)),
                    ne
                }
                getPlotBox(z) {
                    let Y = this.xAxis
                      , U = this.yAxis
                      , Z = this.chart
                      , $ = Z.inverted && !Z.polar && Y && this.invertible !== !1 && z === "series";
                    return Z.inverted && (Y = U,
                    U = this.xAxis),
                    {
                        translateX: Y ? Y.left : Z.plotLeft,
                        translateY: U ? U.top : Z.plotTop,
                        rotation: $ ? 90 : 0,
                        rotationOriginX: $ ? (Y.len - U.len) / 2 : 0,
                        rotationOriginY: $ ? (Y.len + U.len) / 2 : 0,
                        scaleX: $ ? -1 : 1,
                        scaleY: 1
                    }
                }
                removeEvents(z) {
                    z || V(this),
                    this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function(Y) {
                        Y()
                    }),
                    this.eventsToUnbind.length = 0)
                }
                render() {
                    let z = this
                      , Y = z.chart
                      , U = z.options
                      , Z = f(U.animation)
                      , $ = z.visible ? "inherit" : "hidden"
                      , ne = U.zIndex
                      , oe = z.hasRendered
                      , se = Y.seriesGroup;
                    Y.inverted;
                    let le = z.finishedAnimating ? 0 : Z.duration;
                    A(this, "render"),
                    z.plotGroup("group", "series", $, ne, se),
                    z.markerGroup = z.plotGroup("markerGroup", "markers", $, ne, se),
                    U.clip !== !1 && z.setClip(),
                    z.animate && le && z.animate(!0),
                    z.drawGraph && (z.drawGraph(),
                    z.applyZones()),
                    z.visible && z.drawPoints(),
                    z.drawDataLabels && z.drawDataLabels(),
                    z.redrawPoints && z.redrawPoints(),
                    z.drawTracker && U.enableMouseTracking && z.drawTracker(),
                    z.animate && le && z.animate(),
                    oe || (le && Z.defer && (le += Z.defer),
                    z.animationTimeout = ee(function() {
                        z.afterAnimate()
                    }, le || 0)),
                    z.isDirty = !1,
                    z.hasRendered = !0,
                    A(z, "afterRender")
                }
                redraw() {
                    let z = this.isDirty || this.isDirtyData;
                    this.translate(),
                    this.render(),
                    z && delete this.kdTree
                }
                reserveSpace() {
                    return this.visible || !this.chart.options.chart.ignoreHiddenSeries
                }
                searchPoint(z, Y) {
                    let U = this.xAxis
                      , Z = this.yAxis
                      , $ = this.chart.inverted;
                    return this.searchKDTree({
                        clientX: $ ? U.len - z.chartY + U.pos : z.chartX - U.pos,
                        plotY: $ ? Z.len - z.chartX + Z.pos : z.chartY - Z.pos
                    }, Y, z)
                }
                buildKDTree(z) {
                    this.buildingKdTree = !0;
                    let Y = this
                      , U = Y.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
                    delete Y.kdTree,
                    ee(function() {
                        Y.kdTree = function Z($, ne, oe) {
                            let se, le, he = $ && $.length;
                            if (he)
                                return se = Y.kdAxisArray[ne % oe],
                                $.sort(function(Q, q) {
                                    return Q[se] - q[se]
                                }),
                                {
                                    point: $[le = Math.floor(he / 2)],
                                    left: Z($.slice(0, le), ne + 1, oe),
                                    right: Z($.slice(le + 1), ne + 1, oe)
                                }
                        }(Y.getValidPoints(null, !Y.directTouch), U, U),
                        Y.buildingKdTree = !1
                    }, Y.options.kdNow || z && z.type === "touchstart" ? 0 : 1)
                }
                searchKDTree(z, Y, U) {
                    let Z = this
                      , [$,ne] = this.kdAxisArray
                      , oe = Y ? "distX" : "dist"
                      , se = (Z.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1
                      , le = !!Z.isBubble;
                    if (this.kdTree || this.buildingKdTree || this.buildKDTree(U),
                    this.kdTree)
                        return function he(Q, q, ae, re) {
                            var ke;
                            let ce = q.point, ue = Z.kdAxisArray[ae % re], fe, de, ge = ce;
                            (function(Ee, we) {
                                var Ne;
                                let ve = Ee[$]
                                  , _e = we[$]
                                  , Oe = T(ve) && T(_e) ? ve - _e : null
                                  , ze = Ee[ne]
                                  , Qe = we[ne]
                                  , Fe = T(ze) && T(Qe) ? ze - Qe : 0
                                  , rt = le && ((Ne = we.marker) == null ? void 0 : Ne.radius) || 0;
                                we.dist = Math.sqrt((Oe && Oe * Oe || 0) + Fe * Fe) - rt,
                                we.distX = T(Oe) ? Math.abs(Oe) - rt : Number.MAX_VALUE
                            }
                            )(Q, ce);
                            let ye = (Q[ue] || 0) - (ce[ue] || 0) + (le && ((ke = ce.marker) == null ? void 0 : ke.radius) || 0)
                              , pe = ye < 0 ? "left" : "right"
                              , xe = ye < 0 ? "right" : "left";
                            return q[pe] && (ge = (fe = he(Q, q[pe], ae + 1, re))[oe] < ge[oe] ? fe : ce),
                            q[xe] && Math.sqrt(ye * ye) < ge[oe] && (ge = (de = he(Q, q[xe], ae + 1, re))[oe] < ge[oe] ? de : ge),
                            ge
                        }(z, this.kdTree, se, se)
                }
                pointPlacementToXValue() {
                    let {options: {pointPlacement: z, pointRange: Y}, xAxis: U} = this
                      , Z = z;
                    return Z === "between" && (Z = U.reversed ? -.5 : .5),
                    H(Z) ? Z * (Y || U.pointRange) : 0
                }
                isPointInside(z) {
                    let {chart: Y, xAxis: U, yAxis: Z} = this;
                    return z.plotY !== void 0 && z.plotX !== void 0 && z.plotY >= 0 && z.plotY <= (Z ? Z.len : Y.plotHeight) && z.plotX >= 0 && z.plotX <= (U ? U.len : Y.plotWidth)
                }
                drawTracker() {
                    let z = this
                      , Y = z.options
                      , U = Y.trackByArea
                      , Z = [].concat(U ? z.areaPath : z.graphPath)
                      , $ = z.chart
                      , ne = $.pointer
                      , oe = $.renderer
                      , se = $.options.tooltip.snap
                      , le = z.tracker
                      , he = function(q) {
                        Y.enableMouseTracking && $.hoverSeries !== z && z.onMouseOver()
                    }
                      , Q = "rgba(192,192,192," + (g ? 1e-4 : .002) + ")";
                    le ? le.attr({
                        d: Z
                    }) : z.graph && (z.tracker = oe.path(Z).attr({
                        visibility: z.visible ? "inherit" : "hidden",
                        zIndex: 2
                    }).addClass(U ? "highcharts-tracker-area" : "highcharts-tracker-line").add(z.group),
                    $.styledMode || z.tracker.attr({
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        stroke: Q,
                        fill: U ? Q : "none",
                        "stroke-width": z.graph.strokeWidth() + (U ? 0 : 2 * se)
                    }),
                    [z.tracker, z.markerGroup, z.dataLabelsGroup].forEach(function(q) {
                        q && (q.addClass("highcharts-tracker").on("mouseover", he).on("mouseout", function(ae) {
                            ne.onTrackerMouseOut(ae)
                        }),
                        Y.cursor && !$.styledMode && q.css({
                            cursor: Y.cursor
                        }),
                        p && q.on("touchstart", he))
                    })),
                    A(this, "afterDrawTracker")
                }
                addPoint(z, Y, U, Z, $) {
                    let ne, oe, se = this.options, le = this.data, he = this.chart, Q = this.xAxis, q = Q && Q.hasNames && Q.names, ae = se.data, re = this.xData;
                    Y = D(Y, !0);
                    let ce = {
                        series: this
                    };
                    this.pointClass.prototype.applyOptions.apply(ce, [z]);
                    let ue = ce.x;
                    if (oe = re.length,
                    this.requireSorting && ue < re[oe - 1])
                        for (ne = !0; oe && re[oe - 1] > ue; )
                            oe--;
                    this.updateParallelArrays(ce, "splice", [oe, 0, 0]),
                    this.updateParallelArrays(ce, oe),
                    q && ce.name && (q[ue] = ce.name),
                    ae.splice(oe, 0, z),
                    (ne || this.processedData) && (this.data.splice(oe, 0, null),
                    this.processData()),
                    se.legendType === "point" && this.generatePoints(),
                    U && (le[0] && le[0].remove ? le[0].remove(!1) : (le.shift(),
                    this.updateParallelArrays(ce, "shift"),
                    ae.shift())),
                    $ !== !1 && A(this, "addPoint", {
                        point: ce
                    }),
                    this.isDirty = !0,
                    this.isDirtyData = !0,
                    Y && he.redraw(Z)
                }
                removePoint(z, Y, U) {
                    let Z = this
                      , $ = Z.data
                      , ne = $[z]
                      , oe = Z.points
                      , se = Z.chart
                      , le = function() {
                        oe && oe.length === $.length && oe.splice(z, 1),
                        $.splice(z, 1),
                        Z.options.data.splice(z, 1),
                        Z.updateParallelArrays(ne || {
                            series: Z
                        }, "splice", [z, 1]),
                        ne && ne.destroy(),
                        Z.isDirty = !0,
                        Z.isDirtyData = !0,
                        Y && se.redraw()
                    };
                    x(U, se),
                    Y = D(Y, !0),
                    ne ? ne.firePointEvent("remove", null, le) : le()
                }
                remove(z, Y, U, Z) {
                    let $ = this
                      , ne = $.chart;
                    function oe() {
                        $.destroy(Z),
                        ne.isDirtyLegend = ne.isDirtyBox = !0,
                        ne.linkSeries(Z),
                        D(z, !0) && ne.redraw(Y)
                    }
                    U !== !1 ? A($, "remove", null, oe) : oe()
                }
                update(z, Y) {
                    var fe, de;
                    A(this, "update", {
                        options: z = L(z, this.userOptions)
                    });
                    let U = this, Z = U.chart, $ = U.userOptions, ne = U.initialType || U.type, oe = Z.options.plotOptions, se = E[ne].prototype, le = U.finishedAnimating && {
                        animation: !1
                    }, he = {}, Q, q, ae = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], re = z.type || $.type || Z.options.chart.type, ce = !(this.hasDerivedData || re && re !== this.type || z.pointStart !== void 0 || z.pointInterval !== void 0 || z.relativeXValue !== void 0 || z.joinBy || z.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some(ge=>U.hasOptionChanged(ge)));
                    re = re || ne,
                    ce && (ae.push("data", "isDirtyData", "isDirtyCanvas", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"),
                    z.visible !== !1 && ae.push("area", "graph"),
                    U.parallelArrays.forEach(function(ge) {
                        ae.push(ge + "Data")
                    }),
                    z.data && (z.dataSorting && w(U.options.dataSorting, z.dataSorting),
                    this.setData(z.data, !1))),
                    z = ie($, le, {
                        index: $.index === void 0 ? U.index : $.index,
                        pointStart: D((fe = oe == null ? void 0 : oe.series) == null ? void 0 : fe.pointStart, $.pointStart, U.xData[0])
                    }, !ce && {
                        data: U.options.data
                    }, z),
                    ce && z.data && (z.data = U.options.data),
                    (ae = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(ae)).forEach(function(ge) {
                        ae[ge] = U[ge],
                        delete U[ge]
                    });
                    let ue = !1;
                    if (E[re]) {
                        if (ue = re !== U.type,
                        U.remove(!1, !1, !1, !0),
                        ue)
                            if (Object.setPrototypeOf)
                                Object.setPrototypeOf(U, E[re].prototype);
                            else {
                                let ge = Object.hasOwnProperty.call(U, "hcEvents") && U.hcEvents;
                                for (q in se)
                                    U[q] = void 0;
                                w(U, E[re].prototype),
                                ge ? U.hcEvents = ge : delete U.hcEvents
                            }
                    } else
                        k(17, !0, Z, {
                            missingModuleFor: re
                        });
                    if (ae.forEach(function(ge) {
                        U[ge] = ae[ge]
                    }),
                    U.init(Z, z),
                    ce && this.points)
                        for (let ge of ((Q = U.options).visible === !1 ? (he.graphic = 1,
                        he.dataLabel = 1) : (this.hasMarkerChanged(Q, $) && (he.graphic = 1),
                        (de = U.hasDataLabels) != null && de.call(U) || (he.dataLabel = 1)),
                        this.points))
                            ge && ge.series && (ge.resolveColor(),
                            Object.keys(he).length && ge.destroyElements(he),
                            Q.showInLegend === !1 && ge.legendItem && Z.legend.destroyItem(ge));
                    U.initialType = ne,
                    Z.linkSeries(),
                    ue && U.linkedSeries.length && (U.isDirtyData = !0),
                    A(this, "afterUpdate"),
                    D(Y, !0) && Z.redraw(!!ce && void 0)
                }
                setName(z) {
                    this.name = this.options.name = this.userOptions.name = z,
                    this.chart.isDirtyLegend = !0
                }
                hasOptionChanged(z) {
                    var oe, se;
                    let Y = this.chart
                      , U = this.options[z]
                      , Z = Y.options.plotOptions
                      , $ = this.userOptions[z]
                      , ne = D((oe = Z == null ? void 0 : Z[this.type]) == null ? void 0 : oe[z], (se = Z == null ? void 0 : Z.series) == null ? void 0 : se[z]);
                    return $ && !T(ne) ? U !== $ : U !== D(ne, U)
                }
                onMouseOver() {
                    let z = this.chart
                      , Y = z.hoverSeries;
                    z.pointer.setHoverChartIndex(),
                    Y && Y !== this && Y.onMouseOut(),
                    this.options.events.mouseOver && A(this, "mouseOver"),
                    this.setState("hover"),
                    z.hoverSeries = this
                }
                onMouseOut() {
                    let z = this.options
                      , Y = this.chart
                      , U = Y.tooltip
                      , Z = Y.hoverPoint;
                    Y.hoverSeries = null,
                    Z && Z.onMouseOut(),
                    this && z.events.mouseOut && A(this, "mouseOut"),
                    U && !this.stickyTracking && (!U.shared || this.noSharedTooltip) && U.hide(),
                    Y.series.forEach(function($) {
                        $.setState("", !0)
                    })
                }
                setState(z, Y) {
                    let U = this, Z = U.options, $ = U.graph, ne = Z.inactiveOtherPoints, oe = Z.states, se = D(oe[z || "normal"] && oe[z || "normal"].animation, U.chart.options.chart.animation), le, he = Z.lineWidth, Q = 0, q = Z.opacity;
                    if (z = z || "",
                    U.state !== z && ([U.group, U.markerGroup, U.dataLabelsGroup].forEach(function(ae) {
                        ae && (U.state && ae.removeClass("highcharts-series-" + U.state),
                        z && ae.addClass("highcharts-series-" + z))
                    }),
                    U.state = z,
                    !U.chart.styledMode)) {
                        if (oe[z] && oe[z].enabled === !1)
                            return;
                        if (z && (he = oe[z].lineWidth || he + (oe[z].lineWidthPlus || 0),
                        q = D(oe[z].opacity, q)),
                        $ && !$.dashstyle && H(he))
                            for (le = {
                                "stroke-width": he
                            },
                            $.animate(le, se); U["zone-graph-" + Q]; )
                                U["zone-graph-" + Q].animate(le, se),
                                Q += 1;
                        ne || [U.group, U.markerGroup, U.dataLabelsGroup, U.labelBySeries].forEach(function(ae) {
                            ae && ae.animate({
                                opacity: q
                            }, se)
                        })
                    }
                    Y && ne && U.points && U.setAllPointsToState(z || void 0)
                }
                setAllPointsToState(z) {
                    this.points.forEach(function(Y) {
                        Y.setState && Y.setState(z)
                    })
                }
                setVisible(z, Y) {
                    var se;
                    let U = this
                      , Z = U.chart
                      , $ = Z.options.chart.ignoreHiddenSeries
                      , ne = U.visible;
                    U.visible = z = U.options.visible = U.userOptions.visible = z === void 0 ? !ne : z;
                    let oe = z ? "show" : "hide";
                    ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(le=>{
                        var he;
                        (he = U[le]) == null || he[oe]()
                    }
                    ),
                    (Z.hoverSeries === U || ((se = Z.hoverPoint) == null ? void 0 : se.series) === U) && U.onMouseOut(),
                    U.legendItem && Z.legend.colorizeItem(U, z),
                    U.isDirty = !0,
                    U.options.stacking && Z.series.forEach(le=>{
                        le.options.stacking && le.visible && (le.isDirty = !0)
                    }
                    ),
                    U.linkedSeries.forEach(le=>{
                        le.setVisible(z, !1)
                    }
                    ),
                    $ && (Z.isDirtyBox = !0),
                    A(U, oe),
                    Y !== !1 && Z.redraw()
                }
                show() {
                    this.setVisible(!0)
                }
                hide() {
                    this.setVisible(!1)
                }
                select(z) {
                    this.selected = z = this.options.selected = z === void 0 ? !this.selected : z,
                    this.checkbox && (this.checkbox.checked = z),
                    A(this, z ? "select" : "unselect")
                }
                shouldShowTooltip(z, Y, U={}) {
                    return U.series = this,
                    U.visiblePlotOnly = !0,
                    this.chart.isInsidePlot(z, Y, U)
                }
                drawLegendSymbol(z, Y) {
                    var U;
                    (U = l[this.options.legendSymbol || "rectangle"]) == null || U.call(this, z, Y)
                }
            }
            return J.defaultOptions = u,
            J.types = h.seriesTypes,
            J.registerType = h.registerSeriesType,
            w(J.prototype, {
                axisTypes: ["xAxis", "yAxis"],
                coll: "series",
                colorCounter: 0,
                directTouch: !1,
                isCartesian: !0,
                kdAxisArray: ["clientX", "plotY"],
                parallelArrays: ["x", "y"],
                pointClass: c,
                requireSorting: !0,
                sorted: !0
            }),
            h.series = J,
            J
        }),
        i(n, "Core/Chart/Chart.js", [n["Core/Animation/AnimationUtilities.js"], n["Core/Axis/Axis.js"], n["Core/Defaults.js"], n["Core/Templating.js"], n["Core/Foundation.js"], n["Core/Globals.js"], n["Core/Renderer/RendererRegistry.js"], n["Core/Series/Series.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Renderer/SVG/SVGRenderer.js"], n["Core/Time.js"], n["Core/Utilities.js"], n["Core/Renderer/HTML/AST.js"]], function(r, s, o, a, l, c, u, h, d, m, f, x, S) {
            let {animate: v, animObject: p, setAnimation: g} = r
              , {defaultOptions: C, defaultTime: E} = o
              , {numberFormat: O} = a
              , {registerEventOptions: R} = l
              , {charts: F, doc: P, marginNames: _, svg: T, win: L} = c
              , {seriesTypes: I} = d
              , {addEvent: k, attr: w, createElement: b, css: A, defined: j, diffObjects: B, discardElement: W, erase: N, error: H, extend: X, find: ie, fireEvent: K, getStyle: D, isArray: V, isNumber: G, isObject: ee, isString: J, merge: te, objectEach: z, pick: Y, pInt: U, relativeLength: Z, removeEvent: $, splat: ne, syncTimeout: oe, uniqueKey: se} = x;
            class le {
                static chart(Q, q, ae) {
                    return new le(Q,q,ae)
                }
                constructor(Q, q, ae) {
                    this.axes = void 0,
                    this.axisOffset = void 0,
                    this.bounds = void 0,
                    this.chartHeight = void 0,
                    this.chartWidth = void 0,
                    this.clipBox = void 0,
                    this.colorCounter = void 0,
                    this.container = void 0,
                    this.eventOptions = void 0,
                    this.index = void 0,
                    this.isResizing = void 0,
                    this.labelCollectors = void 0,
                    this.margin = void 0,
                    this.numberFormatter = void 0,
                    this.options = void 0,
                    this.plotBox = void 0,
                    this.plotHeight = void 0,
                    this.plotLeft = void 0,
                    this.plotTop = void 0,
                    this.plotWidth = void 0,
                    this.pointCount = void 0,
                    this.pointer = void 0,
                    this.renderer = void 0,
                    this.renderTo = void 0,
                    this.series = void 0,
                    this.sharedClips = {},
                    this.spacing = void 0,
                    this.spacingBox = void 0,
                    this.symbolCounter = void 0,
                    this.time = void 0,
                    this.titleOffset = void 0,
                    this.userOptions = void 0,
                    this.xAxis = void 0,
                    this.yAxis = void 0,
                    this.zooming = void 0,
                    this.getArgs(Q, q, ae)
                }
                getArgs(Q, q, ae) {
                    J(Q) || Q.nodeName ? (this.renderTo = Q,
                    this.init(q, ae)) : this.init(Q, q)
                }
                setZoomOptions() {
                    let Q = this.options.chart
                      , q = Q.zooming;
                    this.zooming = {
                        ...q,
                        type: Y(Q.zoomType, q.type),
                        key: Y(Q.zoomKey, q.key),
                        pinchType: Y(Q.pinchType, q.pinchType),
                        singleTouch: Y(Q.zoomBySingleTouch, q.singleTouch, !1),
                        resetButton: te(q.resetButton, Q.resetZoomButton)
                    }
                }
                init(Q, q) {
                    K(this, "init", {
                        args: arguments
                    }, function() {
                        let ae = te(C, Q)
                          , re = ae.chart;
                        this.userOptions = X({}, Q),
                        this.margin = [],
                        this.spacing = [],
                        this.bounds = {
                            h: {},
                            v: {}
                        },
                        this.labelCollectors = [],
                        this.callback = q,
                        this.isResizing = 0,
                        this.options = ae,
                        this.axes = [],
                        this.series = [],
                        this.time = Q.time && Object.keys(Q.time).length ? new f(Q.time) : c.time,
                        this.numberFormatter = re.numberFormatter || O,
                        this.styledMode = re.styledMode,
                        this.hasCartesianSeries = re.showAxes,
                        this.index = F.length,
                        F.push(this),
                        c.chartCount++,
                        R(this, re),
                        this.xAxis = [],
                        this.yAxis = [],
                        this.pointCount = this.colorCounter = this.symbolCounter = 0,
                        this.setZoomOptions(),
                        K(this, "afterInit"),
                        this.firstRender()
                    })
                }
                initSeries(Q) {
                    let q = this.options.chart
                      , ae = Q.type || q.type
                      , re = I[ae];
                    re || H(17, !0, this, {
                        missingModuleFor: ae
                    });
                    let ce = new re;
                    return typeof ce.init == "function" && ce.init(this, Q),
                    ce
                }
                setSeriesData() {
                    this.getSeriesOrderByLinks().forEach(function(Q) {
                        Q.points || Q.data || !Q.enabledDataSorting || Q.setData(Q.options.data, !1)
                    })
                }
                getSeriesOrderByLinks() {
                    return this.series.concat().sort(function(Q, q) {
                        return Q.linkedSeries.length || q.linkedSeries.length ? q.linkedSeries.length - Q.linkedSeries.length : 0
                    })
                }
                orderItems(Q, q=0) {
                    let ae = this[Q]
                      , re = this.options[Q] = ne(this.options[Q]).slice()
                      , ce = this.userOptions[Q] = this.userOptions[Q] ? ne(this.userOptions[Q]).slice() : [];
                    if (this.hasRendered && (re.splice(q),
                    ce.splice(q)),
                    ae)
                        for (let ue = q, fe = ae.length; ue < fe; ++ue) {
                            let de = ae[ue];
                            de && (de.index = ue,
                            de instanceof h && (de.name = de.getName()),
                            de.options.isInternal || (re[ue] = de.options,
                            ce[ue] = de.userOptions))
                        }
                }
                isInsidePlot(Q, q, ae={}) {
                    let {inverted: re, plotBox: ce, plotLeft: ue, plotTop: fe, scrollablePlotBox: de} = this
                      , ge = 0
                      , ye = 0;
                    ae.visiblePlotOnly && this.scrollingContainer && ({scrollLeft: ge, scrollTop: ye} = this.scrollingContainer);
                    let pe = ae.series
                      , xe = ae.visiblePlotOnly && de || ce
                      , ke = ae.inverted ? q : Q
                      , Ee = ae.inverted ? Q : q
                      , we = {
                        x: ke,
                        y: Ee,
                        isInsidePlot: !0,
                        options: ae
                    };
                    if (!ae.ignoreX) {
                        let ve = pe && (re && !this.polar ? pe.yAxis : pe.xAxis) || {
                            pos: ue,
                            len: 1 / 0
                        }
                          , _e = ae.paneCoordinates ? ve.pos + ke : ue + ke;
                        _e >= Math.max(ge + ue, ve.pos) && _e <= Math.min(ge + ue + xe.width, ve.pos + ve.len) || (we.isInsidePlot = !1)
                    }
                    if (!ae.ignoreY && we.isInsidePlot) {
                        let ve = !re && ae.axis && !ae.axis.isXAxis && ae.axis || pe && (re ? pe.xAxis : pe.yAxis) || {
                            pos: fe,
                            len: 1 / 0
                        }
                          , _e = ae.paneCoordinates ? ve.pos + Ee : fe + Ee;
                        _e >= Math.max(ye + fe, ve.pos) && _e <= Math.min(ye + fe + xe.height, ve.pos + ve.len) || (we.isInsidePlot = !1)
                    }
                    return K(this, "afterIsInsidePlot", we),
                    we.isInsidePlot
                }
                redraw(Q) {
                    K(this, "beforeRedraw");
                    let q = this.hasCartesianSeries ? this.axes : this.colorAxis || [], ae = this.series, re = this.pointer, ce = this.legend, ue = this.userOptions.legend, fe = this.renderer, de = fe.isHidden(), ge = [], ye, pe, xe, ke = this.isDirtyBox, Ee = this.isDirtyLegend, we;
                    for (fe.rootFontSize = fe.boxWrapper.getStyle("font-size"),
                    this.setResponsive && this.setResponsive(!1),
                    g(!!this.hasRendered && Q, this),
                    de && this.temporaryDisplay(),
                    this.layOutTitles(!1),
                    xe = ae.length; xe--; )
                        if (((we = ae[xe]).options.stacking || we.options.centerInCategory) && (pe = !0,
                        we.isDirty)) {
                            ye = !0;
                            break
                        }
                    if (ye)
                        for (xe = ae.length; xe--; )
                            (we = ae[xe]).options.stacking && (we.isDirty = !0);
                    ae.forEach(function(ve) {
                        ve.isDirty && (ve.options.legendType === "point" ? (typeof ve.updateTotals == "function" && ve.updateTotals(),
                        Ee = !0) : ue && (ue.labelFormatter || ue.labelFormat) && (Ee = !0)),
                        ve.isDirtyData && K(ve, "updatedData")
                    }),
                    Ee && ce && ce.options.enabled && (ce.render(),
                    this.isDirtyLegend = !1),
                    pe && this.getStacks(),
                    q.forEach(function(ve) {
                        ve.updateNames(),
                        ve.setScale()
                    }),
                    this.getMargins(),
                    q.forEach(function(ve) {
                        ve.isDirty && (ke = !0)
                    }),
                    q.forEach(function(ve) {
                        let _e = ve.min + "," + ve.max;
                        ve.extKey !== _e && (ve.extKey = _e,
                        ge.push(function() {
                            K(ve, "afterSetExtremes", X(ve.eventArgs, ve.getExtremes())),
                            delete ve.eventArgs
                        })),
                        (ke || pe) && ve.redraw()
                    }),
                    ke && this.drawChartBox(),
                    K(this, "predraw"),
                    ae.forEach(function(ve) {
                        (ke || ve.isDirty) && ve.visible && ve.redraw(),
                        ve.isDirtyData = !1
                    }),
                    re && re.reset(!0),
                    fe.draw(),
                    K(this, "redraw"),
                    K(this, "render"),
                    de && this.temporaryDisplay(!0),
                    ge.forEach(function(ve) {
                        ve.call()
                    })
                }
                get(Q) {
                    let q = this.series;
                    function ae(ce) {
                        return ce.id === Q || ce.options && ce.options.id === Q
                    }
                    let re = ie(this.axes, ae) || ie(this.series, ae);
                    for (let ce = 0; !re && ce < q.length; ce++)
                        re = ie(q[ce].points || [], ae);
                    return re
                }
                getAxes() {
                    let Q = this.options;
                    for (let q of (K(this, "getAxes"),
                    ["xAxis", "yAxis"])) {
                        let ae = Q[q] = ne(Q[q] || {});
                        for (let re of ae)
                            new s(this,re,q)
                    }
                    K(this, "afterGetAxes")
                }
                getSelectedPoints() {
                    return this.series.reduce((Q,q)=>(q.getPointsCollection().forEach(ae=>{
                        Y(ae.selectedStaging, ae.selected) && Q.push(ae)
                    }
                    ),
                    Q), [])
                }
                getSelectedSeries() {
                    return this.series.filter(function(Q) {
                        return Q.selected
                    })
                }
                setTitle(Q, q, ae) {
                    this.applyDescription("title", Q),
                    this.applyDescription("subtitle", q),
                    this.applyDescription("caption", void 0),
                    this.layOutTitles(ae)
                }
                applyDescription(Q, q) {
                    let ae = this
                      , re = this.options[Q] = te(this.options[Q], q)
                      , ce = this[Q];
                    ce && q && (this[Q] = ce = ce.destroy()),
                    re && !ce && ((ce = this.renderer.text(re.text, 0, 0, re.useHTML).attr({
                        align: re.align,
                        class: "highcharts-" + Q,
                        zIndex: re.zIndex || 4
                    }).add()).update = function(ue, fe) {
                        ae.applyDescription(Q, ue),
                        ae.layOutTitles(fe)
                    }
                    ,
                    this.styledMode || ce.css(X(Q === "title" ? {
                        fontSize: this.options.isStock ? "1em" : "1.2em"
                    } : {}, re.style)),
                    this[Q] = ce)
                }
                layOutTitles(Q=!0) {
                    let q = [0, 0, 0]
                      , ae = this.renderer
                      , re = this.spacingBox;
                    ["title", "subtitle", "caption"].forEach(function(ue) {
                        let fe = this[ue]
                          , de = this.options[ue]
                          , ge = de.verticalAlign || "top"
                          , ye = ue === "title" ? ge === "top" ? -3 : 0 : ge === "top" ? q[0] + 2 : 0;
                        if (fe) {
                            fe.css({
                                width: (de.width || re.width + (de.widthAdjust || 0)) + "px"
                            });
                            let pe = ae.fontMetrics(fe).b
                              , xe = Math.round(fe.getBBox(de.useHTML).height);
                            fe.align(X({
                                y: ge === "bottom" ? pe : ye + pe,
                                height: xe
                            }, de), !1, "spacingBox"),
                            de.floating || (ge === "top" ? q[0] = Math.ceil(q[0] + xe) : ge === "bottom" && (q[2] = Math.ceil(q[2] + xe)))
                        }
                    }, this),
                    q[0] && (this.options.title.verticalAlign || "top") === "top" && (q[0] += this.options.title.margin),
                    q[2] && this.options.caption.verticalAlign === "bottom" && (q[2] += this.options.caption.margin);
                    let ce = !this.titleOffset || this.titleOffset.join(",") !== q.join(",");
                    this.titleOffset = q,
                    K(this, "afterLayOutTitles"),
                    !this.isDirtyBox && ce && (this.isDirtyBox = this.isDirtyLegend = ce,
                    this.hasRendered && Q && this.isDirtyBox && this.redraw())
                }
                getContainerBox() {
                    return {
                        width: D(this.renderTo, "width", !0) || 0,
                        height: D(this.renderTo, "height", !0) || 0
                    }
                }
                getChartSize() {
                    let Q = this.options.chart
                      , q = Q.width
                      , ae = Q.height
                      , re = this.getContainerBox();
                    this.chartWidth = Math.max(0, q || re.width || 600),
                    this.chartHeight = Math.max(0, Z(ae, this.chartWidth) || (re.height > 1 ? re.height : 400)),
                    this.containerBox = re
                }
                temporaryDisplay(Q) {
                    let q = this.renderTo, ae;
                    if (Q)
                        for (; q && q.style; )
                            q.hcOrigStyle && (A(q, q.hcOrigStyle),
                            delete q.hcOrigStyle),
                            q.hcOrigDetached && (P.body.removeChild(q),
                            q.hcOrigDetached = !1),
                            q = q.parentNode;
                    else
                        for (; q && q.style && (P.body.contains(q) || q.parentNode || (q.hcOrigDetached = !0,
                        P.body.appendChild(q)),
                        (D(q, "display", !1) === "none" || q.hcOricDetached) && (q.hcOrigStyle = {
                            display: q.style.display,
                            height: q.style.height,
                            overflow: q.style.overflow
                        },
                        ae = {
                            display: "block",
                            overflow: "hidden"
                        },
                        q !== this.renderTo && (ae.height = 0),
                        A(q, ae),
                        q.offsetWidth || q.style.setProperty("display", "block", "important")),
                        (q = q.parentNode) !== P.body); )
                            ;
                }
                setClassName(Q) {
                    this.container.className = "highcharts-container " + (Q || "")
                }
                getContainer() {
                    let Q = this.options, q = Q.chart, ae = "data-highcharts-chart", re = se(), ce, ue = this.renderTo;
                    ue || (this.renderTo = ue = q.renderTo),
                    J(ue) && (this.renderTo = ue = P.getElementById(ue)),
                    ue || H(13, !0, this);
                    let fe = U(w(ue, ae));
                    G(fe) && F[fe] && F[fe].hasRendered && F[fe].destroy(),
                    w(ue, ae, this.index),
                    ue.innerHTML = S.emptyHTML,
                    q.skipClone || ue.offsetWidth || this.temporaryDisplay(),
                    this.getChartSize();
                    let de = this.chartWidth
                      , ge = this.chartHeight;
                    A(ue, {
                        overflow: "hidden"
                    }),
                    this.styledMode || (ce = X({
                        position: "relative",
                        overflow: "hidden",
                        width: de + "px",
                        height: ge + "px",
                        textAlign: "left",
                        lineHeight: "normal",
                        zIndex: 0,
                        "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                        userSelect: "none",
                        "touch-action": "manipulation",
                        outline: "none"
                    }, q.style || {}));
                    let ye = b("div", {
                        id: re
                    }, ce, ue);
                    this.container = ye,
                    this._cursor = ye.style.cursor;
                    let pe = q.renderer || !T ? u.getRendererType(q.renderer) : m;
                    if (this.renderer = new pe(ye,de,ge,void 0,q.forExport,Q.exporting && Q.exporting.allowHTML,this.styledMode),
                    this.containerBox = this.getContainerBox(),
                    g(void 0, this),
                    this.setClassName(q.className),
                    this.styledMode)
                        for (let xe in Q.defs)
                            this.renderer.definition(Q.defs[xe]);
                    else
                        this.renderer.setStyle(q.style);
                    this.renderer.chartIndex = this.index,
                    K(this, "afterGetContainer")
                }
                getMargins(Q) {
                    let {spacing: q, margin: ae, titleOffset: re} = this;
                    this.resetMargins(),
                    re[0] && !j(ae[0]) && (this.plotTop = Math.max(this.plotTop, re[0] + q[0])),
                    re[2] && !j(ae[2]) && (this.marginBottom = Math.max(this.marginBottom, re[2] + q[2])),
                    this.legend && this.legend.display && this.legend.adjustMargins(ae, q),
                    K(this, "getMargins"),
                    Q || this.getAxisMargins()
                }
                getAxisMargins() {
                    let Q = this
                      , q = Q.axisOffset = [0, 0, 0, 0]
                      , ae = Q.colorAxis
                      , re = Q.margin
                      , ce = function(ue) {
                        ue.forEach(function(fe) {
                            fe.visible && fe.getOffset()
                        })
                    };
                    Q.hasCartesianSeries ? ce(Q.axes) : ae && ae.length && ce(ae),
                    _.forEach(function(ue, fe) {
                        j(re[fe]) || (Q[ue] += q[fe])
                    }),
                    Q.setChartSize()
                }
                getOptions() {
                    return B(this.userOptions, C)
                }
                reflow(Q) {
                    let q = this
                      , ae = q.containerBox
                      , re = q.getContainerBox();
                    delete q.pointer.chartPosition,
                    !q.isPrinting && !q.isResizing && ae && re.width && ((re.width !== ae.width || re.height !== ae.height) && (x.clearTimeout(q.reflowTimeout),
                    q.reflowTimeout = oe(function() {
                        q.container && q.setSize(void 0, void 0, !1)
                    }, Q ? 100 : 0)),
                    q.containerBox = re)
                }
                setReflow() {
                    let Q = this
                      , q = ae=>{
                        var re;
                        (re = Q.options) != null && re.chart.reflow && Q.hasLoaded && Q.reflow(ae)
                    }
                    ;
                    if (typeof ResizeObserver == "function")
                        new ResizeObserver(q).observe(Q.renderTo);
                    else {
                        let ae = k(L, "resize", q);
                        k(this, "destroy", ae)
                    }
                }
                setSize(Q, q, ae) {
                    let re = this
                      , ce = re.renderer;
                    re.isResizing += 1,
                    g(ae, re);
                    let ue = ce.globalAnimation;
                    re.oldChartHeight = re.chartHeight,
                    re.oldChartWidth = re.chartWidth,
                    Q !== void 0 && (re.options.chart.width = Q),
                    q !== void 0 && (re.options.chart.height = q),
                    re.getChartSize(),
                    re.styledMode || (ue ? v : A)(re.container, {
                        width: re.chartWidth + "px",
                        height: re.chartHeight + "px"
                    }, ue),
                    re.setChartSize(!0),
                    ce.setSize(re.chartWidth, re.chartHeight, ue),
                    re.axes.forEach(function(fe) {
                        fe.isDirty = !0,
                        fe.setScale()
                    }),
                    re.isDirtyLegend = !0,
                    re.isDirtyBox = !0,
                    re.layOutTitles(),
                    re.getMargins(),
                    re.redraw(ue),
                    re.oldChartHeight = null,
                    K(re, "resize"),
                    setTimeout(()=>{
                        re && K(re, "endResize", void 0, ()=>{
                            re.isResizing -= 1
                        }
                        )
                    }
                    , p(ue).duration)
                }
                setChartSize(Q) {
                    let q, ae, re, ce, ue = this.inverted, fe = this.renderer, de = this.chartWidth, ge = this.chartHeight, ye = this.options.chart, pe = this.spacing, xe = this.clipOffset;
                    this.plotLeft = q = Math.round(this.plotLeft),
                    this.plotTop = ae = Math.round(this.plotTop),
                    this.plotWidth = re = Math.max(0, Math.round(de - q - this.marginRight)),
                    this.plotHeight = ce = Math.max(0, Math.round(ge - ae - this.marginBottom)),
                    this.plotSizeX = ue ? ce : re,
                    this.plotSizeY = ue ? re : ce,
                    this.plotBorderWidth = ye.plotBorderWidth || 0,
                    this.spacingBox = fe.spacingBox = {
                        x: pe[3],
                        y: pe[0],
                        width: de - pe[3] - pe[1],
                        height: ge - pe[0] - pe[2]
                    },
                    this.plotBox = fe.plotBox = {
                        x: q,
                        y: ae,
                        width: re,
                        height: ce
                    };
                    let ke = 2 * Math.floor(this.plotBorderWidth / 2)
                      , Ee = Math.ceil(Math.max(ke, xe[3]) / 2)
                      , we = Math.ceil(Math.max(ke, xe[0]) / 2);
                    this.clipBox = {
                        x: Ee,
                        y: we,
                        width: Math.floor(this.plotSizeX - Math.max(ke, xe[1]) / 2 - Ee),
                        height: Math.max(0, Math.floor(this.plotSizeY - Math.max(ke, xe[2]) / 2 - we))
                    },
                    Q || (this.axes.forEach(function(ve) {
                        ve.setAxisSize(),
                        ve.setAxisTranslation()
                    }),
                    fe.alignElements()),
                    K(this, "afterSetChartSize", {
                        skipAxes: Q
                    })
                }
                resetMargins() {
                    K(this, "resetMargins");
                    let Q = this
                      , q = Q.options.chart;
                    ["margin", "spacing"].forEach(function(ae) {
                        let re = q[ae]
                          , ce = ee(re) ? re : [re, re, re, re];
                        ["Top", "Right", "Bottom", "Left"].forEach(function(ue, fe) {
                            Q[ae][fe] = Y(q[ae + ue], ce[fe])
                        })
                    }),
                    _.forEach(function(ae, re) {
                        Q[ae] = Y(Q.margin[re], Q.spacing[re])
                    }),
                    Q.axisOffset = [0, 0, 0, 0],
                    Q.clipOffset = [0, 0, 0, 0]
                }
                drawChartBox() {
                    let Q = this.options.chart, q = this.renderer, ae = this.chartWidth, re = this.chartHeight, ce = this.styledMode, ue = this.plotBGImage, fe = Q.backgroundColor, de = Q.plotBackgroundColor, ge = Q.plotBackgroundImage, ye = this.plotLeft, pe = this.plotTop, xe = this.plotWidth, ke = this.plotHeight, Ee = this.plotBox, we = this.clipRect, ve = this.clipBox, _e = this.chartBackground, Oe = this.plotBackground, ze = this.plotBorder, Qe, Fe, rt, Ne = "animate";
                    _e || (this.chartBackground = _e = q.rect().addClass("highcharts-background").add(),
                    Ne = "attr"),
                    ce ? Qe = Fe = _e.strokeWidth() : (Fe = (Qe = Q.borderWidth || 0) + (Q.shadow ? 8 : 0),
                    rt = {
                        fill: fe || "none"
                    },
                    (Qe || _e["stroke-width"]) && (rt.stroke = Q.borderColor,
                    rt["stroke-width"] = Qe),
                    _e.attr(rt).shadow(Q.shadow)),
                    _e[Ne]({
                        x: Fe / 2,
                        y: Fe / 2,
                        width: ae - Fe - Qe % 2,
                        height: re - Fe - Qe % 2,
                        r: Q.borderRadius
                    }),
                    Ne = "animate",
                    Oe || (Ne = "attr",
                    this.plotBackground = Oe = q.rect().addClass("highcharts-plot-background").add()),
                    Oe[Ne](Ee),
                    !ce && (Oe.attr({
                        fill: de || "none"
                    }).shadow(Q.plotShadow),
                    ge && (ue ? (ge !== ue.attr("href") && ue.attr("href", ge),
                    ue.animate(Ee)) : this.plotBGImage = q.image(ge, ye, pe, xe, ke).add())),
                    we ? we.animate({
                        width: ve.width,
                        height: ve.height
                    }) : this.clipRect = q.clipRect(ve),
                    Ne = "animate",
                    ze || (Ne = "attr",
                    this.plotBorder = ze = q.rect().addClass("highcharts-plot-border").attr({
                        zIndex: 1
                    }).add()),
                    ce || ze.attr({
                        stroke: Q.plotBorderColor,
                        "stroke-width": Q.plotBorderWidth || 0,
                        fill: "none"
                    }),
                    ze[Ne](ze.crisp({
                        x: ye,
                        y: pe,
                        width: xe,
                        height: ke
                    }, -ze.strokeWidth())),
                    this.isDirtyBox = !1,
                    K(this, "afterDrawChartBox")
                }
                propFromSeries() {
                    let Q, q, ae, re = this, ce = re.options.chart, ue = re.options.series;
                    ["inverted", "angular", "polar"].forEach(function(fe) {
                        for (q = I[ce.type],
                        ae = ce[fe] || q && q.prototype[fe],
                        Q = ue && ue.length; !ae && Q--; )
                            (q = I[ue[Q].type]) && q.prototype[fe] && (ae = !0);
                        re[fe] = ae
                    })
                }
                linkSeries(Q) {
                    let q = this
                      , ae = q.series;
                    ae.forEach(function(re) {
                        re.linkedSeries.length = 0
                    }),
                    ae.forEach(function(re) {
                        let ce = re.options.linkedTo;
                        J(ce) && (ce = ce === ":previous" ? q.series[re.index - 1] : q.get(ce)) && ce.linkedParent !== re && (ce.linkedSeries.push(re),
                        re.linkedParent = ce,
                        ce.enabledDataSorting && re.setDataSortingOptions(),
                        re.visible = Y(re.options.visible, ce.options.visible, re.visible))
                    }),
                    K(this, "afterLinkSeries", {
                        isUpdating: Q
                    })
                }
                renderSeries() {
                    this.series.forEach(function(Q) {
                        Q.translate(),
                        Q.render()
                    })
                }
                render() {
                    let Q = this.axes
                      , q = this.colorAxis
                      , ae = this.renderer
                      , re = function(ye) {
                        ye.forEach(function(pe) {
                            pe.visible && pe.render()
                        })
                    }
                      , ce = 0;
                    this.setTitle(),
                    K(this, "beforeMargins"),
                    this.getStacks && this.getStacks(),
                    this.getMargins(!0),
                    this.setChartSize();
                    let ue = this.plotWidth;
                    Q.some(function(ye) {
                        if (ye.horiz && ye.visible && ye.options.labels.enabled && ye.series.length)
                            return ce = 21,
                            !0
                    }),
                    this.plotHeight = Math.max(this.plotHeight - ce, 0);
                    let fe = this.plotHeight;
                    Q.forEach(function(ye) {
                        ye.setScale()
                    }),
                    this.getAxisMargins();
                    let de = ue / this.plotWidth > 1.1
                      , ge = fe / this.plotHeight > 1.05;
                    (de || ge) && (Q.forEach(function(ye) {
                        (ye.horiz && de || !ye.horiz && ge) && ye.setTickInterval(!0)
                    }),
                    this.getMargins()),
                    this.drawChartBox(),
                    this.hasCartesianSeries ? re(Q) : q && q.length && re(q),
                    this.seriesGroup || (this.seriesGroup = ae.g("series-group").attr({
                        zIndex: 3
                    }).shadow(this.options.chart.seriesGroupShadow).add()),
                    this.renderSeries(),
                    this.addCredits(),
                    this.setResponsive && this.setResponsive(),
                    this.hasRendered = !0
                }
                addCredits(Q) {
                    let q = this
                      , ae = te(!0, this.options.credits, Q);
                    ae.enabled && !this.credits && (this.credits = this.renderer.text(ae.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
                        ae.href && (L.location.href = ae.href)
                    }).attr({
                        align: ae.position.align,
                        zIndex: 8
                    }),
                    q.styledMode || this.credits.css(ae.style),
                    this.credits.add().align(ae.position),
                    this.credits.update = function(re) {
                        q.credits = q.credits.destroy(),
                        q.addCredits(re)
                    }
                    )
                }
                destroy() {
                    let Q, q = this, ae = q.axes, re = q.series, ce = q.container, ue = ce && ce.parentNode;
                    for (K(q, "destroy"),
                    q.renderer.forExport ? N(F, q) : F[q.index] = void 0,
                    c.chartCount--,
                    q.renderTo.removeAttribute("data-highcharts-chart"),
                    $(q),
                    Q = ae.length; Q--; )
                        ae[Q] = ae[Q].destroy();
                    for (this.scroller && this.scroller.destroy && this.scroller.destroy(),
                    Q = re.length; Q--; )
                        re[Q] = re[Q].destroy();
                    ["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"].forEach(function(fe) {
                        let de = q[fe];
                        de && de.destroy && (q[fe] = de.destroy())
                    }),
                    ce && (ce.innerHTML = S.emptyHTML,
                    $(ce),
                    ue && W(ce)),
                    z(q, function(fe, de) {
                        delete q[de]
                    })
                }
                firstRender() {
                    let Q = this
                      , q = Q.options;
                    Q.getContainer(),
                    Q.resetMargins(),
                    Q.setChartSize(),
                    Q.propFromSeries(),
                    Q.getAxes();
                    let ae = V(q.series) ? q.series : [];
                    q.series = [],
                    ae.forEach(function(re) {
                        Q.initSeries(re)
                    }),
                    Q.linkSeries(),
                    Q.setSeriesData(),
                    K(Q, "beforeRender"),
                    Q.render(),
                    Q.pointer.getChartPosition(),
                    Q.renderer.imgCount || Q.hasLoaded || Q.onload(),
                    Q.temporaryDisplay(!0)
                }
                onload() {
                    this.callbacks.concat([this.callback]).forEach(function(Q) {
                        Q && this.index !== void 0 && Q.apply(this, [this])
                    }, this),
                    K(this, "load"),
                    K(this, "render"),
                    j(this.index) && this.setReflow(),
                    this.warnIfA11yModuleNotLoaded(),
                    this.hasLoaded = !0
                }
                warnIfA11yModuleNotLoaded() {
                    let {options: Q, title: q} = this;
                    !Q || this.accessibility || (this.renderer.boxWrapper.attr({
                        role: "img",
                        "aria-label": (q && q.element.textContent || "").replace(/</g, "&lt;")
                    }),
                    Q.accessibility && Q.accessibility.enabled === !1 || H('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this))
                }
                addSeries(Q, q, ae) {
                    let re, ce = this;
                    return Q && (q = Y(q, !0),
                    K(ce, "addSeries", {
                        options: Q
                    }, function() {
                        re = ce.initSeries(Q),
                        ce.isDirtyLegend = !0,
                        ce.linkSeries(),
                        re.enabledDataSorting && re.setData(Q.data, !1),
                        K(ce, "afterAddSeries", {
                            series: re
                        }),
                        q && ce.redraw(ae)
                    })),
                    re
                }
                addAxis(Q, q, ae, re) {
                    return this.createAxis(q ? "xAxis" : "yAxis", {
                        axis: Q,
                        redraw: ae,
                        animation: re
                    })
                }
                addColorAxis(Q, q, ae) {
                    return this.createAxis("colorAxis", {
                        axis: Q,
                        redraw: q,
                        animation: ae
                    })
                }
                createAxis(Q, q) {
                    let ae = new s(this,q.axis,Q);
                    return Y(q.redraw, !0) && this.redraw(q.animation),
                    ae
                }
                showLoading(Q) {
                    let q = this
                      , ae = q.options
                      , re = ae.loading
                      , ce = function() {
                        ue && A(ue, {
                            left: q.plotLeft + "px",
                            top: q.plotTop + "px",
                            width: q.plotWidth + "px",
                            height: q.plotHeight + "px"
                        })
                    }
                      , ue = q.loadingDiv
                      , fe = q.loadingSpan;
                    ue || (q.loadingDiv = ue = b("div", {
                        className: "highcharts-loading highcharts-loading-hidden"
                    }, null, q.container)),
                    fe || (q.loadingSpan = fe = b("span", {
                        className: "highcharts-loading-inner"
                    }, null, ue),
                    k(q, "redraw", ce)),
                    ue.className = "highcharts-loading",
                    S.setElementHTML(fe, Y(Q, ae.lang.loading, "")),
                    q.styledMode || (A(ue, X(re.style, {
                        zIndex: 10
                    })),
                    A(fe, re.labelStyle),
                    q.loadingShown || (A(ue, {
                        opacity: 0,
                        display: ""
                    }),
                    v(ue, {
                        opacity: re.style.opacity || .5
                    }, {
                        duration: re.showDuration || 0
                    }))),
                    q.loadingShown = !0,
                    ce()
                }
                hideLoading() {
                    let Q = this.options
                      , q = this.loadingDiv;
                    q && (q.className = "highcharts-loading highcharts-loading-hidden",
                    this.styledMode || v(q, {
                        opacity: 0
                    }, {
                        duration: Q.loading.hideDuration || 100,
                        complete: function() {
                            A(q, {
                                display: "none"
                            })
                        }
                    })),
                    this.loadingShown = !1
                }
                update(Q, q, ae, re) {
                    let ce, ue, fe, de = this, ge = {
                        credits: "addCredits",
                        title: "setTitle",
                        subtitle: "setSubtitle",
                        caption: "setCaption"
                    }, ye = Q.isResponsiveOptions, pe = [];
                    K(de, "update", {
                        options: Q
                    }),
                    ye || de.setResponsive(!1, !0),
                    Q = B(Q, de.options),
                    de.userOptions = te(de.userOptions, Q);
                    let xe = Q.chart;
                    xe && (te(!0, de.options.chart, xe),
                    this.setZoomOptions(),
                    "className"in xe && de.setClassName(xe.className),
                    ("inverted"in xe || "polar"in xe || "type"in xe) && (de.propFromSeries(),
                    ce = !0),
                    "alignTicks"in xe && (ce = !0),
                    "events"in xe && R(this, xe),
                    z(xe, function(we, ve) {
                        de.propsRequireUpdateSeries.indexOf("chart." + ve) !== -1 && (ue = !0),
                        de.propsRequireDirtyBox.indexOf(ve) !== -1 && (de.isDirtyBox = !0),
                        de.propsRequireReflow.indexOf(ve) !== -1 && (ye ? de.isDirtyBox = !0 : fe = !0)
                    }),
                    !de.styledMode && xe.style && de.renderer.setStyle(de.options.chart.style || {})),
                    !de.styledMode && Q.colors && (this.options.colors = Q.colors),
                    Q.time && (this.time === E && (this.time = new f(Q.time)),
                    te(!0, de.options.time, Q.time)),
                    z(Q, function(we, ve) {
                        de[ve] && typeof de[ve].update == "function" ? de[ve].update(we, !1) : typeof de[ge[ve]] == "function" ? de[ge[ve]](we) : ve !== "colors" && de.collectionsWithUpdate.indexOf(ve) === -1 && te(!0, de.options[ve], Q[ve]),
                        ve !== "chart" && de.propsRequireUpdateSeries.indexOf(ve) !== -1 && (ue = !0)
                    }),
                    this.collectionsWithUpdate.forEach(function(we) {
                        Q[we] && (ne(Q[we]).forEach(function(ve, _e) {
                            let Oe, ze = j(ve.id);
                            ze && (Oe = de.get(ve.id)),
                            !Oe && de[we] && (Oe = de[we][Y(ve.index, _e)]) && (ze && j(Oe.options.id) || Oe.options.isInternal) && (Oe = void 0),
                            Oe && Oe.coll === we && (Oe.update(ve, !1),
                            ae && (Oe.touched = !0)),
                            !Oe && ae && de.collectionsWithInit[we] && (de.collectionsWithInit[we][0].apply(de, [ve].concat(de.collectionsWithInit[we][1] || []).concat([!1])).touched = !0)
                        }),
                        ae && de[we].forEach(function(ve) {
                            ve.touched || ve.options.isInternal ? delete ve.touched : pe.push(ve)
                        }))
                    }),
                    pe.forEach(function(we) {
                        we.chart && we.remove && we.remove(!1)
                    }),
                    ce && de.axes.forEach(function(we) {
                        we.update({}, !1)
                    }),
                    ue && de.getSeriesOrderByLinks().forEach(function(we) {
                        we.chart && we.update({}, !1)
                    }, this);
                    let ke = xe && xe.width
                      , Ee = xe && (J(xe.height) ? Z(xe.height, ke || de.chartWidth) : xe.height);
                    fe || G(ke) && ke !== de.chartWidth || G(Ee) && Ee !== de.chartHeight ? de.setSize(ke, Ee, re) : Y(q, !0) && de.redraw(re),
                    K(de, "afterUpdate", {
                        options: Q,
                        redraw: q,
                        animation: re
                    })
                }
                setSubtitle(Q, q) {
                    this.applyDescription("subtitle", Q),
                    this.layOutTitles(q)
                }
                setCaption(Q, q) {
                    this.applyDescription("caption", Q),
                    this.layOutTitles(q)
                }
                showResetZoom() {
                    let Q = this
                      , q = C.lang
                      , ae = Q.zooming.resetButton
                      , re = ae.theme
                      , ce = ae.relativeTo === "chart" || ae.relativeTo === "spacingBox" ? null : "scrollablePlotBox";
                    function ue() {
                        Q.zoomOut()
                    }
                    K(this, "beforeShowResetZoom", null, function() {
                        Q.resetZoomButton = Q.renderer.button(q.resetZoom, null, null, ue, re).attr({
                            align: ae.position.align,
                            title: q.resetZoomTitle
                        }).addClass("highcharts-reset-zoom").add().align(ae.position, !1, ce)
                    }),
                    K(this, "afterShowResetZoom")
                }
                zoomOut() {
                    K(this, "selection", {
                        resetSelection: !0
                    }, this.zoom)
                }
                zoom(Q) {
                    let q = this, ae = q.pointer, re = !1, ce;
                    !Q || Q.resetSelection ? (q.axes.forEach(function(fe) {
                        ce = fe.zoom()
                    }),
                    ae.initiated = !1) : Q.xAxis.concat(Q.yAxis).forEach(function(fe) {
                        let de = fe.axis
                          , ge = de.isXAxis
                          , {hasPinched: ye, mouseDownX: pe, mouseDownY: xe} = ae;
                        (ae[ge ? "zoomX" : "zoomY"] && j(pe) && j(xe) && q.isInsidePlot(pe - q.plotLeft, xe - q.plotTop, {
                            axis: de,
                            ignoreX: ye,
                            ignoreY: ye
                        }) || !j(q.inverted ? pe : xe)) && (ce = de.zoom(fe.min, fe.max),
                        de.displayBtn && (re = !0))
                    });
                    let ue = q.resetZoomButton;
                    re && !ue ? q.showResetZoom() : !re && ee(ue) && (q.resetZoomButton = ue.destroy()),
                    ce && q.redraw(Y(q.options.chart.animation, Q && Q.animation, q.pointCount < 100))
                }
                pan(Q, q) {
                    let ae, re = this, ce = re.hoverPoints, ue = typeof q == "object" ? q : {
                        enabled: q,
                        type: "x"
                    }, fe = re.options.chart;
                    fe && fe.panning && (fe.panning = ue);
                    let de = ue.type;
                    K(this, "pan", {
                        originalEvent: Q
                    }, function() {
                        ce && ce.forEach(function(pe) {
                            pe.setState()
                        });
                        let ge = re.xAxis;
                        de === "xy" ? ge = ge.concat(re.yAxis) : de === "y" && (ge = re.yAxis);
                        let ye = {};
                        ge.forEach(function(pe) {
                            if (!pe.options.panningEnabled || pe.options.isInternal)
                                return;
                            let xe = pe.horiz, ke = Q[xe ? "chartX" : "chartY"], Ee = xe ? "mouseDownX" : "mouseDownY", we = re[Ee], ve = pe.minPointOffset || 0, _e = pe.reversed && !re.inverted || !pe.reversed && re.inverted ? -1 : 1, Oe = pe.getExtremes(), ze = pe.toValue(we - ke, !0) + ve * _e, Qe = pe.toValue(we + pe.len - ke, !0) - (ve * _e || pe.isXAxis && pe.pointRangePadding || 0), Fe = Qe < ze, rt = pe.hasVerticalPanning(), Ne = Fe ? Qe : ze, Te = Fe ? ze : Qe, Ve = pe.panningState, Ke;
                            rt && !pe.isXAxis && (!Ve || Ve.isDirty) && pe.series.forEach(function(un) {
                                let bn = un.getProcessedData(!0)
                                  , ct = un.getExtremes(bn.yData, !0);
                                Ve || (Ve = {
                                    startMin: Number.MAX_VALUE,
                                    startMax: -Number.MAX_VALUE
                                }),
                                G(ct.dataMin) && G(ct.dataMax) && (Ve.startMin = Math.min(Y(un.options.threshold, 1 / 0), ct.dataMin, Ve.startMin),
                                Ve.startMax = Math.max(Y(un.options.threshold, -1 / 0), ct.dataMax, Ve.startMax))
                            });
                            let st = Math.min(Y(Ve && Ve.startMin, Oe.dataMin), ve ? Oe.min : pe.toValue(pe.toPixels(Oe.min) - pe.minPixelPadding))
                              , Qt = Math.max(Y(Ve && Ve.startMax, Oe.dataMax), ve ? Oe.max : pe.toValue(pe.toPixels(Oe.max) + pe.minPixelPadding));
                            pe.panningState = Ve,
                            pe.isOrdinal || ((Ke = st - Ne) > 0 && (Te += Ke,
                            Ne = st),
                            (Ke = Te - Qt) > 0 && (Te = Qt,
                            Ne -= Ke),
                            pe.series.length && Ne !== Oe.min && Te !== Oe.max && Ne >= st && Te <= Qt && (pe.setExtremes(Ne, Te, !1, !1, {
                                trigger: "pan"
                            }),
                            !re.resetZoomButton && Ne !== st && Te !== Qt && de.match("y") && (re.showResetZoom(),
                            pe.displayBtn = !1),
                            ae = !0),
                            ye[Ee] = ke)
                        }),
                        z(ye, (pe,xe)=>{
                            re[xe] = pe
                        }
                        ),
                        ae && re.redraw(!1),
                        A(re.container, {
                            cursor: "move"
                        })
                    })
                }
            }
            return X(le.prototype, {
                callbacks: [],
                collectionsWithInit: {
                    xAxis: [le.prototype.addAxis, [!0]],
                    yAxis: [le.prototype.addAxis, [!1]],
                    series: [le.prototype.addSeries]
                },
                collectionsWithUpdate: ["xAxis", "yAxis", "series"],
                propsRequireDirtyBox: ["backgroundColor", "borderColor", "borderWidth", "borderRadius", "plotBackgroundColor", "plotBackgroundImage", "plotBorderColor", "plotBorderWidth", "plotShadow", "shadow"],
                propsRequireReflow: ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "spacing", "spacingTop", "spacingRight", "spacingBottom", "spacingLeft"],
                propsRequireUpdateSeries: ["chart.inverted", "chart.polar", "chart.ignoreHiddenSeries", "chart.type", "colors", "plotOptions", "time", "tooltip"]
            }),
            le
        }),
        i(n, "Extensions/ScrollablePlotArea.js", [n["Core/Animation/AnimationUtilities.js"], n["Core/Axis/Axis.js"], n["Core/Chart/Chart.js"], n["Core/Series/Series.js"], n["Core/Renderer/RendererRegistry.js"], n["Core/Utilities.js"]], function(r, s, o, a, l, c) {
            let {stop: u} = r
              , {addEvent: h, createElement: d, defined: m, merge: f, pick: x} = c;
            h(o, "afterSetChartSize", function(S) {
                let v = this.options.chart.scrollablePlotArea, p = v && v.minWidth, g = v && v.minHeight, C, E, O;
                this.renderer.forExport || (p ? (this.scrollablePixelsX = C = Math.max(0, p - this.chartWidth),
                C && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = f(this.plotBox),
                this.plotBox.width = this.plotWidth += C,
                this.inverted ? this.clipBox.height += C : this.clipBox.width += C,
                O = {
                    1: {
                        name: "right",
                        value: C
                    }
                })) : g && (this.scrollablePixelsY = E = Math.max(0, g - this.chartHeight),
                m(E) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = f(this.plotBox),
                this.plotBox.height = this.plotHeight += E,
                this.inverted ? this.clipBox.width += E : this.clipBox.height += E,
                O = {
                    2: {
                        name: "bottom",
                        value: E
                    }
                })),
                O && !S.skipAxes && this.axes.forEach(function(R) {
                    O[R.side] ? R.getPlotLinePath = function() {
                        let F = O[R.side].name, P = O[R.side].value, _ = this[F], T;
                        return this[F] = _ - P,
                        T = s.prototype.getPlotLinePath.apply(this, arguments),
                        this[F] = _,
                        T
                    }
                    : (R.setAxisSize(),
                    R.setAxisTranslation())
                }))
            }),
            h(o, "render", function() {
                this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(),
                this.applyFixed()) : this.fixedDiv && this.applyFixed()
            }),
            o.prototype.setUpScrolling = function() {
                let S, v = {
                    WebkitOverflowScrolling: "touch",
                    overflowX: "hidden",
                    overflowY: "hidden"
                };
                this.scrollablePixelsX && (v.overflowX = "auto"),
                this.scrollablePixelsY && (v.overflowY = "auto"),
                this.scrollingParent = d("div", {
                    className: "highcharts-scrolling-parent"
                }, {
                    position: "relative"
                }, this.renderTo),
                this.scrollingContainer = d("div", {
                    className: "highcharts-scrolling"
                }, v, this.scrollingParent),
                h(this.scrollingContainer, "scroll", ()=>{
                    this.pointer && (delete this.pointer.chartPosition,
                    this.hoverPoint && (S = this.hoverPoint),
                    this.pointer.runPointActions(void 0, S, !0))
                }
                ),
                this.innerContainer = d("div", {
                    className: "highcharts-inner-container"
                }, null, this.scrollingContainer),
                this.innerContainer.appendChild(this.container),
                this.setUpScrolling = null
            }
            ,
            o.prototype.moveFixedElements = function() {
                let S = this.container, v = this.fixedRenderer, p = [".highcharts-breadcrumbs-group", ".highcharts-contextbutton", ".highcharts-credits", ".highcharts-legend", ".highcharts-legend-checkbox", ".highcharts-navigator-series", ".highcharts-navigator-xaxis", ".highcharts-navigator-yaxis", ".highcharts-navigator", ".highcharts-reset-zoom", ".highcharts-drillup-button", ".highcharts-scrollbar", ".highcharts-subtitle", ".highcharts-title"], g;
                this.scrollablePixelsX && !this.inverted ? g = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted || this.scrollablePixelsY && !this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (g = ".highcharts-yaxis"),
                g && p.push(`${g}:not(.highcharts-radial-axis)`, `${g}-labels:not(.highcharts-radial-axis-labels)`),
                p.forEach(function(C) {
                    [].forEach.call(S.querySelectorAll(C), function(E) {
                        (E.namespaceURI === v.SVG_NS ? v.box : v.box.parentNode).appendChild(E),
                        E.style.pointerEvents = "auto"
                    })
                })
            }
            ,
            o.prototype.applyFixed = function() {
                let S, v, p, g = !this.fixedDiv, C = this.options.chart, E = C.scrollablePlotArea, O = l.getRendererType();
                g ? (this.fixedDiv = d("div", {
                    className: "highcharts-fixed"
                }, {
                    position: "absolute",
                    overflow: "hidden",
                    pointerEvents: "none",
                    zIndex: (C.style && C.style.zIndex || 0) + 2,
                    top: 0
                }, null, !0),
                this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer),
                this.renderTo.style.overflow = "visible",
                this.fixedRenderer = S = new O(this.fixedDiv,this.chartWidth,this.chartHeight,this.options.chart.style),
                this.scrollableMask = S.path().attr({
                    fill: this.options.chart.backgroundColor || "#fff",
                    "fill-opacity": x(E.opacity, .85),
                    zIndex: -1
                }).addClass("highcharts-scrollable-mask").add(),
                h(this, "afterShowResetZoom", this.moveFixedElements),
                h(this, "afterApplyDrilldown", this.moveFixedElements),
                h(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight),
                (this.scrollableDirty || g) && (this.scrollableDirty = !1,
                this.moveFixedElements()),
                v = this.chartWidth + (this.scrollablePixelsX || 0),
                p = this.chartHeight + (this.scrollablePixelsY || 0),
                u(this.container),
                this.container.style.width = v + "px",
                this.container.style.height = p + "px",
                this.renderer.boxWrapper.attr({
                    width: v,
                    height: p,
                    viewBox: [0, 0, v, p].join(" ")
                }),
                this.chartBackground.attr({
                    width: v,
                    height: p
                }),
                this.scrollingContainer.style.height = this.chartHeight + "px",
                g && (E.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * E.scrollPositionX),
                E.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * E.scrollPositionY));
                let R = this.axisOffset, F = this.plotTop - R[0] - 1, P = this.plotLeft - R[3] - 1, _ = this.plotTop + this.plotHeight + R[2] + 1, T = this.plotLeft + this.plotWidth + R[1] + 1, L = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), I = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0), k;
                k = this.scrollablePixelsX ? [["M", 0, F], ["L", this.plotLeft - 1, F], ["L", this.plotLeft - 1, _], ["L", 0, _], ["Z"], ["M", L, F], ["L", this.chartWidth, F], ["L", this.chartWidth, _], ["L", L, _], ["Z"]] : this.scrollablePixelsY ? [["M", P, 0], ["L", P, this.plotTop - 1], ["L", T, this.plotTop - 1], ["L", T, 0], ["Z"], ["M", P, I], ["L", P, this.chartHeight], ["L", T, this.chartHeight], ["L", T, I], ["Z"]] : [["M", 0, 0]],
                this.redrawTrigger !== "adjustHeight" && this.scrollableMask.attr({
                    d: k
                })
            }
            ,
            h(s, "afterInit", function() {
                this.chart.scrollableDirty = !0
            }),
            h(a, "show", function() {
                this.chart.scrollableDirty = !0
            })
        }),
        i(n, "Core/Axis/Stacking/StackItem.js", [n["Core/Templating.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {format: a} = r
              , {series: l} = s
              , {destroyObjectProperties: c, fireEvent: u, isNumber: h, pick: d} = o;
            return class {
                constructor(m, f, x, S, v) {
                    let p = m.chart.inverted
                      , g = m.reversed;
                    this.axis = m;
                    let C = this.isNegative = !!x != !!g;
                    this.options = f = f || {},
                    this.x = S,
                    this.total = null,
                    this.cumulative = null,
                    this.points = {},
                    this.hasValidPoints = !1,
                    this.stack = v,
                    this.leftCliff = 0,
                    this.rightCliff = 0,
                    this.alignOptions = {
                        align: f.align || (p ? C ? "left" : "right" : "center"),
                        verticalAlign: f.verticalAlign || (p ? "middle" : C ? "bottom" : "top"),
                        y: f.y,
                        x: f.x
                    },
                    this.textAlign = f.textAlign || (p ? C ? "right" : "left" : "center")
                }
                destroy() {
                    c(this, this.axis)
                }
                render(m) {
                    let f = this.axis.chart
                      , x = this.options
                      , S = x.format
                      , v = S ? a(S, this, f) : x.formatter.call(this);
                    if (this.label)
                        this.label.attr({
                            text: v,
                            visibility: "hidden"
                        });
                    else {
                        this.label = f.renderer.label(v, null, void 0, x.shape, void 0, void 0, x.useHTML, !1, "stack-labels");
                        let p = {
                            r: x.borderRadius || 0,
                            text: v,
                            padding: d(x.padding, 5),
                            visibility: "hidden"
                        };
                        f.styledMode || (p.fill = x.backgroundColor,
                        p.stroke = x.borderColor,
                        p["stroke-width"] = x.borderWidth,
                        this.label.css(x.style || {})),
                        this.label.attr(p),
                        this.label.added || this.label.add(m)
                    }
                    this.label.labelrank = f.plotSizeY,
                    u(this, "afterRender")
                }
                setOffset(m, f, x, S, v, p) {
                    let {alignOptions: g, axis: C, label: E, options: O, textAlign: R} = this
                      , F = C.chart
                      , P = this.getStackBox({
                        xOffset: m,
                        width: f,
                        boxBottom: x,
                        boxTop: S,
                        defaultX: v,
                        xAxis: p
                    })
                      , {verticalAlign: _} = g;
                    if (E && P) {
                        let T = E.getBBox(), L = E.padding, I = d(O.overflow, "justify") === "justify", k;
                        g.x = O.x || 0,
                        g.y = O.y || 0;
                        let {x: w, y: b} = this.adjustStackPosition({
                            labelBox: T,
                            verticalAlign: _,
                            textAlign: R
                        });
                        P.x -= w,
                        P.y -= b,
                        E.align(g, !1, P),
                        (k = F.isInsidePlot(E.alignAttr.x + g.x + w, E.alignAttr.y + g.y + b)) || (I = !1),
                        I && l.prototype.justifyDataLabel.call(C, E, g, E.alignAttr, T, P),
                        E.attr({
                            x: E.alignAttr.x,
                            y: E.alignAttr.y,
                            rotation: O.rotation,
                            rotationOriginX: T.width / 2,
                            rotationOriginY: T.height / 2
                        }),
                        d(!I && O.crop, !0) && (k = h(E.x) && h(E.y) && F.isInsidePlot(E.x - L + (E.width || 0), E.y) && F.isInsidePlot(E.x + L, E.y)),
                        E[k ? "show" : "hide"]()
                    }
                    u(this, "afterSetOffset", {
                        xOffset: m,
                        width: f
                    })
                }
                adjustStackPosition({labelBox: m, verticalAlign: f, textAlign: x}) {
                    let S = {
                        bottom: 0,
                        middle: 1,
                        top: 2,
                        right: 1,
                        center: 0,
                        left: -1
                    }
                      , v = S[f]
                      , p = S[x];
                    return {
                        x: m.width / 2 + m.width / 2 * p,
                        y: m.height / 2 * v
                    }
                }
                getStackBox(m) {
                    let f = this.axis
                      , x = f.chart
                      , {boxTop: S, defaultX: v, xOffset: p, width: g, boxBottom: C} = m
                      , E = f.stacking.usePercentage ? 100 : d(S, this.total, 0)
                      , O = f.toPixels(E)
                      , R = m.xAxis || x.xAxis[0]
                      , F = d(v, R.translate(this.x)) + p
                      , P = f.toPixels(C || h(f.min) && f.logarithmic && f.logarithmic.lin2log(f.min) || 0)
                      , _ = Math.abs(O - P)
                      , T = x.inverted
                      , L = this.isNegative;
                    return T ? {
                        x: (L ? O : O - _) - x.plotLeft,
                        y: R.height - F - g,
                        width: _,
                        height: g
                    } : {
                        x: F + R.transB - x.plotLeft,
                        y: (L ? O - _ : O) - x.plotTop,
                        width: g,
                        height: _
                    }
                }
            }
        }),
        i(n, "Core/Axis/Stacking/StackingAxis.js", [n["Core/Animation/AnimationUtilities.js"], n["Core/Axis/Axis.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Axis/Stacking/StackItem.js"], n["Core/Utilities.js"]], function(r, s, o, a, l) {
            var c;
            let {getDeferredAnimation: u} = r
              , {series: {prototype: h}} = o
              , {addEvent: d, correctFloat: m, defined: f, destroyObjectProperties: x, fireEvent: S, isArray: v, isNumber: p, objectEach: g, pick: C} = l;
            function E() {
                let k = this.inverted;
                this.axes.forEach(w=>{
                    w.stacking && w.stacking.stacks && w.hasVisibleSeries && (w.stacking.oldStacks = w.stacking.stacks)
                }
                ),
                this.series.forEach(w=>{
                    let b = w.xAxis && w.xAxis.options || {};
                    w.options.stacking && w.reserveSpace() && (w.stackKey = [w.type, C(w.options.stack, ""), k ? b.top : b.left, k ? b.height : b.width].join(","))
                }
                )
            }
            function O() {
                var w;
                let k = this.stacking;
                if (k) {
                    let b = k.stacks;
                    g(b, (A,j)=>{
                        x(A),
                        delete b[j]
                    }
                    ),
                    (w = k.stackTotalGroup) == null || w.destroy()
                }
            }
            function R() {
                this.stacking || (this.stacking = new I(this))
            }
            function F(k, w, b, A) {
                return !f(k) || k.x !== w || A && k.stackKey !== A ? k = {
                    x: w,
                    index: 0,
                    key: A,
                    stackKey: A
                } : k.index++,
                k.key = [b, w, k.index].join(","),
                k
            }
            function P() {
                let k, w = this, b = w.yAxis, A = w.stackKey || "", j = b.stacking.stacks, B = w.processedXData, W = w.options.stacking, N = w[W + "Stacker"];
                N && [A, "-" + A].forEach(H=>{
                    var V;
                    let X = B.length, ie, K, D;
                    for (; X--; )
                        ie = B[X],
                        k = w.getStackIndicator(k, ie, w.index, H),
                        K = (V = j[H]) == null ? void 0 : V[ie],
                        (D = K == null ? void 0 : K.points[k.key || ""]) && N.call(w, D, K, X)
                }
                )
            }
            function _(k, w, b) {
                let A = w.total ? 100 / w.total : 0;
                k[0] = m(k[0] * A),
                k[1] = m(k[1] * A),
                this.stackedYData[b] = k[1]
            }
            function T(k) {
                this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && this.chart.series.length > 1 ? h.setStackedPoints.call(this, k, "group") : k.stacking.resetStacks()
            }
            function L(k, w) {
                var le, he;
                let b, A, j, B, W, N, H, X, ie, K = w || this.options.stacking;
                if (!K || !this.reserveSpace() || ({
                    group: "xAxis"
                }[K] || "yAxis") !== k.coll)
                    return;
                let D = this.processedXData
                  , V = this.processedYData
                  , G = []
                  , ee = V.length
                  , J = this.options
                  , te = J.threshold || 0
                  , z = J.startFromThreshold ? te : 0
                  , Y = J.stack
                  , U = w ? `${this.type},${K}` : this.stackKey || ""
                  , Z = "-" + U
                  , $ = this.negStacks
                  , ne = k.stacking
                  , oe = ne.stacks
                  , se = ne.oldStacks;
                for (ne.stacksTouched += 1,
                H = 0; H < ee; H++) {
                    X = D[H],
                    ie = V[H],
                    N = (b = this.getStackIndicator(b, X, this.index)).key || "",
                    oe[W = (A = $ && ie < (z ? 0 : te)) ? Z : U] || (oe[W] = {}),
                    oe[W][X] || ((le = se[W]) != null && le[X] ? (oe[W][X] = se[W][X],
                    oe[W][X].total = null) : oe[W][X] = new a(k,k.options.stackLabels,!!A,X,Y)),
                    j = oe[W][X],
                    ie !== null ? (j.points[N] = j.points[this.index] = [C(j.cumulative, z)],
                    f(j.cumulative) || (j.base = N),
                    j.touched = ne.stacksTouched,
                    b.index > 0 && this.singleStacks === !1 && (j.points[N][0] = j.points[this.index + "," + X + ",0"][0])) : (delete j.points[N],
                    delete j.points[this.index]);
                    let Q = j.total || 0;
                    K === "percent" ? (B = A ? U : Z,
                    Q = $ && ((he = oe[B]) != null && he[X]) ? (B = oe[B][X]).total = Math.max(B.total || 0, Q) + Math.abs(ie) || 0 : m(Q + (Math.abs(ie) || 0))) : K === "group" ? (v(ie) && (ie = ie[0]),
                    ie !== null && Q++) : Q = m(Q + (ie || 0)),
                    K === "group" ? j.cumulative = (Q || 1) - 1 : j.cumulative = m(C(j.cumulative, z) + (ie || 0)),
                    j.total = Q,
                    ie !== null && (j.points[N].push(j.cumulative),
                    G[H] = j.cumulative,
                    j.hasValidPoints = !0)
                }
                K === "percent" && (ne.usePercentage = !0),
                K !== "group" && (this.stackedYData = G),
                ne.oldStacks = {}
            }
            class I {
                constructor(w) {
                    this.oldStacks = {},
                    this.stacks = {},
                    this.stacksTouched = 0,
                    this.axis = w
                }
                buildStacks() {
                    let w, b, A = this.axis, j = A.series, B = A.coll === "xAxis", W = A.options.reversedStacks, N = j.length;
                    for (this.resetStacks(),
                    this.usePercentage = !1,
                    b = N; b--; )
                        w = j[W ? b : N - b - 1],
                        B && w.setGroupedPoints(A),
                        w.setStackedPoints(A);
                    if (!B)
                        for (b = 0; b < N; b++)
                            j[b].modifyStacks();
                    S(A, "afterBuildStacks")
                }
                cleanStacks() {
                    this.oldStacks && (this.stacks = this.oldStacks,
                    g(this.stacks, w=>{
                        g(w, b=>{
                            b.cumulative = b.total
                        }
                        )
                    }
                    ))
                }
                resetStacks() {
                    g(this.stacks, w=>{
                        g(w, (b,A)=>{
                            p(b.touched) && b.touched < this.stacksTouched ? (b.destroy(),
                            delete w[A]) : (b.total = null,
                            b.cumulative = null)
                        }
                        )
                    }
                    )
                }
                renderStackTotals() {
                    var H;
                    let w = this.axis
                      , b = w.chart
                      , A = b.renderer
                      , j = this.stacks
                      , B = (H = w.options.stackLabels) == null ? void 0 : H.animation
                      , W = u(b, B || !1)
                      , N = this.stackTotalGroup = this.stackTotalGroup || A.g("stack-labels").attr({
                        zIndex: 6,
                        opacity: 0
                    }).add();
                    N.translate(b.plotLeft, b.plotTop),
                    g(j, X=>{
                        g(X, ie=>{
                            ie.render(N)
                        }
                        )
                    }
                    ),
                    N.animate({
                        opacity: 1
                    }, W)
                }
            }
            return function(k) {
                let w = [];
                k.compose = function(b, A, j) {
                    if (l.pushUnique(w, b) && (d(b, "init", R),
                    d(b, "destroy", O)),
                    l.pushUnique(w, A)) {
                        let B = A.prototype;
                        B.getStacks = E
                    }
                    if (l.pushUnique(w, j)) {
                        let B = j.prototype;
                        B.getStackIndicator = F,
                        B.modifyStacks = P,
                        B.percentStacker = _,
                        B.setGroupedPoints = T,
                        B.setStackedPoints = L
                    }
                }
            }(c || (c = {})),
            c
        }),
        i(n, "Series/Line/LineSeries.js", [n["Core/Series/Series.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {defined: a, merge: l, isObject: c} = o;
            class u extends r {
                constructor() {
                    super(...arguments),
                    this.data = void 0,
                    this.options = void 0,
                    this.points = void 0
                }
                drawGraph() {
                    let d = this
                      , m = this.options
                      , f = (this.gappedPath || this.getGraphPath).call(this)
                      , x = this.chart.styledMode
                      , S = [["graph", "highcharts-graph"]];
                    x || S[0].push(m.lineColor || this.color || "#cccccc", m.dashStyle),
                    (S = d.getZonesGraphs(S)).forEach(function(v, p) {
                        let g = v[0], C, E = d[g], O = E ? "animate" : "attr";
                        E ? (E.endX = d.preventGraphAnimation ? null : f.xMap,
                        E.animate({
                            d: f
                        })) : f.length && (d[g] = E = d.chart.renderer.path(f).addClass(v[1]).attr({
                            zIndex: 1
                        }).add(d.group)),
                        E && !x && (C = {
                            stroke: v[2],
                            "stroke-width": m.lineWidth || 0,
                            fill: d.fillGraph && d.color || "none"
                        },
                        v[3] ? C.dashstyle = v[3] : m.linecap !== "square" && (C["stroke-linecap"] = C["stroke-linejoin"] = "round"),
                        E[O](C).shadow(p < 2 && m.shadow && l({
                            filterUnits: "userSpaceOnUse"
                        }, c(m.shadow) ? m.shadow : {}))),
                        E && (E.startX = f.xMap,
                        E.isArea = f.isArea)
                    })
                }
                getGraphPath(d, m, f) {
                    let x = this, S = x.options, v = [], p = [], g, C = S.step;
                    d = d || x.points;
                    let E = d.reversed;
                    return E && d.reverse(),
                    (C = {
                        right: 1,
                        center: 2
                    }[C] || C && 3) && E && (C = 4 - C),
                    (d = this.getValidPoints(d, !1, !(S.connectNulls && !m && !f))).forEach(function(O, R) {
                        let F, P = O.plotX, _ = O.plotY, T = d[R - 1], L = O.isNull || typeof _ != "number";
                        (O.leftCliff || T && T.rightCliff) && !f && (g = !0),
                        L && !a(m) && R > 0 ? g = !S.connectNulls : L && !m ? g = !0 : (R === 0 || g ? F = [["M", O.plotX, O.plotY]] : x.getPointSpline ? F = [x.getPointSpline(d, O, R)] : C ? (F = C === 1 ? [["L", T.plotX, _]] : C === 2 ? [["L", (T.plotX + P) / 2, T.plotY], ["L", (T.plotX + P) / 2, _]] : [["L", P, T.plotY]]).push(["L", P, _]) : F = [["L", P, _]],
                        p.push(O.x),
                        C && (p.push(O.x),
                        C === 2 && p.push(O.x)),
                        v.push.apply(v, F),
                        g = !1)
                    }),
                    v.xMap = p,
                    x.graphPath = v,
                    v
                }
                getZonesGraphs(d) {
                    return this.zones.forEach(function(m, f) {
                        let x = ["zone-graph-" + f, "highcharts-graph highcharts-zone-graph-" + f + " " + (m.className || "")];
                        this.chart.styledMode || x.push(m.color || this.color, m.dashStyle || this.options.dashStyle),
                        d.push(x)
                    }, this),
                    d
                }
            }
            return u.defaultOptions = l(r.defaultOptions, {
                legendSymbol: "lineMarker"
            }),
            s.registerSeriesType("line", u),
            u
        }),
        i(n, "Series/Area/AreaSeries.js", [n["Core/Color/Color.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {seriesTypes: {line: a}} = s
              , {extend: l, merge: c, objectEach: u, pick: h} = o;
            class d extends a {
                constructor() {
                    super(...arguments),
                    this.data = void 0,
                    this.options = void 0,
                    this.points = void 0
                }
                drawGraph() {
                    this.areaPath = [],
                    super.drawGraph.apply(this);
                    let f = this
                      , x = this.areaPath
                      , S = this.options
                      , v = this.zones
                      , p = [["area", "highcharts-area", this.color, S.fillColor]];
                    v.forEach(function(g, C) {
                        p.push(["zone-area-" + C, "highcharts-area highcharts-zone-area-" + C + " " + g.className, g.color || f.color, g.fillColor || S.fillColor])
                    }),
                    p.forEach(function(g) {
                        let C = g[0]
                          , E = {}
                          , O = f[C]
                          , R = O ? "animate" : "attr";
                        O ? (O.endX = f.preventGraphAnimation ? null : x.xMap,
                        O.animate({
                            d: x
                        })) : (E.zIndex = 0,
                        (O = f[C] = f.chart.renderer.path(x).addClass(g[1]).add(f.group)).isArea = !0),
                        f.chart.styledMode || (g[3] ? E.fill = g[3] : (E.fill = g[2],
                        E["fill-opacity"] = h(S.fillOpacity, .75))),
                        O[R](E),
                        O.startX = x.xMap,
                        O.shiftUnit = S.step ? 2 : 1
                    })
                }
                getGraphPath(f) {
                    let x, S, v, p = a.prototype.getGraphPath, g = this.options, C = g.stacking, E = this.yAxis, O = [], R = [], F = this.index, P = E.stacking.stacks[this.stackKey], _ = g.threshold, T = Math.round(E.getThreshold(g.threshold)), L = h(g.connectNulls, C === "percent"), I = function(B, W, N) {
                        let H = f[B], X = C && P[H.x].points[F], ie = H[N + "Null"] || 0, K = H[N + "Cliff"] || 0, D, V, G = !0;
                        K || ie ? (D = (ie ? X[0] : X[1]) + K,
                        V = X[0] + K,
                        G = !!ie) : !C && f[W] && f[W].isNull && (D = V = _),
                        D !== void 0 && (R.push({
                            plotX: x,
                            plotY: D === null ? T : E.getThreshold(D),
                            isNull: G,
                            isCliff: !0
                        }),
                        O.push({
                            plotX: x,
                            plotY: V === null ? T : E.getThreshold(V),
                            doCurve: !1
                        }))
                    };
                    f = f || this.points,
                    C && (f = this.getStackPoints(f));
                    for (let B = 0, W = f.length; B < W; ++B)
                        C || (f[B].leftCliff = f[B].rightCliff = f[B].leftNull = f[B].rightNull = void 0),
                        S = f[B].isNull,
                        x = h(f[B].rectPlotX, f[B].plotX),
                        v = C ? h(f[B].yBottom, T) : T,
                        S && !L || (L || I(B, B - 1, "left"),
                        S && !C && L || (R.push(f[B]),
                        O.push({
                            x: B,
                            plotX: x,
                            plotY: v
                        })),
                        L || I(B, B + 1, "right"));
                    let k = p.call(this, R, !0, !0);
                    O.reversed = !0;
                    let w = p.call(this, O, !0, !0)
                      , b = w[0];
                    b && b[0] === "M" && (w[0] = ["L", b[1], b[2]]);
                    let A = k.concat(w);
                    A.length && A.push(["Z"]);
                    let j = p.call(this, R, !1, L);
                    return A.xMap = k.xMap,
                    this.areaPath = A,
                    j
                }
                getStackPoints(f) {
                    let x = this
                      , S = []
                      , v = []
                      , p = this.xAxis
                      , g = this.yAxis
                      , C = g.stacking.stacks[this.stackKey]
                      , E = {}
                      , O = g.series
                      , R = O.length
                      , F = g.options.reversedStacks ? 1 : -1
                      , P = O.indexOf(x);
                    if (f = f || this.points,
                    this.options.stacking) {
                        for (let T = 0; T < f.length; T++)
                            f[T].leftNull = f[T].rightNull = void 0,
                            E[f[T].x] = f[T];
                        u(C, function(T, L) {
                            T.total !== null && v.push(L)
                        }),
                        v.sort(function(T, L) {
                            return T - L
                        });
                        let _ = O.map(T=>T.visible);
                        v.forEach(function(T, L) {
                            let I = 0, k, w;
                            if (E[T] && !E[T].isNull)
                                S.push(E[T]),
                                [-1, 1].forEach(function(b) {
                                    let A = b === 1 ? "rightNull" : "leftNull"
                                      , j = C[v[L + b]]
                                      , B = 0;
                                    if (j) {
                                        let W = P;
                                        for (; W >= 0 && W < R; ) {
                                            let N = O[W].index;
                                            !(k = j.points[N]) && (N === x.index ? E[T][A] = !0 : _[W] && (w = C[T].points[N]) && (B -= w[1] - w[0])),
                                            W += F
                                        }
                                    }
                                    E[T][b === 1 ? "rightCliff" : "leftCliff"] = B
                                });
                            else {
                                let b = P;
                                for (; b >= 0 && b < R; ) {
                                    let A = O[b].index;
                                    if (k = C[T].points[A]) {
                                        I = k[1];
                                        break
                                    }
                                    b += F
                                }
                                I = h(I, 0),
                                I = g.translate(I, 0, 1, 0, 1),
                                S.push({
                                    isNull: !0,
                                    plotX: p.translate(T, 0, 0, 0, 1),
                                    x: T,
                                    plotY: I,
                                    yBottom: I
                                })
                            }
                        })
                    }
                    return S
                }
            }
            return d.defaultOptions = c(a.defaultOptions, {
                threshold: 0,
                legendSymbol: "rectangle"
            }),
            l(d.prototype, {
                singleStacks: !1
            }),
            s.registerSeriesType("area", d),
            d
        }),
        i(n, "Series/Spline/SplineSeries.js", [n["Core/Series/SeriesRegistry.js"], n["Core/Utilities.js"]], function(r, s) {
            let {line: o} = r.seriesTypes
              , {merge: a, pick: l} = s;
            class c extends o {
                constructor() {
                    super(...arguments),
                    this.data = void 0,
                    this.options = void 0,
                    this.points = void 0
                }
                getPointSpline(h, d, m) {
                    let f, x, S, v, p = d.plotX || 0, g = d.plotY || 0, C = h[m - 1], E = h[m + 1];
                    function O(F) {
                        return F && !F.isNull && F.doCurve !== !1 && !d.isCliff
                    }
                    if (O(C) && O(E)) {
                        let F = C.plotX || 0
                          , P = C.plotY || 0
                          , _ = E.plotX || 0
                          , T = E.plotY || 0
                          , L = 0;
                        f = (1.5 * p + F) / 2.5,
                        x = (1.5 * g + P) / 2.5,
                        S = (1.5 * p + _) / 2.5,
                        v = (1.5 * g + T) / 2.5,
                        S !== f && (L = (v - x) * (S - p) / (S - f) + g - v),
                        x += L,
                        v += L,
                        x > P && x > g ? (x = Math.max(P, g),
                        v = 2 * g - x) : x < P && x < g && (x = Math.min(P, g),
                        v = 2 * g - x),
                        v > T && v > g ? (v = Math.max(T, g),
                        x = 2 * g - v) : v < T && v < g && (v = Math.min(T, g),
                        x = 2 * g - v),
                        d.rightContX = S,
                        d.rightContY = v,
                        d.controlPoints = {
                            low: [f, x],
                            high: [S, v]
                        }
                    }
                    let R = ["C", l(C.rightContX, C.plotX, 0), l(C.rightContY, C.plotY, 0), l(f, p, 0), l(x, g, 0), p, g];
                    return C.rightContX = C.rightContY = void 0,
                    R
                }
            }
            return c.defaultOptions = a(o.defaultOptions),
            r.registerSeriesType("spline", c),
            c
        }),
        i(n, "Series/AreaSpline/AreaSplineSeries.js", [n["Series/Spline/SplineSeries.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {area: a, area: {prototype: l}} = s.seriesTypes
              , {extend: c, merge: u} = o;
            class h extends r {
                constructor() {
                    super(...arguments),
                    this.data = void 0,
                    this.points = void 0,
                    this.options = void 0
                }
            }
            return h.defaultOptions = u(r.defaultOptions, a.defaultOptions),
            c(h.prototype, {
                getGraphPath: l.getGraphPath,
                getStackPoints: l.getStackPoints,
                drawGraph: l.drawGraph
            }),
            s.registerSeriesType("areaspline", h),
            h
        }),
        i(n, "Series/Column/ColumnSeriesDefaults.js", [], function() {
            return {
                borderRadius: 3,
                centerInCategory: !1,
                groupPadding: .2,
                marker: null,
                pointPadding: .1,
                minPointLength: 0,
                cropThreshold: 50,
                pointRange: null,
                states: {
                    hover: {
                        halo: !1,
                        brightness: .1
                    },
                    select: {
                        color: "#cccccc",
                        borderColor: "#000000"
                    }
                },
                dataLabels: {
                    align: void 0,
                    verticalAlign: void 0,
                    y: void 0
                },
                startFromThreshold: !0,
                stickyTracking: !1,
                tooltip: {
                    distance: 6
                },
                threshold: 0,
                borderColor: "#ffffff"
            }
        }),
        i(n, "Series/Column/ColumnSeries.js", [n["Core/Animation/AnimationUtilities.js"], n["Core/Color/Color.js"], n["Series/Column/ColumnSeriesDefaults.js"], n["Core/Globals.js"], n["Core/Series/Series.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Utilities.js"]], function(r, s, o, a, l, c, u) {
            let {animObject: h} = r
              , {parse: d} = s
              , {hasTouch: m, noop: f} = a
              , {clamp: x, defined: S, extend: v, fireEvent: p, isArray: g, isNumber: C, merge: E, pick: O, objectEach: R, relativeLength: F} = u;
            class P extends l {
                constructor() {
                    super(...arguments),
                    this.borderWidth = void 0,
                    this.data = void 0,
                    this.group = void 0,
                    this.options = void 0,
                    this.points = void 0
                }
                animate(T) {
                    let L, I, k = this, w = this.yAxis, b = w.pos, A = k.options, j = this.chart.inverted, B = {}, W = j ? "translateX" : "translateY";
                    T ? (B.scaleY = .001,
                    I = x(w.toPixels(A.threshold), b, b + w.len),
                    j ? B.translateX = I - w.len : B.translateY = I,
                    k.clipBox && k.setClip(),
                    k.group.attr(B)) : (L = Number(k.group.attr(W)),
                    k.group.animate({
                        scaleY: 1
                    }, v(h(k.options.animation), {
                        step: function(N, H) {
                            k.group && (B[W] = L + H.pos * (b - L),
                            k.group.attr(B))
                        }
                    })))
                }
                init(T, L) {
                    super.init.apply(this, arguments);
                    let I = this;
                    (T = I.chart).hasRendered && T.series.forEach(function(k) {
                        k.type === I.type && (k.isDirty = !0)
                    })
                }
                getColumnMetrics() {
                    var V, G;
                    let T = this, L = T.options, I = T.xAxis, k = T.yAxis, w = I.options.reversedStacks, b = I.reversed && !w || !I.reversed && w, A = {}, j, B = 0;
                    L.grouping === !1 ? B = 1 : T.chart.series.forEach(function(ee) {
                        let J, te = ee.yAxis, z = ee.options;
                        ee.type === T.type && ee.reserveSpace() && k.len === te.len && k.pos === te.pos && (z.stacking && z.stacking !== "group" ? (A[j = ee.stackKey] === void 0 && (A[j] = B++),
                        J = A[j]) : z.grouping !== !1 && (J = B++),
                        ee.columnIndex = J)
                    });
                    let W = Math.min(Math.abs(I.transA) * (!((V = I.brokenAxis) != null && V.hasBreaks) && ((G = I.ordinal) == null ? void 0 : G.slope) || L.pointRange || I.closestPointRange || I.tickInterval || 1), I.len)
                      , N = W * L.groupPadding
                      , H = (W - 2 * N) / (B || 1)
                      , X = Math.min(L.maxPointWidth || I.len, O(L.pointWidth, H * (1 - 2 * L.pointPadding)))
                      , ie = (H - X) / 2
                      , K = (T.columnIndex || 0) + (b ? 1 : 0)
                      , D = ie + (N + K * H - W / 2) * (b ? -1 : 1);
                    return T.columnMetrics = {
                        width: X,
                        offset: D,
                        paddedWidth: H,
                        columnCount: B
                    },
                    T.columnMetrics
                }
                crispCol(T, L, I, k) {
                    this.chart;
                    let w = this.borderWidth
                      , b = -(w % 2 ? .5 : 0)
                      , A = w % 2 ? .5 : 1;
                    this.options.crisp && (I = Math.round(T + I) + b - (T = Math.round(T) + b));
                    let j = Math.round(L + k) + A
                      , B = .5 >= Math.abs(L) && j > .5;
                    return k = j - (L = Math.round(L) + A),
                    B && k && (L -= 1,
                    k += 1),
                    {
                        x: T,
                        y: L,
                        width: I,
                        height: k
                    }
                }
                adjustForMissingColumns(T, L, I, k) {
                    var w;
                    if (!I.isNull && k.columnCount > 1) {
                        let b = this.xAxis.series.filter(W=>W.visible).map(W=>W.index)
                          , A = 0
                          , j = 0;
                        R((w = this.xAxis.stacking) == null ? void 0 : w.stacks, W=>{
                            if (typeof I.x == "number") {
                                let N = W[I.x.toString()];
                                if (N) {
                                    let H = N.points[this.index];
                                    if (g(H)) {
                                        let X = Object.keys(N.points).filter(ie=>!ie.match(",") && N.points[ie] && N.points[ie].length > 1).map(parseFloat).filter(ie=>b.indexOf(ie) !== -1).sort((ie,K)=>K - ie);
                                        A = X.indexOf(this.index),
                                        j = X.length
                                    }
                                }
                            }
                        }
                        );
                        let B = (j - 1) * k.paddedWidth + L;
                        T = (I.plotX || 0) + B / 2 - L - A * k.paddedWidth
                    }
                    return T
                }
                translate() {
                    let T = this
                      , L = T.chart
                      , I = T.options
                      , k = T.dense = T.closestPointRange * T.xAxis.transA < 2
                      , w = T.borderWidth = O(I.borderWidth, k ? 0 : 1)
                      , b = T.xAxis
                      , A = T.yAxis
                      , j = I.threshold
                      , B = O(I.minPointLength, 5)
                      , W = T.getColumnMetrics()
                      , N = W.width
                      , H = T.pointXOffset = W.offset
                      , X = T.dataMin
                      , ie = T.dataMax
                      , K = T.barW = Math.max(N, 1 + 2 * w)
                      , D = T.translatedThreshold = A.getThreshold(j);
                    L.inverted && (D -= .5),
                    I.pointPadding && (K = Math.ceil(K)),
                    l.prototype.translate.apply(T),
                    T.points.forEach(function(V) {
                        let G = O(V.yBottom, D)
                          , ee = 999 + Math.abs(G)
                          , J = V.plotX || 0
                          , te = x(V.plotY, -ee, A.len + ee);
                        V.stackBox;
                        let z, Y = Math.min(te, G), U = Math.max(te, G) - Y, Z = N, $ = J + H, ne = K;
                        B && Math.abs(U) < B && (U = B,
                        z = !A.reversed && !V.negative || A.reversed && V.negative,
                        C(j) && C(ie) && V.y === j && ie <= j && (A.min || 0) < j && (X !== ie || (A.max || 0) <= j) && (z = !z,
                        V.negative = !V.negative),
                        Y = Math.abs(Y - D) > B ? G - B : D - (z ? B : 0)),
                        S(V.options.pointWidth) && ($ -= Math.round(((Z = ne = Math.ceil(V.options.pointWidth)) - N) / 2)),
                        I.centerInCategory && !I.stacking && ($ = T.adjustForMissingColumns($, Z, V, W)),
                        V.barX = $,
                        V.pointWidth = Z,
                        V.tooltipPos = L.inverted ? [x(A.len + A.pos - L.plotLeft - te, A.pos - L.plotLeft, A.len + A.pos - L.plotLeft), b.len + b.pos - L.plotTop - $ - ne / 2, U] : [b.left - L.plotLeft + $ + ne / 2, x(te + A.pos - L.plotTop, A.pos - L.plotTop, A.len + A.pos - L.plotTop), U],
                        V.shapeType = T.pointClass.prototype.shapeType || "roundedRect",
                        V.shapeArgs = T.crispCol($, V.isNull ? D : Y, ne, V.isNull ? 0 : U)
                    }),
                    p(this, "afterColumnTranslate")
                }
                drawGraph() {
                    this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data")
                }
                pointAttribs(T, L) {
                    let I = this.options, k = this.pointAttrToOptions || {}, w = k.stroke || "borderColor", b = k["stroke-width"] || "borderWidth", A, j, B, W = T && T.color || this.color, N = T && T[w] || I[w] || W, H = T && T.options.dashStyle || I.dashStyle, X = T && T[b] || I[b] || this[b] || 0, ie = O(T && T.opacity, I.opacity, 1);
                    T && this.zones.length && (j = T.getZone(),
                    W = T.options.color || j && (j.color || T.nonZonedColor) || this.color,
                    j && (N = j.borderColor || N,
                    H = j.dashStyle || H,
                    X = j.borderWidth || X)),
                    L && T && (B = (A = E(I.states[L], T.options.states && T.options.states[L] || {})).brightness,
                    W = A.color || B !== void 0 && d(W).brighten(A.brightness).get() || W,
                    N = A[w] || N,
                    X = A[b] || X,
                    H = A.dashStyle || H,
                    ie = O(A.opacity, ie));
                    let K = {
                        fill: W,
                        stroke: N,
                        "stroke-width": X,
                        opacity: ie
                    };
                    return H && (K.dashstyle = H),
                    K
                }
                drawPoints(T=this.points) {
                    let L, I = this, k = this.chart, w = I.options, b = k.renderer, A = w.animationLimit || 250;
                    T.forEach(function(j) {
                        let B = j.plotY
                          , W = j.graphic
                          , N = !!W
                          , H = W && k.pointCount < A ? "animate" : "attr";
                        C(B) && j.y !== null ? (L = j.shapeArgs,
                        W && j.hasNewShapeType() && (W = W.destroy()),
                        I.enabledDataSorting && (j.startXPos = I.xAxis.reversed ? -(L && L.width || 0) : I.xAxis.width),
                        !W && (j.graphic = W = b[j.shapeType](L).add(j.group || I.group),
                        W && I.enabledDataSorting && k.hasRendered && k.pointCount < A && (W.attr({
                            x: j.startXPos
                        }),
                        N = !0,
                        H = "animate")),
                        W && N && W[H](E(L)),
                        k.styledMode || W[H](I.pointAttribs(j, j.selected && "select")).shadow(j.allowShadow !== !1 && w.shadow),
                        W && (W.addClass(j.getClassName(), !0),
                        W.attr({
                            visibility: j.visible ? "inherit" : "hidden"
                        }))) : W && (j.graphic = W.destroy())
                    })
                }
                drawTracker(T=this.points) {
                    let L, I = this, k = I.chart, w = k.pointer, b = function(A) {
                        let j = w.getPointFromEvent(A);
                        j !== void 0 && I.options.enableMouseTracking && (w.isDirectTouch = !0,
                        j.onMouseOver(A))
                    };
                    T.forEach(function(A) {
                        L = g(A.dataLabels) ? A.dataLabels : A.dataLabel ? [A.dataLabel] : [],
                        A.graphic && (A.graphic.element.point = A),
                        L.forEach(function(j) {
                            j.div ? j.div.point = A : j.element.point = A
                        })
                    }),
                    I._hasTracking || (I.trackerGroups.forEach(function(A) {
                        I[A] && (I[A].addClass("highcharts-tracker").on("mouseover", b).on("mouseout", function(j) {
                            w.onTrackerMouseOut(j)
                        }),
                        m && I[A].on("touchstart", b),
                        !k.styledMode && I.options.cursor && I[A].css({
                            cursor: I.options.cursor
                        }))
                    }),
                    I._hasTracking = !0),
                    p(this, "afterDrawTracker")
                }
                remove() {
                    let T = this
                      , L = T.chart;
                    L.hasRendered && L.series.forEach(function(I) {
                        I.type === T.type && (I.isDirty = !0)
                    }),
                    l.prototype.remove.apply(T, arguments)
                }
            }
            return P.defaultOptions = E(l.defaultOptions, o),
            v(P.prototype, {
                directTouch: !0,
                getSymbol: f,
                negStacks: !0,
                trackerGroups: ["group", "dataLabelsGroup"]
            }),
            c.registerSeriesType("column", P),
            P
        }),
        i(n, "Core/Series/DataLabel.js", [n["Core/Animation/AnimationUtilities.js"], n["Core/Templating.js"], n["Core/Utilities.js"]], function(r, s, o) {
            var a;
            let {getDeferredAnimation: l} = r
              , {format: c} = s
              , {defined: u, extend: h, fireEvent: d, isArray: m, isString: f, merge: x, objectEach: S, pick: v, pInt: p, splat: g} = o;
            return function(C) {
                let E = [];
                function O() {
                    return g(this.options.dataLabels || {}).some(k=>k == null ? void 0 : k.enabled)
                }
                function R(k, w, b, A, j) {
                    let B = this, W = this.chart, N = this.isCartesian && W.inverted, H = this.enabledDataSorting, X = k.plotX, ie = k.plotY, K = b.rotation, D = b.align, V = u(X) && u(ie) && W.isInsidePlot(X, Math.round(ie), {
                        inverted: N,
                        paneCoordinates: !0,
                        series: B
                    }), G = Z=>{
                        H && B.xAxis && !z && B.setDataLabelStartPos(k, w, j, V, Z)
                    }
                    , ee, J, te, z = v(b.overflow, H ? "none" : "justify") === "justify", Y = this.visible && k.visible !== !1 && u(X) && (k.series.forceDL || H && !z || V || v(b.inside, !!this.options.stacking) && A && W.isInsidePlot(X, N ? A.x + 1 : A.y + A.height - 1, {
                        inverted: N,
                        paneCoordinates: !0,
                        series: B
                    })), U = k.pos();
                    if (Y && U) {
                        K && w.attr({
                            align: D
                        });
                        let Z = w.getBBox(!0)
                          , $ = [0, 0];
                        if (ee = W.renderer.fontMetrics(w).b,
                        A = h({
                            x: U[0],
                            y: Math.round(U[1]),
                            width: 0,
                            height: 0
                        }, A),
                        h(b, {
                            width: Z.width,
                            height: Z.height
                        }),
                        K ? (z = !1,
                        J = W.renderer.rotCorr(ee, K),
                        te = {
                            x: A.x + (b.x || 0) + A.width / 2 + J.x,
                            y: A.y + (b.y || 0) + {
                                top: 0,
                                middle: .5,
                                bottom: 1
                            }[b.verticalAlign] * A.height
                        },
                        $ = [Z.x - Number(w.attr("x")), Z.y - Number(w.attr("y"))],
                        G(te),
                        w[j ? "attr" : "animate"](te)) : (G(A),
                        w.align(b, void 0, A),
                        te = w.alignAttr),
                        z && A.height >= 0)
                            this.justifyDataLabel(w, b, te, Z, A, j);
                        else if (v(b.crop, !0)) {
                            let {x: ne, y: oe} = te;
                            ne += $[0],
                            oe += $[1],
                            Y = W.isInsidePlot(ne, oe, {
                                paneCoordinates: !0,
                                series: B
                            }) && W.isInsidePlot(ne + Z.width, oe + Z.height, {
                                paneCoordinates: !0,
                                series: B
                            })
                        }
                        b.shape && !K && w[j ? "attr" : "animate"]({
                            anchorX: U[0],
                            anchorY: U[1]
                        })
                    }
                    j && H && (w.placed = !1),
                    Y || H && !z ? w.show() : (w.hide(),
                    w.placed = !1)
                }
                function F() {
                    return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6)
                }
                function P(k) {
                    let w = this.hasRendered || 0
                      , b = this.initDataLabelsGroup().attr({
                        opacity: +w
                    });
                    return !w && b && (this.visible && b.show(),
                    this.options.animation ? b.animate({
                        opacity: 1
                    }, k) : b.attr({
                        opacity: 1
                    })),
                    b
                }
                function _(k) {
                    var G, ee, J;
                    k = k || this.points;
                    let w = this, b = w.chart, A = w.options, j = b.renderer, {backgroundColor: B, plotBackgroundColor: W} = b.options.chart, N = b.options.plotOptions, H = j.getContrast(f(W) && W || f(B) && B || "#000000"), X = A.dataLabels, ie;
                    X = L(L((G = N == null ? void 0 : N.series) == null ? void 0 : G.dataLabels, (ee = N == null ? void 0 : N[w.type]) == null ? void 0 : ee.dataLabels), X);
                    let {animation: K, defer: D} = g(X)[0]
                      , V = D ? l(b, K, w) : {
                        defer: 0,
                        duration: 0
                    };
                    d(this, "drawDataLabels"),
                    (J = w.hasDataLabels) != null && J.call(w) && (ie = this.initDataLabels(V),
                    k.forEach(te=>{
                        var U, Z;
                        let z = te.dataLabels || [];
                        g(L(X, te.dlOptions || ((U = te.options) == null ? void 0 : U.dataLabels))).forEach(($,ne)=>{
                            var fe;
                            let oe = $.enabled && te.visible && (!te.isNull || te.dataLabelOnNull) && function(de, ge) {
                                let ye = ge.filter;
                                if (ye) {
                                    let pe = ye.operator
                                      , xe = de[ye.property]
                                      , ke = ye.value;
                                    return pe === ">" && xe > ke || pe === "<" && xe < ke || pe === ">=" && xe >= ke || pe === "<=" && xe <= ke || pe === "==" && xe == ke || pe === "===" && xe === ke
                                }
                                return !0
                            }(te, $), se = $.style || {}, le = $.distance, he, Q, q, ae, re = {}, ce = z[ne], ue = !ce;
                            if (oe) {
                                if (Q = v($[te.formatPrefix + "Format"], $.format),
                                he = te.getLabelConfig(),
                                q = u(Q) ? c(Q, he, b) : ($[te.formatPrefix + "Formatter"] || $.formatter).call(he, $),
                                ae = $.rotation,
                                !b.styledMode && (se.color = v($.color, se.color, f(w.color) ? w.color : void 0, "#000000"),
                                se.color === "contrast" ? (te.contrastColor = j.getContrast(te.color || w.color),
                                se.color = !u(le) && $.inside || 0 > p(le || 0) || A.stacking ? te.contrastColor : H) : delete te.contrastColor,
                                A.cursor && (se.cursor = A.cursor)),
                                re = {
                                    r: $.borderRadius || 0,
                                    rotation: ae,
                                    padding: $.padding,
                                    zIndex: 1
                                },
                                !b.styledMode) {
                                    let {backgroundColor: de, borderColor: ge} = $;
                                    re.fill = de === "auto" ? te.color : de,
                                    re.stroke = ge === "auto" ? te.color : ge,
                                    re["stroke-width"] = $.borderWidth
                                }
                                S(re, (de,ge)=>{
                                    de === void 0 && delete re[ge]
                                }
                                )
                            }
                            if (!ce || oe && u(q) && !!ce.div == !!$.useHTML && (ce.rotation && $.rotation || ce.rotation === $.rotation) || (ce = void 0,
                            ue = !0),
                            oe && u(q) && (ce ? re.text = q : (ce = ae ? j.text(q, 0, 0, $.useHTML).addClass("highcharts-data-label") : j.label(q, 0, 0, $.shape, void 0, void 0, $.useHTML, void 0, "data-label")) && ce.addClass(" highcharts-data-label-color-" + te.colorIndex + " " + ($.className || "") + ($.useHTML ? " highcharts-tracker" : "")),
                            ce)) {
                                ce.options = $,
                                ce.attr(re),
                                b.styledMode || ce.css(se).shadow($.shadow);
                                let de = $[te.formatPrefix + "TextPath"] || $.textPath;
                                de && !$.useHTML && (ce.setTextPath(((fe = te.getDataLabelPath) == null ? void 0 : fe.call(te, ce)) || te.graphic, de),
                                te.dataLabelPath && !de.enabled && (te.dataLabelPath = te.dataLabelPath.destroy())),
                                ce.added || ce.add(ie),
                                w.alignDataLabel(te, ce, $, void 0, ue),
                                ce.isActive = !0,
                                z[ne] && z[ne] !== ce && z[ne].destroy(),
                                z[ne] = ce
                            }
                        }
                        );
                        let Y = z.length;
                        for (; Y--; )
                            z[Y] && z[Y].isActive ? z[Y].isActive = !1 : ((Z = z[Y]) == null || Z.destroy(),
                            z.splice(Y, 1));
                        te.dataLabel = z[0],
                        te.dataLabels = z
                    }
                    )),
                    d(this, "afterDrawDataLabels")
                }
                function T(k, w, b, A, j, B) {
                    let W = this.chart, N = w.align, H = w.verticalAlign, X = k.box ? 0 : k.padding || 0, {x: ie=0, y: K=0} = w, D, V;
                    return (D = (b.x || 0) + X) < 0 && (N === "right" && ie >= 0 ? (w.align = "left",
                    w.inside = !0) : ie -= D,
                    V = !0),
                    (D = (b.x || 0) + A.width - X) > W.plotWidth && (N === "left" && ie <= 0 ? (w.align = "right",
                    w.inside = !0) : ie += W.plotWidth - D,
                    V = !0),
                    (D = b.y + X) < 0 && (H === "bottom" && K >= 0 ? (w.verticalAlign = "top",
                    w.inside = !0) : K -= D,
                    V = !0),
                    (D = (b.y || 0) + A.height - X) > W.plotHeight && (H === "top" && K <= 0 ? (w.verticalAlign = "bottom",
                    w.inside = !0) : K += W.plotHeight - D,
                    V = !0),
                    V && (w.x = ie,
                    w.y = K,
                    k.placed = !B,
                    k.align(w, void 0, j)),
                    V
                }
                function L(k, w) {
                    let b = [], A;
                    if (m(k) && !m(w))
                        b = k.map(function(j) {
                            return x(j, w)
                        });
                    else if (m(w) && !m(k))
                        b = w.map(function(j) {
                            return x(k, j)
                        });
                    else if (m(k) || m(w)) {
                        if (m(k) && m(w))
                            for (A = Math.max(k.length, w.length); A--; )
                                b[A] = x(k[A], w[A])
                    } else
                        b = x(k, w);
                    return b
                }
                function I(k, w, b, A, j) {
                    let B = this.chart
                      , W = B.inverted
                      , N = this.xAxis
                      , H = N.reversed
                      , X = ((W ? w.height : w.width) || 0) / 2
                      , ie = k.pointWidth
                      , K = ie ? ie / 2 : 0;
                    w.startXPos = W ? j.x : H ? -X - K : N.width - X + K,
                    w.startYPos = W ? H ? this.yAxis.height - X + K : -X - K : j.y,
                    A ? w.visibility === "hidden" && (w.show(),
                    w.attr({
                        opacity: 0
                    }).animate({
                        opacity: 1
                    })) : w.attr({
                        opacity: 1
                    }).animate({
                        opacity: 0
                    }, void 0, w.hide),
                    B.hasRendered && (b && w.attr({
                        x: w.startXPos,
                        y: w.startYPos
                    }),
                    w.placed = !0)
                }
                C.compose = function(k) {
                    if (o.pushUnique(E, k)) {
                        let w = k.prototype;
                        w.initDataLabelsGroup = F,
                        w.initDataLabels = P,
                        w.alignDataLabel = R,
                        w.drawDataLabels = _,
                        w.justifyDataLabel = T,
                        w.setDataLabelStartPos = I,
                        w.hasDataLabels = O
                    }
                }
            }(a || (a = {})),
            a
        }),
        i(n, "Series/Column/ColumnDataLabel.js", [n["Core/Series/DataLabel.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Utilities.js"]], function(r, s, o) {
            var a;
            let {series: l} = s
              , {merge: c, pick: u} = o;
            return function(h) {
                let d = [];
                function m(f, x, S, v, p) {
                    let g = this.chart.inverted
                      , C = f.series
                      , E = (C.xAxis ? C.xAxis.len : this.chart.plotSizeX) || 0
                      , O = (C.yAxis ? C.yAxis.len : this.chart.plotSizeY) || 0
                      , R = f.dlBox || f.shapeArgs
                      , F = u(f.below, f.plotY > u(this.translatedThreshold, O))
                      , P = u(S.inside, !!this.options.stacking);
                    if (R) {
                        if (v = c(R),
                        !(S.overflow === "allow" && S.crop === !1)) {
                            v.y < 0 && (v.height += v.y,
                            v.y = 0);
                            let _ = v.y + v.height - O;
                            _ > 0 && _ < v.height && (v.height -= _)
                        }
                        g && (v = {
                            x: O - v.y - v.height,
                            y: E - v.x - v.width,
                            width: v.height,
                            height: v.width
                        }),
                        P || (g ? (v.x += F ? 0 : v.width,
                        v.width = 0) : (v.y += F ? v.height : 0,
                        v.height = 0))
                    }
                    S.align = u(S.align, !g || P ? "center" : F ? "right" : "left"),
                    S.verticalAlign = u(S.verticalAlign, g || P ? "middle" : F ? "top" : "bottom"),
                    l.prototype.alignDataLabel.call(this, f, x, S, v, p),
                    S.inside && f.contrastColor && x.css({
                        color: f.contrastColor
                    })
                }
                h.compose = function(f) {
                    r.compose(l),
                    o.pushUnique(d, f) && (f.prototype.alignDataLabel = m)
                }
            }(a || (a = {})),
            a
        }),
        i(n, "Series/Bar/BarSeries.js", [n["Series/Column/ColumnSeries.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {extend: a, merge: l} = o;
            class c extends r {
                constructor() {
                    super(...arguments),
                    this.data = void 0,
                    this.options = void 0,
                    this.points = void 0
                }
            }
            return c.defaultOptions = l(r.defaultOptions, {}),
            a(c.prototype, {
                inverted: !0
            }),
            s.registerSeriesType("bar", c),
            c
        }),
        i(n, "Series/Scatter/ScatterSeriesDefaults.js", [], function() {
            return {
                lineWidth: 0,
                findNearestPointBy: "xy",
                jitter: {
                    x: 0,
                    y: 0
                },
                marker: {
                    enabled: !0
                },
                tooltip: {
                    headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>',
                    pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
                }
            }
        }),
        i(n, "Series/Scatter/ScatterSeries.js", [n["Series/Scatter/ScatterSeriesDefaults.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {column: a, line: l} = s.seriesTypes
              , {addEvent: c, extend: u, merge: h} = o;
            class d extends l {
                constructor() {
                    super(...arguments),
                    this.data = void 0,
                    this.options = void 0,
                    this.points = void 0
                }
                applyJitter() {
                    let f = this
                      , x = this.options.jitter
                      , S = this.points.length;
                    x && this.points.forEach(function(v, p) {
                        ["x", "y"].forEach(function(g, C) {
                            let E, O = "plot" + g.toUpperCase(), R, F, P;
                            x[g] && !v.isNull && (E = f[g + "Axis"],
                            P = x[g] * E.transA,
                            E && !E.isLog && (R = Math.max(0, v[O] - P),
                            F = Math.min(E.len, v[O] + P),
                            v[O] = R + (F - R) * function(_) {
                                let T = 1e4 * Math.sin(_);
                                return T - Math.floor(T)
                            }(p + C * S),
                            g === "x" && (v.clientX = v.plotX)))
                        })
                    })
                }
                drawGraph() {
                    this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy())
                }
            }
            return d.defaultOptions = h(l.defaultOptions, r),
            u(d.prototype, {
                drawTracker: a.prototype.drawTracker,
                sorted: !1,
                requireSorting: !1,
                noSharedTooltip: !0,
                trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
                takeOrdinalPosition: !1
            }),
            c(d, "afterTranslate", function() {
                this.applyJitter()
            }),
            s.registerSeriesType("scatter", d),
            d
        }),
        i(n, "Series/CenteredUtilities.js", [n["Core/Globals.js"], n["Core/Series/Series.js"], n["Core/Utilities.js"]], function(r, s, o) {
            var a, l;
            let {deg2rad: c} = r
              , {fireEvent: u, isNumber: h, pick: d, relativeLength: m} = o;
            return (l = a || (a = {})).getCenter = function() {
                let f = this.options, x = this.chart, S = 2 * (f.slicedOffset || 0), v = x.plotWidth - 2 * S, p = x.plotHeight - 2 * S, g = f.center, C = Math.min(v, p), E = f.thickness, O, R = f.size, F = f.innerSize || 0, P, _;
                typeof R == "string" && (R = parseFloat(R)),
                typeof F == "string" && (F = parseFloat(F));
                let T = [d(g[0], "50%"), d(g[1], "50%"), d(R && R < 0 ? void 0 : f.size, "100%"), d(F && F < 0 ? void 0 : f.innerSize || 0, "0%")];
                for (!x.angular || this instanceof s || (T[3] = 0),
                P = 0; P < 4; ++P)
                    _ = T[P],
                    O = P < 2 || P === 2 && /%$/.test(_),
                    T[P] = m(_, [v, p, C, T[2]][P]) + (O ? S : 0);
                return T[3] > T[2] && (T[3] = T[2]),
                h(E) && 2 * E < T[2] && E > 0 && (T[3] = T[2] - 2 * E),
                u(this, "afterGetCenter", {
                    positions: T
                }),
                T
            }
            ,
            l.getStartAndEndRadians = function(f, x) {
                let S = h(f) ? f : 0
                  , v = h(x) && x > S && x - S < 360 ? x : S + 360;
                return {
                    start: c * (S + -90),
                    end: c * (v + -90)
                }
            }
            ,
            a
        }),
        i(n, "Series/Pie/PiePoint.js", [n["Core/Animation/AnimationUtilities.js"], n["Core/Series/Point.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {setAnimation: a} = r
              , {addEvent: l, defined: c, extend: u, isNumber: h, isString: d, pick: m, relativeLength: f} = o;
            class x extends s {
                constructor() {
                    super(...arguments),
                    this.half = 0,
                    this.options = void 0,
                    this.series = void 0
                }
                getConnectorPath(v) {
                    let p = v.dataLabelPosition
                      , g = v.options || {}
                      , C = g.connectorShape
                      , E = this.connectorShapes[C] || C;
                    return p && E.call(this, {
                        ...p.computed,
                        alignment: p.alignment
                    }, p.connectorPosition, g) || []
                }
                getTranslate() {
                    return this.sliced && this.slicedTranslation || {
                        translateX: 0,
                        translateY: 0
                    }
                }
                haloPath(v) {
                    let p = this.shapeArgs;
                    return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(p.x, p.y, p.r + v, p.r + v, {
                        innerR: p.r - 1,
                        start: p.start,
                        end: p.end,
                        borderRadius: p.borderRadius
                    })
                }
                init() {
                    super.init.apply(this, arguments),
                    this.name = m(this.name, "Slice");
                    let v = p=>{
                        this.slice(p.type === "select")
                    }
                    ;
                    return l(this, "select", v),
                    l(this, "unselect", v),
                    this
                }
                isValid() {
                    return h(this.y) && this.y >= 0
                }
                setVisible(v, p) {
                    let g = this.series
                      , C = g.chart
                      , E = g.options.ignoreHiddenPoint;
                    p = m(p, E),
                    v !== this.visible && (this.visible = this.options.visible = v = v === void 0 ? !this.visible : v,
                    g.options.data[g.data.indexOf(this)] = this.options,
                    ["graphic", "dataLabel", "connector"].forEach(O=>{
                        this[O] && this[O][v ? "show" : "hide"](v)
                    }
                    ),
                    this.legendItem && C.legend.colorizeItem(this, v),
                    v || this.state !== "hover" || this.setState(""),
                    E && (g.isDirty = !0),
                    p && C.redraw())
                }
                slice(v, p, g) {
                    let C = this.series
                      , E = C.chart;
                    a(g, E),
                    p = m(p, !0),
                    this.sliced = this.options.sliced = v = c(v) ? v : !this.sliced,
                    C.options.data[C.data.indexOf(this)] = this.options,
                    this.graphic && this.graphic.animate(this.getTranslate())
                }
            }
            return u(x.prototype, {
                connectorShapes: {
                    fixedOffset: function(S, v, p) {
                        let g = v.breakAt
                          , C = v.touchingSliceAt
                          , E = p.softConnector ? ["C", S.x + (S.alignment === "left" ? -5 : 5), S.y, 2 * g.x - C.x, 2 * g.y - C.y, g.x, g.y] : ["L", g.x, g.y];
                        return [["M", S.x, S.y], E, ["L", C.x, C.y]]
                    },
                    straight: function(S, v) {
                        let p = v.touchingSliceAt;
                        return [["M", S.x, S.y], ["L", p.x, p.y]]
                    },
                    crookedLine: function(S, v, p) {
                        let {breakAt: g, touchingSliceAt: C} = v
                          , {series: E} = this
                          , [O,R,F] = E.center
                          , P = F / 2
                          , {plotLeft: _, plotWidth: T} = E.chart
                          , L = S.alignment === "left"
                          , {x: I, y: k} = S
                          , w = g.x;
                        if (p.crookDistance) {
                            let A = f(p.crookDistance, 1);
                            w = L ? O + P + (T + _ - O - P) * (1 - A) : _ + (O - P) * A
                        } else
                            w = O + (R - k) * Math.tan((this.angle || 0) - Math.PI / 2);
                        let b = [["M", I, k]];
                        return (L ? w <= I && w >= g.x : w >= I && w <= g.x) && b.push(["L", w, k]),
                        b.push(["L", g.x, g.y], ["L", C.x, C.y]),
                        b
                    }
                }
            }),
            x
        }),
        i(n, "Series/Pie/PieSeriesDefaults.js", [], function() {
            return {
                borderRadius: 3,
                center: [null, null],
                clip: !1,
                colorByPoint: !0,
                dataLabels: {
                    connectorPadding: 5,
                    connectorShape: "crookedLine",
                    crookDistance: void 0,
                    distance: 30,
                    enabled: !0,
                    formatter: function() {
                        return this.point.isNull ? void 0 : this.point.name
                    },
                    softConnector: !0,
                    x: 0
                },
                fillColor: void 0,
                ignoreHiddenPoint: !0,
                inactiveOtherPoints: !0,
                legendType: "point",
                marker: null,
                size: null,
                showInLegend: !1,
                slicedOffset: 10,
                stickyTracking: !1,
                tooltip: {
                    followPointer: !0
                },
                borderColor: "#ffffff",
                borderWidth: 1,
                lineWidth: void 0,
                states: {
                    hover: {
                        brightness: .1
                    }
                }
            }
        }),
        i(n, "Series/Pie/PieSeries.js", [n["Series/CenteredUtilities.js"], n["Series/Column/ColumnSeries.js"], n["Core/Globals.js"], n["Series/Pie/PiePoint.js"], n["Series/Pie/PieSeriesDefaults.js"], n["Core/Series/Series.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Renderer/SVG/Symbols.js"], n["Core/Utilities.js"]], function(r, s, o, a, l, c, u, h, d) {
            let {getStartAndEndRadians: m} = r
              , {noop: f} = o
              , {clamp: x, extend: S, fireEvent: v, merge: p, pick: g, relativeLength: C, splat: E} = d;
            class O extends c {
                constructor() {
                    super(...arguments),
                    this.center = void 0,
                    this.data = void 0,
                    this.options = void 0,
                    this.points = void 0
                }
                animate(F) {
                    let P = this
                      , _ = P.points
                      , T = P.startAngleRad;
                    F || _.forEach(function(L) {
                        let I = L.graphic
                          , k = L.shapeArgs;
                        I && k && (I.attr({
                            r: g(L.startR, P.center && P.center[3] / 2),
                            start: T,
                            end: T
                        }),
                        I.animate({
                            r: k.r,
                            start: k.start,
                            end: k.end
                        }, P.options.animation))
                    })
                }
                drawEmpty() {
                    let F, P, _ = this.startAngleRad, T = this.endAngleRad, L = this.options;
                    this.total === 0 && this.center ? (F = this.center[0],
                    P = this.center[1],
                    this.graph || (this.graph = this.chart.renderer.arc(F, P, this.center[1] / 2, 0, _, T).addClass("highcharts-empty-series").add(this.group)),
                    this.graph.attr({
                        d: h.arc(F, P, this.center[2] / 2, 0, {
                            start: _,
                            end: T,
                            innerR: this.center[3] / 2
                        })
                    }),
                    this.chart.styledMode || this.graph.attr({
                        "stroke-width": L.borderWidth,
                        fill: L.fillColor || "none",
                        stroke: L.color || "#cccccc"
                    })) : this.graph && (this.graph = this.graph.destroy())
                }
                drawPoints() {
                    let F = this.chart.renderer;
                    this.points.forEach(function(P) {
                        P.graphic && P.hasNewShapeType() && (P.graphic = P.graphic.destroy()),
                        P.graphic || (P.graphic = F[P.shapeType](P.shapeArgs).add(P.series.group),
                        P.delayedRendering = !0)
                    })
                }
                generatePoints() {
                    super.generatePoints(),
                    this.updateTotals()
                }
                getX(F, P, _, T) {
                    let L = this.center
                      , I = this.radii ? this.radii[_.index] || 0 : L[2] / 2
                      , k = T.dataLabelPosition
                      , w = (k == null ? void 0 : k.distance) || 0
                      , b = Math.asin(x((F - L[1]) / (I + w), -1, 1));
                    return L[0] + (P ? -1 : 1) * (Math.cos(b) * (I + w)) + (w > 0 ? (P ? -1 : 1) * (T.padding || 0) : 0)
                }
                hasData() {
                    return !!this.processedXData.length
                }
                redrawPoints() {
                    let F, P, _, T, L = this, I = L.chart;
                    this.drawEmpty(),
                    L.group && !I.styledMode && L.group.shadow(L.options.shadow),
                    L.points.forEach(function(k) {
                        let w = {};
                        P = k.graphic,
                        !k.isNull && P ? (T = k.shapeArgs,
                        F = k.getTranslate(),
                        I.styledMode || (_ = L.pointAttribs(k, k.selected && "select")),
                        k.delayedRendering ? (P.setRadialReference(L.center).attr(T).attr(F),
                        I.styledMode || P.attr(_).attr({
                            "stroke-linejoin": "round"
                        }),
                        k.delayedRendering = !1) : (P.setRadialReference(L.center),
                        I.styledMode || p(!0, w, _),
                        p(!0, w, T, F),
                        P.animate(w)),
                        P.attr({
                            visibility: k.visible ? "inherit" : "hidden"
                        }),
                        P.addClass(k.getClassName(), !0)) : P && (k.graphic = P.destroy())
                    })
                }
                sortByAngle(F, P) {
                    F.sort(function(_, T) {
                        return _.angle !== void 0 && (T.angle - _.angle) * P
                    })
                }
                translate(F) {
                    v(this, "translate"),
                    this.generatePoints();
                    let P = this.options, _ = P.slicedOffset, T = m(P.startAngle, P.endAngle), L = this.startAngleRad = T.start, I = this.endAngleRad = T.end, k = I - L, w = this.points, b = P.ignoreHiddenPoint, A = w.length, j, B, W, N, H, X, ie, K = 0;
                    for (F || (this.center = F = this.getCenter()),
                    X = 0; X < A; X++) {
                        ie = w[X],
                        j = L + K * k,
                        ie.isValid() && (!b || ie.visible) && (K += ie.percentage / 100),
                        B = L + K * k;
                        let D = {
                            x: F[0],
                            y: F[1],
                            r: F[2] / 2,
                            innerR: F[3] / 2,
                            start: Math.round(1e3 * j) / 1e3,
                            end: Math.round(1e3 * B) / 1e3
                        };
                        ie.shapeType = "arc",
                        ie.shapeArgs = D,
                        (W = (B + j) / 2) > 1.5 * Math.PI ? W -= 2 * Math.PI : W < -Math.PI / 2 && (W += 2 * Math.PI),
                        ie.slicedTranslation = {
                            translateX: Math.round(Math.cos(W) * _),
                            translateY: Math.round(Math.sin(W) * _)
                        },
                        N = Math.cos(W) * F[2] / 2,
                        H = Math.sin(W) * F[2] / 2,
                        ie.tooltipPos = [F[0] + .7 * N, F[1] + .7 * H],
                        ie.half = W < -Math.PI / 2 || W > Math.PI / 2 ? 1 : 0,
                        ie.angle = W
                    }
                    v(this, "afterTranslate")
                }
                updateTotals() {
                    let F = this.points, P = F.length, _ = this.options.ignoreHiddenPoint, T, L, I = 0;
                    for (T = 0; T < P; T++)
                        (L = F[T]).isValid() && (!_ || L.visible) && (I += L.y);
                    for (T = 0,
                    this.total = I; T < P; T++)
                        (L = F[T]).percentage = I > 0 && (L.visible || !_) ? L.y / I * 100 : 0,
                        L.total = I
                }
            }
            return O.defaultOptions = p(c.defaultOptions, l),
            S(O.prototype, {
                axisTypes: [],
                directTouch: !0,
                drawGraph: void 0,
                drawTracker: s.prototype.drawTracker,
                getCenter: r.getCenter,
                getSymbol: f,
                isCartesian: !1,
                noSharedTooltip: !0,
                pointAttribs: s.prototype.pointAttribs,
                pointClass: a,
                requireSorting: !1,
                searchPoint: f,
                trackerGroups: ["group", "dataLabelsGroup"]
            }),
            u.registerSeriesType("pie", O),
            O
        }),
        i(n, "Series/Pie/PieDataLabel.js", [n["Core/Series/DataLabel.js"], n["Core/Globals.js"], n["Core/Renderer/RendererUtilities.js"], n["Core/Series/SeriesRegistry.js"], n["Core/Utilities.js"]], function(r, s, o, a, l) {
            var c;
            let {noop: u} = s
              , {distribute: h} = o
              , {series: d} = a
              , {arrayMax: m, clamp: f, defined: x, pick: S, relativeLength: v} = l;
            return function(p) {
                let g = []
                  , C = {
                    radialDistributionY: function(P, _) {
                        var T;
                        return (((T = _.dataLabelPosition) == null ? void 0 : T.top) || 0) + P.distributeBox.pos
                    },
                    radialDistributionX: function(P, _, T, L, I) {
                        let k = I.dataLabelPosition;
                        return P.getX(T < ((k == null ? void 0 : k.top) || 0) + 2 || T > ((k == null ? void 0 : k.bottom) || 0) - 2 ? L : T, _.half, _, I)
                    },
                    justify: function(P, _, T, L) {
                        var I;
                        return L[0] + (P.half ? -1 : 1) * (T + (((I = _.dataLabelPosition) == null ? void 0 : I.distance) || 0))
                    },
                    alignToPlotEdges: function(P, _, T, L) {
                        let I = P.getBBox().width;
                        return _ ? I + L : T - I - L
                    },
                    alignToConnectors: function(P, _, T, L) {
                        let I = 0, k;
                        return P.forEach(function(w) {
                            (k = w.dataLabel.getBBox().width) > I && (I = k)
                        }),
                        _ ? I + L : T - I - L
                    }
                };
                function E(P, _) {
                    let {center: T, options: L} = this
                      , I = T[2] / 2
                      , k = P.angle || 0
                      , w = Math.cos(k)
                      , b = Math.sin(k)
                      , A = T[0] + w * I
                      , j = T[1] + b * I
                      , B = Math.min((L.slicedOffset || 0) + (L.borderWidth || 0), _ / 5);
                    return {
                        natural: {
                            x: A + w * _,
                            y: j + b * _
                        },
                        computed: {},
                        alignment: _ < 0 ? "center" : P.half ? "right" : "left",
                        connectorPosition: {
                            breakAt: {
                                x: A + w * B,
                                y: j + b * B
                            },
                            touchingSliceAt: {
                                x: A,
                                y: j
                            }
                        },
                        distance: _
                    }
                }
                function O() {
                    var D;
                    let P = this, _ = P.points, T = P.chart, L = T.plotWidth, I = T.plotHeight, k = T.plotLeft, w = Math.round(T.chartWidth / 3), b = P.center, A = b[2] / 2, j = b[1], B = [[], []], W = [0, 0, 0, 0], N = P.dataLabelPositioners, H, X, ie, K = 0;
                    P.visible && ((D = P.hasDataLabels) != null && D.call(P)) && (_.forEach(V=>{
                        (V.dataLabels || []).forEach(G=>{
                            G.shortened && (G.attr({
                                width: "auto"
                            }).css({
                                width: "auto",
                                textOverflow: "clip"
                            }),
                            G.shortened = !1)
                        }
                        )
                    }
                    ),
                    d.prototype.drawDataLabels.apply(P),
                    _.forEach(V=>{
                        (V.dataLabels || []).forEach((G,ee)=>{
                            var Y;
                            let J = b[2] / 2
                              , te = G.options
                              , z = v((te == null ? void 0 : te.distance) || 0, J);
                            ee === 0 && B[V.half].push(V),
                            !x((Y = te == null ? void 0 : te.style) == null ? void 0 : Y.width) && G.getBBox().width > w && (G.css({
                                width: Math.round(.7 * w) + "px"
                            }),
                            G.shortened = !0),
                            G.dataLabelPosition = this.getDataLabelPosition(V, z),
                            K = Math.max(K, z)
                        }
                        )
                    }
                    ),
                    B.forEach((V,G)=>{
                        let ee = V.length, J = [], te, z, Y = 0, U;
                        ee && (P.sortByAngle(V, G - .5),
                        K > 0 && (te = Math.max(0, j - A - K),
                        z = Math.min(j + A + K, T.plotHeight),
                        V.forEach(Z=>{
                            (Z.dataLabels || []).forEach(($,ne)=>{
                                var se;
                                let oe = $.dataLabelPosition;
                                oe && oe.distance > 0 && (oe.top = Math.max(0, j - A - oe.distance),
                                oe.bottom = Math.min(j + A + oe.distance, T.plotHeight),
                                Y = $.getBBox().height || 21,
                                Z.distributeBox = {
                                    target: (((se = $.dataLabelPosition) == null ? void 0 : se.natural.y) || 0) - oe.top + Y / 2,
                                    size: Y,
                                    rank: Z.y
                                },
                                J.push(Z.distributeBox))
                            }
                            )
                        }
                        ),
                        h(J, U = z + Y - te, U / 5)),
                        V.forEach(Z=>{
                            (Z.dataLabels || []).forEach($=>{
                                let ne = $.options || {}
                                  , oe = Z.distributeBox
                                  , se = $.dataLabelPosition
                                  , le = (se == null ? void 0 : se.natural.y) || 0
                                  , he = ne.connectorPadding || 0
                                  , Q = 0
                                  , q = le
                                  , ae = "inherit";
                                if (se) {
                                    if (J && x(oe) && se.distance > 0 && (oe.pos === void 0 ? ae = "hidden" : (ie = oe.size,
                                    q = N.radialDistributionY(Z, $))),
                                    ne.justify)
                                        Q = N.justify(Z, $, A, b);
                                    else
                                        switch (ne.alignTo) {
                                        case "connectors":
                                            Q = N.alignToConnectors(V, G, L, k);
                                            break;
                                        case "plotEdges":
                                            Q = N.alignToPlotEdges($, G, L, k);
                                            break;
                                        default:
                                            Q = N.radialDistributionX(P, Z, q, le, $)
                                        }
                                    if (se.attribs = {
                                        visibility: ae,
                                        align: se.alignment
                                    },
                                    se.posAttribs = {
                                        x: Q + (ne.x || 0) + ({
                                            left: he,
                                            right: -he
                                        }[se.alignment] || 0),
                                        y: q + (ne.y || 0) - $.getBBox().height / 2
                                    },
                                    se.computed.x = Q,
                                    se.computed.y = q,
                                    S(ne.crop, !0)) {
                                        let re;
                                        Q - (X = $.getBBox().width) < he && G === 1 ? (re = Math.round(X - Q + he),
                                        W[3] = Math.max(re, W[3])) : Q + X > L - he && G === 0 && (re = Math.round(Q + X - L + he),
                                        W[1] = Math.max(re, W[1])),
                                        q - ie / 2 < 0 ? W[0] = Math.max(Math.round(-q + ie / 2), W[0]) : q + ie / 2 > I && (W[2] = Math.max(Math.round(q + ie / 2 - I), W[2])),
                                        se.sideOverflow = re
                                    }
                                }
                            }
                            )
                        }
                        ))
                    }
                    ),
                    (m(W) === 0 || this.verifyDataLabelOverflow(W)) && (this.placeDataLabels(),
                    this.points.forEach(V=>{
                        (V.dataLabels || []).forEach(G=>{
                            var z;
                            let {connectorColor: ee, connectorWidth: J=1} = G.options || {}
                              , te = G.dataLabelPosition;
                            if (J) {
                                let Y;
                                H = G.connector,
                                te && te.distance > 0 ? (Y = !H,
                                H || (G.connector = H = T.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + V.colorIndex + (V.className ? " " + V.className : "")).add(P.dataLabelsGroup)),
                                T.styledMode || H.attr({
                                    "stroke-width": J,
                                    stroke: ee || V.color || "#666666"
                                }),
                                H[Y ? "attr" : "animate"]({
                                    d: V.getConnectorPath(G)
                                }),
                                H.attr({
                                    visibility: (z = te.attribs) == null ? void 0 : z.visibility
                                })) : H && (G.connector = H.destroy())
                            }
                        }
                        )
                    }
                    )))
                }
                function R() {
                    this.points.forEach(P=>{
                        (P.dataLabels || []).forEach(_=>{
                            var L;
                            let T = _.dataLabelPosition;
                            T ? (T.sideOverflow && (_.css({
                                width: Math.max(_.getBBox().width - T.sideOverflow, 0) + "px",
                                textOverflow: (((L = _.options) == null ? void 0 : L.style) || {}).textOverflow || "ellipsis"
                            }),
                            _.shortened = !0),
                            _.attr(T.attribs),
                            _[_.moved ? "animate" : "attr"](T.posAttribs),
                            _.moved = !0) : _ && _.attr({
                                y: -9999
                            })
                        }
                        ),
                        delete P.distributeBox
                    }
                    , this)
                }
                function F(P) {
                    let _ = this.center
                      , T = this.options
                      , L = T.center
                      , I = T.minSize || 80
                      , k = I
                      , w = T.size !== null;
                    return !w && (L[0] !== null ? k = Math.max(_[2] - Math.max(P[1], P[3]), I) : (k = Math.max(_[2] - P[1] - P[3], I),
                    _[0] += (P[3] - P[1]) / 2),
                    L[1] !== null ? k = f(k, I, _[2] - Math.max(P[0], P[2])) : (k = f(k, I, _[2] - P[0] - P[2]),
                    _[1] += (P[0] - P[2]) / 2),
                    k < _[2] ? (_[2] = k,
                    _[3] = Math.min(T.thickness ? Math.max(0, k - 2 * T.thickness) : Math.max(0, v(T.innerSize || 0, k)), k),
                    this.translate(_),
                    this.drawDataLabels && this.drawDataLabels()) : w = !0),
                    w
                }
                p.compose = function(P) {
                    if (r.compose(d),
                    l.pushUnique(g, P)) {
                        let _ = P.prototype;
                        _.dataLabelPositioners = C,
                        _.alignDataLabel = u,
                        _.drawDataLabels = O,
                        _.getDataLabelPosition = E,
                        _.placeDataLabels = R,
                        _.verifyDataLabelOverflow = F
                    }
                }
            }(c || (c = {})),
            c
        }),
        i(n, "Extensions/OverlappingDataLabels.js", [n["Core/Utilities.js"]], function(r) {
            let {addEvent: s, fireEvent: o, isNumber: a, objectEach: l, pick: c, pushUnique: u} = r
              , h = [];
            function d(x) {
                let S = x.length, v = this.renderer, p = (_,T)=>!(T.x >= _.x + _.width || T.x + T.width <= _.x || T.y >= _.y + _.height || T.y + T.height <= _.y), g = _=>{
                    let T = _.box ? 0 : _.padding || 0, L, I, k, w = 0, b = 0, A, j;
                    if (_ && (!_.alignAttr || _.placed))
                        return L = _.alignAttr || {
                            x: _.attr("x"),
                            y: _.attr("y")
                        },
                        I = _.parentGroup,
                        _.width || (k = _.getBBox(),
                        _.width = k.width,
                        _.height = k.height,
                        w = v.fontMetrics(_.element).h),
                        A = _.width - 2 * T,
                        (j = {
                            left: "0",
                            center: "0.5",
                            right: "1"
                        }[_.alignValue]) ? b = +j * A : a(_.x) && Math.round(_.x) !== _.translateX && (b = _.x - (_.translateX || 0)),
                        {
                            x: L.x + (I.translateX || 0) + T - (b || 0),
                            y: L.y + (I.translateY || 0) + T - w,
                            width: _.width - 2 * T,
                            height: (_.height || 0) - 2 * T
                        }
                }
                , C, E, O, R, F, P = !1;
                for (let _ = 0; _ < S; _++)
                    (C = x[_]) && (C.oldOpacity = C.opacity,
                    C.newOpacity = 1,
                    C.absoluteBox = g(C));
                x.sort((_,T)=>(T.labelrank || 0) - (_.labelrank || 0));
                for (let _ = 0; _ < S; ++_) {
                    R = (E = x[_]) && E.absoluteBox;
                    for (let T = _ + 1; T < S; ++T)
                        F = (O = x[T]) && O.absoluteBox,
                        R && F && E !== O && E.newOpacity !== 0 && O.newOpacity !== 0 && E.visibility !== "hidden" && O.visibility !== "hidden" && p(R, F) && ((E.labelrank < O.labelrank ? E : O).newOpacity = 0)
                }
                for (let _ of x)
                    m(_, this) && (P = !0);
                P && o(this, "afterHideAllOverlappingLabels")
            }
            function m(x, S) {
                let v, p = !1;
                return x && (v = x.newOpacity,
                x.oldOpacity !== v && (x.alignAttr && x.placed ? (x[v ? "removeClass" : "addClass"]("highcharts-data-label-hidden"),
                p = !0,
                x.alignAttr.opacity = v,
                x[x.isOld ? "animate" : "attr"](x.alignAttr, null, function() {
                    S.styledMode || x.css({
                        pointerEvents: v ? "auto" : "none"
                    })
                }),
                o(S, "afterHideOverlappingLabel")) : x.attr({
                    opacity: v
                })),
                x.isOld = !0),
                p
            }
            function f() {
                var v;
                let x = this
                  , S = [];
                for (let p of x.labelCollectors || [])
                    S = S.concat(p());
                for (let p of x.yAxis || [])
                    p.stacking && p.options.stackLabels && !p.options.stackLabels.allowOverlap && l(p.stacking.stacks, g=>{
                        l(g, C=>{
                            C.label && S.push(C.label)
                        }
                        )
                    }
                    );
                for (let p of x.series || [])
                    if (p.visible && ((v = p.hasDataLabels) != null && v.call(p))) {
                        let g = C=>{
                            for (let E of C)
                                E.visible && (E.dataLabels || []).forEach(O=>{
                                    var F;
                                    let R = O.options || {};
                                    O.labelrank = c(R.labelrank, E.labelrank, (F = E.shapeArgs) == null ? void 0 : F.height),
                                    R.allowOverlap ?? Number(R.distance) > 0 ? (O.oldOpacity = O.opacity,
                                    O.newOpacity = 1,
                                    m(O, x)) : S.push(O)
                                }
                                )
                        }
                        ;
                        g(p.nodes || []),
                        g(p.points)
                    }
                this.hideOverlappingLabels(S)
            }
            return {
                compose: function(x) {
                    if (u(h, x)) {
                        let S = x.prototype;
                        S.hideOverlappingLabels = d,
                        s(x, "render", f)
                    }
                }
            }
        }),
        i(n, "Extensions/BorderRadius.js", [n["Core/Defaults.js"], n["Core/Globals.js"], n["Core/Utilities.js"]], function(r, s, o) {
            let {defaultOptions: a} = r
              , {noop: l} = s
              , {addEvent: c, extend: u, isObject: h, merge: d, pushUnique: m, relativeLength: f} = o
              , x = []
              , S = {
                radius: 0,
                scope: "stack",
                where: void 0
            }
              , v = l
              , p = l;
            function g(F, P, _, T, L={}) {
                let I = v(F, P, _, T, L)
                  , {innerR: k=0, r: w=_, start: b=0, end: A=0} = L;
                if (L.open || !L.borderRadius)
                    return I;
                let j = A - b
                  , B = Math.sin(j / 2)
                  , W = Math.max(Math.min(f(L.borderRadius || 0, w - k), (w - k) / 2, w * B / (1 + B)), 0)
                  , N = Math.min(W, 2 * (j / Math.PI) * k)
                  , H = I.length - 1;
                for (; H--; )
                    (function(X, ie, K) {
                        let D, V, G, ee = X[ie], J = X[ie + 1];
                        if (J[0] === "Z" && (J = X[0]),
                        (ee[0] === "M" || ee[0] === "L") && J[0] === "A" ? (D = ee,
                        V = J,
                        G = !0) : ee[0] === "A" && (J[0] === "M" || J[0] === "L") && (D = J,
                        V = ee),
                        D && V && V.params) {
                            let te = V[1]
                              , z = V[5]
                              , Y = V.params
                              , {start: U, end: Z, cx: $, cy: ne} = Y
                              , oe = z ? te - K : te + K
                              , se = oe ? Math.asin(K / oe) : 0
                              , le = z ? se : -se
                              , he = Math.cos(se) * oe;
                            G ? (Y.start = U + le,
                            D[1] = $ + he * Math.cos(U),
                            D[2] = ne + he * Math.sin(U),
                            X.splice(ie + 1, 0, ["A", K, K, 0, 0, 1, $ + te * Math.cos(Y.start), ne + te * Math.sin(Y.start)])) : (Y.end = Z - le,
                            V[6] = $ + te * Math.cos(Y.end),
                            V[7] = ne + te * Math.sin(Y.end),
                            X.splice(ie + 1, 0, ["A", K, K, 0, 0, 1, $ + he * Math.cos(Z), ne + he * Math.sin(Z)])),
                            V[4] = Math.abs(Y.end - Y.start) < Math.PI ? 0 : 1
                        }
                    }
                    )(I, H, H > 1 ? N : W);
                return I
            }
            function C() {
                var F, P;
                if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
                    let {options: _, yAxis: T} = this
                      , L = _.stacking === "percent"
                      , I = (P = (F = a.plotOptions) == null ? void 0 : F[this.type]) == null ? void 0 : P.borderRadius
                      , k = E(_.borderRadius, h(I) ? I : {})
                      , w = T.options.reversed;
                    for (let b of this.points) {
                        let {shapeArgs: A} = b;
                        if (b.shapeType === "roundedRect" && A) {
                            let {width: j=0, height: B=0, y: W=0} = A
                              , N = W
                              , H = B;
                            if (k.scope === "stack" && b.stackTotal) {
                                let D = T.translate(L ? 100 : b.stackTotal, !1, !0, !1, !0)
                                  , V = T.translate(_.threshold || 0, !1, !0, !1, !0)
                                  , G = this.crispCol(0, Math.min(D, V), 0, Math.abs(D - V));
                                N = G.y,
                                H = G.height
                            }
                            let X = (b.negative ? -1 : 1) * (w ? -1 : 1) == -1
                              , ie = k.where;
                            !ie && this.is("waterfall") && Math.abs((b.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (ie = "all"),
                            ie || (ie = "end");
                            let K = Math.min(f(k.radius, j), j / 2, ie === "all" ? B / 2 : 1 / 0) || 0;
                            ie === "end" && (X && (N -= K),
                            H += K),
                            u(A, {
                                brBoxHeight: H,
                                brBoxY: N,
                                r: K
                            })
                        }
                    }
                }
            }
            function E(F, P) {
                return h(F) || (F = {
                    radius: F || 0
                }),
                d(S, P, F)
            }
            function O() {
                let F = E(this.options.borderRadius);
                for (let P of this.points) {
                    let _ = P.shapeArgs;
                    _ && (_.borderRadius = f(F.radius, (_.r || 0) - (_.innerR || 0)))
                }
            }
            function R(F, P, _, T, L={}) {
                let I = p(F, P, _, T, L)
                  , {r: k=0, brBoxHeight: w=T, brBoxY: b=P} = L
                  , A = P - b
                  , j = b + w - (P + T)
                  , B = A - k > -.1 ? 0 : k
                  , W = j - k > -.1 ? 0 : k
                  , N = Math.max(B && A, 0)
                  , H = Math.max(W && j, 0)
                  , X = [F + B, P]
                  , ie = [F + _ - B, P]
                  , K = [F + _, P + B]
                  , D = [F + _, P + T - W]
                  , V = [F + _ - W, P + T]
                  , G = [F + W, P + T]
                  , ee = [F, P + T - W]
                  , J = [F, P + B]
                  , te = (z,Y)=>Math.sqrt(Math.pow(z, 2) - Math.pow(Y, 2));
                if (N) {
                    let z = te(B, B - N);
                    X[0] -= z,
                    ie[0] += z,
                    K[1] = J[1] = P + B - N
                }
                if (T < B - N) {
                    let z = te(B, B - N - T);
                    K[0] = D[0] = F + _ - B + z,
                    V[0] = Math.min(K[0], V[0]),
                    G[0] = Math.max(D[0], G[0]),
                    ee[0] = J[0] = F + B - z,
                    K[1] = J[1] = P + T
                }
                if (H) {
                    let z = te(W, W - H);
                    V[0] += z,
                    G[0] -= z,
                    D[1] = ee[1] = P + T - W + H
                }
                if (T < W - H) {
                    let z = te(W, W - H - T);
                    K[0] = D[0] = F + _ - W + z,
                    ie[0] = Math.min(K[0], ie[0]),
                    X[0] = Math.max(D[0], X[0]),
                    ee[0] = J[0] = F + W - z,
                    D[1] = ee[1] = P
                }
                return I.length = 0,
                I.push(["M", ...X], ["L", ...ie], ["A", B, B, 0, 0, 1, ...K], ["L", ...D], ["A", W, W, 0, 0, 1, ...V], ["L", ...G], ["A", W, W, 0, 0, 1, ...ee], ["L", ...J], ["A", B, B, 0, 0, 1, ...X], ["Z"]),
                I
            }
            return {
                compose: function(F, P, _, T) {
                    if (m(x, F) && c(F, "afterColumnTranslate", C, {
                        order: 9
                    }),
                    m(x, P) && c(P, "afterTranslate", O),
                    m(x, _) && _.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"),
                    m(x, T)) {
                        let L = T.prototype.symbols;
                        v = L.arc,
                        p = L.roundedRect,
                        L.arc = g,
                        L.roundedRect = R
                    }
                },
                optionsToObject: E
            }
        }),
        i(n, "Core/Responsive.js", [n["Core/Utilities.js"]], function(r) {
            var s;
            let {diffObjects: o, extend: a, find: l, isArray: c, isObject: u, merge: h, objectEach: d, pick: m, splat: f, uniqueKey: x} = r;
            return function(S) {
                let v = [];
                function p(C, E) {
                    let O = C.condition;
                    (O.callback || function() {
                        return this.chartWidth <= m(O.maxWidth, Number.MAX_VALUE) && this.chartHeight <= m(O.maxHeight, Number.MAX_VALUE) && this.chartWidth >= m(O.minWidth, 0) && this.chartHeight >= m(O.minHeight, 0)
                    }
                    ).call(this) && E.push(C._id)
                }
                function g(C, E) {
                    let O = this.options.responsive, R = this.currentResponsive, F = [], P;
                    !E && O && O.rules && O.rules.forEach(L=>{
                        L._id === void 0 && (L._id = x()),
                        this.matchResponsiveRule(L, F)
                    }
                    , this);
                    let _ = h(...F.map(L=>l((O || {}).rules || [], I=>I._id === L)).map(L=>L && L.chartOptions));
                    _.isResponsiveOptions = !0,
                    F = F.toString() || void 0;
                    let T = R && R.ruleIds;
                    F !== T && (R && this.update(R.undoOptions, C, !0),
                    F ? ((P = o(_, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0,
                    this.currentResponsive = {
                        ruleIds: F,
                        mergedOptions: _,
                        undoOptions: P
                    },
                    this.update(_, C, !0)) : this.currentResponsive = void 0)
                }
                S.compose = function(C) {
                    return r.pushUnique(v, C) && a(C.prototype, {
                        matchResponsiveRule: p,
                        setResponsive: g
                    }),
                    C
                }
            }(s || (s = {})),
            s
        }),
        i(n, "masters/highcharts.src.js", [n["Core/Globals.js"], n["Core/Utilities.js"], n["Core/Defaults.js"], n["Core/Animation/Fx.js"], n["Core/Animation/AnimationUtilities.js"], n["Core/Renderer/HTML/AST.js"], n["Core/Templating.js"], n["Core/Renderer/RendererUtilities.js"], n["Core/Renderer/SVG/SVGElement.js"], n["Core/Renderer/SVG/SVGRenderer.js"], n["Core/Renderer/HTML/HTMLElement.js"], n["Core/Renderer/HTML/HTMLRenderer.js"], n["Core/Axis/Axis.js"], n["Core/Axis/DateTimeAxis.js"], n["Core/Axis/LogarithmicAxis.js"], n["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], n["Core/Axis/Tick.js"], n["Core/Tooltip.js"], n["Core/Series/Point.js"], n["Core/Pointer.js"], n["Core/Legend/Legend.js"], n["Core/Chart/Chart.js"], n["Core/Axis/Stacking/StackingAxis.js"], n["Core/Axis/Stacking/StackItem.js"], n["Core/Series/Series.js"], n["Core/Series/SeriesRegistry.js"], n["Series/Column/ColumnSeries.js"], n["Series/Column/ColumnDataLabel.js"], n["Series/Pie/PieSeries.js"], n["Series/Pie/PieDataLabel.js"], n["Core/Series/DataLabel.js"], n["Extensions/OverlappingDataLabels.js"], n["Extensions/BorderRadius.js"], n["Core/Responsive.js"], n["Core/Color/Color.js"], n["Core/Time.js"]], function(r, s, o, a, l, c, u, h, d, m, f, x, S, v, p, g, C, E, O, R, F, P, _, T, L, I, k, w, b, A, j, B, W, N, H, X) {
            return r.animate = l.animate,
            r.animObject = l.animObject,
            r.getDeferredAnimation = l.getDeferredAnimation,
            r.setAnimation = l.setAnimation,
            r.stop = l.stop,
            r.timers = a.timers,
            r.AST = c,
            r.Axis = S,
            r.Chart = P,
            r.chart = P.chart,
            r.Fx = a,
            r.Legend = F,
            r.PlotLineOrBand = g,
            r.Point = O,
            r.Pointer = R,
            r.Series = L,
            r.StackItem = T,
            r.SVGElement = d,
            r.SVGRenderer = m,
            r.Templating = u,
            r.Tick = C,
            r.Time = X,
            r.Tooltip = E,
            r.Color = H,
            r.color = H.parse,
            x.compose(m),
            f.compose(d),
            R.compose(P),
            F.compose(P),
            r.defaultOptions = o.defaultOptions,
            r.getOptions = o.getOptions,
            r.time = o.defaultTime,
            r.setOptions = o.setOptions,
            r.dateFormat = u.dateFormat,
            r.format = u.format,
            r.numberFormat = u.numberFormat,
            s.extend(r, s),
            r.distribute = h.distribute,
            r.seriesType = I.seriesType,
            w.compose(k),
            W.compose(L, b, d, m),
            j.compose(L),
            v.compose(S),
            p.compose(S),
            B.compose(P),
            A.compose(b),
            g.compose(S),
            N.compose(P),
            _.compose(S, P, L),
            E.compose(R),
            r
        }),
        n["masters/highcharts.src.js"]._modules = n,
        n["masters/highcharts.src.js"]
    })
}
)(MA);
var YX = MA.exports;
const fv = Jr(YX);
var EA = {
    exports: {}
};
(function(e, t) {
    (function(n, i) {
        e.exports = i(M)
    }
    )(typeof self < "u" ? self : n8, function(n) {
        return function(i) {
            function r(o) {
                if (s[o])
                    return s[o].exports;
                var a = s[o] = {
                    i: o,
                    l: !1,
                    exports: {}
                };
                return i[o].call(a.exports, a, a.exports, r),
                a.l = !0,
                a.exports
            }
            var s = {};
            return r.m = i,
            r.c = s,
            r.d = function(o, a, l) {
                r.o(o, a) || Object.defineProperty(o, a, {
                    configurable: !1,
                    enumerable: !0,
                    get: l
                })
            }
            ,
            r.n = function(o) {
                var a = o && o.__esModule ? function() {
                    return o.default
                }
                : function() {
                    return o
                }
                ;
                return r.d(a, "a", a),
                a
            }
            ,
            r.o = function(o, a) {
                return Object.prototype.hasOwnProperty.call(o, a)
            }
            ,
            r.p = "",
            r(r.s = 0)
        }([function(i, r, s) {
            function o() {
                return o = Object.assign ? Object.assign.bind() : function(p) {
                    for (var g = 1; g < arguments.length; g++) {
                        var C = arguments[g];
                        for (var E in C)
                            Object.prototype.hasOwnProperty.call(C, E) && (p[E] = C[E])
                    }
                    return p
                }
                ,
                o.apply(this, arguments)
            }
            function a(p) {
                return h(p) || u(p) || c(p) || l()
            }
            function l() {
                throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
            }
            function c(p, g) {
                if (p) {
                    if (typeof p == "string")
                        return d(p, g);
                    var C = Object.prototype.toString.call(p).slice(8, -1);
                    return C === "Object" && p.constructor && (C = p.constructor.name),
                    C === "Map" || C === "Set" ? Array.from(p) : C === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(C) ? d(p, g) : void 0
                }
            }
            function u(p) {
                if (typeof Symbol < "u" && p[Symbol.iterator] != null || p["@@iterator"] != null)
                    return Array.from(p)
            }
            function h(p) {
                if (Array.isArray(p))
                    return d(p)
            }
            function d(p, g) {
                (g == null || g > p.length) && (g = p.length);
                for (var C = 0, E = new Array(g); C < g; C++)
                    E[C] = p[C];
                return E
            }
            function m(p) {
                "@babel/helpers - typeof";
                return (m = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
                    return typeof g
                }
                : function(g) {
                    return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g
                }
                )(p)
            }
            Object.defineProperty(r, "__esModule", {
                value: !0
            }),
            s.d(r, "HighchartsReact", function() {
                return v
            });
            var f = s(1)
              , x = s.n(f)
              , S = typeof window < "u" ? f.useLayoutEffect : f.useEffect
              , v = Object(f.memo)(Object(f.forwardRef)(function(p, g) {
                var C = Object(f.useRef)()
                  , E = Object(f.useRef)()
                  , O = Object(f.useRef)(p.constructorType)
                  , R = Object(f.useRef)(p.highcharts);
                return S(function() {
                    function F() {
                        var _ = p.highcharts || (typeof window > "u" ? "undefined" : m(window)) === "object" && window.Highcharts
                          , T = p.constructorType || "chart";
                        _ ? _[T] ? p.options ? E.current = _[T](C.current, p.options, p.callback) : console.warn('The "options" property was not passed.') : console.warn('The "constructorType" property is incorrect or some required module is not imported.') : console.warn('The "highcharts" property was not passed.')
                    }
                    if (E.current) {
                        if (p.allowChartUpdate !== !1)
                            if (p.constructorType !== O.current || p.highcharts !== R.current)
                                O.current = p.constructorType,
                                R.current = p.highcharts,
                                F();
                            else if (!p.immutable && E.current) {
                                var P;
                                (P = E.current).update.apply(P, [p.options].concat(a(p.updateArgs || [!0, !0])))
                            } else
                                F()
                    } else
                        F()
                }, [p.options, p.allowChartUpdate, p.updateArgs, p.containerProps, p.highcharts, p.constructorType]),
                S(function() {
                    return function() {
                        E.current && (E.current.destroy(),
                        E.current = null)
                    }
                }, []),
                Object(f.useImperativeHandle)(g, function() {
                    return {
                        get chart() {
                            return E.current
                        },
                        container: C
                    }
                }, []),
                x.a.createElement("div", o({}, p.containerProps, {
                    ref: C
                }))
            }));
            r.default = v
        }
        , function(i, r) {
            i.exports = n
        }
        ])
    })
}
)(EA);
var $X = EA.exports;
const pv = Jr($X)
  , PA = ({dataChart: e})=>{
    const t = e[0]
      , n = e[1]
      , i = (s,o)=>e.length === 4 ? s : e[4].length === 2 && o === 1 ? e[4][0] : e[4].length === 2 && o === 2 ? e[4][1] : s
      , r = {
        chart: {
            type: "area",
            style: {
                fontFamily: "Lato",
                fontSize: 15
            }
        },
        title: {
            text: ""
        },
        legend: {
            align: "left"
        },
        credits: {
            enabled: !1
        },
        xAxis: {
            categories: e[2],
            tickInterval: e[3],
            tickWidth: 0,
            crosshair: {
                width: 1,
                color: "rgba(44, 64, 110, 1)",
                dashStyle: "shortdot"
            },
            labels: {
                format: "{value}",
                style: {
                    color: "rgba(44, 64, 110, 0.50)"
                }
            },
            lineWidth: 0
        },
        yAxis: [{
            labels: {
                format: "${value}b",
                style: {
                    color: "rgba(44, 64, 110, 0.50)"
                }
            },
            lineWidth: 0,
            gridLineWidth: 0,
            title: {
                text: ""
            }
        }, {
            labels: {
                format: "{value}k",
                style: {
                    color: "rgba(44, 64, 110, 0.50)"
                }
            },
            lineWidth: 0,
            gridLineWidth: 0,
            opposite: !0,
            title: {
                text: ""
            }
        }],
        tooltip: {
            shared: !0,
            valueDecimals: 2,
            backgroundColor: "rgba(43, 121, 255, 0.4)",
            borderWidth: 1,
            borderColor: "#FEFEFE",
            borderRadius: 5,
            fontSize: 12,
            useHTML: !0,
            headerFormat: "<table>",
            pointFormat: '<tr><td style="color: #fff";">{series.name} </td><td style="text-align: right; color: #fff";><b>&nbsp;&nbsp;&nbsp;$ {point.y}</b></td></tr>',
            footerFormat: '<tr><th style="color: #fff">{point.key}</th></tr></table>'
        },
        plotOptions: {
            series: {
                marker: {
                    enabled: !1,
                    states: {
                        hover: {
                            enabled: !0
                        }
                    }
                }
            }
        },
        series: [{
            name: i("Fully diluted market cap", 1),
            data: n,
            color: "#2B7AFF",
            gapSize: 5,
            tooltip: {
                valueDecimals: 2
            },
            fillOpacity: .3,
            fillColor: {
                linearGradient: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 1
                },
                stops: [[0, "rgb(43, 122, 255, 0.3) "], [1, "rgba(43, 121, 255, 0)"]]
            },
            threshold: null
        }, {
            name: i("Daily active users", 2),
            data: t,
            yAxis: 1,
            color: "#D663FF",
            gapSize: 5,
            tooltip: {
                valueDecimals: 2
            },
            fillColor: {
                linearGradient: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 1
                },
                stops: [[0, "rgba(213, 99, 255, 0.3)"], [1, "rgba(213, 99, 255, 0.1)"]]
            },
            threshold: null
        }]
    };
    return y.jsx(pv, {
        highcharts: fv,
        options: r
    })
}
  , br = e=>{
    let t = [];
    for (var n = new Date, i = 0; i < e; i++) {
        var r = n.getDate()
          , s = n.getMonth() + 1
          , o = n.getFullYear() % 100
          , a = `${l(r)}-${l(s)}-${l(o)}`;
        t.push(a),
        n.setDate(n.getDate() - 1)
    }
    function l(c) {
        return c < 10 ? "0" + c : c
    }
    return t.reverse()
}
  , z0 = {
    growthRate: ["24h", "7d", "30d", "90d", "180d", "365d"],
    fullyDilutedMarketCap: ["+0.8 %", "-5.8%", "-16.7%", "-21.3%", "-10.9%", "-10.0%"],
    dailyActiveUsers: ["-6.3%", "+2.7%", "+58.8%", "+73.6%", "+93.0%", "+273.5%"]
}
  , zt = [153.12, 151.83, 152.51, 153.65, 154.3, 156.69, 155.11, 154.07, 148.97, 149.55, 148.12, 149.03, 148.79, 146.06, 142.94, 143.43, 145.85, 146.83, 146.92, 145.37, 141.91, 142.83, 141.5, 142.65, 139.14, 141.11, 142, 143.29, 142.9, 142.81, 141.51, 140.91, 143.76, 144.84, 146.55, 148.76, 149.26, 149.48, 148.69, 148.64, 149.32, 148.85, 152.57, 149.8, 148.96, 150.02, 151.49, 150.96, 151.28, 150.44, 150.81, 147.92, 147.87, 149.99, 150, 151, 153.49, 157.87, 160.55, 161.02, 161.41, 161.94, 156.81, 160.24, 165.3, 164.77, 163.76, 161.84, 165.32, 171.18, 175.08, 174.56, 179.45, 175.74, 174.33, 179.3, 172.26, 171.14, 169.75, 172.99, 175.64, 176.28, 180.33, 179.29, 179.38, 178.2, 177.57, 182.01, 179.7, 174.92, 172, 172.17, 172.19, 175.08, 175.53, 172.19, 173.07, 169.8, 166.23, 164.51, 162.41, 161.62, 159.78, 159.69, 159.22, 170.33, 174.78, 174.61, 175.84, 172.9, 172.39, 171.66, 174.83, 176.28, 172.12, 168.64, 168.88, 172.79, 172.55, 168.88, 167.3, 164.32, 160.07, 162.74, 164.85, 165.12, 163.2, 166.56, 166.23, 163.17, 159.3, 157.44, 162.95, 158.52, 154.73, 150.62, 155.09, 159.59, 160.62, 163.98, 165.38, 168.82, 170.21, 174.07, 174.72, 175.6, 178.96, 177.77, 174.61, 174.31, 178.44, 175.06, 171.83, 172.14, 170.09, 165.75, 167.66, 170.4, 165.29, 165.07, 167.4, 167.23, 166.42, 161.79, 162.88, 156.8, 156.57, 163.64, 157.65, 157.96, 159.48, 166.02, 156.77, 157.28, 152.06, 154.51, 146.5, 142.56, 147.11, 145.54, 149.24, 140.82, 137.35, 137.59, 143.11, 140.36, 140.52, 143.78, 149.64, 148.84, 148.71, 151.21, 145.38, 146.14, 148.71, 147.96, 142.64, 137.13, 131.88, 132.76, 135.43, 130.06, 131.56, 135.87, 135.35, 138.27, 141.66, 141.66, 137.44, 139.23, 136.72, 138.93, 141.56, 142.92, 146.35, 147.04, 144.87, 145.86, 145.49, 148.47, 150.17, 147.07, 151, 153.04, 155.35, 154.09, 152.95, 151.6, 156.79, 157.35, 162.51, 161.51, 160.01, 166.13, 165.81, 165.35, 164.87, 164.92, 169.24, 168.49, 172.1, 173.19, 173.03, 174.55, 174.15, 171.52, 167.57, 167.23, 167.53, 170.03, 163.62, 161.38, 158.91, 157.22, 157.96, 155.81, 154.53, 155.96, 154.46, 157.37, 163.43, 153.84, 155.31, 152.37, 150.7, 154.48, 156.9, 153.72, 152.74, 150.43, 150.77, 151.76, 149.84, 142.48, 138.2, 142.45, 146.1, 146.4, 145.43, 140.09, 140.42, 138.98, 138.34, 142.99, 138.38, 142.41, 143.75, 143.86, 143.39, 147.27, 149.45, 152.34, 149.35, 144.8, 155.74, 153.34, 150.65, 145.03, 138.88, 138.38, 138.92, 139.5, 134.87, 146.87, 149.7, 148.28, 150.04, 148.79, 150.72, 151.29, 148.01, 150.18, 151.07, 148.11, 144.22, 141.17, 148.03, 148.31, 147.81, 146.63, 142.91, 140.94, 142.65, 142.16, 144.49, 145.47, 143.21, 136.5, 134.51, 132.37, 132.3, 135.45, 132.23, 131.86, 130.03, 126.04, 129.61, 129.93, 125.07, 126.36, 125.02, 129.62, 130.15, 130.73, 133.49, 133.41, 134.76, 135.94, 135.21, 135.27, 137.87, 141.11, 142.53, 141.86, 143.96, 145.93, 143, 144.29, 145.43, 150.82, 154.5, 151.73, 154.65, 151.92, 150.87, 151.01, 153.85, 153.2, 155.33, 153.71, 152.55, 148.48, 148.91, 149.4, 146.71, 147.92, 147.41, 145.31, 145.91, 151.03, 153.83, 151.6, 152.87, 150.59, 148.5, 150.47, 152.59, 152.99, 155.85, 155, 157.4, 159.28, 157.83, 158.93, 160.25, 158.28, 157.65, 160.77, 162.36, 164.9, 166.17, 165.63, 163.76, 164.66, 162.03, 160.8, 160.1, 165.56, 165.21, 165.23, 166.47, 167.63, 166.65, 165.02, 165.33, 163.77, 163.76, 168.41, 169.68, 169.59, 168.54, 167.45, 165.79, 173.57, 173.5, 171.77, 173.56, 173.75, 172.57, 172.07, 172.07, 172.69, 175.05, 175.16, 174.2, 171.56, 171.84, 172.99, 175.43, 177.3, 177.25, 180.09, 180.95, 179.58, 179.21, 177.82, 180.57, 180.96, 183.79, 183.31, 183.95, 186.01, 184.92, 185.01, 183.96, 187, 186.68, 185.27, 188.06, 189.25, 189.59, 193.97, 192.46, 191.33, 191.81, 190.68, 188.61, 188.08, 189.77, 190.54, 190.69, 193.99, 193.73, 195.1, 193.13, 191.94, 192.75, 193.62, 194.5, 193.22, 195.83, 196.45, 195.61, 192.58, 191.17, 181.99, 178.85, 179.8, 178.19, 177.97, 177.79, 179.46, 177.45, 176.57, 174, 174.49, 175.84, 177.23, 181.12, 176.38, 178.61, 180.19, 182.57]
  , KX = ()=>{
    const [e,t] = Ce.useState("6m")
      , {ref: n, inView: i} = AA({
        threshold: 0
    })
      , r = s=>{
        switch (s) {
        case "empty":
            return [Array(176).fill(0), Array(176).fill(0), br(7), 0];
        case "7d":
            return [zt.slice(100, 107), zt.slice(0, 7).map(o=>o - 50), br(7), 0];
        case "1m":
            return [zt.slice(100, 131), zt.slice(0, 31).map(o=>o - 50), br(31), 3];
        case "3m":
            return [zt.slice(100, 193), zt.slice(0, 93).map(o=>o - 50), br(93), 10];
        case "6m":
            return [zt.slice(100, 286), zt.slice(0, 186).map(o=>o - 50), br(186), 15];
        case "1y":
            return [zt.slice(100, 466), zt.slice(0, 366).map(o=>o - 50), br(366), 20];
        case "All":
            return [zt.slice(100, 500), zt.slice(0, 400).map(o=>o - 50), br(400), 22]
        }
    }
    ;
    return y.jsxs("section", {
        children: [y.jsx("h2", {
            children: "Key metrics"
        }), y.jsxs("div", {
            className: "key-metrics",
            children: [y.jsxs("div", {
                className: "key-metrics__filter",
                children: [y.jsxs("button", {
                    children: ["Filters ", y.jsx(oC, {
                        className: "btn-svg"
                    })]
                }), y.jsx("div", {
                    children: ["7d", "1m", "3m", "6m", "1y", "All"].map((s,o)=>y.jsx("button", {
                        className: e === s ? "btn-active" : "",
                        onClick: ()=>t(s),
                        children: s
                    }, o))
                })]
            }), y.jsx("p", {
                children: "Daily fully diluted market cap vs. daily active users in the past 180 days"
            }), y.jsxs("div", {
                className: "key-metrics__chart",
                ref: n,
                children: [y.jsxs("div", {
                    children: [y.jsx("p", {
                        children: "Fully diluted market cap"
                    }), y.jsx("p", {
                        children: "Daily active users"
                    })]
                }), y.jsx(PA, {
                    dataChart: r(i ? e : "empty")
                }), y.jsx("div", {
                    children: y.jsxs("div", {
                        children: [["More info", "Embed chart", "Expand", "Copy link"].map((s,o)=>y.jsx("button", {
                            children: s
                        }, o)), y.jsx("a", {
                            href: "./test.svc",
                            download: !0,
                            children: y.jsx("button", {
                                children: "Download"
                            })
                        })]
                    })
                })]
            }), y.jsxs("table", {
                children: [y.jsx("thead", {
                    children: y.jsxs("tr", {
                        children: [y.jsx("th", {
                            children: "Growth rate"
                        }), z0.growthRate.map((s,o)=>y.jsx("th", {
                            children: s
                        }, o))]
                    })
                }), y.jsxs("tbody", {
                    children: [y.jsxs("tr", {
                        children: [y.jsx("td", {
                            children: "Fully diluted market cap"
                        }), z0.fullyDilutedMarketCap.map((s,o)=>y.jsx("td", {
                            style: Di(s),
                            children: s
                        }, o))]
                    }), y.jsxs("tr", {
                        children: [y.jsx("td", {
                            children: "Daily active users"
                        }), z0.dailyActiveUsers.map((s,o)=>y.jsx("td", {
                            style: Di(s),
                            children: s
                        }, o))]
                    })]
                })]
            })]
        })]
    })
}
  , QX = ()=>y.jsx("main", {
    children: y.jsxs(Hr, {
        gutter: [32, 32],
        style: {
            marginTop: "18px"
        },
        children: [y.jsx(Ot, {
            className: "gutter-row",
            xs: 24,
            lg: 24,
            xl: 24,
            xxl: 16,
            children: y.jsx(EX, {})
        }), y.jsx(Ot, {
            xs: 24,
            xxl: 8,
            children: y.jsx(FX, {})
        }), y.jsx(Ot, {
            xs: 24,
            children: y.jsx(XX, {})
        }), y.jsx(Ot, {
            xs: 24,
            children: y.jsx(KX, {})
        })]
    })
})
  , V0 = ({dataChart: e, color: t})=>{
    const n = e.slice(100, 500)
      , i = e.slice(0, 400).map(o=>o - 50)
      , r = (o,a)=>{
        if (typeof o == "string" && a === 1)
            return o;
        if (typeof o == "string" && a === 2)
            return "#ffffff";
        if (o.length === 2 && a === 1)
            return o[0];
        if (o.length === 2 && a === 2)
            return o[1];
        console.log("Error in LineRatingHighchart")
    }
      , s = {
        chart: {
            type: "area",
            style: {
                fontFamily: "Lato",
                fontSize: 15
            }
        },
        title: {
            text: ""
        },
        legend: {
            enabled: !1
        },
        credits: {
            enabled: !1
        },
        xAxis: {
            tickInterval: 22,
            tickWidth: 0,
            crosshair: {
                width: 0,
                color: "rgba(44, 64, 110, 1)",
                dashStyle: "shortdot"
            },
            labels: {
                enabled: !1
            },
            lineWidth: 0
        },
        yAxis: [{
            labels: {
                enabled: !1
            },
            lineWidth: 0,
            gridLineWidth: 0,
            title: {
                text: ""
            }
        }, {
            labels: {
                enabled: !1
            },
            lineWidth: 0,
            gridLineWidth: 0,
            title: {
                text: ""
            }
        }],
        tooltip: {
            shared: !1,
            valueDecimals: 2
        },
        plotOptions: {
            series: {
                marker: {
                    enabled: !1,
                    states: {
                        hover: {
                            enabled: !1
                        }
                    }
                }
            }
        },
        series: [{
            name: "Fully diluted market cap",
            data: i,
            color: r(t, 1),
            gapSize: 5,
            tooltip: {
                valueDecimals: 2
            },
            fillOpacity: .3,
            fillColor: {
                linearGradient: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 1
                },
                stops: [[0, `${r(t, 1)}30`], [1, `${r(t, 1)}00`]]
            },
            threshold: null
        }, {
            name: "Daily active users",
            data: n,
            color: r(t, 2),
            gapSize: 5,
            tooltip: {
                valueDecimals: 2
            },
            fillColor: {
                linearGradient: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 1
                },
                stops: [[0, `${r(t, 2)}30`], [1, `${r(t, 2)}00`]]
            },
            threshold: null
        }]
    };
    return y.jsx(pv, {
        highcharts: fv,
        options: s
    })
}
  , qX = ({data: e})=>{
    const [t,n] = Ce.useState(e.checkbox)
      , {id: i, nameBot: r, tradeRatio: s, numberTrades: o, profitGained: a, ercentageGain: l, workingTime: c, status: u, totalBalance: h, orders: d, svg: m, bothLineChartColor: f, oneLineChartColor: x, checkbox: S} = e;
    return y.jsx("li", {
        className: "item-bots",
        children: y.jsx("div", {
            className: "item-bots__wrapper-scroll",
            children: y.jsxs("div", {
                className: "item-bots__wrapper",
                children: [y.jsxs(Vn, {
                    to: `/ai-trading-bots/${i}`,
                    children: [y.jsxs("div", {
                        className: "item-bots__row-1",
                        children: [y.jsxs("h3", {
                            children: ["Bot ", i]
                        }), y.jsxs("div", {
                            children: [y.jsxs("div", {
                                children: [y.jsx(tn, {
                                    name: m[0],
                                    className: "svg-30px"
                                }), y.jsx(tn, {
                                    name: m[1],
                                    className: "svg-30px"
                                })]
                            }), y.jsx("h4", {
                                children: r
                            })]
                        }), y.jsxs("h5", {
                            children: ["2", i, " Apr-2023 | 04:5", i]
                        }), y.jsx("div", {
                            children: y.jsx(V0, {
                                dataChart: zt,
                                color: f
                            })
                        })]
                    }), y.jsxs("div", {
                        className: "item-bots__row-2",
                        children: [y.jsxs("div", {
                            children: [y.jsx("h4", {
                                children: "Trade Ratio"
                            }), y.jsxs("div", {
                                className: "range-slider-procent",
                                children: [y.jsxs("h5", {
                                    style: {
                                        color: "#03a66d"
                                    },
                                    children: [s, "%"]
                                }), y.jsxs("h5", {
                                    style: {
                                        color: "#cf304a"
                                    },
                                    children: [s ? 100 - s : 0, "%"]
                                })]
                            }), y.jsx("div", {
                                className: "range-slider",
                                children: y.jsx("div", {
                                    style: {
                                        width: `${s}%`
                                    }
                                })
                            })]
                        }), y.jsxs("div", {
                            children: [y.jsx("h4", {
                                children: "Number of trades"
                            }), y.jsx("h5", {
                                children: o
                            })]
                        })]
                    })]
                }), y.jsxs("div", {
                    className: "item-bots__row-3",
                    children: [y.jsxs("div", {
                        children: [y.jsx("h4", {
                            children: "Profit gained"
                        }), y.jsxs("div", {
                            className: "item-bots-procent-chart",
                            children: [y.jsxs("h5", {
                                style: {
                                    color: "#03a66d"
                                },
                                children: [a, "%"]
                            }), y.jsx("div", {
                                children: S ? y.jsx(V0, {
                                    dataChart: zt,
                                    color: x[0]
                                }) : null
                            })]
                        })]
                    }), y.jsxs("div", {
                        children: [y.jsx("h4", {
                            children: "Percentage gain"
                        }), y.jsxs("div", {
                            className: "item-bots-procent-chart",
                            children: [y.jsxs("h5", {
                                style: {
                                    color: "#cf304a"
                                },
                                children: [l, "%"]
                            }), y.jsx("div", {
                                children: S ? y.jsx(V0, {
                                    dataChart: zt,
                                    color: x[1]
                                }) : null
                            })]
                        })]
                    })]
                }), y.jsxs("div", {
                    className: "item-bots__row-4",
                    children: [y.jsxs("div", {
                        children: [y.jsx("h4", {
                            children: "Working time"
                        }), y.jsx("h5", {
                            children: c
                        })]
                    }), y.jsxs("div", {
                        children: [y.jsx("h4", {
                            children: "Status"
                        }), y.jsx("h5", {
                            style: {
                                color: u === "Active" ? "#03a66d" : "#cf304a"
                            },
                            children: u
                        })]
                    })]
                }), y.jsxs("div", {
                    className: "item-bots__row-5",
                    children: [y.jsxs("div", {
                        children: [y.jsx("h4", {
                            children: "Total Balance"
                        }), y.jsx("h5", {
                            children: h
                        })]
                    }), y.jsxs("div", {
                        children: [y.jsx("h4", {
                            children: "Orders"
                        }), y.jsx("h5", {
                            children: d
                        })]
                    })]
                }), y.jsxs("div", {
                    className: "item-bots__row-6",
                    children: [y.jsxs("div", {
                        className: `custom-checkbox
                  ${t ? "" : "custom-checkbox_unactive"}
                `,
                        onClick: ()=>n(!t),
                        children: [t ? y.jsx("span", {
                            className: "custom-checkbox__on",
                            children: "ON"
                        }) : y.jsx("span", {
                            className: "custom-checkbox__off",
                            children: "OFF"
                        }), y.jsx("div", {
                            className: `custom-checkbox__button
                  ${t ? "" : "custom-checkbox__button_unactive"}
                `
                        })]
                    }), y.jsxs("div", {
                        children: [y.jsx("h4", {
                            children: "Exchanges"
                        }), y.jsxs("div", {
                            children: [["atlas", "avax", "ok", "usd", "xrp", "btc"].map((v,p)=>y.jsx(tn, {
                                name: v,
                                className: "svg-21px token-info__svg"
                            }, p)), y.jsx("img", {
                                src: dv,
                                alt: "Arrow Right"
                            })]
                        })]
                    })]
                })]
            })
        })
    })
}
  , Cl = [{
    id: 1,
    nameBot: "ETH/USDT",
    tradeRatio: 30.6,
    numberTrades: 373,
    profitGained: 34.12,
    ercentageGain: 14.56,
    workingTime: "5h 23m",
    status: "Active",
    totalBalance: "$4,308.12",
    orders: 36,
    checkbox: !0,
    svg: ["eth", "usdt"],
    bothLineChartColor: ["#2B7AFF", "#53AE94"],
    oneLineChartColor: ["#03A66D", "#CF304A"]
}, {
    id: 2,
    nameBot: "ETH/BTC",
    tradeRatio: 52,
    numberTrades: 212,
    profitGained: 23.36,
    ercentageGain: 13.56,
    workingTime: "1h 12m",
    status: "Active",
    totalBalance: "$1,224.31",
    orders: 56,
    checkbox: !0,
    svg: ["eth", "btc"],
    bothLineChartColor: ["#2B7AFF", "#F7931A"],
    oneLineChartColor: ["#03A66D", "#CF304A"]
}, {
    id: 3,
    nameBot: "ETH/BAND",
    tradeRatio: 0,
    numberTrades: 0,
    profitGained: 0,
    ercentageGain: 0,
    workingTime: "0",
    status: "Inactive",
    totalBalance: "0",
    orders: 0,
    checkbox: !1,
    svg: ["eth", "band"],
    bothLineChartColor: ["#2B7AFF", "#2775CA"],
    oneLineChartColor: ["#fff", "#fff"]
}]
  , ZX = ()=>y.jsxs("section", {
    className: "list-tranding-strategies",
    children: [y.jsxs("div", {
        className: "list-tranding-strategies__panel",
        children: [y.jsx("h2", {
            children: "AI Trading Strategies"
        }), y.jsxs("div", {
            children: [y.jsxs("button", {
                children: ["All Bots   ", y.jsx(Kr, {})]
            }), y.jsx(Vn, {
                to: "/create-strategy",
                children: y.jsx("button", {
                    children: "+   Add Strategy"
                })
            })]
        })]
    }), y.jsx("div", {
        className: "list-tranding-strategies__content",
        children: y.jsx("ul", {
            children: Cl.map(e=>y.jsx(qX, {
                data: e
            }, e.id))
        })
    })]
})
  , JX = ()=>y.jsx("main", {
    children: y.jsx(ZX, {})
})
  , eY = "data:image/svg+xml,%3csvg%20width='21'%20height='21'%20viewBox='0%200%2021%2021'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20id='Vector'%20d='M10.2225%206.44746V10.4181M10.2225%2014.3888H10.2324M19.1565%2010.4181C19.1565%2011.5913%2018.9254%2012.7531%2018.4764%2013.837C18.0275%2014.9209%2017.3694%2015.9058%2016.5398%2016.7354C15.7102%2017.565%2014.7253%2018.2231%2013.6414%2018.672C12.5575%2019.121%2011.3957%2019.3521%2010.2225%2019.3521C9.04927%2019.3521%207.88753%2019.121%206.80361%2018.672C5.71969%2018.2231%204.73481%2017.565%203.90522%2016.7354C3.07562%2015.9058%202.41755%2014.9209%201.96857%2013.837C1.5196%2012.7531%201.28851%2011.5913%201.28851%2010.4181C1.28851%208.04868%202.22977%205.77628%203.90522%204.10083C5.58066%202.42539%207.85306%201.48413%2010.2225%201.48413C12.5919%201.48413%2014.8643%202.42539%2016.5398%204.10083C18.2152%205.77628%2019.1565%208.04868%2019.1565%2010.4181Z'%20stroke='%232c406e'%20stroke-width='1.91443'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e"
  , tY = ({pathId: e})=>y.jsxs("div", {
    className: "overview",
    children: [y.jsxs("div", {
        children: [y.jsx("img", {
            src: eY,
            alt: "Overview"
        }), y.jsx("h3", {
            children: "Overview"
        })]
    }), y.jsxs("div", {
        children: [y.jsxs("div", {
            children: [y.jsx("h3", {
                children: "Start Date"
            }), y.jsx("h3", {
                children: "27.04.2020"
            })]
        }), y.jsxs("div", {
            children: [y.jsx("h3", {
                children: "End Date"
            }), y.jsx("h3", {
                children: "27.10.2023"
            })]
        })]
    }), y.jsxs("div", {
        children: [y.jsx("h3", {
            children: "Risk"
        }), y.jsx("h3", {
            children: "Good Risk Adjusted Return"
        })]
    }), y.jsxs("div", {
        children: [y.jsxs("div", {
            children: [y.jsx("h3", {
                children: "Pair"
            }), y.jsx("h3", {
                children: Cl[e - 1].nameBot
            })]
        }), y.jsxs("div", {
            children: [y.jsx("h3", {
                children: "Exchange"
            }), y.jsx("h3", {
                children: "Aggregated"
            })]
        })]
    }), y.jsxs("div", {
        children: [y.jsxs("div", {
            children: [y.jsx("h3", {
                children: "Exposure"
            }), y.jsx("h3", {
                children: "100,000"
            })]
        }), y.jsxs("div", {
            children: [y.jsx("h3", {
                children: "Fees"
            }), y.jsx("h3", {
                children: "Not Included"
            })]
        })]
    }), y.jsxs("div", {
        children: [y.jsx("button", {
            children: "More info"
        }), y.jsxs("div", {
            children: [["atlas", "avax", "ok", "usd", "xrp", "btc"].map((t,n)=>y.jsx(tn, {
                name: t,
                className: "svg-27px token-info__svg"
            }, n)), y.jsx("img", {
                src: dv,
                alt: "Arrow Right"
            })]
        })]
    })]
})
  , nY = "data:image/svg+xml,%3csvg%20width='18'%20height='21'%20viewBox='0%200%2018%2021'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9.42869%201.48413L1.15648%2012.2049H8.60147L7.77425%2019.3521L16.0465%208.63132H8.60147L9.42869%201.48413Z'%20stroke='%232C406E'%20stroke-width='1.91443'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e"
  , iY = ()=>y.jsxs("div", {
    className: "total-gain",
    children: [y.jsxs("div", {
        children: [y.jsx("img", {
            src: nY,
            alt: "Total Gain"
        }), y.jsx("h3", {
            children: "Total Gain"
        })]
    }), y.jsx("h3", {
        children: "$ +1,448,655.9"
    }), y.jsx("h6", {
        children: "14.56%"
    })]
})
  , H7 = "data:image/svg+xml,%3csvg%20width='20'%20height='21'%20viewBox='0%200%2020%2021'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20id='Vector'%20d='M1.15648%204.40341L4.13447%205.39608M4.13447%205.39608L1.15648%2014.3301C2.01583%2014.9743%203.06092%2015.3226%204.13497%2015.3226C5.20902%2015.3226%206.25411%2014.9743%207.11346%2014.3301L4.13447%205.39608ZM4.13447%205.39608L7.11247%2014.3301M4.13447%205.39608L10.0905%203.41075M10.0905%203.41075L16.0465%205.39608M10.0905%203.41075V1.42542M10.0905%203.41075V19.2934M16.0465%205.39608L19.0244%204.40341M16.0465%205.39608L13.0685%2014.3301C13.9278%2014.9743%2014.9729%2015.3226%2016.047%2015.3226C17.121%2015.3226%2018.1661%2014.9743%2019.0254%2014.3301L16.0465%205.39608ZM10.0905%2019.2934H7.11247M10.0905%2019.2934H13.0685'%20stroke='%232C406E'%20stroke-width='1.91443'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e"
  , rY = ()=>y.jsxs("div", {
    className: "trade-ratio",
    children: [y.jsxs("div", {
        children: [y.jsx("img", {
            src: H7,
            alt: "Trade Ratio"
        }), y.jsx("h3", {
            children: "Trade Ratio"
        })]
    }), y.jsxs("div", {
        children: [y.jsx("h3", {
            children: "30.56%"
        }), y.jsx("h3", {
            children: "69.44%"
        })]
    }), y.jsxs("div", {
        children: [y.jsx("h4", {
            children: "114 Positive"
        }), y.jsx("h4", {
            children: "259 Negative"
        })]
    }), y.jsx("div", {
        className: "range-slider",
        children: y.jsx("div", {
            style: {
                width: `${H7}%`
            }
        })
    })]
})
  , sY = "data:image/svg+xml,%3csvg%20width='21'%20height='21'%20viewBox='0%200%2021%2021'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='Group%208855'%3e%3cpath%20id='Vector'%20d='M18.9361%2013.837C19.3851%2012.7531%2019.6161%2011.5913%2019.6161%2010.4181C19.6161%208.04868%2018.6749%205.77628%2016.9994%204.10083C15.324%202.42539%2013.0516%201.48413%2010.6822%201.48413C8.31271%201.48413%206.04032%202.42539%204.36487%204.10083C2.68943%205.77628%201.74817%208.04868%201.74817%2010.4181C1.74817%2011.5913%201.97925%2012.7531%202.42823%2013.837C2.8772%2014.9209%203.53528%2015.9058%204.36487%2016.7354C5.19447%2017.565%206.17935%2018.2231%207.26327%2018.672C8.34719%2019.121%209.50893%2019.3521%2010.6822%2019.3521C11.8554%2019.3521%2013.0171%2019.121%2014.101%2018.672C15.185%2018.2231%2016.1698%2017.565%2016.9994%2016.7354C17.829%2015.9058%2018.4871%2014.9209%2018.9361%2013.837Z'%20stroke='%232c406e'%20stroke-width='1.91443'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20id='Vector_2'%20d='M13.4339%2011.5577C13.5835%2011.1964%2013.6605%2010.8091%2013.6605%2010.4181C13.6605%209.62825%2013.3468%208.87078%2012.7883%208.3123C12.2298%207.75382%2011.4724%207.44006%2010.6826%207.44006C9.89274%207.44006%209.13528%207.75382%208.57679%208.3123C8.01831%208.87078%207.70456%209.62825%207.70456%2010.4181C7.70456%2010.8091%207.78159%2011.1964%207.93125%2011.5577C8.0809%2011.919%208.30026%2012.2473%208.57679%2012.5238C8.85333%2012.8004%209.18162%2013.0197%209.54293%2013.1694C9.90423%2013.319%2010.2915%2013.3961%2010.6826%2013.3961C11.0736%2013.3961%2011.4609%2013.319%2011.8222%2013.1694C12.1835%2013.0197%2012.5118%2012.8004%2012.7883%2012.5238C13.0648%2012.2473%2013.2842%2011.919%2013.4339%2011.5577Z'%20stroke='%232c406e'%20stroke-width='1.91443'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3c/svg%3e"
  , oY = ({pathId: e})=>y.jsxs("div", {
    className: "asset-performance",
    children: [y.jsxs("div", {
        children: [y.jsxs("div", {
            children: [y.jsx("img", {
                src: sY,
                alt: "Asset Performance"
            }), y.jsx("h3", {
                children: "AssetPerformance"
            })]
        }), y.jsx(Vn, {
            to: "/ai-trading-bots",
            children: "Back"
        })]
    }), y.jsxs("div", {
        children: [y.jsxs("div", {
            children: [y.jsx(tn, {
                name: Cl[e - 1].svg[0],
                className: "svg-38px"
            }), y.jsx("h3", {
                children: "ETH"
            })]
        }), y.jsxs("div", {
            children: [y.jsx(tn, {
                name: Cl[e - 1].svg[1],
                className: "svg-38px"
            }), y.jsx("h3", {
                children: Cl[e - 1].svg[1].toLocaleUpperCase()
            })]
        })]
    }), y.jsxs("div", {
        children: [y.jsxs("div", {
            children: [y.jsx(Kr, {}), y.jsx("h5", {
                children: "857.78"
            })]
        }), y.jsxs("div", {
            children: [y.jsx(Kr, {}), y.jsx("h5", {
                children: "235.64"
            })]
        })]
    })]
})
  , aY = "data:image/svg+xml,%3csvg%20width='16'%20height='20'%20viewBox='0%200%2016%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20id='Vector'%20d='M14.8301%205.24097L14.8301%2018.868M8.28912%201.42542V18.868M1.74817%2011.2368L1.74817%2018.868'%20stroke='%232C406E'%20stroke-width='1.91443'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e"
  , lY = ()=>y.jsxs("div", {
    className: "trades-win-loss",
    children: [y.jsxs("div", {
        children: [y.jsx("img", {
            src: aY,
            alt: "Trades Win/Loss"
        }), y.jsx("h3", {
            children: "Trades Win/Loss"
        })]
    }), y.jsx("table", {
        children: y.jsxs("tbody", {
            children: [y.jsxs("tr", {
                children: [y.jsx("td", {
                    children: y.jsxs("div", {
                        children: [y.jsx("h5", {
                            children: "Average Win"
                        }), y.jsxs("div", {
                            className: "trades-win-loss__win",
                            children: [y.jsx("h5", {
                                children: "6.71%"
                            }), y.jsx(Kr, {})]
                        })]
                    })
                }), y.jsx("td", {
                    children: y.jsxs("div", {
                        children: [y.jsx("h5", {
                            children: "Trades"
                        }), y.jsx("h5", {
                            children: "114"
                        })]
                    })
                })]
            }), y.jsxs("tr", {
                children: [y.jsx("td", {
                    children: y.jsxs("div", {
                        children: [y.jsx("h5", {
                            children: "Average Loss"
                        }), y.jsxs("div", {
                            className: "trades-win-loss__loss",
                            children: [y.jsx("h5", {
                                children: "1.60%"
                            }), y.jsx(Kr, {})]
                        })]
                    })
                }), y.jsx("td", {
                    children: y.jsxs("div", {
                        children: [y.jsx("h5", {
                            children: "Trades"
                        }), y.jsx("h5", {
                            children: "259"
                        })]
                    })
                })]
            })]
        })
    })]
})
  , cY = ()=>{
    const e = +rs().pathname.slice(17);
    return y.jsxs("section", {
        children: [y.jsxs("h2", {
            style: {
                marginTop: "4px",
                fontSize: "25.5px",
                fontWeight: 900
            },
            children: ["Bot ", e, " Details"]
        }), y.jsxs(Hr, {
            gutter: [32, 32],
            style: {
                marginTop: "50px"
            },
            children: [y.jsx(Ot, {
                className: "gutter-row",
                xs: 24,
                lg: 12,
                xl: 12,
                xxl: 8,
                children: y.jsx(tY, {
                    pathId: e
                })
            }), y.jsx(Ot, {
                className: "gutter-row",
                xs: 24,
                lg: 12,
                xl: 12,
                xxl: 8,
                children: y.jsxs(Hr, {
                    gutter: [32, 32],
                    style: {
                        height: "calc(50% - 16px)"
                    },
                    children: [y.jsx(Ot, {
                        xs: 24,
                        children: y.jsx(iY, {})
                    }), y.jsx(Ot, {
                        xs: 24,
                        children: y.jsx(rY, {})
                    })]
                })
            }), y.jsx(Ot, {
                className: "gutter-row",
                xs: 24,
                lg: 24,
                xl: 24,
                xxl: 8,
                children: y.jsxs(Hr, {
                    gutter: [32, 32],
                    style: {
                        height: "calc(50% - 16px)"
                    },
                    children: [y.jsx(Ot, {
                        className: "gutter-row",
                        xs: 24,
                        xl: 12,
                        lg: 12,
                        xxl: 24,
                        children: y.jsx(oY, {
                            pathId: e
                        })
                    }), y.jsx(Ot, {
                        className: "gutter-row",
                        xs: 24,
                        xl: 12,
                        lg: 12,
                        xxl: 24,
                        children: y.jsx(lY, {})
                    })]
                })
            })]
        })]
    })
}
  , uY = ()=>{
    const e = zt.slice(100, 500)
      , t = zt.slice(0, 400).map(i=>i - 50)
      , n = [e, t, br(400), 22, ["ETH", "BTC"]];
    return y.jsxs("section", {
        className: "equity-curve",
        children: [y.jsx("h2", {
            children: "Equity Curve"
        }), y.jsx("div", {
            className: "equity-curve__container",
            children: y.jsx(PA, {
                dataChart: n
            })
        })]
    })
}
  , U7 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  , G7 = [{
    year: 2019,
    data: [{
        data: "+26.4%",
        color: "#03A66D4D"
    }, {
        data: "+2.81%",
        color: "#03A66D4D"
    }, {
        data: "+53.7%",
        color: "#03A66DB2"
    }, {
        data: "+52.4%",
        color: "#03A66DB2"
    }, {
        data: "+89.3%",
        color: "#03A66D"
    }, {
        data: "+23.5%",
        color: "#03A66D4D"
    }, {
        data: "+67.2%",
        color: "#03A66DCC"
    }, {
        data: "+56.2%",
        color: "#03A66DB2"
    }, {
        data: "+55.3%",
        color: "#03A66DB2"
    }, {
        data: "-24.6%",
        color: "#CF304A4D"
    }, {
        data: "+27.2%",
        color: "#03A66D4D"
    }, {
        data: "+25.2%",
        color: "#03A66D4D"
    }]
}, {
    year: 2020,
    data: [{
        data: "+22.3%",
        color: "#03A66D4D"
    }, {
        data: "-89.2%",
        color: "#CF304A"
    }, {
        data: "+34.5%",
        color: "#03A66D99"
    }, {
        data: "+21.2%",
        color: "#03A66D33"
    }, {
        data: "-22.1%",
        color: "#CF304A33"
    }, {
        data: "+45.2%",
        color: "#03A66D99"
    }, {
        data: "+46.7%",
        color: "#03A66D99"
    }, {
        data: "+22.1%",
        color: "#03A66D33"
    }, {
        data: "+23.9%",
        color: "#03A66D33"
    }, {
        data: "+22.6%",
        color: "#03A66D33"
    }, {
        data: "+86.5%",
        color: "#03A66D33"
    }, {
        data: "+85.1%",
        color: "#03A66D33"
    }]
}, {
    year: 2021,
    data: [{
        data: "+26.4%",
        color: "#03A66D4D"
    }, {
        data: "+36.4%",
        color: "#03A66D99"
    }, {
        data: "+27.2%",
        color: "#03A66D33"
    }, {
        data: "+22.4%",
        color: "#03A66D33"
    }, {
        data: "-18.2%",
        color: "#CF304AB2"
    }, {
        data: "+22.4%",
        color: "#03A66D4D"
    }, {
        data: "-6.41%",
        color: "#CF304A66"
    }, {
        data: "+22.3%",
        color: "#03A66D33"
    }, {
        data: "-5.32%",
        color: "#CF304A4D"
    }, {
        data: "+22.5%",
        color: "#03A66D33"
    }, {
        data: "+86.4%",
        color: "#03A66D"
    }, {
        data: "+81.2%",
        color: "#03A66D"
    }]
}, {
    year: 2022,
    data: [{
        data: "+82.3%",
        color: "#03A66D"
    }, {
        data: "+25.2%",
        color: "#03A66D66"
    }, {
        data: "+23.1%",
        color: "#03A66D66"
    }, {
        data: "+14.2%",
        color: "#03A66D33"
    }, {
        data: "-17.3%",
        color: "#CF304AB2"
    }, {
        data: "+28.1%",
        color: "#03A66D99"
    }, {
        data: "+22.3%",
        color: "#03A66D99"
    }, {
        data: "+9.1%",
        color: "#03A66D33"
    }, {
        data: "-19.9%",
        color: "#992A3F"
    }, {
        data: "+12.8%",
        color: "#03A66D33"
    }, {
        data: "+19.3%",
        color: "#03A66D4D"
    }, {
        data: "+18.2%",
        color: "#03A66D4D"
    }]
}]
  , hY = ()=>y.jsxs("section", {
    className: "profit-loss",
    children: [y.jsx("h2", {
        children: "Profit Loss"
    }), y.jsx("div", {
        className: "profit-loss__buttons-panel",
        children: y.jsx("div", {
            children: ["HeatMap", "Rolling Sharpe", "Rolling Sortino", "Rolling Volatility", "BETA"].map((e,t)=>y.jsx("button", {
                className: t === 0 ? "active" : "",
                children: e
            }, t))
        })
    }), y.jsx("div", {
        className: "profit-loss__main-content",
        children: y.jsx("div", {
            className: "profit-loss__wrapper-overflow",
            children: y.jsxs("div", {
                className: "profit-loss__wrapper",
                children: [y.jsxs("div", {
                    children: [G7.slice(0, 2).map((e,t)=>y.jsxs("div", {
                        className: "profit-loss__row row-1",
                        children: [y.jsx("span", {
                            children: e.year
                        }), e.data.map(({color: n, data: i})=>y.jsx("div", {
                            style: {
                                background: n
                            },
                            children: i
                        }))]
                    }, t)), y.jsx("div", {
                        className: "profit-loss__mounts",
                        children: U7.map((e,t)=>y.jsx("p", {
                            children: e
                        }, t))
                    })]
                }), y.jsxs("div", {
                    children: [G7.slice(2).map((e,t)=>y.jsxs("div", {
                        className: "profit-loss__row",
                        children: [y.jsx("span", {
                            children: e.year
                        }), e.data.map(({color: n, data: i})=>y.jsx("div", {
                            style: {
                                background: n
                            },
                            children: i
                        }))]
                    }, t)), y.jsx("div", {
                        className: "profit-loss__mounts",
                        children: U7.map((e,t)=>y.jsx("p", {
                            children: e
                        }, t))
                    })]
                })]
            })
        })
    })]
})
  , dY = ()=>y.jsxs("main", {
    children: [y.jsx(cY, {}), y.jsx(uY, {}), y.jsx(hY, {})]
})
  , TA = ({data: e, select: t})=>y.jsxs("li", {
    className: "create-strategy-item",
    children: [y.jsxs("div", {
        children: [y.jsx("img", {
            src: e.img,
            alt: "icon"
        }), y.jsxs("div", {
            children: [y.jsxs("h3", {
                children: [e.title, y.jsx("span", {
                    children: " v2"
                })]
            }), y.jsx("p", {
                children: e.text
            })]
        })]
    }), t ? y.jsx(Vn, {
        to: "/create-strategy",
        children: y.jsx("button", {
            children: "Change"
        })
    }) : y.jsx(Vn, {
        to: `/create-strategy/${e.id}`,
        children: y.jsx("button", {
            children: "SELECT"
        })
    })]
})
  , fY = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA5pSURBVHgBtVoLcJTVFf72nd1kH9k8yJuEYEIgQAihQDGKBJBabRUr06pV2+qonaGF2nerorWDjnaqMNWC1ekgUypSkJGHz4gCgoAhhAgBQsgCIQmbzT6yu9n333P/3X/331dIQnuZS+7577nnnnPP455770pwnWXDhg2Kbdu25XV1dc31+/1LZTLZ92w2W65EIknCZd/kcjkMBoPV7XZvz87O3pubm3u4ubm5B9dZJBhnWblypWrnzp13EPP3UV0SDAYzIWI4bpIRYKlU6tTpdJ8qlcrXVqxY8emaNWs8GEcZsyC0gloq33c6nU8GAoHSROYytQpo9UrkFqiRZVBCpZYBHOD1BOG0+zB41YNBsxc+ghPHkjb7SagXFy5cuG7jxo1+jKGMSZCqqqrb7Hb7C16vt4Yml0WFI6Ybbi7A7MYJqJiigy5biVSmxQrHcRh2BXH2pBUtn/ej/ZgFvSZ3HA5pp6WoqGjN0aNH38Moy6gEmTt37oTBwcHfm83mx9g8jElVhgxTG3Kw7J5y1C3Ih8A38RkmLIm1ozCPgCTc9qMW7N3SjbbDAwiFOGERguRLr2ZmZv7p+PHjZlyvIPPmzas5f/78JvKDhjBDEsyYl4tv3zsJdfPzwgwlEOMSCHMJfelwT7UM4p2NnTjXZhOGBrOysr40Go0/Pnbs2BmMVxC9Xr+YGH+Baj2DDbkq3HH/JDQtL0NGhgz/j8I08sHWS9i1uRtDNh//jczxOAnzSEdHx1fpxqXlpqSk5GaKRFuoeQOz6wmlmfjty3NQ35gPmVxCKynhVzNcORHMRf6mgkfqC8PM7ibX6jFjrhFn2+xwWH3MCgopsNxSWFh43GKxXBy1IDU1NbXkE6+TAJXMlKpnZGP18/UoKNMgrERBBKGkghPb3CjGxtosYMycn4vOr+2wUpQLhUI5Pp9ven19/T6TyTSIawlSWVmZT0JspYH1TIjKqXr8+uUGGHKUNIfIEsWezNpxvIn7hH5Jetw0dNUaOeYszOM1YzXzZlZMYX/2tGnTdl26dMmFkQQpKCh40eFw3E5CSEsqs3hN6LIV4FdTIposGnoi/yWGouhnKR9yU48VQlyKvggsV8gwpU5PEc0C91CAaYbtXZqBgYE9SCdIbW3tXVeuXGHOLdOSalc/PwsFJZo4xlJYQRLMmC/PbkJ9yWOozrsTZdk3Qy5VYdB9Lsz7aKxL1K+hTbZmthHHD1jgHQ7C4/HMrK6ubu/t7e1IEmT16tXqgwcPbqHVm8Dgux+ZjFk35onmEs8cD3MJvTX5d6M0+0a09ryJs+adsLo7UZn7LajlRlx1tifIkJ6uGNbqFZTOUIg+xodmOflLTV1d3ebu7m5fnCC02f2CErl7mV9UTTfgwV/WQDKOTEybUYwZRQ/g4IUXYRu+gEDQA5fPjH4SoK74QfTYjsIfdGE8pbgiExfPujDQ5wVF1ALK0y729/fzIVnK/qNELYP84gn+g1SC5Q9X8nbLbJvVUKSK4XR9OlUphjyXqfZE+1h1efupXkW2pnJMdEMiWKGSYtFdRfxfVijLfpbxHhVk06ZNiylO57N27RwjqmYawNHGFIpULlLFcLq+YMgHpVwX18cqOBkUsixeQ2OhyyXANbP1ZDE6XhDKNvK3b9++JCoICbFSUN+Se0qjqzKe2m8nH+BC5CPz4r6XGRvB8sxe+4nros9q4+0FUXMbHh5+hL5J5IsWLSo+ceLEAvaxkDa8KbMM4XAZKcIWlqok9jHYF3TjxOXNaJj4KAp1s2FxnYMuowQFuuk4atpAGvNHom34/3BOkH6OVGVagx7GPBWsAz4WwRYtXbq0UKZSqZbSJnM/Q2i4OR/T5+ZAnNpxkekEGHHRSpIS10n+0GdvhYpMSasuxrDPQsJtoejVxWMYNBWoLV6BLNUEDDjPRuiknwcp5rH0emA662QflHTqPCQnIW4T0GfOM5IdhkQEEtdpJDjWVsq10KqKEAh54fRcRZDzQU/RTK3QoyJnIQr0daR1P7z+obD/jGOeqQ0G7N9zlW9TtG2Sq9Xq5S6Xi05ycpTXZIk25pFWR+iPtWW04ZXn3oiynG/CqJkEi7MTbr+F/M8LuUzJm5ZGmYteWyuaO55B/cSHKLL1isw4Nd3kvjBcPEkNTZYcbmcAdNBbIKe8ysD2DoNRAZVKFt6AuDSrwcskhsO4ek0JGsofJmGUONO3Fy3ut5CrncxrQCnTwkMrbx7qoD2klbRg54fqyeS6Q4EwuTR008IEaLRyqjL+tEl+MlEqrAg7a7DcjQ936faKUEK8JzhPOwWLa56haHUKH7b/gRh1oGnqUyjPaYRKboA34IRKkUXauolPU4Sx7Zd3YGbpD5Cvm5aSbihh3kSe2D9DrpJvkyL0ckHGTJKQt1dxkioRGVYELjV+g1bYBrPjLDJVOVhww8/RYnoLnVebedwrtOrvHV9FAjj4MMyJrEUionu27wP4Ai7MnfQY3m/7XRhfUEzCvOl4YqYl3A1IWYNVRYY0nDMJkvOcx68Ag/O1NbhhwhKe1IzSFeixtuJc/ydRXMpO4fZZ6W8waaxAN1OZR2ZnRJd5Py4PHkVDxUO8/0i4CIsJ86bjSaEK886qVGR2URVGd1QuGW67tI2iznQ0Vj/Ba+eE6d9pceN270ifkkLyktqnqT7Dh+dW09vIUBjwrRlrcfusl1GRuzDt2KR5RH4T9RGfNxS1T05kq4mwx+cgU3iSN5shTz+F14G0uHE7cgQOBH3os52Cw91D5uQmn3Lig7an8Z8jj9P3kyg0TE87NnEef4RnVuSCjbFDi3hHH6k43L24aD6MyQVNox4jFH9gGAfOrEv+TjmYNzBE+VjGqGkOO4NRH+GdnQFsuw8FKQJIR0WDtGGGWpk9ZkHSFbJ0snNFxOGvTZOh2AfCl5GUzg/I6SJ5wGq15rpII06HH1k6dqxNvxEJbZvrMhRyNaUbZbA6TSPiJsMxXKaBqSW3I09XhQn6qTjVs5tMB9cc66GTosMe4NuUZp1h6/8O04iHNpbL59287cdidigFHG4zX+nq24/a0jvT4safKZLpsiPx7MoHUWCohcn8JbYdfhwtXf8a1dhL59y8j0Q00i7VaDR7BblPt9jDkYCDaIOKwRyHKMz6Tve8T845DVOKlqbERQo45sR0l1ywGOV58/DZqXU4c+VjSi4dcXRSjRX6O44PhfVDSqDLu+1Sul1vIYn4W+RTx+wR5Eg0iA4OxTEhwA53Hz79+q+oK1+BmWXLebULYxNx488UlGlX3o8pJbfho9Y/wxWJfOnmScXThVNuXgi6wR+iO+I26U033dRPNnaQfbRb/OhgWmHjQxDFbCSkDDH4ymA7Pjn5F8woX04piXZUY9lVQW3pd3Dw9GsUcs+Mah4x3fNfO2Hp8wv+sW/Pnj19cjrzBuhS7lU6aS1hwhz+yIIbZmojuhQ5GpfgeFzM8Ya91rDrRlaSdS6ofgz6zAIKtx4KChkUEC7h0Jk3o2ODXABur4239+R5RIEjBXz4Q3s0DGRkZKzn/YT919TU9KFCoRhg7a5TLrrZG4r4AxfnG1ycr8RMRRBSgCUSOapLmnht9QyeRPfVI6guXkway4oKCnAJ9LmEOVLD3R3D6GoP38LQgcrU2Nj4eVQQeh1y5+XlPUXNYMDP4dBeC//CFCMSSrDxeGFCPHNSfl/JyshDVeEttONb0HphB9pNu6juph3di7K8OdSfT8lmfpzgsRoaAQ7x+9xn7w6GnZ8KOfna9evXe3mhBBXRDeNmsrfH6WZieme7E8f2WTF/qTE6YdwdF6Mk+sDMx+uz47bZa6Lf2rp30t2TP4p74sJOzK16MNrvcPfT+T0QedhBynnEMGsfa3bQFhF+YqQA1TJ//vx/0rsJxMbHl1mzZi0mgXbRIJXWIMcPf1WGvCJl1DxHer2RSGWQidKCIL+aQVE/RRiJPLl/JLoi2Nzjw9vr6G7MwdMMTJo06Y59+/a9L6DF3f329fV1TZw4MZfOwPP8Xg5dJ12YPCMTGRpp7GwgxHTEt3nVU+rOajAUDIeYOFwu2ifuH4muADsGg3j3dTNsAwE+5JIb/O3QoUPrxbwnZVb5+fnPkRM1M1UOmv14940+eNxBnpE4n0jwEwEOJfhQatxYX2rc2Dzs0nrnP8y8RniGpdID5ALPJfKd9KxAl8LuBQsWfE7auZHAIsdgAKYzw6iYqoFSLY1G4UjcSYJjFsGNgCvGTIUbrkwD771hwZULXgH1K7KYBw4cOHDpmoKw0tnZaaMBHXTjzYTJGbIFYaKwV1JJNxdaaWxGJMwuhpEGHiXuYF8AO/4+QJoIb3y0PVwha/nRF198cQIpSto3RLqdv0gvqgepyR5Ci11D9Dbe6uJttHCiKuFBBsnJb6q+UeAGfBxa97vw8VYrnLaQcJT9ivzip0eOHNmPNGXEp1m6vOulZ6599HcW2WxRwAdp9+lhMjUPPcXJoTPKkWQTSAFzaeAE3O4OD/btsKHtgAss2LBC/rCf3jTvowjVghHKqF5AKioqJhDBP9rtdvaDAT6GsueH8qlqzL5Fi4lVqgRyo1FDDDad9qL1oAs953x0wx7uJy14KKF9taqqau2WLVsGcI0ypqecOXPmLKPnrrX0yFIn/omGsUCB0skqVE5Xo7BcCWXkdiNVYdHI4+Jw9bIfF057KN3w8CYk6g/Qop0ks/5Na2vrRxhlGfObFPtZ0yuvvPIT0s7PaFL2m5TIDhwmpVBKkKmTQUtmp6b9R64M/3aDpT4eN11YENMsnPuGk2lTSm7S6XTP0qa8lXzUiTGUcTyuxQR66aWXFlLzcbp7XUxa0sYRHuGnTeI2Me+gfWs31a2rVq3a/eijj47pV0FRmvgflFtvvbWQNFRHZ//vMrOjsD2ZPfDHTRRhnv7ayXS6lUplM/1tpjB/ZNmyZdbxCiCU/wL1OkmPykLeCwAAAABJRU5ErkJggg=="
  , pY = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA6TSURBVHgBvVoLUJvXlf706414CIFAvA3YBhJeNsQYO3b8qjP1utk2bdI27nh2ujvdeHeT8W6zO83ujjc7yTTtZNJMpmncuK/MpNMmdSd167hTp34kBmyCIRiDY+M3IBAChBBCSEKvnnvF/yMJiZfdHs81/7n/f+89373nnHvuuZLhHumtt95SHj58OM/r9TZMTk7u1Wq1X7fZbHKZTDbvW1anUCiQmpp6k9g/BgKB41u3bm1/++23J3CPJMMK6ZlnnlEfP378my6X6xuhUKiGhNKJwsYdKKZe5AmYXa1Wny0oKDj87LPPnn3yyScDWAEtG0h1dXWWw+H4xtTU1HPBYDAnVjBVqgrabC2SjElQ69WQa+RACPC5fPCOe+G2ujE9Oo3gTHAeOLlc3m00Gl9sbGw8duTIER+WQcsCUllZ+bjFYnmZZr+UhJCL9fpSPfI/l4+CHQVILUmFOlUNmTDXdYj+yWaHCgVD8Ix7MNI+gv6T/bC2WeG1eaXJoNX1p6Sk/MlkMj1//vz5niWKtjQgDQ0N2cPDwz+llfg8sVz/FRoFCnYVoPLpSqStSZvtTDZP8MX4UCAES4sFV45cga3LxoEyEgRhSqfTvbR///5XX3jhBf9iMi4KpK6ubn1fX9+v/X7/Wt6AQORty0Ptt2uhX63H/STzKTO63+iG87ZTrPKTY3g3KSnp25cvXx5ZqO2CQNLS0naR4O9RMTA+KTsJVc9UofRLpfhrUdAXRM+PenD9nevEhOuUSmVrWVnZF0+fPm1N1C4hENLRPR6P57cEQkt6C2OtEY2vNEJn0uFvQdZWKzr+vwOeUQ/nCUwTlSfu3LkTF4w8XmVtbe1DZA+/Jq+Uzvj8nfnY8voW7pGYfjM9ZuB4ieQx+/de+NlnXZ4O2ZuyMXJhBD6nDyRLEdnNxn379h29ePHizKJASktLs+x2+/szMzPMMyFncw42vLiBu1FJ+L9RUaWpkFmXidGLo/A7/SBvWWg2m1OKi4s/Ju/pSwiE7dJnzpx5x+12b2UgMqozsPn1zZCrw3uBWNggkXxk3ULvFmqf6B3biww1BgydGkLIHwJNcJ1Goxm2Wq0XEwLp7e390sTExP8QCEGVrsLm1zbzWREHEEssHwsi0TuJB+KvAuK3VxvU0OZoMdo6yty1QOHQhqqqqvcGBgYcouyKGJV6iYGTKWSo/NdKaEwappu4X7Q2qRSfN+xCijwZdz39+IPtT5j0O5fU1rTNBFuHDeYTZqZixrGxsf8jkP9Ekx6KAkKV/0J7RTlTqaz6LOQ9modg4P6ByFZl4T/yD0AtqDlfql2FDGU6Xu8/gmBoaeOU7C/B6IVRHupQjLdv/fr1h6m6nb0T2H8HDx7UO53OAwwEM+ryp8vD3uM+lofTNkgghrzD/G+lrgIGuX7Jfaj0Kqz66iq+KZOmqMle/ksEyYF88MEHX6HVyGLPOY/kQFek46vB1IqXQHD5fDCar02p5gNavaP4xcCv+LNCpuDqtpy+TbtM3F4YkT3v3b17dwEHQnGMglbjn0VkhY8XzjVcJoBH0jfjqZwvY5N+A2SkLeJ7jUyDTBXfkmD2DGHUY4M3GN4KSrTFyxpLppYhc1Mmb0vmoKXwaT+flNbW1nzyAtVsuXSFOiQXJ0fbBtv7QxHPiM8fLH0aGw31UrMGfR1euflD/i5Tk44keRKvv+68idrUSox6x5CvzUWZLrwiC/Udy+d9IQ/m982cJdmfIEDfFciFNRIIFas01BrmdtlI/RT5QHy+Lq06CgSjOn0NKnRr+bf56vxZGUIwTw9hXVoVPpu8xuvyNLlIlack7DueLIpUBbQFYfUiD1axa9euYmF8fPzv2GqwYtxsXJE9PGzYyDv1BX148bNXJDA7jFv4eyY4n72AF0qyi1yNCf3Tg7xOLhPwes3LeL7sIKpSHuCBYtyxAtG8vjocedOzamhoqFyRnJz8GAWHUOqUkpEvh5IUWjyQVs6fL030YHB6GBb3MHK0JpTqiiEPCSjRFfL3Fs8IuVwD0lV6jJGdiKSVa1Crr+JlhFTujPUcTlGxe+0Jx02pSIHlhIU/007fKFCiIIWthsqggqARor3NEsqWjEakKVN5hxdG2/DN4qfQZb/C+SxNJlYlFXJQjK47bqImrZJ7q2QhmQzeO0/ALHUmvlb4OBoNdQuOqy3SQiYPGw5pVYUgdsCALNWfy+nfFuNG7Mzaik3GDbz9tH+afLmADRl16BrvDusyCbzbtF0S8prjBoqSubfEKl0BeuzXpHenLR/D6gmfnTykgh1jXQvKIKgFKLQKbhKUuamQdnaFTrGoWulVqajPXI+nSr6CTLUB/qAfCkExK0gT6g3rwkstaDDpcyKNvt9h2iq1n5qZklZvTUoJX7m6jBrMkG1dm7iBnTmP8HdtY5/CPDW0oCwsJpGpaEVcYIGkQQIiqITouIq5vQiXt3/N17A7dxv06rnjrQiCUftoJ/679t8lIW8772JdRrX03jEzyQGKtCq5EMf6TvDnXlqpFGWy9O6k+fScLPHc8eyzqFpMfEH0WJLLC0S4vohnFg+JIOzeCbhIlUQado+gSJcvhSAPGetwJUJtGPVPmVFleEDi1XI1qZ6Sq2CT5QI2Zobd992pAVyxXYuWIxhfLgZKTClJNhLwBBY0ro/Mzdx9MrrhuIU/D5ydm8GBM9iW+7DEM7XrsV2NAnJprBtlqauj6pgzuE4qNel1Yq0+/K5p6Dy8fu+iTibgC/DzCSM6Ak9JQPwOf7SvjvHhdxx9+HBW+IeM63HZdoUDYzN6dbwXJSmrJAF5poU8lc07LtX12m+iKKUgCki+LhdHb/0eO2YngTmMM+am+HLE7Cd+N8nrlUzBLrBcLCOfw8dRso+5Ks0il1SLns+az8Ht93BBN2bVo9nSygFtyFovCRcIhTOem0wNaB5s5c8zgRmyzfnpgbykHA7woay68KqNdmPQOTQ3djCUUBb/hJ9nK3n/MzPXBIPBYGWCMSCsiB9GNmIzwPjLo59xwRntLtyBVks7jt06gc0kNCOLy4p26yX+XJNZiU+s/KjAg0Q2+yKdt7Txv2yF/rf+OUnPj985KY0VO3YUT8+uGy6e5GNt9Xp9s0D69Q7rhKFz3XaFG0QsY+SMMP79G8el42q5fg18fh+yk/gJgL87PxQWknm0JEHL1YWp5YMZYUOf8rnwm97f8VViBl+WvobXd49dRdtQR8JQiIGJlMt9yy0dhQnMFYFenBBnarJrMu5ZIpLvsvagZyxsyHuKd+NAzT/yZ9Zhq+UiPhpokmZ+nbEGtybuoINWabW+mNfdJv7SSDdebnsNZucgxj12et+FV9t/OM+goyYxkmdA+ty8P0p82ygT2aOgXfEaYyiKzJjsnoTJZ+IJ6NBsfjY068hF3h1w42jv71FmWA2tQoO85HBC/sSdD9E/EQ6tB50W5KXk0CqU4xNSP+vUCAwa/SyQPj67Z+6ew8f9LVDJlZj2uePmhmPHFmlmaAZ+m5+rFeW6Pm1ubrYrKNk1nJub205IHw26gnBediK5OjmczZDNdjirSmJfZ0kIDanF42u/AJ1Ki08tXfhR58/Cxkn/Llo6CMheKrlobruANHUqRblhY+8cviydP9j3TDUjN7nYseLxjmYpeQK6W/klV2X2H6VHX6NzyaPs2f6xHUnlSTxRxDdKzKVwRKNk/IkbJ/HHmx/y+Er0VOL3Tf2t+OLavVCSnWRoM1CUGna7gWCAVLObq4f4rdhfZN+xY0XyLFE33T0tqtXY9u3b37969Wp4Q3zsscf+rFKpuOK777rhuu7CYmcR0Sn4A/4onqlND3k3FlcxeqLs77G9MLxPMK9mm7bHPV/E6zse7/jQgZAvDI7M4sibb77JB+JA6NwepMz78wwwm6SxD8YQdEcbGfcawZiOE/AO9yQ+Gezggz1orMAqfRF/bum/wFVpnhEvsW9mG+5uychHS0pKXhNVTNqltm3b1k8nrUZqUMJshXWgKdXMpS+B6PTmIvwng+0oJgDZyVkUAczgXF8L3mj7CTwUfsxLlS6hb7aLTxydQMAR4GpGnuo7LS0tH4nyR10r0KVO+eDgYCeB0bB4P+OrGdCu1mKlpCSPVJRWQHuGD/2OAdwLOU854W4LrwbtfZd37tzZSPeMUuQaFTdQhnuMDD9ImYlHeI71phfqNWoIWmFF2XRy6WQT45hwO1ackWfF3eWGu8XNz/Pkbr0VFRVPvfvuuzcjZZ8XAOXn53dS42xK2NUxo/Le8UJVqIJMO+fBpMzGQvxyygJ9ea9QevSkKxy2kw2np6d/q6mp6Q+xcguxFXRX59q7d+9z5J9bGB+wBWB/zw6fxRc/RZSIX05J0JenywPXqTAInldQqV46cODArxCHEl690WUKW5WjPp9vC0esE5D8uWSo16rx1yZ2zvC2eXkRiS5Ff37o0KFvJfpBwYKXoZmZmTnklt+hzPdOsU5bo4V2i5anLhfMDsa+W+z9LB+0BuH5yIOAVdpkPWTc31u3bt2rR48enUICWvR6urGx0UCe7PsU8/8DdcojAbY66lo11HXqOMq5Mgq5KFxp98F/1S/aA9srHBSif6ezs/PHi7Vf8i8f6CLo38ibHWKXLLwhC9hSBCgfVEL5gJKDWwkFx4LwddFl5wDtXe655SN7+JTGPHDy5Mm2pfSzrJ9wNDQ05FMq/z8pe89i97l7asIgN1K2y0QlVw7BSBW0WOzmS0yCM+MF+/0C3TYHhum8bSH3PEDq444RSCbr0+l0b1D48WZHR8f0UmVb0a+D6uvrywjQIbo0/TKx6sigTwTG0ks8JBVmf9rBTqUEhMdJIUloqQmp0RDZwg9oH/vNuXPnlr17rvhnToz27Nljun379r7p6emvE5jVVNLmDSBLOISfhJ8kFeqkb35Bm9yJY8eOrfh3W/cEJJIoVjONjIzUklpsoqvjalKNEgp10smF8ysLEtpHxUruvJcMuI2E76JvLrFDEe4D/QXegSQw6eolaAAAAABJRU5ErkJggg=="
  , gY = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAz3SURBVHgBtVp5cFXVGf/ufXte9uVlhYQQSEKSQiORKItILKRo60jdwLGdqgzqNK3aP9pxpi1VZ9TqP2prRxw7U/9wQYqggjONhKhhC4SwRRJCQhayke295L2Xt97b37lvyduXQM/MN/ece8655/zOt5zvfOdydJPpvffeU+zbty+rt7d3jd1u3wxab7FYlnEcpwxsi3ckk8lmlUrlAPIn09LSvs7MzDzZ1NQ0RDeZOFpgamhoUB08ePBnmPhjoJ84nU4t+UzYb5AIZZ7njcnJyUcB7p8PP/zw0d27d1toASluIFjBJKRHjUbjnxwOx6LAySXJRUpREGWriFLlRGoZXopEFoFoxsHRmI1owsahzAUBA7fGAOqNjRs3vr1nzx47xZHiArJ8+fKtBoPhdavVWo7BZZ73OWqi9ekirUsTqSxRBACRON4FwG8klEWQCSAuznLUMs1Tm4GnAQvvNw64czYvL2/36dOnv6QYU0xA1qxZkz01NfXi+Pj402wctoIqjH1bikgP5gl0R6roN9mgfJS6MzM8fToip1aAEkQvh5ypqanvarXal9vb28fpZoHU1taW9/T0fAg9WC11wCC3Y+KPAEBtmki3MrUD0AfXFXTJ6OWQMzEx8VR6evoTZ86c6YrUNyKQlJSUezDx10HVrJwBO/QoANyfI5KGp/9LcmJt/jMmo09GFWRwuKYnimI7wOzs7OxsC9dPFq6ioKDgLliij5Fdhg9RgYbob+UC3ZmOTpwoSQY0wf2MVPbkA8uh27KlXZEoUE2yQB3gjB5gsJC5MCx35+bmtk9OTg7EDKS8vLwSOvE+ACxlolSZTLS7VJDACN5BXavlKZN7Yr5l/7ZcxLau8nxbZvluTxHoB4CZtKOvIGTYbLaq6urq5v7+/qmoQJYuXaoDiL3oWM1AMCv0KjiRpiCflfUnIY5ytLa+lIDZrUt3QmdkACPJcj7M/m0VFRVfDQ4OmiICycnJeWNmZuY+gOCLEoj+skygVPceHW5AiqMcrW0gKcCgSiwms2xGp8QZtnclTExMHA4LpLKy8oHh4WGm3DK2mf15uUB5msgDhSQxjjox+ve0MpFWJgl00iCTNlK4QCtLS0svjYyMdHrm7rU9zz//vAYVLzNwTLnZ/rBYI0p2PRZKra0nWXq2q0wR2lKUchjKV8FaZjk801VB6XfDA0gM4gg2uxfMZvMOphcrkjl6tkjambzKGpGwjRc//VeyG6bJNNAdW58F0GKNQL1zPN2wywgWNQd+2sDY2FiblyNw1NTQi99LLyCT2/MFyRQ6xdiIT0wlTeFy0hSVxtxnIaSA2a/PcMC1cGmXXq9/ic3dy5GBgYF6cGMny1fD7diW6yujXIDMcgF5jrQlFaTJX0KKlEwabf4irr7xts1WCtRtlsH55Jnia2GKW8GVKxJHsNk0eERsa7ZLbp2S3XfZfvYMLM/nYUIKy2jydDMp07Pgiaki9nUG9A393cC+/m3r0r26QnNzczuh0xy/adOmfJPJtJa9ZBaqIkmU3ARfRXMG5APrtYWlZOjpIOO1LkpYUhaxrzq3iJLKqoPqopV981WJTspQiJLfBwu2afPmzbk8zG0tYxEDUpEYedKh6hgllf6I9Fc7SN99iRKKyiL2zanbRkt2/C7sOM4Yx12Z5GQ+mCRe09PTd/DYKbd62LQqRfT7UCykSNOR6HSSzWymiQunKKm4MmL7lLJVpMrIJnlyetxj+VKl1uk9kEG/63iNRrONFdQyjooTRK88xkpaiNJ013kpb7jWSRpdHolyRci2ysxcmGqOej7bQwVbt8c9li8VqJ1wYUQJCA56a3n4VakMWQp2ciUfsEGRf1kGM1uy4zd+9YmFy2j6yiVvWw4gFKmZITe+1IrVNN7WQsPHG0m3ps6l1CHGibhpegwML5KWJ4+eFPJMzlhKV7q44RRdlsJJHja68yCbxUy6mruJT0hy13OUtfouGj5xxNvW0N9N2kUlrjLN92VlXc1GGgIIq3lW0qe0qjUhxwnuGzwnNtc0hSDpCcAwPriSVs5JDeZTcN5ps9NIazMt2vIg6a90kDoji5RJabT0F09SdvVa4sENAyxX5spaSllWSSOnjkplluQqDSUWFJNh8Jr0vSHU5W24l8bOnwozZrQyJx3uPHoi92TYrimIFDEptImSk1f000epX3mALFPjZDFM0ZXP/02dn71PTquVkgtLqPShp+hG05e07KGdlALR6/nyI5oCB4yjg94xxjvOUukjT5MyLQvGwkHqdB2lLS2n5OIyurDnNYolKXyBeF6y70cDYjUaqXP/v0hbUETjF9tInZZJUzC7c/r5c870tW4ofAENn/4Wq95MKrRZvHErFd+3gxxzZrrn75+DszaQhYxDfQCzi9LgGcwiP3b2GCXo8kmelEq2GT1FS77TlbtljKyCSx6jJSfM7NVDn1LJvdvJODIgTdavH1bXbpqVzPLc5BiZpyeo8/MPacvb++joi0+Qw2ohmVIprVpi3mKq2PEsNb6wXeqakJlN5QA2FwMIlmwCeXQEPqKbNSYnF+Q6B+60HrrR0U6pxaWkq6qhqd6uoLYTEKPMytXeMq/RsugbWWZnyA5uMM5azSaavHpZEikVxIu1W/bAr+jiJ3sokjvvO45Z4LyiJflarKBHXM/htQ6c2zL4lH3Ijg2w66uPSZ2JVTfOen0gT/2Ni2covbTKW86pXkcDxxqD2jHqaz5ERZu3EQdjoKu6nQYlDoce13dODpDB4TpOwZ2fkCOQPIEtPtME+TA6mPUKIYAsH2BArn37Nc4EbgMRUD96+TxVPd4gbX4i2uTfsYkuffpByLY9TYdo82sfkCjgrNH0FVlNxvDj+szJCgmadYddVSpVF4P0mbSp4OWghZt3A0gMyPu6LyIZpybphy8+Cm4LsoBLHERJpkmCaVFQRskKmuzrDtnWpJ+EKHZQ2f2PU3fjQf9xAsf16dtvk5HdDQQcuSRPSEj4GgeUZ9iLLiNHS7WiGzznsxiR7bt/W1d5ZuQ6afMWkQ2g9MMD0gYWrm33N19IQM2SknMxjXPF7DrcMiYgeLdfjuj62dHRUTO8yIROE0/1ouDTMfYU2HYU+0R68QpYKAX1tRzxM+2Bba+fa6Xr50/HNKCnSb9V7r1vQYz4Ar9hw4YxyNgx9tIAHekycTfllXpooO0EZVfdRovvrKPB9pPR+wixe969FhlNuRUdc28+fPjwKI8zrwNh/Hc9PtcZRMRvBZDp6/2kK6siTWoGGcZGbsk3PdRmnL8MU6vV77CnBKuuru6/CoViQmKZGW62mb8pF5sRovfSGWWs88JNf8uXBqwy6rO4TKtcLu9fv379dywvaUxbW5u9uLgYZyxjPUwmb4ZpK9EKQBkpQMAFBBCC26bkL6LOI4dpdnw0hsADF+a78+MyII16Dc06XWIF/f7jgQMHTnmBsIQ4URfk7edQ+mwWAVcjLpSjEmKIbohh6/rbjrtBhOvHhflO6KjKOZOSLs8ppPnC5J6FJDW0trY6/YDguGgrKSnpBlceYVxjEfBCjesOMPyqheNM4PtwddG+PV9m8/luRi15H0iOJUuWPLV3717v5Y9f7BdmuLewsDAToGrt6NA/x8CI0snRf3WiERdHXfTYlhEbX6NeLYkUs65ZWVn/OHHixDu+cw+6d9LpdK9AiZqYFWM3Ro2TMulG9lYqbDw0BxDfQC+mHDKPSLVABV4JmHbwtUJfX5957dq134E761DMY6H8YStP+WoRpzB39NxDFJCnMHWxtCUKiszPgAPNBg2N273r3QaJ+WVLS8tgVCAsXb16VY8OnbghYmAymIs/BDA5ONerZBSnmC2M9ABxxKCmaffGh+1hGNLy6+PHj58PNeewd4iIzg/gRvUYsuwiNJ+xuM/iap4hGQ7O5d2KgZF597tIdaHK7jzTzS6Lgk7NqsksyiSdALVBL56Fhfo+3HzDAmEJFmwE11zNeP4YOpOHcwDPxGwEAWR2+cLiSreSC8PwaNvMKuqGiXVbJ+aCfI87zceam5vPUoQUEQhLQ0NDU9h4DoM7CQiEMe7wTNSugTsTuKdgPw5oZYE3tdFMrH/bYbuc2uF2dFqUkl6wBC5YwIW3q6qqGvbv3x/1p5u4fuGoqampx63Wq9g8V/n+GJMsF0mHcH8+iAWXWUTG+2XRfySm0DaIqR6LMWKTA4QMlmneeILzDnDhIhbuD+fOnWukGFPcP9Ww35reeuutJw0Gw28xKPsnxRsAYEkOEGredSOr5F2WjiXm7NkgLkzXrAI7qgb/cQCXvD85OfklBNb3QkeN8cxrwb85MUBvvvnmRmSfgcjdAy4l+X04wq9NvnlMfgb71iHQ3ueee+7Qrl274voryPtNugVpy5YtueDQKpz972diB7Ndwi74/QZyTx5PA0SnD0eHJjybYOZb6+vrpxcKwJP+B68uQe0TxQRRAAAAAElFTkSuQmCC"
  , mY = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA3XSURBVHgBrVoJbFTHGf7f4V2v12uv7wMbY2xiCLbBQONyhCNBSQsUNc3VFEqqpE3rqkRpm1SNKtFITZVIVVpFakGhFYkatSElQjSQNGmDAhgo5QYbH2AMxo7va+31rtfefa/fzO57+956ba9Nxhq/97+Z+ef/Z/5r/lmB7rK89dZbcXv27Jnj8/kqh4aGtthstqf6+vokQRAm9GXfZFmmpKSkJoAfBwKBw2vXrj3/zjvvDNJdFoFmWXbu3Gk9fPjwMyMjI9tVVV0CouwasVEniviuwWBswGq1fp6fn7/n+eef//yJJ54I0CzKjBkpLy/PdLlc291u94uKouREEiYmWEl22lATSEq0khAnE6kqKT4/BdyjFOj3UMDlIdWvTGBOkqSajIyM36xcufLQ3r17x2kGZUaMlJaWfqujo+M1rH4RiJC075YcJ9kr8imxYi5Zsp0k2i1B1Ay7GjEbmAoMjZL3Rhd5Ltwh7/VOUgBri4Hd9Tscjk+ys7NfPn36dC3FWGJipLKyMquzs/Mv2ImvA+TyL1hkTnjK5nKy5DrN2NQIzFPBikrea+00+K9aGrvVS6oS5FwURbfdbn91x44db7zyyit+ultGli9fvqylpeU9v99/Dx8AJuzl+ZT66DLOwGxoj4S1TfNcbqXBD6+Qv3NI6+aHYdifkJDw86tXr3bTbBlJTk7eCMLfR01lsJSSQGlbK8ixqkif/MtkhEsedMf1UQ0NH63XG+Li4s6UlJR88+jRo100U0Ygo5tGR0c/ABM2yC3FF2VS1g/uJznFPiUh0YpKU69YNCZ9DZ3U/7ezpLi8GjPVqI/funUrKjNStI9Lly79CvThPVilFAbboQvZVeu5ReKzgLFgpSiwOkvYjEtOSyTbvTnkq4cx8I4RaCmA3nx127ZtB86dOzc2LSNFRUWZAwMDB8fGxphlooTFuZTx9CqYUWkaBijifabwRFzM+lkXZNLYjW5SveMEazm3ra3NUVhYeBzW02SeRSPAvDQ89F7UUsaEdV46ZXx/LYmwUNyaGOqXCU/VJmc5KHn7fSRYZW5o4L+qxsfHvzfljjQ2Nj4yODj4KwwQRYeVsn60jiS71eQKiCgmeKaKPxUu0RHPRW0MYgbmRCz0fWVlZe+3tra6tH76joRE6lXGnCAK5NyyhERYKZWvkMKrgneFr5QZNraH36PD7EkhWA3BU+HWYEtZLlnhdFmBiGX09vb+GkZImMAIPv4YvmIhF6mSbLKvKAhus6oEZTeEFFhZXxMcFotQm9Zu6qv1V/VvseA2wvaNJcQkhRXEeNuWLVu23MTICy+84BweHq4KemyJnJvLDARRcFcMBE6ANeLUUF8lPDbW9unnIq78CWuLua5gJ60wSL8wMXLkyJHHsBuZ7D2hPI/kTIcBiWJSQk0RFzhzTDAZ+saLcTQvKYPDke122UolKbk6btWIe5K5yNDXWpFHYmoCJx76vOWhhx7i8iYijpGxGz/UOLOvLuYrwGU6NDgMB99z7Cn05sZnNJHU27W+WxesoB2l63XY2L4iu4ieW7oxOu4oc0XiJlkiy6IsbW4bwqcdnJEzZ87kwQqUM0DOcJCc7eDKFd5axQAH37MSkmiOI5XywJCxXXuvzFnACdZgYzvbjYXpeSRBT6PhngzWcWEBrJUFXLxYBe2PM6UXYcJW4gOLu8lanBHyS6qhUsQ7gYk0ancP0LKcoijtKqXaEvmKy4j0I3FVzllAra4eyk1MjYo7FliArogZds2CLdq4cWOh2N/fv1njzro4N8S5aqhKxLtC85Mz6XDjWZqblD6hPdWaSP1eN51vv0nFKdkmXHYZBMCDfHLjEi3NKoyKO1ZYnpfGGYHYWdrb2xeKiYmJWzmX8JxyVuIkDJjhfCjyv5su0TwwJJFgai/LKKD/tjZQbXcLLefiFR5fkJxBX7j7qa6nhZZkz4tpruiLqZKU79SdZnx8/EoRiQIH2w3mPYnFUyGHpQ2KhOMEkSQ4zDZXL/kDCiXK8Xo7e64rWEy1nS1U3VJLK3KLTeOLnNl0oe0G3RnopWK8TzeXESYdDraJWRAtMegPIVWLdIcoMUZM8qzqsGKAHZZ4MBCgYZ+X+jxDVOjMMlmYxVlzqbGnjTqHBijTnsxFSQmN3Th/CZ1uaSDX6Ah5xn2UZkuaci4jrBpgrixYdDEUfyFzE2ZEsMWZtjOaLbdJFq6kPv84fIVMrYM9tCAthxLwndV0m4M8Y6OceCt8CdOV1HgHb5MhhGkJDs4Eg//Xdp1Wz12oj7WFKnu3ivKEuSPpglhwU8wKHGOqkJqayuO0+LI5ZP9GKU1WUmCJ/rS1iuq671AKCCpMyaKarts0jt1ZmlNItjgLVd+uJQFmdU3hYj7ms6YrZJFkWgv4sxuXaRkslj/gp0xHMh29eZUWZeTzXZOl4Hq2DHRTktVOtcD7+vEPaLri23eOJy4sFku3kJaWxhmxlOaQffPi0PZQOAwVQkAIfva+h6nD1U8fN57jRO57/Ke0ff/veNtvv/Y0fVBzki7BYrH+DxQtIScW4GDtKarILaK180vpzVP/5BNYRIneffIlevK913Tcy+cU07aKDfSzI38O08H+qWpUWnxvnydyj7HTY3f4PDLmD9trg0dWDfEOa8uHyW2DH2Cwz+8n7/gYpScEZZ3pS1NPR6g/UVNfO60uuJe3PVBUTqdv1+mKzMSzZbCLki0JOu5HFq+i/VdOGOigkBM00BXCzfNiSpAjMOLWGVE840HZU82mzwgzq5FksUE3enW4rvM2lcGUshjKrwTIBb3QiO2GwhekZHJ4CZxnc1+HCXdTTzsVpQVjtuxEJ5VkzKHzrY0mK2WcO0yLElz4cUUjf0BmuVgEjKSO+OAm0TFk0rTtUw0ZBgmybJHjqM/tCu4w2q513aF7M/OZhwURN8JigIdnzAeUAXLGJ3BR6hl2hQUc7XUYu7awlM63XKd1ELuDNadBS0DHbeyrGsWd8TWCY7s/mF2FsjeIUPYunuEbwZnY7QuLE3uSaoLzIFYu74hJ9I43XQUR5bQSFoj5CH3FQ2PrOu+gvYy6hgfMooq/BrSVYjdlMFmZX0L7L35uFmsjLUaY/bUPQXuCEYnT6TwpQr7e5UyOByjAEmN6yGwMsYPwnOR06kaMpQdzaPP4Rnn/lfPupSttN/Wxmtmsbr5Kz8BAnGiunYC7xz0IK2Wj1fMWcb/E/JMRtyloNcDsqbQP68yBmWsiYpWPtB0MNPeZQmbtiKoNYHLMLJYxvGa1vrOVhkc9NOAZJlMojnq5rZmvej1WPxI3I/zM7QZ6+cFv0+GaM6a5lIi5jbCCcdQ9wmlG4rsPmchaEV6xgQHso7+5n+uJIdQ01UQoel1Hy4TvTOFPshWPMqZrqB8hSTfd7P0iavtZMNIDnTvbUj/pvJFV7UXSbtjHxQq5rosnT54c4CqVm5v7CVIsD3N/8vA9JM1Po5kUB8SDIR3CrkQrOUmp1AGGohVZFCkb7W2whDGXk3dg24P4kOh+ur6+/q/c/CI9+getj7+mk9vomYTUQzAALo+bJote20PmOlr7OCxPa393zHOpsFbq7QFOKySpd8OGDQfZO2dk69at/4Gbr2fvSscwKa2DsSGdElZmCU+Nmy52kOAP2mGoxd7du3e7OVPs37Fjx1RcfbV5PJ7HWHJO7RshsTiNhwQCGxMST/acCtbeI2HV8F2Yon1a3P0ISM93hHya1IMM/XevX7/u0RlhZf369Xdw0loJyzCfRv3cxIm5SbpYMjyxZgtnWmLCDSMkVbfCy45zfYSl+uWpU6eOaX30EOXAgQNe6MpOWAF+D6Y09JLS5gqHBBHbPB08UUQmb48Ft3AF9zz9wSsGRCNX16xZs8+4GKbcLzLcvWBGQWZiHcuxEpwO3DmyEhLpGXNSDcuk7X00WDWFK6bx0XBNhputdrOLpLpe3gcL7Vu0aNF39u/f3zQpI6zk5eVdgtPJQvy1nG2n0AldYhkLnMbMRJFh0ihPmqbd+Ix8N8BSyxBJFzqDnh1GNSUl5bnq6uoPI2YxXyuwgru6kS1btryIu+9T/MMQgsnjt/m2Thn/xBIfTQZPMlZsHiTxUhdngukFLOurVVVVf6coZdIbMVymsF05AEd5P/9gw/FzGUJuJmoT1JFCpmUSdBPaoow3tAmIQKTr/SQ3hJ0oLkX37dq167nJflAw5WVoenp6Di5E30Xm+0F9mvnILpYjkRcnzfryMxI2vgsDoxRX00figH73PorA9vWKioo3YJDcNEmRaIoCv+JeuHDhETzTcN4oZz5GGIQth9zys0tKfJiSu6yC109x17ALtWDCG7xWh69wQSdeqqurewN1bCpaY/7lAy6CfgJrtotdsvCB7AwDcVMKkkmZh6NuvBz9hw7TwILLR3IzFLrHS8JYWGqgDxcxZ9Wnn356lmIoM/oJR2VlZR5S+S8he/8sQHsYC5hyxpOaimu6VBsFnLiMiRNJlYSgbnDPjH8BlRMr9vtIgpeWej0k+BQzQYLQgkDwjwg/dl+4cMETK22z+nXQihUrSsDQLq/X+yhAa+hwE+7Ajss87ySaMiECY4QfE3Si9SEQo3bowu/hx/5x4sSJVpphmRUjWtm0aVN2c3PzNujQU2CmGDV5wgTCpFP4QfwQROgS+rwNJ/fRoUOHZv27rbtixFgQq2V3d3cvhVis6urqKodozGc/OIAJ51cWIHoctQvmvBFn7LMg/gr6XGaHIvoSyv8ByFYie5GatSIAAAAASUVORK5CYII="
  , vY = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA19SURBVHgBrVoLcFTVGf7uvbt795Xs5h0kEEOICZBEQggxIBAUnYoMo0Vtq5Zp1drCAMPUR+1okVpbGTvYTqcDkqrQ6dCCUEVBWmRUJMCgAkHkGR4hJCQkhGw22Wdy997+9+7efW+yG3pmTnL+e17/f/7n+c8yuMWyceNG7YYNG8Z6vd7a/v7+hfRppsvlKmAYRhc9lr6B47g+rVZ7xmg0HvX5fLvmzJlzdPPmzX24xcJglGXFihX8rl27nnI6nU9KknQnIWVSkY27UdR3FdZoNDae578YN27chpUrV37x2GOP+TCKkjIhlZWVuXa7/UmHw/G8KIpjohFjNWnQ6DOh47PBai1gWT9jRJ8bvsE+CN4bEAZvQhKHYogjbn2Xk5Pzu7q6up0NDQ1DSKGkREh5efn3Ozs736DTLyYkOPU7bypEWu5sqrOgM40HR8QgAWcgSRCGbHDbvsPAjS/p/wki0OZHhuYQd4W0tLT/5ufn//rw4cOnkGRJipDa2tq869evv0OceIBATt6QYXkF+ewJT4I3F0UtJ0UtnRiWJB9cvd+gt2ULvANnCRaV7yzLOkwm0+tLlixZt2bNGgG3Skh1dfW01tbWfwmCcIcygYgwZ89ETsmzRMDtgSWkOEtKUe2R+503DuJmyyYMua6qg4X09PStZBieO3nyZDdGS4jFYplPiG+jminDGn0OceApWG77Hm3NRKElf2GCCEbyINQbD5bCkJF1x3bl77C3bw/2kJU7Ulpa+tBnn33WhVQJIRld4PF4dhARBpJbGK3lyC//DbT6XFnM/ZMDs+PB4SqSCqyu5ek7jp7mdaQ/N1ViGqk+2tLSEpcYNt7HqVOn1pBCv0NNhQhz7hyMrVoHDZ8jK6N/N6pSoEbAYqAtpghHraW3ViGv/A2SAr9hHBoamk047Vi2bJk5Hs5c9Ifi4uJcm832weDgoGyZYMqqRf7kl0i59ZGiLiEWxihhKT7MatOht9wJr70Jks8BImR8e3t7WlFR0ZdkPSPMcwRHZC9NHrqBarlMBJ8+mU5lDRFhhEinJCJ0ivFgta3ACJ3ySP3Dra0xFCKz5FdgOKNiaMh/LSXu/ATDceT8+fMP9/X1vUwTWFZrxW2VvyefkB5SxsBJJYLVhhTWp/YzI/UPszarzSQRy4fXdpQgH0sHPaOiomJbW1ubPYYjAZF6HYqf0CCz6GmwulzFrqtVDGsn+iaG/RcTwAxhyWkQM364tQ0Zs6DPrldwJRHL6enpeZU4xsQQQh+Xka8ok9mnz5gGU+78CAWUohRSFYnwPjFK8ZFgbl2VCY8vzEhq7XDYPPaHxJ0MBV+K8Z6YNm1adQQhq1atsg4MDCxVPXZG4U8VS++39wF5HQaW4vRHjw3vn1uThsoyY1Jrh8OsxgpT/mJFVyjO48kgvRhByO7dux8hbuTKbWPWbHCG8X6lC9SggqYAR/eFfyu5nceYHO2o1uaz6sHy+QrypM8L77///nEKIRTHaIgbP1cpM49ZlNhHJIClFGC9jlEQarvuRUGeNuW9wOjBW2pVdTBQ+LREIeTIkSMFZAUqZUBjHAetsShi42QqUvhfNI7HhVYPjp9yoLrCOKo9+JwHFfGSK+H+qKz0LJmwOvU2p0+vTKh4ycCrVxSgpsKU0AjI7aICHQ4f78e5y25MnmhMeq/wtViO7jl8gWrBJs2fP7+I7e3tfVCljicTpzijCJMpIWQOpYSwgWdwV5UZ9XXpEXOj15pOhJ4858S5Sy4Uj+fD+qWk95LnaMwVCiGk9LqOjo4yCvvZGplS2XPKXtQ/MfwUxKh2fHj+LAv2HuhD1RRzgrmS4j9Kbjfg+g0v7ANDcLh8MOiZEdeOB2uMZapaQ6/X1zEZGRleWbQ4/VhkTfkLRioNf7gDY/Mi8wq9fQKGBAlHTvRjVnU6LpEO1E5Ni5l7pKmfdEQPPc9Cp2Hw9UkHXG4fHqhXbgmw2QUcPdmPP2/uGAkNSBQVOy79kho++d7/b42qH5w2yy+bI5Tlr16I+ZZl1eCV5YV4d1sn7P0Cya2EtW9fjRlXNdmEe+oysO7ddgVeQATwOhYP/+K0AmdatXjhZwXQaUmJB8Vh8ZA4PemKgehwwmAwTAp6doYzIxnr4fH6Yuqi+VkkVr3EFRH7DvVi9oz0uOOqK9JI0e1B+OIVFyaXGIJw/QwLviGOyO0RrRjo/AOJDXKMmZogIazWfzeId21TYWpPKjYizaxRPshdNrsP82qtWLuxFTMqzXSSErIsWpQU6pFh0QRGSXCSPtTIhByzo6YyTfmm4VhF1MaP4enixOCBuRl4829XI/EI2zsSZukTp6LJatSUjBoQQIqiJAw28hyefnQMBDEUprZcc+Nyu5uQyILZxNEFSMIFOul5dVZC0hDcu6XNA5ORQ/kdRkyaaFLmX+vyQEvE1NyZRs5Rh86eQVjTuAAeUacoRVGiWGgplB8Ldvk88KuISoB6/wx4VCpWCwctyfTzvz2veGe5f83KImzb1YWj3/UH76tzaiwoLTbhxbUXg2sVFhgwkbi0aUdn2NpytoRBd48XU0pMeO/9azjd7AxIQuTeIZoCcyU5seJPrtAV2BGKfn0DxNKAiRMDZk6MNHntnR7ctA1i1nSLAmdnaFBeasKxU/0hE0lzvj07gPtmZUasVV5ixFcn+mLWbm5xKgZAtoSnmh3JmV95rughJ+JV0bcxlNmzkVOxcnweTBPepCPigtxDFHfl8swPxqJ0ggmXrrpIxhnkZetiMob9DoGcowWbtneQGbYoJjaXxp0mRAvHGiLGtpBYPvdMIT5tJHPq9NEhOLB9z/XYvaMla6gTvmtrFIDM7xYNma5LlHSuFgU75MoE4v3wSeFlz/4bmFJqRgfJ9z0zMxWx6huIzJ8JZH4HXALG5Oqw5aNOOImQt16+A39saEG6WRsxtq9/CA/dl0Omu53m+Q9BCr9KJsBD8jQHpJOB1Wo9qKE/X8iEyGwSPJfplKdhuCKL157Pu3HvrGxoyakdOmaLO85LJvSV5RPw9pY2Ql4DgUxzWweJAzwxYxcva4LHM7IPiyTkQtDvkUScZkmsPlE7fQNNSCY0+bSxB8WFBvxnf09CeW5pc+G2PJ7Yzigm9uwlZ8LQxe32JR2aBOHBKwrOlPi+SZnIU7JonZMBiiKzfA4iJMen2GiomYEIQfXDPhqy6rUzihcPRQPRJyrixBm7EltVkCg2ftMbFTmIcddODIeVoTYwwg3FelGsePzgwYM2jiJHB6VG7yHOTCQywfDjSE/yw5mIWGGVFNmWPXBkvxQBDw6SAyWzWleVgQ/3dimBYvzxSAIOrc3YdxEh/jCHGPEaJSK+VcwvpUf/pE719e0j0yaEsRJR7ZHgkMhcaHVgbm2mYrE6uj0x/amvLbsPygB5mhRcSZJ65s2b94HcVghZtGjRPp1Od1ZhuPciRM+ZpHQlPhxC9Fqnm3yNjhRfJO74MNorQjjMDHxMOS+vyo2G9evXOxSi5D/79++X6OmrnazXI7LYSd42urzfhTgZ1ZTLxEIT2sjSHTrai1stjHAN3MCHkPWLuHGDMvQ/bm5udiEc0/r6+qukL3WkKxMgOvx81JfFPn9ErBzVF2ds02k7Tl8YIGcnpDY/uo/0l7NvBuOzKQ6YLNVLhw4d2q92B0OU7du3u0lXVpAVUAy95PgSkvt0IBerZv3Ue3MAFhPD6lhZwTu73Yi8d6uhRiycaG3WsQfsUKuCK3nyk3ffffd74WcSITuU4e4hYkTKTMwlrWIZL+kKX07kmpGchcEo4eHX5jxfQePeR0wSZXPrnTRp0uNbt269iESEyKWgoKCJTiKPEnbVFNCAGTwPSTsxQMxwiCT6lkp/LMx5j0Pn3EEKroimQFfzZxsbGz+OmhD70ENvdc6FCxc+T2/fh2SYEbrB2hoUJxQyh2JccxvZjziWabj+WJjzHIHWuVMJ2WW9IMv6+tKlS/+JOCXh0xs9pshc2S6/FPlJTocvfTFEvhLqtSX4XBYNSyM8tSHxBVBpkyToPJ9DS1Ut9Cj63urVq59N9IOCYR9Ds7Ozx5DX/wdlvu9Vv4mGOgimhXRhMyT7Ah0fWyBumM752qB3fQTW5/fcxAkPXZzWVlVVrSOD5ECCMqyjIL/iKCsr203/sygWq1QegCg00HjlBxcBIifnj9kgRyJwk6LwHq6f2qzYD96zh+puavt/mkK+wk468cKZM2fWUR3EMCXpXz7QQ9Bysmar5UcWZaL8KwXWCkFfC0FXA5FJjytaQSKY2NuqXFixE7y3ERrhAomUM7gf6cNx2nPp3r17v0YSJaWfcNTW1hZQKv8Fyt4/TaAp1MNC1BRQHQ+fpgg+jvKyJHoStGFb+KhFQankIvFpBSdcgU6gyxEipYUOqNVkMv2Vwo/1x44dcyWJ2uh+HTR9+vRSImi12+1eTCAfns1QCZPowUjOPYV+siITMhSIk4IXouAMEqMO0oW3yI+9f+DAgTakWEZFiFoWLFiQf/ny5SdIh35ExEykaonZgEm4hUDI95MINdGYTeTkPtm5c+eof7d1S4SEF4rV8ru7u6eSWMzs6uqqJNGYQHFbBplwf0qW44aodpE5P0/X668J+W9pzAn5UoT/Q/kfYur7Mgb64KMAAAAASUVORK5CYII="
  , jA = [{
    id: 1,
    title: "Bollinger Bands",
    text: "This strategy is based on the popular Bollinger Bands indicator. It buys the when current price is below the lower band and sells when it is above the upper band.",
    img: pY
}, {
    id: 2,
    title: "Multi-Level RSI",
    text: "This strategy aims to buy an asset when it dips below defined RSI levels, dollar cost averaging by buying more if the price drops further. It sells when the profit target or stop loss level is reached.",
    img: vY
}, {
    id: 3,
    title: "MACD",
    text: "This is a MACD indicator based trading strategy. A buy signal occurs when the MACD line crosses above the signal line, and sell signal when MACD line crosses below the signal line.",
    img: gY
}, {
    id: 4,
    title: "Mean Reversion",
    text: "This is a simple RSI based strategy which buys an asset if the price is below the “oversold” RSI level, and sells when the price is above the “overbought” level.",
    img: mY
}, {
    id: 5,
    title: "Accumulator",
    text: "Use this bot to “accumulate” or buy a certain amount of desired asset over time. This strategy is useful in achieving an average price (DCA) when uncertainty about future price exists or a large quantity needs to be purchased.",
    img: fY
}]
  , yY = ()=>y.jsxs("section", {
    className: "create-strategy",
    children: [y.jsxs("div", {
        children: [y.jsx("h2", {
            children: "Create Strategy"
        }), y.jsx(Vn, {
            to: "/ai-trading-bots",
            children: y.jsx("button", {
                children: "Back"
            })
        })]
    }), y.jsx("ul", {
        children: jA.map(e=>y.jsx(TA, {
            data: e
        }, e.id))
    })]
})
  , xY = ()=>y.jsx("main", {
    children: y.jsx(yY, {})
})
  , $i = ({valueDefault: e, labelName: t, conAfret: n, conArrow: i, iconSvg: r})=>{
    const s = n ? "con-afret" : ""
      , o = i ? "con-arrow" : "";
    return y.jsx("div", {
        className: `input-text-custom ${s} ${o}`,
        children: y.jsx("form", {
            children: y.jsxs("div", {
                className: "group",
                children: [y.jsx("input", {
                    value: e,
                    type: "text",
                    required: !0
                }), r && y.jsx(tn, {
                    name: "btc",
                    className: "svg-16px"
                }), y.jsx("span", {
                    className: "highlight"
                }), y.jsx("span", {
                    className: "bar"
                }), y.jsxs("label", {
                    children: [" ", t]
                })]
            })
        })
    })
}
  , X7 = ({valueDefault: e, labelName: t})=>{
    const n = Number(e)
      , [i,r] = Ce.useState(n);
    return y.jsxs("div", {
        className: "slider-custom",
        children: [y.jsx("div", {
            className: "input-text-custom",
            children: y.jsx("form", {
                children: y.jsxs("div", {
                    className: "group",
                    children: [y.jsx("input", {
                        value: i,
                        type: "text",
                        required: !0
                    }), y.jsx("span", {
                        className: "highlight"
                    }), y.jsx("span", {
                        className: "bar"
                    }), y.jsx("label", {
                        children: t
                    })]
                })
            })
        }), y.jsx("div", {
            children: y.jsx(Ma, {
                theme: {
                    components: {
                        Slider: {
                            railSize: 1,
                            handleSize: 8,
                            trackBg: "#2B7AFF",
                            railBg: "rgba(166, 178, 205, 0.80)",
                            railHoverBg: "rgba(166, 178, 205, 0.80)"
                        }
                    }
                },
                children: y.jsx(KN, {
                    onChange: s=>r(s),
                    value: i
                })
            })
        })]
    })
}
  , bY = ()=>y.jsxs("section", {
    className: "form-strategy",
    children: [y.jsxs("div", {
        className: "general-settings",
        children: [y.jsx("h2", {
            children: "General Settings"
        }), y.jsxs("div", {
            className: "general-settings__wrapper-1",
            children: [y.jsxs("div", {
                className: "general-settings__wrapper-2",
                children: [y.jsx($i, {
                    valueDefault: "Bot 4",
                    labelName: "Bot Name"
                }), y.jsx($i, {
                    valueDefault: "     Bitcoin",
                    labelName: "Exchange",
                    conArrow: !0,
                    iconSvg: !0
                }), y.jsx($i, {
                    valueDefault: " ",
                    labelName: "Starting Capital",
                    conAfret: !0
                }), y.jsx($i, {
                    valueDefault: "BTC/USDT",
                    labelName: "Market"
                })]
            }), y.jsx("button", {
                className: "form-strategy__btn",
                children: "CONNECT ACCOUNT"
            })]
        })]
    }), y.jsxs("div", {
        className: "strategy-settings",
        children: [y.jsx("h2", {
            children: "Strategy Settings"
        }), y.jsxs("div", {
            className: "strategy-settings__wrapper-1",
            children: [y.jsxs("div", {
                className: "strategy-settings__wrapper-2",
                children: [y.jsx($i, {
                    valueDefault: "5 Minute",
                    labelName: "Candle Timeframe"
                }), y.jsx($i, {
                    valueDefault: "20",
                    labelName: "Moving Average Period"
                }), y.jsx($i, {
                    valueDefault: "1. Profit Target or Stop Loss",
                    labelName: "Exit Condition",
                    conArrow: !0
                }), y.jsx($i, {
                    valueDefault: "0",
                    labelName: "Cooldown Period"
                }), y.jsx($i, {
                    valueDefault: "1",
                    labelName: "Band Std Dev Multiplier"
                })]
            }), y.jsx("button", {
                className: "form-strategy__btn",
                children: "SMART SUGGEST"
            })]
        })]
    }), y.jsxs("div", {
        className: "profit",
        children: [y.jsx("h2", {
            children: "Profit & Risk Management"
        }), y.jsxs("div", {
            className: "profit__wrapper",
            children: [y.jsx("div", {
                children: y.jsx(X7, {
                    valueDefault: "2",
                    labelName: "Profit Target"
                })
            }), y.jsx("div", {
                children: y.jsx(X7, {
                    valueDefault: "100",
                    labelName: "Stop Loss"
                })
            })]
        })]
    }), y.jsxs("div", {
        children: [y.jsx("button", {
            children: "CANCEL"
        }), y.jsx(Vn, {
            to: "/ai-trading-bots/1",
            className: "form-strategy__btn",
            style: {
                marginLeft: "20px"
            },
            children: "ACTIVATE"
        })]
    })]
})
  , wY = ()=>y.jsxs("article", {
    className: "how-work",
    children: [y.jsx("h2", {
        children: "How does it work?"
    }), y.jsx("p", {
        children: "This strategy is based on the popular Bollinger Bands indicator. It buys when the price is below the lower band and sells when the defined exit condition is met."
    }), y.jsx("a", {
        href: "http://www.extej.com/",
        children: "Learn More"
    })]
});
var OA = {
    exports: {}
}
  , SY = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
  , CY = SY
  , kY = CY;
function LA() {}
function RA() {}
RA.resetWarningCache = LA;
var AY = function() {
    function e(i, r, s, o, a, l) {
        if (l !== kY) {
            var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw c.name = "Invariant Violation",
            c
        }
    }
    e.isRequired = e;
    function t() {
        return e
    }
    var n = {
        array: e,
        bigint: e,
        bool: e,
        func: e,
        number: e,
        object: e,
        string: e,
        symbol: e,
        any: e,
        arrayOf: t,
        element: e,
        elementType: e,
        instanceOf: t,
        node: e,
        objectOf: t,
        oneOf: t,
        oneOfType: t,
        shape: t,
        exact: t,
        checkPropTypes: RA,
        resetWarningCache: LA
    };
    return n.PropTypes = n,
    n
};
OA.exports = AY();
var MY = OA.exports;
const qt = Jr(MY);
var EY = function e(t, n) {
    if (t === n)
        return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
        if (t.constructor !== n.constructor)
            return !1;
        var i, r, s;
        if (Array.isArray(t)) {
            if (i = t.length,
            i != n.length)
                return !1;
            for (r = i; r-- !== 0; )
                if (!e(t[r], n[r]))
                    return !1;
            return !0
        }
        if (t.constructor === RegExp)
            return t.source === n.source && t.flags === n.flags;
        if (t.valueOf !== Object.prototype.valueOf)
            return t.valueOf() === n.valueOf();
        if (t.toString !== Object.prototype.toString)
            return t.toString() === n.toString();
        if (s = Object.keys(t),
        i = s.length,
        i !== Object.keys(n).length)
            return !1;
        for (r = i; r-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(n, s[r]))
                return !1;
        for (r = i; r-- !== 0; ) {
            var o = s[r];
            if (!e(t[o], n[o]))
                return !1
        }
        return !0
    }
    return t !== t && n !== n
};
const PY = Jr(EY);
var Zg = {
    exports: {}
}, _A;
/**
* @link https://github.com/gajus/sister for the canonical source repository
* @license https://github.com/gajus/sister/blob/master/LICENSE BSD 3-Clause
*/
_A = function() {
    var e = {}
      , t = {};
    return e.on = function(n, i) {
        var r = {
            name: n,
            handler: i
        };
        return t[n] = t[n] || [],
        t[n].unshift(r),
        r
    }
    ,
    e.off = function(n) {
        var i = t[n.name].indexOf(n);
        i !== -1 && t[n.name].splice(i, 1)
    }
    ,
    e.trigger = function(n, i) {
        var r = t[n], s;
        if (r)
            for (s = r.length; s--; )
                r[s].handler(i)
    }
    ,
    e
}
;
var TY = _A
  , Jg = {
    exports: {}
}
  , jY = function(t, n, i) {
    var r = document.head || document.getElementsByTagName("head")[0]
      , s = document.createElement("script");
    typeof n == "function" && (i = n,
    n = {}),
    n = n || {},
    i = i || function() {}
    ,
    s.type = n.type || "text/javascript",
    s.charset = n.charset || "utf8",
    s.async = "async"in n ? !!n.async : !0,
    s.src = t,
    n.attrs && OY(s, n.attrs),
    n.text && (s.text = "" + n.text);
    var o = "onload"in s ? Y7 : LY;
    o(s, i),
    s.onload || Y7(s, i),
    r.appendChild(s)
};
function OY(e, t) {
    for (var n in t)
        e.setAttribute(n, t[n])
}
function Y7(e, t) {
    e.onload = function() {
        this.onerror = this.onload = null,
        t(null, e)
    }
    ,
    e.onerror = function() {
        this.onerror = this.onload = null,
        t(new Error("Failed to load " + this.src), e)
    }
}
function LY(e, t) {
    e.onreadystatechange = function() {
        this.readyState != "complete" && this.readyState != "loaded" || (this.onreadystatechange = null,
        t(null, e))
    }
}
(function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = jY
      , i = r(n);
    function r(s) {
        return s && s.__esModule ? s : {
            default: s
        }
    }
    t.default = function(s) {
        var o = new Promise(function(a) {
            if (window.YT && window.YT.Player && window.YT.Player instanceof Function) {
                a(window.YT);
                return
            } else {
                var l = window.location.protocol === "http:" ? "http:" : "https:";
                (0,
                i.default)(l + "//www.youtube.com/iframe_api", function(u) {
                    u && s.trigger("error", u)
                })
            }
            var c = window.onYouTubeIframeAPIReady;
            window.onYouTubeIframeAPIReady = function() {
                c && c(),
                a(window.YT)
            }
        }
        );
        return o
    }
    ,
    e.exports = t.default
}
)(Jg, Jg.exports);
var RY = Jg.exports
  , em = {
    exports: {}
}
  , tm = {
    exports: {}
}
  , nm = {
    exports: {}
}
  , sc = 1e3
  , oc = sc * 60
  , ac = oc * 60
  , lc = ac * 24
  , _Y = lc * 365.25
  , DY = function(e, t) {
    t = t || {};
    var n = typeof e;
    if (n === "string" && e.length > 0)
        return NY(e);
    if (n === "number" && isNaN(e) === !1)
        return t.long ? IY(e) : FY(e);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e))
};
function NY(e) {
    if (e = String(e),
    !(e.length > 100)) {
        var t = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(e);
        if (t) {
            var n = parseFloat(t[1])
              , i = (t[2] || "ms").toLowerCase();
            switch (i) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
                return n * _Y;
            case "days":
            case "day":
            case "d":
                return n * lc;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
                return n * ac;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
                return n * oc;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
                return n * sc;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
                return n;
            default:
                return
            }
        }
    }
}
function FY(e) {
    return e >= lc ? Math.round(e / lc) + "d" : e >= ac ? Math.round(e / ac) + "h" : e >= oc ? Math.round(e / oc) + "m" : e >= sc ? Math.round(e / sc) + "s" : e + "ms"
}
function IY(e) {
    return Du(e, lc, "day") || Du(e, ac, "hour") || Du(e, oc, "minute") || Du(e, sc, "second") || e + " ms"
}
function Du(e, t, n) {
    if (!(e < t))
        return e < t * 1.5 ? Math.floor(e / t) + " " + n : Math.ceil(e / t) + " " + n + "s"
}
(function(e, t) {
    t = e.exports = r.debug = r.default = r,
    t.coerce = l,
    t.disable = o,
    t.enable = s,
    t.enabled = a,
    t.humanize = DY,
    t.names = [],
    t.skips = [],
    t.formatters = {};
    var n;
    function i(c) {
        var u = 0, h;
        for (h in c)
            u = (u << 5) - u + c.charCodeAt(h),
            u |= 0;
        return t.colors[Math.abs(u) % t.colors.length]
    }
    function r(c) {
        function u() {
            if (u.enabled) {
                var h = u
                  , d = +new Date
                  , m = d - (n || d);
                h.diff = m,
                h.prev = n,
                h.curr = d,
                n = d;
                for (var f = new Array(arguments.length), x = 0; x < f.length; x++)
                    f[x] = arguments[x];
                f[0] = t.coerce(f[0]),
                typeof f[0] != "string" && f.unshift("%O");
                var S = 0;
                f[0] = f[0].replace(/%([a-zA-Z%])/g, function(p, g) {
                    if (p === "%%")
                        return p;
                    S++;
                    var C = t.formatters[g];
                    if (typeof C == "function") {
                        var E = f[S];
                        p = C.call(h, E),
                        f.splice(S, 1),
                        S--
                    }
                    return p
                }),
                t.formatArgs.call(h, f);
                var v = u.log || t.log || console.log.bind(console);
                v.apply(h, f)
            }
        }
        return u.namespace = c,
        u.enabled = t.enabled(c),
        u.useColors = t.useColors(),
        u.color = i(c),
        typeof t.init == "function" && t.init(u),
        u
    }
    function s(c) {
        t.save(c),
        t.names = [],
        t.skips = [];
        for (var u = (typeof c == "string" ? c : "").split(/[\s,]+/), h = u.length, d = 0; d < h; d++)
            u[d] && (c = u[d].replace(/\*/g, ".*?"),
            c[0] === "-" ? t.skips.push(new RegExp("^" + c.substr(1) + "$")) : t.names.push(new RegExp("^" + c + "$")))
    }
    function o() {
        t.enable("")
    }
    function a(c) {
        var u, h;
        for (u = 0,
        h = t.skips.length; u < h; u++)
            if (t.skips[u].test(c))
                return !1;
        for (u = 0,
        h = t.names.length; u < h; u++)
            if (t.names[u].test(c))
                return !0;
        return !1
    }
    function l(c) {
        return c instanceof Error ? c.stack || c.message : c
    }
}
)(nm, nm.exports);
var BY = nm.exports;
(function(e, t) {
    var n = {};
    t = e.exports = BY,
    t.log = s,
    t.formatArgs = r,
    t.save = o,
    t.load = a,
    t.useColors = i,
    t.storage = typeof chrome < "u" && typeof chrome.storage < "u" ? chrome.storage.local : l(),
    t.colors = ["lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson"];
    function i() {
        return typeof window < "u" && window.process && window.process.type === "renderer" ? !0 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
    }
    t.formatters.j = function(c) {
        try {
            return JSON.stringify(c)
        } catch (u) {
            return "[UnexpectedJSONParseError]: " + u.message
        }
    }
    ;
    function r(c) {
        var u = this.useColors;
        if (c[0] = (u ? "%c" : "") + this.namespace + (u ? " %c" : " ") + c[0] + (u ? "%c " : " ") + "+" + t.humanize(this.diff),
        !!u) {
            var h = "color: " + this.color;
            c.splice(1, 0, h, "color: inherit");
            var d = 0
              , m = 0;
            c[0].replace(/%[a-zA-Z%]/g, function(f) {
                f !== "%%" && (d++,
                f === "%c" && (m = d))
            }),
            c.splice(m, 0, h)
        }
    }
    function s() {
        return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments)
    }
    function o(c) {
        try {
            c == null ? t.storage.removeItem("debug") : t.storage.debug = c
        } catch {}
    }
    function a() {
        var c;
        try {
            c = t.storage.debug
        } catch {}
        return !c && typeof process < "u" && "env"in process && (c = n.DEBUG),
        c
    }
    t.enable(a());
    function l() {
        try {
            return window.localStorage
        } catch {}
    }
}
)(tm, tm.exports);
var zY = tm.exports
  , im = {
    exports: {}
};
(function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = ["cueVideoById", "loadVideoById", "cueVideoByUrl", "loadVideoByUrl", "playVideo", "pauseVideo", "stopVideo", "getVideoLoadedFraction", "cuePlaylist", "loadPlaylist", "nextVideo", "previousVideo", "playVideoAt", "setShuffle", "setLoop", "getPlaylist", "getPlaylistIndex", "setOption", "mute", "unMute", "isMuted", "setVolume", "getVolume", "seekTo", "getPlayerState", "getPlaybackRate", "setPlaybackRate", "getAvailablePlaybackRates", "getPlaybackQuality", "setPlaybackQuality", "getAvailableQualityLevels", "getCurrentTime", "getDuration", "removeEventListener", "getVideoUrl", "getVideoEmbedCode", "getOptions", "getOption", "addEventListener", "destroy", "setSize", "getIframe"],
    e.exports = t.default
}
)(im, im.exports);
var VY = im.exports
  , rm = {
    exports: {}
};
(function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = ["ready", "stateChange", "playbackQualityChange", "playbackRateChange", "error", "apiChange", "volumeChange"],
    e.exports = t.default
}
)(rm, rm.exports);
var WY = rm.exports
  , sm = {
    exports: {}
}
  , om = {
    exports: {}
};
(function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = {
        BUFFERING: 3,
        ENDED: 0,
        PAUSED: 2,
        PLAYING: 1,
        UNSTARTED: -1,
        VIDEO_CUED: 5
    },
    e.exports = t.default
}
)(om, om.exports);
var HY = om.exports;
(function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = HY
      , i = r(n);
    function r(s) {
        return s && s.__esModule ? s : {
            default: s
        }
    }
    t.default = {
        pauseVideo: {
            acceptableStates: [i.default.ENDED, i.default.PAUSED],
            stateChangeRequired: !1
        },
        playVideo: {
            acceptableStates: [i.default.ENDED, i.default.PLAYING],
            stateChangeRequired: !1
        },
        seekTo: {
            acceptableStates: [i.default.ENDED, i.default.PLAYING, i.default.PAUSED],
            stateChangeRequired: !0,
            timeout: 3e3
        }
    },
    e.exports = t.default
}
)(sm, sm.exports);
var UY = sm.exports;
(function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = zY
      , i = u(n)
      , r = VY
      , s = u(r)
      , o = WY
      , a = u(o)
      , l = UY
      , c = u(l);
    function u(m) {
        return m && m.__esModule ? m : {
            default: m
        }
    }
    var h = (0,
    i.default)("youtube-player")
      , d = {};
    d.proxyEvents = function(m) {
        var f = {}
          , x = function(R) {
            var F = "on" + R.slice(0, 1).toUpperCase() + R.slice(1);
            f[F] = function(P) {
                h('event "%s"', F, P),
                m.trigger(R, P)
            }
        }
          , S = !0
          , v = !1
          , p = void 0;
        try {
            for (var g = a.default[Symbol.iterator](), C; !(S = (C = g.next()).done); S = !0) {
                var E = C.value;
                x(E)
            }
        } catch (O) {
            v = !0,
            p = O
        } finally {
            try {
                !S && g.return && g.return()
            } finally {
                if (v)
                    throw p
            }
        }
        return f
    }
    ,
    d.promisifyPlayer = function(m) {
        var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
          , x = {}
          , S = function(F) {
            f && c.default[F] ? x[F] = function() {
                for (var P = arguments.length, _ = Array(P), T = 0; T < P; T++)
                    _[T] = arguments[T];
                return m.then(function(L) {
                    var I = c.default[F]
                      , k = L.getPlayerState()
                      , w = L[F].apply(L, _);
                    return I.stateChangeRequired || Array.isArray(I.acceptableStates) && I.acceptableStates.indexOf(k) === -1 ? new Promise(function(b) {
                        var A = function j() {
                            var B = L.getPlayerState()
                              , W = void 0;
                            typeof I.timeout == "number" && (W = setTimeout(function() {
                                L.removeEventListener("onStateChange", j),
                                b()
                            }, I.timeout)),
                            Array.isArray(I.acceptableStates) && I.acceptableStates.indexOf(B) !== -1 && (L.removeEventListener("onStateChange", j),
                            clearTimeout(W),
                            b())
                        };
                        L.addEventListener("onStateChange", A)
                    }
                    ).then(function() {
                        return w
                    }) : w
                })
            }
            : x[F] = function() {
                for (var P = arguments.length, _ = Array(P), T = 0; T < P; T++)
                    _[T] = arguments[T];
                return m.then(function(L) {
                    return L[F].apply(L, _)
                })
            }
        }
          , v = !0
          , p = !1
          , g = void 0;
        try {
            for (var C = s.default[Symbol.iterator](), E; !(v = (E = C.next()).done); v = !0) {
                var O = E.value;
                S(O)
            }
        } catch (R) {
            p = !0,
            g = R
        } finally {
            try {
                !v && C.return && C.return()
            } finally {
                if (p)
                    throw g
            }
        }
        return x
    }
    ,
    t.default = d,
    e.exports = t.default
}
)(em, em.exports);
var GY = em.exports;
(function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
        return typeof h
    }
    : function(h) {
        return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h
    }
      , i = TY
      , r = c(i)
      , s = RY
      , o = c(s)
      , a = GY
      , l = c(a);
    function c(h) {
        return h && h.__esModule ? h : {
            default: h
        }
    }
    var u = void 0;
    t.default = function(h) {
        var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
          , m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1
          , f = (0,
        r.default)();
        if (u || (u = (0,
        o.default)(f)),
        d.events)
            throw new Error("Event handlers cannot be overwritten.");
        if (typeof h == "string" && !document.getElementById(h))
            throw new Error('Element "' + h + '" does not exist.');
        d.events = l.default.proxyEvents(f);
        var x = new Promise(function(v) {
            if ((typeof h > "u" ? "undefined" : n(h)) === "object" && h.playVideo instanceof Function) {
                var p = h;
                v(p)
            } else
                u.then(function(g) {
                    var C = new g.Player(h,d);
                    return f.on("ready", function() {
                        v(C)
                    }),
                    null
                })
        }
        )
          , S = l.default.promisifyPlayer(x, m);
        return S.on = f.on,
        S.off = f.off,
        S
    }
    ,
    e.exports = t.default
}
)(Zg, Zg.exports);
var XY = Zg.exports;
const YY = Jr(XY);
var $Y = Object.defineProperty
  , KY = Object.defineProperties
  , QY = Object.getOwnPropertyDescriptors
  , $7 = Object.getOwnPropertySymbols
  , qY = Object.prototype.hasOwnProperty
  , ZY = Object.prototype.propertyIsEnumerable
  , K7 = (e,t,n)=>t in e ? $Y(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : e[t] = n
  , am = (e,t)=>{
    for (var n in t || (t = {}))
        qY.call(t, n) && K7(e, n, t[n]);
    if ($7)
        for (var n of $7(t))
            ZY.call(t, n) && K7(e, n, t[n]);
    return e
}
  , lm = (e,t)=>KY(e, QY(t))
  , JY = (e,t,n)=>new Promise((i,r)=>{
    var s = l=>{
        try {
            a(n.next(l))
        } catch (c) {
            r(c)
        }
    }
      , o = l=>{
        try {
            a(n.throw(l))
        } catch (c) {
            r(c)
        }
    }
      , a = l=>l.done ? i(l.value) : Promise.resolve(l.value).then(s, o);
    a((n = n.apply(e, t)).next())
}
);
function e$(e, t) {
    var n, i;
    if (e.videoId !== t.videoId)
        return !0;
    const r = ((n = e.opts) == null ? void 0 : n.playerVars) || {}
      , s = ((i = t.opts) == null ? void 0 : i.playerVars) || {};
    return r.start !== s.start || r.end !== s.end
}
function Q7(e={}) {
    return lm(am({}, e), {
        height: 0,
        width: 0,
        playerVars: lm(am({}, e.playerVars), {
            autoplay: 0,
            start: 0,
            end: 0
        })
    })
}
function t$(e, t) {
    return e.videoId !== t.videoId || !PY(Q7(e.opts), Q7(t.opts))
}
function n$(e, t) {
    var n, i, r, s;
    return e.id !== t.id || e.className !== t.className || ((n = e.opts) == null ? void 0 : n.width) !== ((i = t.opts) == null ? void 0 : i.width) || ((r = e.opts) == null ? void 0 : r.height) !== ((s = t.opts) == null ? void 0 : s.height) || e.iframeClassName !== t.iframeClassName || e.title !== t.title
}
var i$ = {
    videoId: "",
    id: "",
    className: "",
    iframeClassName: "",
    style: {},
    title: "",
    loading: void 0,
    opts: {},
    onReady: ()=>{}
    ,
    onError: ()=>{}
    ,
    onPlay: ()=>{}
    ,
    onPause: ()=>{}
    ,
    onEnd: ()=>{}
    ,
    onStateChange: ()=>{}
    ,
    onPlaybackRateChange: ()=>{}
    ,
    onPlaybackQualityChange: ()=>{}
}
  , r$ = {
    videoId: qt.string,
    id: qt.string,
    className: qt.string,
    iframeClassName: qt.string,
    style: qt.object,
    title: qt.string,
    loading: qt.oneOf(["lazy", "eager"]),
    opts: qt.objectOf(qt.any),
    onReady: qt.func,
    onError: qt.func,
    onPlay: qt.func,
    onPause: qt.func,
    onEnd: qt.func,
    onStateChange: qt.func,
    onPlaybackRateChange: qt.func,
    onPlaybackQualityChange: qt.func
}
  , ah = class extends Ce.Component {
    constructor(e) {
        super(e),
        this.destroyPlayerPromise = void 0,
        this.onPlayerReady = t=>{
            var n, i;
            return (i = (n = this.props).onReady) == null ? void 0 : i.call(n, t)
        }
        ,
        this.onPlayerError = t=>{
            var n, i;
            return (i = (n = this.props).onError) == null ? void 0 : i.call(n, t)
        }
        ,
        this.onPlayerStateChange = t=>{
            var n, i, r, s, o, a, l, c;
            switch ((i = (n = this.props).onStateChange) == null || i.call(n, t),
            t.data) {
            case ah.PlayerState.ENDED:
                (s = (r = this.props).onEnd) == null || s.call(r, t);
                break;
            case ah.PlayerState.PLAYING:
                (a = (o = this.props).onPlay) == null || a.call(o, t);
                break;
            case ah.PlayerState.PAUSED:
                (c = (l = this.props).onPause) == null || c.call(l, t);
                break
            }
        }
        ,
        this.onPlayerPlaybackRateChange = t=>{
            var n, i;
            return (i = (n = this.props).onPlaybackRateChange) == null ? void 0 : i.call(n, t)
        }
        ,
        this.onPlayerPlaybackQualityChange = t=>{
            var n, i;
            return (i = (n = this.props).onPlaybackQualityChange) == null ? void 0 : i.call(n, t)
        }
        ,
        this.destroyPlayer = ()=>this.internalPlayer ? (this.destroyPlayerPromise = this.internalPlayer.destroy().then(()=>this.destroyPlayerPromise = void 0),
        this.destroyPlayerPromise) : Promise.resolve(),
        this.createPlayer = ()=>{
            if (typeof document > "u")
                return;
            if (this.destroyPlayerPromise) {
                this.destroyPlayerPromise.then(this.createPlayer);
                return
            }
            const t = lm(am({}, this.props.opts), {
                videoId: this.props.videoId
            });
            this.internalPlayer = YY(this.container, t),
            this.internalPlayer.on("ready", this.onPlayerReady),
            this.internalPlayer.on("error", this.onPlayerError),
            this.internalPlayer.on("stateChange", this.onPlayerStateChange),
            this.internalPlayer.on("playbackRateChange", this.onPlayerPlaybackRateChange),
            this.internalPlayer.on("playbackQualityChange", this.onPlayerPlaybackQualityChange),
            (this.props.title || this.props.loading) && this.internalPlayer.getIframe().then(n=>{
                this.props.title && n.setAttribute("title", this.props.title),
                this.props.loading && n.setAttribute("loading", this.props.loading)
            }
            )
        }
        ,
        this.resetPlayer = ()=>this.destroyPlayer().then(this.createPlayer),
        this.updatePlayer = ()=>{
            var t;
            (t = this.internalPlayer) == null || t.getIframe().then(n=>{
                this.props.id ? n.setAttribute("id", this.props.id) : n.removeAttribute("id"),
                this.props.iframeClassName ? n.setAttribute("class", this.props.iframeClassName) : n.removeAttribute("class"),
                this.props.opts && this.props.opts.width ? n.setAttribute("width", this.props.opts.width.toString()) : n.removeAttribute("width"),
                this.props.opts && this.props.opts.height ? n.setAttribute("height", this.props.opts.height.toString()) : n.removeAttribute("height"),
                this.props.title ? n.setAttribute("title", this.props.title) : n.setAttribute("title", "YouTube video player"),
                this.props.loading ? n.setAttribute("loading", this.props.loading) : n.removeAttribute("loading")
            }
            )
        }
        ,
        this.getInternalPlayer = ()=>this.internalPlayer,
        this.updateVideo = ()=>{
            var t, n, i, r;
            if (typeof this.props.videoId > "u" || this.props.videoId === null) {
                (t = this.internalPlayer) == null || t.stopVideo();
                return
            }
            let s = !1;
            const o = {
                videoId: this.props.videoId
            };
            if ((n = this.props.opts) != null && n.playerVars && (s = this.props.opts.playerVars.autoplay === 1,
            "start"in this.props.opts.playerVars && (o.startSeconds = this.props.opts.playerVars.start),
            "end"in this.props.opts.playerVars && (o.endSeconds = this.props.opts.playerVars.end)),
            s) {
                (i = this.internalPlayer) == null || i.loadVideoById(o);
                return
            }
            (r = this.internalPlayer) == null || r.cueVideoById(o)
        }
        ,
        this.refContainer = t=>{
            this.container = t
        }
        ,
        this.container = null,
        this.internalPlayer = null
    }
    componentDidMount() {
        this.createPlayer()
    }
    componentDidUpdate(e) {
        return JY(this, null, function*() {
            n$(e, this.props) && this.updatePlayer(),
            t$(e, this.props) && (yield this.resetPlayer()),
            e$(e, this.props) && this.updateVideo()
        })
    }
    componentWillUnmount() {
        this.destroyPlayer()
    }
    render() {
        return Ce.createElement("div", {
            className: this.props.className,
            style: this.props.style
        }, Ce.createElement("div", {
            id: this.props.id,
            className: this.props.iframeClassName,
            ref: this.refContainer
        }))
    }
}
  , hf = ah;
hf.propTypes = r$;
hf.defaultProps = i$;
hf.PlayerState = {
    UNSTARTED: -1,
    ENDED: 0,
    PLAYING: 1,
    PAUSED: 2,
    BUFFERING: 3,
    CUED: 5
};
var s$ = hf;
const o$ = "0tZFQs7qBfQ"
  , a$ = ()=>y.jsxs("article", {
    className: "watch-demo",
    children: [y.jsx("h2", {
        children: "Watch a demo:"
    }), y.jsx("div", {
        className: "watch-demo__video",
        children: y.jsx(l$, {
            videoId: o$
        })
    }), y.jsx("p", {
        children: "This strategy is based on the popular Bollinger Bands indicator. It buys when the current price is below the lower band and sells when either the profit target or stop-loss level has been reached or when the current price is above the upper band. Trade smarter with IUH"
    }), y.jsx("a", {
        href: "http://www.extej.com/",
        children: "More info"
    })]
})
  , l$ = ({videoId: e})=>{
    const [t,n] = Ce.useState(window.innerWidth)
      , [i,r] = Ce.useState(t > 1200 ? 342 : 142)
      , s = ()=>{
        n(window.innerWidth),
        t > 1200 ? r(142) : r(342)
    }
    ;
    Ce.useEffect(()=>(window.addEventListener("resize", s),
    ()=>{
        window.removeEventListener("resize", s)
    }
    ), [t]);
    const o = {
        height: `${i}px`,
        width: "100%",
        playerVars: {
            autoplay: 0
        }
    };
    return y.jsx(s$, {
        videoId: e,
        opts: o
    })
}
  , c$ = ()=>{
    const e = Number(rs().pathname.slice(17))
      , t = jA.filter(n=>n.id === e);
    return y.jsxs("div", {
        className: "create-strategy",
        children: [y.jsxs("div", {
            children: [y.jsx("h2", {
                children: "Create Strategy"
            }), y.jsx(Vn, {
                to: "/ai-trading-bots",
                children: y.jsx("button", {
                    children: "Back"
                })
            })]
        }), y.jsx("ul", {
            children: y.jsx(TA, {
                data: t[0],
                select: !0
            })
        }), y.jsxs(Hr, {
            gutter: [32, 32],
            style: {
                marginTop: "40px"
            },
            children: [y.jsx(Ot, {
                className: "gutter-row",
                xs: 24,
                lg: 24,
                xl: 18,
                xxl: 18,
                children: y.jsx(bY, {})
            }), y.jsx(Ot, {
                className: "gutter-row",
                xs: 24,
                lg: 24,
                xl: 6,
                xxl: 6,
                children: y.jsxs(Hr, {
                    gutter: [0, 32],
                    children: [y.jsx(wY, {}), y.jsx(a$, {})]
                })
            })]
        })]
    })
}
  , u$ = ()=>y.jsx("main", {
    children: y.jsx(c$, {})
})
  , h$ = ({dataChart: e})=>{
    const t = e[1]
      , n = {
        chart: {
            type: "area",
            style: {
                fontFamily: "Lato",
                fontSize: 15
            }
        },
        title: {
            text: ""
        },
        legend: {
            enabled: !1
        },
        credits: {
            enabled: !1
        },
        xAxis: {
            tickWidth: 0,
            crosshair: {
                width: 1,
                color: "rgba(44, 64, 110, 1)",
                dashStyle: "shortdot"
            },
            labels: {
                enabled: !1
            },
            lineWidth: 0
        },
        yAxis: [{
            labels: {
                enabled: !1
            },
            lineWidth: 0,
            gridLineWidth: 0,
            title: {
                text: ""
            }
        }],
        tooltip: {
            enabled: !1
        },
        plotOptions: {
            series: {
                marker: {
                    enabled: !1,
                    states: {
                        hover: {
                            enabled: !0
                        }
                    }
                }
            }
        },
        series: [{
            name: "Fully diluted market cap",
            data: t,
            color: "#2B7AFF",
            gapSize: 5,
            tooltip: {
                valueDecimals: 2
            },
            fillOpacity: .3,
            fillColor: {
                linearGradient: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 1
                },
                stops: [[0, "rgb(43, 122, 255, 0.3) "], [1, "rgba(43, 121, 255, 0)"]]
            },
            threshold: null
        }]
    };
    return y.jsx(pv, {
        highcharts: fv,
        options: n
    })
}
;
Ec.register(tl, mA, fA, hA);
function d$({handleChangeLabel: e}) {
    const t = {
        labels: ["Ethereum", "BNB Chain", "Polygon", "OKTC", "Arbitrum One"],
        datasets: [{
            label: "",
            data: [50, 13, 5, 15, 17],
            backgroundColor: ["#2B7AFF", "#ffce2d", "#AA78FF", "#FF61C0", "#4EDFFF"],
            borderColor: "#fff",
            borderWidth: 2,
            cutout: 63
        }]
    }
      , n = {
        responsive: !0,
        plugins: {
            tooltip: {
                enabled: !1
            },
            legend: {
                display: !1,
                position: "bottom",
                maxHeight: 80,
                labels: {
                    boxWidth: 8,
                    boxHeight: 8,
                    fontSize: 12,
                    color: "#2C406E",
                    fontFamily: "Lato"
                }
            }
        },
        onHover: (i,r)=>{
            if (r.length) {
                var s = t.labels[r[0].index]
                  , o = t.datasets[0].data[r[0].index];
                e({
                    title: s,
                    procent: o
                })
            }
        }
    };
    return y.jsx(xX, {
        data: t,
        options: n
    })
}
const W0 = [{
    title: "Ethereum",
    procent: 50,
    color: {
        background: "#2B7AFF"
    }
}, {
    title: "BNB Chain",
    procent: 13,
    color: {
        background: "#ffce2d"
    }
}, {
    title: "Polygon",
    procent: 5,
    color: {
        background: "#AA78FF"
    }
}, {
    title: "OKTC",
    procent: 15,
    color: {
        background: "#FF61C0"
    }
}, {
    title: "Arbitrum One",
    procent: 17,
    color: {
        background: "#4EDFFF"
    }
}]
  , f$ = [{
    id: 1,
    name: "Crypto",
    amount: "$22,291.04",
    percent: 98.42
}, {
    id: 2,
    name: "NFTs",
    amount: "$0.57",
    percent: .01
}, {
    id: 3,
    name: "DeFi",
    amount: "$356.95",
    percent: 1.52
}]
  , p$ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAAAVCAYAAACXMsrYAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA5tSURBVHgBrVoNdBRVlv5e9U+60wn5IRICMnQAMQhIIsriwGoaBfSokAgjIzjQ7J5dYXQOop5RRySBGZnRPc4AKjjs7iHJgLDomOCOMxMF0qgwECMkgBCVkI7kn0A6P53+raq5ryrppNOdf75zXter996telXfu/fde6sZ+oF1U106mGYpVTMEBrMsU40xhyzLpTEmTWmLw7sj53dJ9r7kp7z4j3RB1qxhGqRDlm8lYS01O6iUQpYOM79cUL793j7lMz54O12jFdaQ3L+SfAKVaAisho4VsizlSoLOVpC5vk/51qJFGYKnbqnEWDqDbAYTqFWk+7NSepRcUdTY4h4u7Us+lk+BCn/+VCrmznZ1/iRPxUYlrDxdnzWkL9jAgFkyo+cHJlJh/N5gsl2WcDjJdiwHNxksXONTL9el63SaLKZOpF9IMnLcPnHLwR7EciI1TPO/VJ00kDw9eI5A8j2JXZ6/O11m0m66eEq/wozRu8Lv4zXazXuWPN3R1dxaOJMWoPAHuZuEPm4u0Y+YHb344pZePRuoZEMltT/YqeRQCZJvTE/fIDMhWx6EPE1ha9LxY3txkxBC6L9vvr5BksXtLAzVUUYB7S4p3HXskle0cG2d+suvspgsZ2NosDOfaOGkPp7/7tDlmWAX4bEUZG60txXO/AOdPzckcVm2+yTB0qmt/OVaMTRwjc2sTE93GME+oIX24JCkGQpckrQ22WZzYIQIos266VqWIIR/mZzgjU/FYt8nbWi8IYYb4vjKU5PjlXyBlzlnUjSeXTgeb37yAy5UBxQIv30iWTm+81kNapq9Xc32qbPPFuj1viGR0QP2HZF/ssUIbiuGAU5q1OJzNgydzMD96y0PNJHa341hgZW6ZNEyUlK1XRVuZvsik+Ox+00YHSdg9h0R+OsXHeitwY1ie2wXmdEGDX693IyH7oxH8ZU2NDuDF8DZqnY8vWAc8iZH49VDlThV0YbYMdfNIyATGboSc39k6ievgxCRCHeIdVWxbV+jGZ1kZmRkIDa221oWFBTA4VDfM6MHX7ZsGaKiogL9ubm52DplCsnL5r7uH/3MzwGNFm07d/YxQk41CUIWVTZiBAjQ8m+bGyvRx56TECvgd8/Fo+GGhO/sfhRfcOPSFW/QmBJ3NTyyX6kfevYOmMcY8Ivcyzhd0aq03Z8SQyUWWwuqlPOkWD1++cgEPDwrHj/fdwHV2lPQR3gC11t/lwUzEm7FQHip6BAM/uvYGvkhIpkv7BhOpn7SOqXurz0M9zdZQf0/NHgx/WeXAufnz5/HjBkzAudmsxlVVVWB87q6OowdOzZwPjEyEsVz70Vf0CQmIuHA+0q9eePz8JaV9TmWnD1Lks1mwyCw/+OvrauWzM7p2cbdPvzsV41W9ONArHgoWlmZXZg1NQI6bfc5aWeAzGcXjsPMCSas3l0eIJNr7KKZ8ci4OwHj4/RKW53Di437K1B4rhk/uU8bRCaHSWdAomnUgIUjQ3dqUGRyaMcthWH61k6HSMW2PzVgJHjRnNxvv2mttbu+Zk2/Y+k9Z2GQIJdww4H//zpovGJyNRq2VPE3w+DHqQbcNU0fOCevFjodMPfOCHxxxq20NfrblWMUEfeTOWOwp6gO5XXqnskJzFuXApdPon3UiaOvzMK2j68i78t6pf+1P1ci7V/KQ+57svp72B3X1EkKApan3KPUL1yrplITGOeVRKRENIade08yvRW74G+vhvHO14nUJTDQ87ovvMYdKnxR1o7hQm5vxxM9tLU3DIsWwUglMKfUWdBOmQz/5Yo+JFg6OVexg9lLPRKzRDCcJVLx5GOzlb1EIZRitPRwApEGhgxLpFL3izJqGkW4vTIi6SqTbtXjuyofGq6LaJFUYudOiUZijA6HTl8LXOOn946BKUKDB357Tjlfe18iHpweFyDU6fPiuqc55N4nay4H6hG093QTWoMPvy0J9CWwdiQIToSD7L2hHDmZ3it7lLqLpmGc/gpkv1Mh83yFSzG5PZGTk4PkZFXrKObG4sWLaRHrAv15eXkwmUxKPam5GfPQN6KswRop1jf0Q6YKgxr32jAA1mamOQ7kn7XIGhS9/5ez9pWPpuVqM55rjmXMFzZeevT+SETQc9hr/ahtlFDd4Ed5pQcJcRqMHa3FvDQj/u9I90K6a2I0LtV2kOfabT6b2/2UC2B4NC0eJ75rxd7PG5TSBaOpI+S+CZHRiNTqSTM10JF2tnm7rxep02MM9ccaIiGSuRjjawmR55oJWSQS/xtiywVIrRehm7ACgikZnkvb0OGm3ERrGYTR81FbP4EkXg6Sf+utt4LOKysrlX20C0lJSaivVxfkirFJmDdtGsLBQAtB00t7nbm5GAgyhEERyvFkZpp9f35xJoMmn45l2thYdywkTchAMsNIjNfiTLmfzKySIgr0NTWLSjGQpsbHU3unBYwzkRfnCvZoP/zqGm4ba8SvlyXDqBcUsj8sbsLuo7Wdkw829VF6A1bdMRc7vz6iaAcH19AudJBGN3a0KYX3T42hvbBHaKyJuztgZsUbJZQXOktETkJEyitqW/PX8Dd8RgNNMKTuRNu5PIwEEwyGsO3cEYpaszqojWunq7BQqcdu3YK2d3dBbAjdv9nACYkgrMqcU0oO0hYmaPdqHQ6DI35UqEPBNfOwrR23Jupx2490If1+4q2KNNfbw1lyekREG4MXRysR/AqFJrxMJWKXz0nAhsXjse9EA9rcIiQx+NrtXjf2XzyFhebp0JOG+iVJCZEOlReTB8fgoz3z8dtno8XtUsjXtp6hG3fLi80lZGLfA2dZIXPUdNLQb+Ap36ZoqL++ECwmTdFQ9/lNkFwmjARX3e6w7cbHHg3RztY33lCOXHMj5s+H1O5E65tvhsjKanpx0Nibf9ZM22aWLPkztQXb4xxrX2t00EsLWhUdbhmTxpPZ08goPNmBeanqSqT3izanBCNljdKmRaDkGw+0tBf5yWv8vsGFpbMTFK+Wk8Xx+1WTkRClw+o/luO7eheOfOPA6vljyUtW8qrwuvUhE2wi7fu08kLgnGvo/iVPK/WDF08H76FCGx6LDJb3XnlPOXIzyzXTW/GuYn65ZyuMfQTGmdvgrz5IJL+BacwVcn+r1RpkYvfu7c7McW9/5cqVGDVK9bCncSvy+RdB8lw7TTSmJ1yFnyrhCqO9t0tzjQ8thps0tncYwyCVYpDgZEZo5CKydFu4pnY6RcxGT5vRe/DnZ1zY9os4LPwxwx8/aEV7hwwnpf7mzDDgR0nk/BS2weeXYWJ6tMhu/K3sBrIzJyKTwpO8L1VTcvBUI/KeTsE7q29DfYsXj6TGK07TjXbVKoh+DSaYEnHVObzQoUmKRhPl7BNYW0gf08UpR/3kZ5Sjv+USjHf8SiGFaVTNnDnZCPrQgJYeyY8XXnhh0HEo93IvHyvCKG33thAuNOnaOyOXLwvSXD7W+/zzQWPdaipxQATIlOXcVUvVeFSJQyX6chFOgGvjW3mtGB0j4NX/iMODcyOxJD1KIfPsJQ9cHnWPi9eoKsLN674TjfjPBUlK4oCjmLJA3MP1+iU8NW8Msj+yY/Of7YF78Lj13olmjARf+qaGbeeaqppflVRjKqV5tdGUXCigkGVTYNyqRXEYLhhljE46gi2kMDpe0TpePCdOoOX1bbR/qk6UQOO7+niRne3KNQLXo48dg03/RWjl/E4ys7valGWV85vEAutrDXbyRs29ha6R83Pw7048+XAUpk/RKZmimmt+nPu+2/Mco4lCrb9VSS68TfnZBRSW7FufgtXvlSu5Wu4I/fXcddw+zojC890hykoKaXiud/cx2kslLQTBj+HgU98MLNKdp+SCN6Svy/xyz5cJuk4yN0P9lKbimcdvwa78JgwXe6qv4qGEhMC546WX+xzLHaH+IEHagkGCyNzRpZldCHgwM+57qYwcW2s4wYqrfiTdokVMtAB7jR/HS1zw+rq9Ux6WRNCnzibRCQ+Z4KO0T2befQuWzbkFGvqQepn21vJaF94/qSYAZow34XVK0K+en4hdR2qxs7COJqdBVGz4hckTC4uSZ8IrirjYVINvb9QH9fvoMXy0Nmdqq8PKc0dJeQHuWjXt1ysRHROlQSyVIyWq2XY6nSgj7eEZOF6OHz8Odw/nx+v14vTp04H+/bQPxtA+PzsmBiOBxLBjXFHRwcGO/+jAnhDTHPRkqzc1ZGuF8KknI4Uo656IwUdHnKiqC/WKiVRHcccPuR6I/FuiQuT6B5IUYl/94ApOXe7e43jmiC+CnZ9WKya5cyb221PPHNYZ/BswLDD7TlNu6SjmyRiWNH1tmbTifGmjQx6WPMHeYLE4ZLBUDAusZGzR0XswQgg9T/J+k5gtSXJYlef75dsHWsKSSbB3+GTLuf+a/Ry9GEWeB/3vfFZL+2cZkRacWnsm5zKe2n0piEwmiJaPV64LyA8JjNlFJljGLy7OhCZmB4YIumepr6PVQmRm0umQ5QnHqVj0smyhmON/MESQrTtOn84W4iYg7D8WrNl1ZtknFFFywdyfMPfYyRrmiMy5MSc7OWAvU178R7osaPbSTPuV78QOj0+Xbd+eFpD/6Sd7rD6vP4vCjIHkHUTGDr8Qtb0gc21AvvWTyVZBF5U14D8WGMV7krjD31G9PS4zyLOxUuGWqn95NV7kCyC7Z2Nd+gIrGaAB5enlOyijumWc7dh23CSw/jrpg3c6WXaanGJGZvGth0yKg5gsow3ZZh4v5WSv7/s/Rbe/+NVSiqkyFTPEMEu9I7tO8heICJvbr9/ek8jeWJ6/62E6rJBkke7PbqPb60m+jtq+5dGfhMi3exLZG61H77HCz02wbOb/7eFtEhOqmOyz0/wLJFdETlxmaX8epRXq/4rM6JQn8PiF7102qH8/6VNeIZaHg6qzyeW5DvxAvzbGP2hDyrkZ/1LoiX8CvZ0q07GUvowAAAAASUVORK5CYII="
  , g$ = "/assets/DeFiSmallIconLink-bo8_xNHo.png"
  , m$ = "/assets/nftsSmallIconLink-ISIsLEqW.png"
  , v$ = ({data: e})=>{
    const {name: t, amount: n, percent: i, id: r} = e;
    return y.jsxs("section", {
        className: "renge-slider-chart",
        children: [y.jsx("h2", {
            children: t
        }), y.jsx("h3", {
            children: n
        }), y.jsxs("div", {
            className: "renge-slider-chart__chart",
            children: [y.jsxs("div", {
                children: [y.jsx("h4", {
                    children: "Ratio"
                }), y.jsxs("h4", {
                    children: [i, "%"]
                })]
            }), y.jsx("div", {
                className: "range-slider",
                children: y.jsx("div", {
                    style: {
                        width: `${i}%`
                    }
                })
            })]
        }), r === 1 ? y.jsx("img", {
            src: p$,
            alt: "crypto"
        }) : r === 2 ? y.jsx("img", {
            src: m$,
            alt: "nfts"
        }) : r === 3 ? y.jsx("img", {
            src: g$,
            alt: "deFi"
        }) : null]
    })
}
  , y$ = ()=>{
    const [e,t] = Ce.useState(W0[0])
      , [n,i] = Ce.useState(1)
      , r = zt.slice(0, 200).map(f=>f)
      , s = zt.slice(0, 61).map(f=>f)
      , o = [0, r, 0, 22]
      , a = [0, s, 0, 22]
      , l = f=>{
        t(f)
    }
      , c = new Date;
    let u = String(c.getDate()).padStart(2, "0")
      , h = String(c.getMonth() + 1).padStart(2, "0")
      , d = c.getFullYear()
      , m = `${u}/${h}/${d}`;
    return y.jsx("div", {
        className: "summaty",
        children: y.jsxs(Hr, {
            gutter: [32, 32],
            style: {
                marginTop: "40px"
            },
            children: [y.jsx(Ot, {
                className: "gutter-row",
                xs: 24,
                lg: 24,
                xl: 16,
                xxl: 18,
                children: y.jsxs("div", {
                    className: "summaty__line-chart",
                    children: [y.jsxs("div", {
                        className: "summaty__panel-line-chart",
                        children: [y.jsxs("div", {
                            children: [y.jsx("h2", {
                                children: "Performance"
                            }), y.jsx("h3", {
                                children: "$23,449.85"
                            }), y.jsx("h4", {
                                children: m
                            })]
                        }), y.jsx("div", {
                            children: ["7d", "30d"].map((f,x)=>y.jsx("button", {
                                className: n === x ? "active" : "",
                                onClick: ()=>i(x),
                                children: f
                            }, x))
                        })]
                    }), y.jsx(h$, {
                        dataChart: n ? o : a
                    })]
                })
            }), y.jsx(Ot, {
                className: "gutter-row",
                xs: 24,
                lg: 12,
                xl: 8,
                xxl: 6,
                children: y.jsxs("div", {
                    className: "doughnut-chart",
                    children: [y.jsx("h2", {
                        children: "Network allocation"
                    }), y.jsxs("div", {
                        className: "doughnut-chart__wrapper",
                        children: [y.jsx("div", {
                            className: "doughnut-chart__border"
                        }), y.jsx(d$, {
                            handleChangeLabel: l
                        }), y.jsxs("div", {
                            className: "doughnut-chart__text",
                            children: [y.jsx("h5", {
                                children: e == null ? void 0 : e.title
                            }), y.jsxs("h4", {
                                children: [e == null ? void 0 : e.procent, "%"]
                            })]
                        })]
                    }), y.jsx("ul", {
                        children: W0.map(({title: f, color: x},S)=>y.jsxs("li", {
                            onMouseEnter: ()=>t(W0[S]),
                            children: [y.jsx("span", {
                                style: x
                            }), " ", f]
                        }, S))
                    })]
                })
            }), f$.map(f=>y.jsx(Ot, {
                className: "gutter-row",
                xs: 24,
                lg: 12,
                xl: 8,
                children: y.jsx(v$, {
                    data: f
                })
            }, f.id))]
        })
    })
}
;
var q7;
function cm() {
    return cm = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    ,
    cm.apply(this, arguments)
}
const df = e=>M.createElement("svg", cm({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 3 3"
}, e), q7 || (q7 = M.createElement("path", {
    fill: "#2C406E",
    d: "m.125.838 1.082 1.269a.374.374 0 0 0 .589 0L2.878.837C3.14.53 2.953 0 2.58 0H.417C.045 0-.139.53.125.838Z"
})))
  , x$ = ()=>{
    const [e,t] = Ce.useState(5)
      , [n,i] = Ce.useState(Ns)
      , r = o=>{
        t(a=>o)
    }
    ;
    Ce.useEffect(()=>{
        i(s(n, e))
    }
    , [e]);
    function s(o, a) {
        let l = [...o];
        switch (a) {
        case 0:
            l.sort((c,u)=>c.token[0].localeCompare(u.token[0]));
            break;
        case 1:
            l.sort((c,u)=>{
                const h = c.price[0]
                  , d = u.price[0];
                return !isNaN(h) && !isNaN(d) ? d - h : 0
            }
            );
            break;
        case 2:
            l.sort((c,u)=>{
                const h = c.volume[0]
                  , d = u.volume[0];
                return !isNaN(h) && !isNaN(d) ? d - h : 0
            }
            );
            break;
        case 3:
            l.sort((c,u)=>{
                const h = c.circulatingSuppy[1]
                  , d = u.circulatingSuppy[1];
                return !isNaN(h) && !isNaN(d) ? d - h : 0
            }
            );
            break;
        default:
            return l
        }
        return l
    }
    return y.jsx("section", {
        className: "crypto-wallet-table",
        children: y.jsxs("table", {
            children: [y.jsx("thead", {
                children: y.jsx("tr", {
                    children: ["Asset", "Price", "Balance", "Proportion"].map((o,a)=>{
                        const l = a === e ? "active-sort" : "";
                        return y.jsx("th", {
                            children: y.jsxs("h4", {
                                onClick: ()=>r(a),
                                children: [o, " ", y.jsx(df, {
                                    className: l
                                })]
                            })
                        }, a)
                    }
                    )
                })
            }), y.jsx("tbody", {
                children: n.map(({id: o, token: a, price: l, marketCap: c, volume: u, circulatingSuppy: h})=>y.jsxs("tr", {
                    children: [y.jsx("td", {
                        children: y.jsxs("div", {
                            className: "row-1",
                            children: [y.jsx(tn, {
                                name: a[2],
                                className: "svg-37px"
                            }), y.jsxs("div", {
                                children: [y.jsx("h5", {
                                    children: a[0]
                                }), y.jsx("h5", {
                                    style: {
                                        color: "#A6B2CD"
                                    },
                                    children: a[1]
                                })]
                            })]
                        })
                    }), y.jsx("td", {
                        children: y.jsxs("div", {
                            className: "row-2",
                            children: [y.jsxs("h5", {
                                children: ["$", l[0]]
                            }), y.jsxs("div", {
                                children: [y.jsx("h6", {
                                    className: "bg-transpatent-blue",
                                    children: "24h"
                                }), y.jsx("h6", {
                                    style: tb(l[1]),
                                    children: l[1]
                                }), y.jsx("h6", {
                                    className: "bg-transpatent-blue",
                                    children: "7h"
                                }), y.jsx("h6", {
                                    style: tb(l[2]),
                                    children: l[2]
                                })]
                            })]
                        })
                    }), y.jsx("td", {
                        children: y.jsxs("div", {
                            className: "row-3",
                            children: [y.jsx("h5", {
                                children: u[0]
                            }), y.jsxs("h6", {
                                children: ["$", c, "00"]
                            })]
                        })
                    }), y.jsx("td", {
                        children: y.jsx("div", {
                            className: "row-4",
                            children: y.jsxs("div", {
                                children: [y.jsxs("h4", {
                                    children: [h[1], "%"]
                                }), y.jsx("div", {
                                    className: "range-slider",
                                    children: y.jsx("div", {
                                        style: {
                                            width: `${h[1]}%`
                                        }
                                    })
                                })]
                            })
                        })
                    })]
                }, o))
            })]
        })
    })
}
  , b$ = [{
    id: 0,
    protocol: "Vesper",
    assets: 41.1,
    proportion: 8.36,
    svgIcon: "wan"
}, {
    id: 1,
    protocol: "SushiSwap",
    assets: 38.73,
    proportion: 7.64,
    svgIcon: "band"
}, {
    id: 2,
    protocol: "CherrySwap",
    assets: 6.93,
    proportion: 2.98,
    svgIcon: "arpa"
}, {
    id: 3,
    protocol: "Lido",
    assets: 2.05,
    proportion: 1.36,
    svgIcon: "inj"
}, {
    id: 4,
    protocol: "Maker",
    assets: 630.46,
    proportion: 44.6,
    svgIcon: "exmo"
}, {
    id: 5,
    protocol: "Curve",
    assets: .81,
    proportion: .98,
    svgIcon: "etc"
}, {
    id: 6,
    protocol: "Aave",
    assets: 62.94,
    proportion: 9.98,
    svgIcon: "avax"
}, {
    id: 7,
    protocol: "Convex",
    assets: 4.15,
    proportion: 1.36,
    svgIcon: "atlas"
}, {
    id: 8,
    protocol: "Uniswap",
    assets: 5.02,
    proportion: 2.64,
    svgIcon: "usdt"
}, {
    id: 9,
    protocol: "Aura Finance",
    assets: 1.81,
    proportion: .98,
    svgIcon: "ae"
}]
  , w$ = ()=>{
    const [e,t] = Ce.useState(5)
      , [n,i] = Ce.useState(b$)
      , r = o=>{
        t(a=>o)
    }
    ;
    Ce.useEffect(()=>{
        i(s(n, e))
    }
    , [e]);
    function s(o, a) {
        let l = [...o];
        switch (a) {
        case 0:
            l.sort((c,u)=>c.protocol.localeCompare(u.protocol));
            break;
        case 3:
            l.sort((c,u)=>{
                const h = c.assets
                  , d = u.assets;
                return !isNaN(h) && !isNaN(d) ? d - h : 0
            }
            );
            break;
        case 4:
            l.sort((c,u)=>{
                const h = c.proportion
                  , d = u.proportion;
                return !isNaN(h) && !isNaN(d) ? h - d : 0
            }
            );
            break;
        default:
            return l
        }
        return l
    }
    return y.jsx("section", {
        className: "defi-wallet-table",
        children: y.jsxs("table", {
            children: [y.jsx("thead", {
                children: y.jsx("tr", {
                    children: ["Protocol", "Network", "Invested products", "Assets", "Proportion"].map((o,a)=>{
                        const l = a === e ? "active-sort" : "";
                        return y.jsx("th", {
                            children: y.jsxs("h4", {
                                onClick: ()=>r(a),
                                children: [o, " ", y.jsx(df, {
                                    className: l
                                })]
                            })
                        }, a)
                    }
                    )
                })
            }), y.jsx("tbody", {
                children: n.map(({id: o, protocol: a, assets: l, proportion: c, svgIcon: u})=>y.jsxs("tr", {
                    children: [y.jsx("td", {
                        children: y.jsxs("div", {
                            className: "row-1",
                            children: [y.jsx(tn, {
                                name: u,
                                className: "svg-37px"
                            }), y.jsx("div", {
                                children: y.jsx("h5", {
                                    children: a
                                })
                            })]
                        })
                    }), y.jsx("td", {
                        children: y.jsx("div", {
                            className: "row-1",
                            children: y.jsx(tn, {
                                name: "eth",
                                className: "svg-37px"
                            })
                        })
                    }), y.jsx("td", {
                        children: y.jsx("h5", {
                            children: "1"
                        })
                    }), y.jsx("td", {
                        children: y.jsx("div", {
                            className: "row-1",
                            children: y.jsxs("h5", {
                                children: ["$", l]
                            })
                        })
                    }), y.jsx("td", {
                        children: y.jsx("div", {
                            className: "row-4",
                            children: y.jsxs("div", {
                                children: [y.jsxs("h5", {
                                    children: [c, "%"]
                                }), y.jsx("div", {
                                    className: "range-slider",
                                    children: y.jsx("div", {
                                        style: {
                                            width: `${c}%`
                                        }
                                    })
                                })]
                            })
                        })
                    })]
                }, o))
            })]
        })
    })
}
  , S$ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAlCAYAAAAuqZsAAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAoiSURBVHgBzVhbbB1XFV1nzrzuXN+nX7Edx26cd/PqA0SVIlJRKCDUCiFUvppIFOgfAqGWD6QWJBBISIUfhJCQ2m8EVFRAK1Hq8qpUmpY0bUOVR20ndh37+r7n3nkPa+Y6tEVOfOP+9FhHts/MnLNm77XX3nuAD+kQuMGx95bJccVSPhuE0RjCCH4Y2I1my1U0JY4CNzRN86/vnGm9xVtjfIDRN7BJAiqPFR+Ymhn91sjowLAqJaI45OydL4RA1+2gWml0q6vN31SWar8qdMVLp06908EWxubAvgQ5vTj6+V0Hph8pjxZu1S0YQo35YIw4ASV6W8SI1qeCIOCFpmisvF05a691fh7VC789derUDQHcDJhy8IvjJ8cnx74/PFKYkGrEoxMUCp9MQCQARWqtZMaiBy2OFCixRBwAkaPYtSX35cpK++sv//7lt9DnkNe7eOe9e+/ZsW/iR4Wh7JSQhMSDEwMJXJ1i/f94faG3mjg3SoDLGKou9WK+MC0ccY8C/enKcqWODwLs4KdnJsdmBn9WHMkegQwhpQrXCdFuO+lsNjtw3RiaKiGV3jNC8A9FoYsZFEGAkNOxfbhtD+VcfrBZv7K0eLH6T/Qx1GtdGBsbuTNXzn00Uj0kDAqDhOhANmsRTM8q3a6Hen0NQ+USQkaoNBVEvMnnve1WG4V8gZbzYWYUNOsV5AsD+9aNvWnEKhuukvBS105oGU13Ih7iufD9AFnNhB6ZEH4WXTrEb0vkxTCitgYGJMHHBNvFWq2KcqmYvrWVMelOFZaVg911d4yNjWWwVYsd9Y/myJC9yWsFCYF9iQG9hE61g6ULVbz1+iXYto1jHz+G3HAelxbehl6WqcXIKlg6LWUbWLtch910sX/3QURhjIy0j4aysovbvoatWGwwM2jEUax2Ol2QtNCdDJbPVbFn21G0LnuozlXhr/kwugZ+8ZMn8N3v/BCBx0iUGnRaNc+XyMZlVM45ePP5ORiNLH7w8I8xPbm7XSqXWuhjbAisXZ/vWpbpqiS8JS2+PfCNr34b33zwERw5cAuUNBIjFAs5qCT/vr37sWfXDFdcmAYtR+EdJ++iZhNho4W5N87CUhUcPrC/OTUzZaOPsaEr16pVTIidlKoYtZUKJoYmUR7J4kp7Dvd/5QsIMj75YuOu+z6JJ5/6JS4snoHtXEEmEyNwmzD1DBar57D7Y9uw//Yp3HrkI3jquV/jj3/5gze/stRFH2NDgb3jngPl/GT+leEd+anAc2DQPY7rUAlUdJ2AllFSodVUA0L1KRMugbUwPFLmatTLCBTZ0FfQatkInRgDagHn/r30r0y38JkXX3yxiq1YrGk3Jssyl9UNbp4R8IUHJUuJoIvIayRylYipiFxKCGEKHcX8EII4uUdJ+ZFKmhmjYFkEGUH3VEztHLPmz69F6GNsyLHV+vLhfDFXjBCmd4QKUxFVP+SPJBCdLjYYZUYkIF1azHGgUSr0QHJdhxaqnAwaAlJDn28fMl05yJa1XYHqHEUfY0OLhTbpHcpUBXkM/Ghd+dtdlGIVUa1LHWtBJgADL8lUUFSNVtIRkByB4AulWTNI94gF91JMGAPbjNFC6XOvAy9gE5HdkGO333lo5/Dewt84x/2ok+5gr1QZ9i5GmgG2qRZKpgXFj6DRasnbxSyDwAgNlSRP9vbp5UyBgNzsUAtPzy+hFiqnXeh3z86eqlwH18a5cmlhpT558/DhPPOkz+Rt1xsw1mzscDQcHRhCkYBUN4DJvGgyUTJDQePUmZYMpqOMx2ucGT/k/0G6bnFODhZQrdZy5xeWn12tdxZuGFgySjPZcmF04F4/9oXm0jJLTdyWH0feZk5kNnAJwOVhQVIwKnRVSvwe+UM6IiD7a802KtU62s0WMqoKSZ8PDA/pdWnZ5y8uPoPrjGsmca8bnREd0dR0FFJZ4OEhLRCSbwoPMTUJ2+2iVlmD73nQ6S5N6bkyVWA6UtM0DA2VKa4GXarCV3oViB/4u7FJMr8mMLfpV6NO3BGaKAQaAyKr4XxrFQfNEkxGZrLrgGkgb+q9apbWY4WYRrGQKYJUz5REHCKWQKx6XQbSwtJy5Lnun5JVXGco17rg1Bu1TqddpSngcmb2TGAuG+LNsIFVPYZtsMZPACeClUQl+ZZUEUkak3SnTJQmSCSGIksSLsPD2U4FXslScuXipvnymha73GlGh0XsGTxQaBE8WiN3YBK1lo/VtSaUWgdFiskgxbVEmUgKRoWWCpIsGiKty7zQxSrfrS676DB7WNMTlI5MJ3QalS0DKyIp66OYTRlUnkS9hC95aMmgD4egTQhmCIc8c3Gu1mB1QT2jiAmSUupG2j3FtKw+XoLIDcLSLHKUVcrl2nPVy/V/YKvA6oTW9dlcJGCUqxxN2g8CoDZ4rOcTN/vIQGzLQBe9HiDlFt4Nd18Je72CZ+D864u1ymL78TdeurCFXDn9mGkNBHfnSs6hVnBmPEzB+O+5oQcyaZTiqz3lVZ0WSDul94Zacl+y4Pkeq1vnUtbXXkMfpfX7gN1229e0S5h+PMxOPhibtvSkI0Ixx/M2rlR6LVvvlPB/wP7/ptRgqXToulxZrnpt9DHeF5VL7swRYe55oKscUu14j2iEEyR9IdWgXnRH66+qrJc+Siqo6WQ+TNfiniWjWKRPxClSyXyrI1JHL53fvj3sB9j7lD8evP/mKL/nhI8hRRo5OBFdGNVYqdJZSodNbNwDldY1eLeXFFeTI3WLVYcSsPRhpRG5XlrDRaLABmUccxcPbY+qB5yZ8rFXV1dnw76B+ZWnLxo7H6Ym5o6HAaNLFtFYseG0OygMZOh3fb2HZNJhp0214u+EbCynedXpumjW2vA6ZKVLKzkEqI5ipbYNF96eQcs+lhXq8B2NqPmKu/zshesB27C60O/ynlAUeYIZjwl6jYJ5kbnuLAbzy0wxNeiW18s664+nhozjtMn1uqQQazBTy8PpWFiuD6MW7OK1nXTvMAxGOdpn/yPr819eeeOh09cCtqFceM/rJ827u3PkyKNRkKenJtH1TCxXfVypJh1+I+VQSN4wI5JfLBjFOmFZ7YZeh30oc6ccpP6V4MZJoqf0hmsQpIhp7dinBu6tvPv0DVns6tA+1T6pBeGjlliYlt4Fbt6la9owTI/ldobgbqIltlPhdbrNSd2sqSR5bNDZGkHF6ccXJhB+YGFdF7AdVPU6jML33D9v/+n1zt70M1Tx+NnpnPn3x0q5MycM00VpNAOrlCXIPN5ZGMWZV4dY7O6ne/MUY1owYL4MjfQ7UGq9sMW1pJHRoZrmC1LGJ+vPlOY2O7fvD3fHH3po2nEaj6nqjvtWa8Viw2Vn7lFOov2MulGsf/uhdXRGZk9epGLDbtXqmj7wJC35VHs2N9vveTf8qbN4/HdFqc8cd0XuEy4yR8LYmoo5k40Uuk6JlXklEvOq9E57rcsvWIacrc/e1Nenp/eO/wJZn7Q9sJV+7QAAAABJRU5ErkJggg=="
  , C$ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAlCAYAAAAuqZsAAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAASqSURBVHgBzVhdbFRFFP5m7t3d0lpom7Y0ttFNg0oAUR401UDEB3+IxHZ3oUQMsUYTQ39IUBIfMKXYyAMaSGqLBEUkJiC23SWoiS9QjTYSDLTWxhCrpi2lYdtCW1qX7nbvHc5cspvS3v1radkvmZ2fc+beb8+ZO+fMMCSI9S3HUjKGxotUFRt0na1mHI9BIE8AKRzMLyB6SK2PMXZR1/Fjs7P8J2oLJAgWr6LDXfecIniJYKKMpmUgbrBRMOHRJib3nn5tZ3fcs2IpbP62IU9XxH7S3IY5gl72BVMttY2vvtMbh24UUp767boQ+xKzUAwI0asztt/jrGzAbIg5PQ17mBA1mCcIxmrcjoq9keSmxFzuhgM0dSfmGbReD7kdVRVmMj59QFpqIUhJMMHKnc2ffmgqm9pxuevfoOorLDDIrW+TW49OHQsTKzl50K7YLC3UtGPhMWKz8sITG8uHQwNqqKFYLXsikaINEkdeLsNcsevcNxj13zITZfj9Qrq06i5i0lpku7JoD81MScW8golKV1Pdl82bdrTJrrH4uc2yG8kAzt8KN+/8sI1IDrxecuygsZmrDnf9CxR486KqC4Ha1jOmom2rnoV9SXa4P+gbw+G2FlPdm4EJxEAGX6wsp/q8SnH/pVgRU6YGfwxcMZUVT3uZbzIQUTceCMZflMTIi1iDJAJnYoWsVSJWgBjZUprFhlU5+bApKgbIVZN6EFZugY2SsqxpX2uqxYonlj6Ecf8EFM5pjgWLVAs0oeHf4UGM+H2IQe1Jgxh58eFIKjmp6ShetgYdQ31oH+iFPxicoXOD5AXpWeG+4UrvzKxG/qmnHyxEfnomznb/ZaxFMwghcg16ZC0rImDrimfgJ+tc6P/PlFQi8GtBtPZ1GdbfvPypiHpkqCWylhusXL2LzJS+7vzVIPfx81vQQRbrHOqH9/9RXKNCeZqh890/bWjz9tDaYMbY9Vvj4fkquTIrJQ3LMpdSycXjOQX0jKtouvw7omAsRMyLCKHoxoQP9ZfOQqHEfmV2vvHwInKHXEeSVpCSeuluXegGKRm65Ne0tuARBHQNGhU53j8+gkvXenDq8oXYlhfoukNMiHZ6oj2arkYv7hi8YpTpqF5bjNVkiRB6Rq+j+hcPZgv6b/2y5pTmdiGZwFirrLiq8h+QRBCa+FnWHBPZv1F3BMkBH9cDHbLBG0tLAzpwHEkA+qBONZa+ayRsRnZB8bIRSQCdKeH83yDmdlW1Et0juL84cNqxvTvUCZ+SrH7LbjLlEO4D6L3eNGDf1DEl1Ohs/t63cssrcg9xIgHkpC6m+OjH1bFho3TfHEK7N+YNwF1QOHvzpKPy4tSxGZnYJjpXink8gU+HfBctpRknctMUkch9QhPewzyDriBqm1xV1WYybjbY5KjYRZMi3ivcC1BM/SASKYmoSTUd37cyxj8ig9txj0CBfpji+vvNzorPo+nxaELy/QkhtHVE7DDmDkpBUBccCRTGIiUR941iieczuyK0GmpuoJIb7zwm0yomjmuCHaU7sb8TmJc4nGcOFbGgWE+f1DqyeS5FjkdpL3qARPLuYZDa7Vzof1KoO+d27TiPWeA2v/i7XdcP980AAAAASUVORK5CYII="
  , Z7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAlCAYAAAAuqZsAAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAuwSURBVHgBnVh7cFTlFf/d1+5ms8vuJhFC0sAuCRIFhCBPY2V9VOo/ldZ/7PRB7EPaaRXt+E9HMDCttnWmPurYmU47I4ztqCPjo/WBVSSIEIVSgu20AoENCSEhD7JkN/u4r6/n+767m1BBo3e5ZJN773d/55zf+Z1zPgWf82BsLNo92L20aBVvVw1tqQ3EHebGXebyq9CY0aMxvcdlTpeh6Xsr6qo7Ekoijc95KNO9cTjTl8ybhduLxUybBTPK6EkCBJfAiP8ZE8DE4TiwLQuqqsBQdTBX3R6Af9tViTU9033fZwJLDaTiul95PFe8sJ7BgqvYAogtADEJhVByYBwbv4fBhMt/sV35EqbRBR0qC2w31OC2lkRLz2e9V/20i4Njg5sIyJGclV3vaBYcrQhHtelk3gkCygRE4S367nJPKjqdKl1XxGlrZAg9X1RzbXl3/MjJwY/vwxf1WP+FVHvezG81nbzwkiIAOPSBeLnLvSNcJE/hMQLosFJo+Ul3KzLc4Bzk1+hhHQGoDtva2rhu2+cC1j9y8hkTxTaTmbDpZAKOPFgphByIKznFPJCu4JwjQZUC7gHj1x0Bjv45BM7WENLC269tTN41LWADwyfaTcfcalPIbIV7yIZcTd7KwdimhcFzQxgcOIuJiQJM0xQnZSF8FT4EwxWYNasG0dgMuBqtobMSG6VBZKfK17N0VAbCT6yYu/b+TwU2nh1rG88OPuOo5CkOiVuryIxTBDAFmbEsHnrwFxg5N4pYVQQzImH4fT4oqgqXspF7JT2eRjaTQ2NTA7678VvwRQ2ySwLjSaEIT1PC8LCyIGr0uvuvnrvoialYyuQfyw/Exwuj7SYKRFxHkFrhH8ooBRrZq4qQWaaDlpalaGpqRHWslrjiRy7nkOdM5PMuinnAZ1Ri5uxqNC9qRDQaJG1zyUN8PSY8Ucpgniw28si6I+2dqT3xS3qsfzT1TN7KtCmqLawTQDjukgwwz3MlQ9Jj+PDDQ1jasgQmaZZFp6Zp0H1+dHcfx9x4LaJVAfEGRnQXuudlsOO4F4XNtVVUKpUda+bfcmPpb7rg1dhA3LYzbUQRkXFgqsgeSQoNxz8+hgP7DkA3dCQa47h6YTN2734Xx451Y9XqlQTMpJeZdN1PYdXx1mtvYcWqpbghuRrdJ1I4fqIX6XQGK1pbkLiynjJcEZzjfOWOc0lOcnY+eaTvULKlYUVHGZjq5toZs/gXQXRGGgT+MIFyLBdPP/UHHOw8BGZDeLP5qgXw+/3oOnwUh/d9hIkCSQoHphlE5hBOnOxGdqSAN158G0eO/gua4RNeOtLVhV8/thnMQLlI8PV4ipH+ImemN9GfJoEVHWc9dzXnE0Mpg3ggFfQPDuDKBfNx7z0/Igsd7Nt7EE8+9nsUJvKUXQwXhsfxiXyif2+/vgeVoQrc+8A9aG5ZAMNfgZdfeRHjmQwqqys92fHowXWRtNJixeQYS0VjVFvV/rHUeiJ61FXgEVwVsFQOi6wpFCZQ/6VazG+ah1m1Nej84ADMYlFqmHIxWT1BkcJGRz5XwP4DnYjFIsS5WUSBJowMj0rDvQd4WD3fwXLN6MmevqSIou26SVHKFI9fVEIkByYLs0M1b2T0An776NPY19Ep6yBfVJ1ENqWEQ9UUcc0l8O/9fT8e3vIomMlJTyLkupeyRiYBJdhEMSOBMVVd4gqnTi48aTkQCs1A/5lB/PWl17HzhVfhWpy0LgyfgTlzGhAIBC4KZCDgR319HXykbdxavtahfYfx/I6dGB06jxkzQpO4PG9N/akpyloJjFlxpWyv6xnBP1LiZs+qxejwCP70x+1Cw0qwq6pi2PLQZjy45ecCHF87UOHHT+/5Cba0b0YsGvVcqQqlf+7ZnThzegA1NdW47EFrFBVTPEjFwoxLy9hF/pUdA4Q2xaJVGD43ImOtyHuGhoZw9w82YtbsWqnqqvTy8y88h4GBIVEFSmvxJBobSSMWiUHTDRJV6/LA1GJceEwuxy59Fx2Dg4N442+7IGPNymTi6v/U079DMBigOlkUlwoFE5Zt45ePbMOy5dd663hln/i2m/g2PJiGcqneQRHSi1IuyDpTFohPAtv//n70nT4jecAmwS1cuBA33pjEvHnzUG5e6Zb6ujrclEyieUGzp/qSvfz5sxTKgx8ewVTGT33nVAcpqfPHU9SfxxnVR76IKvo9CiVlom0z/HjjJry7ay+8yJYTSaWizYk8dmEcM8JhkoO5OH36NDLZLMLhSmSzOSGqipcApdq48ublePipzVAM8qLGxVURSeIqlijuhqOnb77yjpgO19cFxYqLJ71aJqivahg4ewY93b0ekknzZJowqpfjWHfbrbhm8SKqjyfxlXW34vDhf+K99/aVPSjXlN5WiKOn/pvChZFxVNfFPK6pZQ/ybwElcJR/12E7p1VdlfnoucMVYmfj7PAQ+s/1I1ITwZyGBgQrg8iOZ9Db24tINILW61qx/o5v4PsbvodcNg8j4MOjj/0GsxtrsXf3HvJmGg1fakA4FBIe7Ev1YuT8KM6Q/NTUeVlbDoUr4CiK0SWABfzBVywrv4lJxaQe3RVWQif3kgmrqRA/8MDPUHNFDWkT2WFbmMhmRHmqitWINX+4aQNefek13Pa1dWi9uQVrblmM72z8OnUcpgBFuU1L6hgbzeDhR37Ff/U6F16TefttyxhQZ+szQh0CWG000NU3lE/TLVERIq9ZdUlEE/PmoL5hNhrmNhAoTWSNj4tupEoouGWaouNou/vbMCoV3PnNO1E0CyKzIlVh8VLeD4j7SCYqXAMLly3A7PqZAlw58VTZcqsEvjo+WwBTFSWWppq4Qy1lnXcYpF9XVEdwy01J/OXPzyI3kaGGypa9u8MEsXlIDx76B97c9SZOpk7Rz1346Oi/KYv7Raehqobwiq77qJnMY+fLO7F42SLRRLpuaY5QRWulujqCPv/20nAsWDecGUia5sQekxVFlS95jB8kS/jgg07qvY6htbVV9GMus+XEZDvIUcuTodBWk6KfJ/4Y5JlK4qKXbKJ8DY0M452336FnG7F85XIxMYmPIkYXwS/DMhDTZyZavKG4LCjnxntfzps0P1La8httx2uARLOgIHWyB+/vP0CkD+O661eQVIRli6yU5iZX8M4td7xUUyxHdBenTp3ADWu/jHgiLkInhIkLqiuVgLfdfje4/fqmr95V1rHSl4GxFN+DOGKxbNQVwLyxSxRzKio06vMB40DnPpzo/g/mz2/CkiVLxDAimj0KsyIoTN0o9WpHj35EhnTimmuWYPWalVQh/ATGkfcKg3g0XDEtBVhFukaPtEzdQrioNlzIDt+XLYw+XqCBhE9JIhTCA4o4uTdUEsXBc2fpxUcpvCcQicxAIjGXXkyiOpElkU3RWDeM5uYmrFq1CqFwSM6TkKMgN9riXiZN08R86UONMfP+qxPXXjQlfaJo9Q0f22rBbrf4PoXqeFM0ygMJzxHTKgrlLxZN0qR+9PX1CgNsy0ZdfS2FjGcxFWtOUEWVTRUfZoi/fCDhuxsqDbwanQEjtG1VYu3W/8dxyUm8dzS1vejmNtiKTAYAk02j43rbAd7WQBk4E1sCsjY6EqjjSE+LFXiBloS3baotpo6IP7pj2bzr2y6F4ZKbKnOqE20+PbBNgx9CZcuF3hW28PYb3gBc/lmuW5Jp4lTkWWqphKg6OgwacsOByJOXA3VZj5WOM2O9bdl8up12euJ8D0LsQzhcSjD5YuGlyR0faggEF7ncMG8jheNyhEG0naJWpoMstG1RYskTn/buz9wfG6AJvTAxQbs+2Q0O7Xs5ZTkQ+z4y06bMB2JzhdDzkPNORbZxFDqX9jQC4b2uZbe1TGMDb9o7igP5lACYK5q3W44VFTVO9Eicg5JLMswExpHyoYrflbSm+3YEg9FXrrpiccd03zdtYKWD78EeH+pLFgqFpKIpS13FjDMU50qh5TOz/7TK/D1U7LtCwVDHzJnhjtgX2IP9HyiuncucYtcuAAAAAElFTkSuQmCC"
  , k$ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAlCAYAAAAuqZsAAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAW3SURBVHgBzVhLSGRHFC21x7/4/38WOnE0OhNQGMg2GQJCFqMhGVzoKgs3gSyDC9GNYWaTBLKTGAgThLgwSJhFsjQICWEIjqOOqPH//7a/7rZfv5xTYz1e1+tuu7UH5krZ772quvfcW/feulUJIkbq7e1NbGtra6isrGx1u923i4qK7iQkJNwzTTM1EAh4MeTF4eHhq9TU1NmlpaU/RkdH/8KcgHhTND8/f/fg4KDv9PR0zev1mhcXF6bP5zP9fr8JQLKR+GsYhuzjuP39/aPNzc1v5ubmikQ8aWdnp2xlZeUxrOOjIAplU2AUoHDEfp/XZ2K+HwD7JyYmcsVNaWtr6+He3t6Ux+Px62CiBaZIWdF95H61urr6qbguwVJfQstdMlSax4PI7+TkxIcl7haxEiY98Zx7AvQjMz54LFI+eHZ2FtjY2HgcC6huLN2lJzuZ2p8JPGAEHGOUcAaGvUl3MAKWnxIcAqo3FI4E+wvC+8OCgoJn6enpyeobJgswkQ1y5Tf+JiUliaysLJGYmBjEUI05Pz8XAO4Q6HK5BPjLZ/KEEfYg4/Pi4uJfQwIbGxvLbWxs/BPC3qUw5CaB1CC6urrEzMyMAxjylxgaGhL5+fkO4chjorOzU8DJHX11dXViYGBAgoNlpZzj4+Np+PODqqqqdceE3d3dfqC3zEw6Ojoym5ubTQA1wUA24mIrKyszEbUhfWh9fd0sLS215thbU1OTCeBBcxj1CLaf7XjkOjD5ZWRkfKEvCzVis1vK3me3orUEsAC/6d8VhepLTk5OgvxH09PTd4OAYTm64TOZ9JtwFErQVQCi5UVlUlJSkgoLC7uCgN26deuzWEFFIgpii9Sv8+RqpaWlPeReLN+xRbwPYKXiLSAYp6ylpaWJzy446QP6CsNY1xKABSKFW1OQr5EqKirEyfGJ2E7ctr6pfkSZ7NeJ/HNzc8NalFarra1tweM/LoC6g/V1DKQQfh8cHBTY4+S7GsNnbCuivb1dIHtbYa/6ysvLZSrJzMwM4scxVDY7O1uEI2SCe9JimPyO0lQHRw1ycnKs7/Z+pASZp7a3t4MsqfwHUSawGg5lI/ke5SEAqiQwDH4PhpV/OtmZ6AztFgolPBSASKAUMJC0GJ9SxNtFqfznQvOoFztdpd2bIsglHpGIhwnUA0JfSX1vDJXLrspXsSRZRQik//jrQtnxL/a9++EmowwSKKkdABiVKiXoWxmjkv0opYWuCJKorErUuy4P855LYKA1lcfsRGHMR0wJk5OTDg1xSpIpgVWCDozzOjo6xPLysiVQ8URRIOcRoE7EgSQ7K4Fhpx/BXtmno0dBJ/MTqg6Zq0IR81RJSYlDa/IiKFpMTyU42Mi8yHSiz6M8pKHfpRI9PT1TqLs2iDZeFOvequYAh3tkZORvCWx4eNiAD/3AE8x1GOpkz2/R8lNjUfX+qA7H0jkQAL+gvN1EjR80OB4AoyWcCQwY52v1LoHV19e/QH3+1AgYhtqs5Z9Na5UaVNMdXpGao48PB5RjeTZA9H9fXV29pb5boYio/BYl7seIlnpV8zNSAdrBmMyQYkJGFgkVqWhoaJDnAp1Y86vaTymNFDGLK4g++7ggNRAxrXl5eQO4ELFOGDwl0Yp2RpeKyMgKtTFzPFMGI1snzsvMyrT4wb99iPpPampqfhORCCHejcGBcMf/q64Gwl0j6O3yyiCAdBX9iRz3FU946I10X3GTKwPOpfIoQKM/iStCpPLuwitP23EERmWRFs6hfK+4Li0uLn4AgC953rwuMPvSQUkD0TcFvq3ipjQ+Pp6HKrUfpvczCduXNxpQ6g4D870Iru943xaN3Kiz4MLCQjH2xq+QIh4h3EsZXazfDb/xOiptnPjOLQ6A2DaA8SdE91Psq5PRyou5GuS5r7W19T7y2EcQehsljHUHi24Pnl/iQDHDKmFtbe0Z7mCfX+cO9n9yw9AEFgiFoAAAAABJRU5ErkJggg=="
  , J7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAlCAYAAAAuqZsAAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAdxSURBVHgBvVhpSFVpGH7v9dqq5TouUbYolZoyk5VQ0tAyMkr0YyrmV39qLIKsQJhGTJsfA8EwEDRFCymW86cIijYiWigiNS1HzbZpccXKLb0u93ruPfM8Hx652rV7TeuFT88951ued3ve9xyRUcrGjRt9dJse53A4cu12e+GHDx+KOzo6evBf7+rqslmt1hKM0/39/Xm6rifv37/fLJ8hJm8n2my2WPz76f3791tLSkoir1+/rj979sz08uVLE+7pvb29lqlTp2oBAQHmqKgoPSEhoT81NdW0ZMkSa0hISMHEiRMPmEymVhkvgdah7969+6O8vNya/Vu2fc6cOQ6z2azjkCGDU12HcW/evHmOrKwsR3VVtRXK7cN+ATJWgXt+fPr0aTk27sYBGrR2WiwW3cfHxyMwDkMBrpk5c6aWm5trf/PmzcO+vr50+Vzp7u7OuHjxYgPcoU2ZMsXpevhwUO6GuFjNuEeFVq5cqd28ebMLSu+U0QoW5RQUFHTGx8dr0NbJDd1ZxBMwd/O5V2RkpHbixIlOhEiO16B6enp2Hj16tDM4ONgxXPOxAjPW0MVIEu3w4cOdyOAsj6A6OztT7t692z579mz7pzYfCzDXtQsXLtQuXbpUz1geERS4KLCurq54xYoVGjXytLEnYN4MuNW5Zs0aG2injNnvFhhTGWIbKZ6+BDAOcJ8zOzu7C97K/wgU0IZUV1c3z5gxQ/MW1HgB44iJidFu3brVN0DiSlS5QGn59cKFC6Fv3741Y6J8bWlsbDSfOnWKIH8Z8gCxVYvS4RAPVuFvg1xdSda4FjdWlBGyUoZRCL3V0NBQy1pMTBZYK/nKlSthL168cKsNNpHp06fLpEmTBEVakN7qHn/7+flJS0uLIE4kKChINE0TWtzpdDLD1X3w4JD9wPrS1tY2+BthpOY3Nzf7FBcXR5w5cyYRezy0AG3qtWvXSKpufchFO3bskA0bNsjJkyflyJEjgjWya9cuAQHL9u3bZdOmTbJ7924Fms9Q0CU/P1/S09MF1COoHEwuQcchjx8/lj179ijgBGWAQ7cibAzWrVvHcvXQgtITXVlZ6YuHboFNnjxZQCGyaNEiBeDs2bOMSUlLS5MHDx6wdKnnBIVaqNYQALoOqa+vV+AJ5M6dO4ISpwBxrjt58uSJE3vHK1cCUMyrV6+UCwwNXCU0NFRpjeIrsbGxgliUmpoa8ff3FyikXAWiFLhBbty4oSzMfehuxIyyFq/platXr6rrkc56/fq1BeujBkLI/G17e7vT3UQKugJBeZKDBw8qC6xfv15ZYdq0adRQAY+OjpbVq1fLuXPnlEVTUlIUAO5JS9OCyLxBQHSbO0Ffx1BIUBbDpAkMSFea4CFNTU3qYFoJVUFu374tgYGBkpGRoeKI92jFZcuWqSCnm1BnFQhaiodzHoEx2HmPoCIiIgSEqmKwoqJCWdgQ4KDFVLZYoFkv+ixfBCc7UFm8eLHMnz9fHUw3LV26VGpra+X58+fqcAJjrBnxkpSUpLe2tpoYX8xKw/JUNCwsTFkT5M3kUvcJEpylkgEtkMpqlCQVt+yAsc5puLISra+Jpkc7ojY4duyYoGNVdBAXF6csR0sQHDJHoIi6x+xbsGCB6dGjR0MAGdanm8PDw5VleDDn0DtlZWUqTktLS1VI8ByuoUcg/ymL4ca/c+fOTaLrOGgtWs1IZ2bTvXv3BjdFnyaISUGzR6I0MTPpUleXGAAJhta5f/++ukePUCkmRHBQsPj5+wl6MpWl3H/WrFka3F+u1sMSueCpnMLCQgtcYTLIk5uAjdUmSgO4lTGDONJBESa62shAAwSFc4y5JGZagdd8TmV5PUCoirCprKHUtm3b+g4dOnTA19f3dxM2jjt//nzFli1bfGAJ0/DsJFBuNmHChMFUJ7dhsRoMclrBWMffjDUeZpAqn3EQnBGHxnA9BxltA8F+j7OK1XsiaEDVSnd9mFHbjDH8met/cVMrXdeNVEd5DVpywIqtRq1UAs3y0IsxO52eWhQZRVvk7cC5OkpbP9z65xB3sQ9CS10HhtcMLb8mOLwgO3B+N/vCQdfyDxDXgAhPw4x2xI/uLgZcxaCEsfZuXM843bx5s5aYmPg3frd8NAkgvqmqqipHD+4Y3i99KevxHDQAdvSD5Z98Q+fbCgptI0jVMVLjN57A8LnBDo5sA4/9IJ4E3JKJnssKDnIYwD5lvdEAcZ3P/XFOJ4yRKd4K+CynqKioAxrZxjMR2EIjppyoNI7jx493oZvYJ6MV1MGtyJS25cuX2/n+97ngXJ/zVW3VqlU29GYtXr2BjyR8M0dnUZKXl9fL7w3kORllUtBKYHJlpb1793ah0yhDh5EmYxVkSyCstw/dahe+DvbjAL57Oj2BIyCGAdoee2ZmZh8+9lkRT38x+70512siIvmhzmXh3fNntC3hly9f1vHtTIdFfdGPsfe3wDIaijZfYB3gRfPatWvNycnJTQj0IhT2f8iX8qVEfYPFt1WWMViyAICKES82uJ3fYPkttpTfYAe+Hn43pPaNQv4HQuUajLVxYToAAAAASUVORK5CYII="
  , H0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAlCAYAAAAuqZsAAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAWVSURBVHgBtVhfSKRVFD/zRx3/4198iBzEYldRSAoiAkHMwHwodkWQXgQR6UmXAh9aFkyUxbYthMoRQkrJoHrowR4CXzJIikW0NmsflEwdw1XUVUdnnNvvHOd+zMx+38x8k/sbDvfe79577u+ec++5946DbEIp5Tg7O6tD9g2Hw1GF8lXkueyBBCC/4fuf+L7qdDpn3W73AsphsglHqg1PT0/rkbRDuiEVlDoegZgP/W/n5+f/m2qnpMSOj4+fwqz7YIE+FF2UPkKQ9wOBwGhhYeFussYJiWGW15AMQq5AnHQ5eAC5lZWV9WWiRpaDwVI3kPggNXR5pBjPQL7ApN9N1MjUYljcH4TD4X5p4Eh5GdoGdN/NzMy8YVb3mCV4JprUkwbWbT/Ge8+sLsYcJycnzZjF98i6jQZP0GIR/bsg2IM1903Md505ODgoQeWPyF41U3B+fi4pdijPVPLr6+u0/vc6KVIxbblNTU0N5ebmSluXy0VOh5PCyjKc3Yf+V3Nycv4xdOgMSL1tRYqBYEmHh4e0vb1NzGP+p3kaHBwkv99vENXtmFBHRwf19PSQx+ORem+ll7I8WVbqr4D8HaQd+oNYDAOWYxHyNi6I78GuxJqjmZkZGh0dZcvKQDs7O2LF9uvtlJGZYbTntisrK7S4uEjl5eWGjpaWFhoZGaGCggIhb4JwMBh8Li8vb8n4gl14B4tQmUkoFFIbGxuqoaFBQaGqrKxUXq9XwRKqpKRE2gTPgoZAlxoeHlYgoyoqKqQtIr7CxNX09LTUW42Fuk8o2pWwQCdZgGf7cOchbW1tEUjR8vIy7e7uUlNTk7hxbm5O1pRuy9bY3NyUlC3U2dlJU1NT1N3dLe25TbTrdb8Ij9chb/Gk3AikL1GCs0+UOC5SFsxc3NHY2EiTk5PU1tYm7osfpKysjOrq6kiFlfHNjFQcwQq483lkf3Gj0Eo2wIqzs7NpaGiIamtraW1tzSDGdTw4k29tbZV6h9OwhkEqPgRFk4Wu14QYTO4lG2AS7Kbi4mLq7e2VUBAzCCwUDAVlN+oQYwfQzUegrLFnySa0ZUQB1heT5TL/lEvJLk1EKpE7Aa8QpItLnm3s7e1Rc3MzZWRkiDBBl9tllOfn5ylNCB+2mIfSAK+j6upqOjo6MmIduxXhReoQjyhNeDSxAKVBjgeemJgwXMbkmBiniGfizujdagMBTWwZ8gLZBFtqYGBAojxDjh2vl8bHx2UnMqnotZgq0GdNiKHjPRRsE0OUpoWFBVpaWjKI6eNKuzadmwn63xNicIXf4uxKCBwz5PP5ZBMwGdZRVFQUE0zTxKoQg8Jvkd4im2Ai9fX1dNlA5J8V/dhBvMb8dMmQuGbfao/giZ854+QDE+vhMyJSlCY0iWiJrksGfVxBfPpxLIsLbvkKH/1WnXQoYBhR3oSEGeFoHUkifghuvK0Lcl/B7XUJD1F+5/VR3AOF4xQf2nikytWnq6tLzsH42ZqR0puKdy7nS0tLExH82PSlzi9uhIDfTS5vko6NjSncFhQCqwJRQ/jCaCa6Hvd4hQNf4V6mcC03vSjCKH/t7+8Xx0wsjtx1uGwc2WI96+h0dXVV7vxJXBJR7BDt3JctXFVVJW8BE+AUC11D3Xex/eOAGdyki78FDFJya8BPR/NUIL30OsRJwGeoRby8iaU09Hh/E8C0d6GwTxNjaEJW68mUXNR3s4si0g8Rrkwf16ZTgOn7oYSfcyGr+7lVORki7YOQIStS0i6REljuFSj6iBK8N5ORiJsYxyg+9fnfnq8T9U14SMJyP4Dcy1hbHF9C9P9wDpKf8os7GSlGyn6A0nJs9XeQfZNS/EcxYjEO3J9DpkBomVKE7cMMAznx58uLkdfV09hp/Kde9H+w92HhP/D9AdrM4pr9Kx97ZBP/AcQOBv7fNsyUAAAAAElFTkSuQmCC"
  , U0 = [{
    id: 0,
    transactionName: "Mint",
    transactionCode: "0x74b8...6973",
    amount: ["+1", "Polygon.Gifts"],
    network: "Polygon",
    time: ["05.29", "07:46"],
    pngIcon: J7
}, {
    id: 1,
    transactionName: "Mint",
    transactionCode: "0x74b8...6973",
    amount: ["+1", "NativePunk Official"],
    network: "Polygon",
    time: ["05.27", "01:36"],
    pngIcon: J7
}, {
    id: 2,
    transactionName: "Receive",
    transactionCode: "From 0x74b8...6973",
    amount: ["+314 USDT", "BNB Chain"],
    network: "BNB Chain",
    time: ["05.27", "0:54"],
    pngIcon: C$
}, {
    id: 3,
    transactionName: "Contract interaction",
    transactionCode: "From 0x74b8...6973",
    amount: ["+750,000 Visit https://bpepe.org", "Ethereum"],
    network: "Ethereum",
    time: ["05.26", "5:37"],
    pngIcon: H0
}, {
    id: 4,
    transactionName: "Receive",
    transactionCode: "From 0x74b8...6973",
    amount: ["+2,344,000 LHINU", "Ethereum"],
    network: "Ethereum",
    time: ["05.26", "5:36"],
    pngIcon: S$
}, {
    id: 5,
    transactionName: "Contract interaction",
    transactionCode: "From 0x74b8...6973",
    amount: ["+688 LHINU", "BNB Chain"],
    network: "BNB Chain",
    time: ["05.26", "05:35"],
    pngIcon: H0
}, {
    id: 6,
    transactionName: "Receive",
    transactionCode: "From 0x74b8...6973",
    amount: ["+227.3 !https://KdUSD.xyz", "Ethereum"],
    network: "Ethereum",
    time: ["05.25", "2:12"],
    pngIcon: Z7
}, {
    id: 7,
    transactionName: "Receive",
    transactionCode: "From 0x74b8...6973",
    amount: ["+11.023164 ETH", "Ethereum"],
    network: "Ethereum",
    time: ["05.24", "2:45"],
    pngIcon: Z7
}, {
    id: 8,
    transactionName: "Contract interaction",
    transactionCode: "From 0x74b8...6973",
    amount: ["+0.004362 ETH", "Polygon"],
    network: "Polygon",
    time: ['05.22","2:34'],
    pngIcon: H0
}, {
    id: 9,
    transactionName: "Receive",
    transactionCode: "From 0x74b8...6973",
    amount: ["+4.701199 OKT", "OKTC"],
    network: "OKTC",
    time: ["05.20", "08:06"],
    pngIcon: k$
}]
  , A$ = ()=>{
    const [e,t] = Ce.useState(5)
      , [n,i] = Ce.useState(U0)
      , r = o=>{
        t(a=>o)
    }
    ;
    Ce.useEffect(()=>{
        i(s(n, e))
    }
    , [e]);
    function s(o, a) {
        let l = [...o];
        switch (a) {
        case 0:
            l.sort((c,u)=>c.transactionName.localeCompare(u.transactionName));
            break;
        case 2:
            l.sort((c,u)=>c.network.localeCompare(u.network));
            break;
        case 1:
            return U0;
        case 3:
            return U0;
        default:
            return l
        }
        return l
    }
    return y.jsx("section", {
        className: "history-wallet-table",
        children: y.jsxs("table", {
            children: [y.jsx("thead", {
                children: y.jsx("tr", {
                    children: ["Transaction", "Amount", "Network", "Time"].map((o,a)=>{
                        const l = a === e ? "active-sort" : "";
                        return y.jsx("th", {
                            children: y.jsxs("h4", {
                                onClick: ()=>r(a),
                                children: [o, " ", y.jsx(df, {
                                    className: l
                                })]
                            })
                        }, a)
                    }
                    )
                })
            }), y.jsx("tbody", {
                children: n.map(({id: o, transactionName: a, transactionCode: l, amount: c, network: u, time: h, pngIcon: d})=>y.jsxs("tr", {
                    children: [y.jsx("td", {
                        children: y.jsxs("div", {
                            className: "row-1",
                            children: [y.jsx("div", {
                                children: y.jsx("img", {
                                    src: d,
                                    alt: a
                                })
                            }), y.jsxs("div", {
                                children: [y.jsx("h5", {
                                    children: a
                                }), y.jsx("h5", {
                                    style: {
                                        color: "#A6B2CD"
                                    },
                                    children: l
                                })]
                            })]
                        })
                    }), y.jsx("td", {
                        children: y.jsx("div", {
                            children: y.jsxs("h5", {
                                children: [c[0], " ", c[1]]
                            })
                        })
                    }), y.jsx("td", {
                        children: y.jsx("div", {
                            children: y.jsx("h5", {
                                children: u
                            })
                        })
                    }), y.jsx("td", {
                        children: y.jsx("div", {
                            children: y.jsxs("h5", {
                                children: [h[0], " ", h[1]]
                            })
                        })
                    })]
                }, o))
            })]
        })
    })
}
  , M$ = "/assets/Azuki-kuLKXvVj.png"
  , E$ = "/assets/Bored _ Dangerous-QD6O7OOV.png"
  , P$ = "/assets/BoredApeKennelClub-M1CTWWbM.png"
  , T$ = "/assets/Doodles-Q9cYM4P2.png"
  , j$ = "/assets/Dreadfulz-D52GH6wR.png"
  , O$ = "/assets/Koda-hdu1BXbc.png"
  , L$ = "/assets/Milady-yTnx-I2N.png"
  , R$ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANsAAADUCAYAAAAV1VaVAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAjVSURBVHgB7d1vbFX1Hcfxzzn3Xv5Z9RbUyVxMZeFPpsyKCIMrXZs4kyWagVkmWWZAn/jIOBO36CCxZESfOeczH60sC0aXASNZXGSzYqlYMbSK20CUNBAFAenlT1hr7z1n99e7LjB7z6323K/3z/uVlF56f33Qpu97/vzO+V1Pk9Dds7c94SVb/YR3qwAUeWE2yIfv5v386x0rVgyWHV7qie7+/nRyOPeoQv28MCotAFFeD4NwS1tmWVepARPG1vPW248q8DqJDPhyPHldoxrdNNGW7guxvfHWvt94bmsG4CspBDfoBcGaTGbZwOVfvwShATHxlPXzYcelwfnjD3r69j1FaEBMQqVD39/uzn2Mf2kstu69e1sUqFMAYhMqbEmO5H43/v+x2FJKPSUA8Qu1uqdnX7t76LutWqHA9QJQEUEiXO0++4kg0S4AFeP73rqxz17C+5EAVE7hZEl3b2+rO2ZrEYCKSijV6oehx1UiQIW5M5O+V/hHACrOFwATxAYYITbACLEBRogNMEJsgBFiA4wQG2CE2AAjxAYYITbACLEBRogNMEJsgBFiA4wQG2CE2AAjxAYYITbACLEBRogNMEJsgBFiA4wQG2CE2AAjxAYYITbASFKYsjAMdfiDQ2pUV6ebNWfOHCWT/DlF4bcTk61/+L0a1fLvrdTKzJ2F6HhDpCjEFpO//22XGlVz82wtuX2prhaicMwGGCE2wAixAUaIDTBCbIARYgOMEBtghHm2Mj44dFB/+uPLOn78E2FivXt6dKjwe4q6gmTxd2/Vj3+ytjAn16xGRWxlZLNZHfzXP3TkyBFhYu6FqNyL0RVNTWp07EYCRogNMEJsgBFiA4wQG2CE2AAjxAYYaeh5tjd796hv75s6depkyTFDQ0M6ceJTYWr++f77evrXnUqlUiXHuJtQf/HEr1SvGjq2EyeO68CBd3X06NGSY4J8Xvl8IExNNjuk/v79kWPmzv2m6llDx+ZCGhkZ0cjwsFBZQRCU/T0PD/9b9YxjNsAIsQFGiA0wQmyAEWIDjHA/WxVJJKRZs6Rp01RxYSiNjkrnzwtGiK2KuNW7V62Sbr5ZFXfxovTRR9LOnYIRYqsi114r3X+/tHatKu70aWnbNmKzxDEbYITYACPEBhghNsAIsQFGiA0wQmwNzE1sww7zbEauu0665x7pxhujxx06JG3apIobD62zM3rcwIC0Y4cQA2Iz4mJ76CEpkyk95uDB4h//Sy+p4q65RrrvPumFF6LHdXURW1zYjQSMEBtghNgAI8QGGCE2wAixAUaIrYowyVzfmGeLyebN0c8HgfTqq9Irr5Qe89ln0oEDMuHu1N6/X9q4MXrcyEj0z+ZeIN55R9q92616LEQgtpg88ED084cPS88+Gx1TLiedPSsTbnFiN4n+aZm3Mbj3XumRR6LHuBeSffuIrRxii0m5y7DOnSuGdOyYqoIL5MKF4kcUtwUs97O5tVPcYkWIxjEbYITYACPEBhghNsAIsQFGiA0wwqn/mETdYOkmft07CZ85IzQwYovJww+XH2M1YY3qRGwxOXlSQCSO2QAjxAYYITbACLEBRogNMEJsgJG6PfV//vx5XSjz7uzZ7JByubwAC3Ub2543duvpzQaL5gOTxG4kYITYACPEBhghNsAIsQFGiA0wQmyAEe5na1DTpxffenj+/Ohxbsxrr0WP+fDD4jLliEZsDWrWLGn5cunJJ6PH9fVJjz8ePebUKZYenwxia1BuufDZs6UlS6LHvfee1N8vxIBjNsAIsQFGiA0wQmyAEWIDjBAbYIRT/3Vq3jzpqqsKr6YlXk7dPFtTU/F9tUsZXzYd8SC2OvXgg9LSpdK0aRM/71aMGByc3IQ14kFsdWrxYqmtrbgFm8jp08U3r+/uFoxwzAYYITbACLEBRogNMEJsgBFiA4wQW51yE9JxjEF86naebVXb9/Xytp2RY/6y88/ateuv+uTjj1VLtm+XWlujx2zcKG3YIF28WHpM1HOIX93G1nTllWMfUdLNaSWTtfcrSKellpboMRcuFK8QIajqwW4kYITYACPEBhghNsAIsQFGiA0wwv1sNejkyeJHFJYDrz7EVoOef17aujV6jFvFmOCqC7HVoN5eoQZxzAYYITbACLEBRogNMEJsgBFiA4wQG2CE2AAjxAYYITbACLEBRogNMEJsgBFiA4wQG2CE2AAj3Dxag9avL78i8osvSkeOSKOjQpUgthq0bp3U3h49xi2LcOwYsVUTdiMBI8QGGCE2wAixAUaIDTBCbIARYgOMMM9Wg555huXHaxGx1aC+Pmn//ugx585J+bxQRYitBp09K9QgjtkAI8QGGCE2wAixAUaIDTDC2UiY8H1fqVQqcsyM6TNUz4gNJtLpZi1YuDAyuObm2apnxAYT37nlFv3yiQ2FoJrVqDhmA4wQG2CE2AAjxAYYITbACLEBRogNMMI8G6YsXZg7mzt3buQVIPPmfVszZ9b3FSLlEBum7K677tban/5M37j+eqE0diMBI8QGGCE2wAixAUaIDTBCbIARYgOMMM9Wg5bcvnRsIrlaLFi4SDNmNPaE9WQQWw36wd0/1PwFC1Qt3N3XVzQ1CdGSCpWVp7RQM2741g1auGiRUFv80POyAlBxvueFxAZUmOclBvwgCHcLQEXlw5FBv7Bp2yEAFePJG+zIZAb83HByYOwkCYCKyAf5Le6z39FxWzbwgt8KQOzcVi3wgy73eOwKkmB42nPuiwIQqzAIt3SsWDHoHo/F5rZuXhCsYXcSiE8YhrtXZe7oHP///66NzGSWDYRe+JgATJnnaSA/M7X60q9ddiFy24plXWHorWGXEvjq3BZtdHqysMN422V7il+46r9t5dIdoxrtKHzDFgGYvMJhmBfqsbaVy9r/PzRnwlts3AFd4RvW55S7yUXHlg4ozW3JwkJkuZnJm+5cecdzpcZFXvX/37Mo693j3t63WwPfSxfOrrSoTozmPi+cLfJUa85kh9xZLuHrlZAGPp+VGpxoKzaR/wA5ly3RQow/MQAAAABJRU5ErkJggg=="
  , _$ = "/assets/Moonbirds-4fNZ1eQu.png"
  , D$ = "/assets/Polygon.Gifts-bWBhRQD5.png"
  , N$ = "/assets/PudgyPenguins-5YVC3xDc.png"
  , F$ = "/assets/WokePixels-t50QJTcs.png"
  , e8 = [{
    id: 0,
    name: "Polygon.Gifts",
    tag: "#1811",
    pngImage: D$
}, {
    id: 1,
    name: "Azuki",
    tag: "#6374",
    pngImage: M$
}, {
    id: 2,
    name: "Dreadfulz",
    tag: "#1191",
    pngImage: j$
}, {
    id: 3,
    name: "Milady",
    tag: "#1346",
    pngImage: L$
}, {
    id: 4,
    name: "Doodles",
    tag: "#7573",
    pngImage: T$
}, {
    id: 5,
    name: "Koda",
    tag: "#9952",
    pngImage: O$
}, {
    id: 6,
    name: "PudgyPenguins",
    tag: "#84",
    pngImage: N$
}, {
    id: 7,
    name: "MineablePunks",
    tag: "#10",
    pngImage: R$
}, {
    id: 8,
    name: "Moonbirds",
    tag: "#3761",
    pngImage: _$
}, {
    id: 9,
    name: "BoredApeKennelClub",
    tag: "#6873",
    pngImage: P$
}, {
    id: 10,
    name: "Bored & Dangerous",
    tag: "#11058",
    pngImage: E$
}, {
    id: 11,
    name: "WokePixels",
    tag: "#1729",
    pngImage: F$
}]
  , I$ = ()=>{
    const [e,t] = Ce.useState(e8)
      , [n,i] = Ce.useState("");
    Ce.useEffect(()=>{
        t(r(e8))
    }
    , [n]);
    function r(o) {
        return o.filter(a=>n ? String(a.name).toLocaleLowerCase().includes(n) : a)
    }
    const s = o=>{
        i(o.target.value)
    }
    ;
    return y.jsxs("section", {
        className: "nfts-wallet",
        children: [y.jsxs("div", {
            className: "nfts-wallet__panel",
            children: [["Collected", "Sales status", "Collections"].map((o,a)=>y.jsxs("button", {
                children: [o, " ", y.jsx(df, {})]
            }, a)), y.jsx("div", {
                children: y.jsxs("label", {
                    children: [y.jsx("div", {
                        children: y.jsx(Ew, {
                            className: "search-input"
                        })
                    }), y.jsx("input", {
                        type: "text",
                        placeholder: "Search",
                        onChange: s,
                        value: n
                    })]
                })
            })]
        }), y.jsx("div", {
            className: "nfts-wallet__content-cards",
            children: e.map(({id: o, name: a, tag: l, pngImage: c})=>y.jsxs("div", {
                className: "nfts-wallet__item",
                children: [y.jsx("img", {
                    src: c,
                    alt: "png Card"
                }), y.jsx("h3", {
                    children: l
                }), y.jsx("h3", {
                    children: a
                })]
            }, o))
        })]
    })
}
  , B$ = ()=>{
    const [e,t] = Ce.useState(0)
      , n = ["Summary", "Crypto", "NFTs", "DEFI", "History"]
      , i = ["Deposit", "Withdraw", "Swap", "Borrow"];
    return y.jsxs("div", {
        className: "wallet",
        children: [y.jsx("h2", {
            children: "Wallet"
        }), y.jsx("div", {
            className: "wallet__divider"
        }), y.jsxs("div", {
            className: "wallet__amounts",
            children: [y.jsxs("div", {
                className: "wallet__total",
                children: [y.jsx("h4", {
                    children: "Total Net USD Value"
                }), y.jsx("h2", {
                    children: "$51,696.56"
                })]
            }), y.jsxs("div", {
                children: [y.jsx("h4", {
                    children: "Credit Limit"
                }), y.jsx("h2", {
                    children: "$250,000.00"
                })]
            }), y.jsxs("div", {
                children: [y.jsx("h4", {
                    children: "Credit Used"
                }), y.jsx("h2", {
                    children: "$109,126.59"
                })]
            }), y.jsxs("div", {
                children: [y.jsx("h4", {
                    children: "Credit Available"
                }), y.jsx("h2", {
                    children: "$140,874.41"
                })]
            })]
        }), y.jsxs("div", {
            className: "panel-buttons",
            children: [y.jsx("div", {
                className: "panel-buttons__left",
                children: n.map((r,s)=>y.jsx("button", {
                    className: e === s ? "active" : "",
                    onClick: ()=>t(s),
                    children: r
                }, s))
            }), y.jsx("div", {
                className: "panel-buttons__right",
                children: i.map((r,s)=>y.jsx("button", {
                    children: r
                }, s))
            })]
        }), y.jsx("div", {
            className: "wallet__content",
            children: e === 0 ? y.jsx(y$, {}) : e === 1 ? y.jsx(x$, {}) : e === 2 ? y.jsx(I$, {}) : e === 3 ? y.jsx(w$, {}) : e === 4 ? y.jsx(A$, {}) : null
        })]
    })
}
  , z$ = ()=>y.jsx("main", {
    children: y.jsx(B$, {})
})
  , V$ = ()=>y.jsx(oT, {
    children: y.jsx(eT, {
        children: y.jsxs(Pi, {
            path: "/",
            element: y.jsx(VT, {}),
            children: [y.jsx(Pi, {
                index: !0,
                element: y.jsx(AX, {})
            }), y.jsx(Pi, {
                path: "market/:id",
                element: y.jsx(QX, {})
            }), y.jsx(Pi, {
                path: "ai-trading-bots/:id",
                element: y.jsx(dY, {})
            }), y.jsx(Pi, {
                path: "create-strategy/:id",
                element: y.jsx(u$, {})
            }), y.jsx(Pi, {
                path: "create-strategy",
                element: y.jsx(xY, {})
            }), y.jsx(Pi, {
                path: "ai-trading-bots",
                element: y.jsx(JX, {})
            }), y.jsx(Pi, {
                path: "wallet",
                element: y.jsx(z$, {})
            }), y.jsx(Pi, {
                path: "*",
                element: y.jsx(MX, {})
            })]
        })
    })
})
  , W$ = ()=>y.jsx(V$, {})
  , H$ = G0.createRoot(document.getElementById("root"));
H$.render(y.jsx(Ce.StrictMode, {
    children: y.jsx(W$, {})
}));
